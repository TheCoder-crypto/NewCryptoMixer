{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/bindings/crypto/constants.ts", "../../src/lib/ml/base.ts", "../../src/bindings/crypto/bindings/util.ts", "../../src/bindings/crypto/bindings/bigint256.ts", "../../src/bindings/crypto/elliptic-curve.ts", "../../src/bindings/crypto/bigint-helpers.ts", "../../src/bindings/crypto/finite-field.ts", "../../src/lib/util/assert.ts", "../../src/bindings/crypto/random.ts", "../../src/lib/util/errors.ts", "../../src/bindings/crypto/elliptic-curve-endomorphism.ts", "../../src/bindings/crypto/bindings/curve.ts", "../../src/bindings/crypto/bindings/field.ts", "../../src/bindings/crypto/bindings/vector.ts", "../../src/bindings/crypto/bindings/conversion-base.ts", "../../src/bindings/crypto/bindings/conversion-core.ts", "../../src/bindings/crypto/bindings/conversion-proof.ts", "../../src/bindings/crypto/bindings/conversion-verifier-index.ts", "../../src/bindings/crypto/bindings/conversion-oracles.ts", "../../src/bindings/crypto/bindings/env.ts", "../../src/lib/util/fs.ts", "../../src/lib/proof-system/cache.ts", "../../src/bindings/crypto/bindings/srs.ts", "../../src/bindings/crypto/bindings.ts", "../../src/bindings/js/node/node-backend.js", "../../src/lib/proof-system/workers.ts", "../../src/bindings.js", "../../src/bindings/lib/provable-generic.ts", "../../src/bindings/crypto/non-negative.ts", "../../src/bindings/lib/binable.ts", "../../src/mina-signer/src/derivers-bigint.ts", "../../src/mina-signer/src/field-bigint.ts", "../../src/lib/util/global-context.ts", "../../src/lib/provable/core/provable-context.ts", "../../src/lib/provable/core/fieldvar.ts", "../../src/lib/provable/core/field-constructor.ts", "../../src/lib/util/types.ts", "../../src/lib/provable/core/exists.ts", "../../src/lib/provable/gates.ts", "../../src/lib/provable/gadgets/common.ts", "../../src/lib/provable/types/provable-intf.ts", "../../src/lib/provable/types/provable-derivers.ts", "../../src/lib/provable/types/witness.ts", "../../src/lib/provable/provable.ts", "../../src/lib/provable/gadgets/basic.ts", "../../src/lib/provable/gadgets/compatible.ts", "../../src/lib/provable/bool.ts", "../../src/lib/provable/types/unconstrained.ts", "../../src/lib/provable/types/fields.ts", "../../src/lib/provable/gadgets/range-check.ts", "../../src/lib/provable/gadgets/foreign-field.ts", "../../src/lib/provable/gadgets/comparison.ts", "../../src/lib/provable/field.ts", "../../src/lib/provable/gadgets/native-curve.ts", "../../src/lib/util/base58.ts", "../../src/mina-signer/src/curve-bigint.ts", "../../src/lib/provable/scalar.ts", "../../src/lib/provable/group.ts", "../../src/lib/provable/wrapped.ts", "../../src/lib/proof-system/feature-flags.ts", "../../src/lib/proof-system/zkprogram-context.ts", "../../src/lib/proof-system/proof.ts", "../../src/lib/provable/types/struct.ts", "../../src/lib/provable/gadgets/arithmetic.ts", "../../src/lib/provable/gadgets/bitwise.ts", "../../src/lib/provable/types/circuit-value.ts", "../../src/lib/util/arrays.ts", "../../src/lib/provable/gadgets/bit-slices.ts", "../../src/lib/provable/int.ts", "../../src/lib/provable/bytes.ts", "../../src/lib/provable/wrapped-classes.ts", "../../src/lib/provable/gadgets/sha2.ts", "../../src/lib/provable/gadgets/sha256.ts", "../../src/lib/provable/gadgets/blake2b.ts", "../../src/lib/provable/gadgets/lookup.ts", "../../src/lib/provable/gadgets/gadgets.ts", "../../src/lib/provable/foreign-field.ts", "../../src/lib/provable/gadgets/elliptic-curve.ts", "../../src/lib/provable/crypto/foreign-curve.ts", "../../src/lib/provable/crypto/keccak.ts", "../../src/lib/provable/crypto/foreign-ecdsa.ts", "../../src/lib/provable/crypto/hash-generic.ts", "../../src/lib/ml/fields.ts", "../../src/bindings/crypto/poseidon.ts", "../../src/lib/provable/crypto/poseidon.ts", "../../src/lib/provable/crypto/hash.ts", "../../src/lib/provable/scalar-field.ts", "../../src/mina-signer/src/signature.ts", "../../src/mina-signer/src/poseidon-bigint.ts", "../../src/mina-signer/src/types.ts", "../../src/lib/provable/crypto/signature.ts", "../../src/bindings/mina-transaction/gen/v1/transaction.ts", "../../src/bindings/lib/generic.ts", "../../src/bindings/lib/from-layout.ts", "../../src/lib/mina/v1/events.ts", "../../src/bindings/mina-transaction/v1/derived-leaves.ts", "../../src/bindings/mina-transaction/v1/transaction-leaves.ts", "../../src/bindings/mina-transaction/gen/v1/js-layout.ts", "../../src/bindings/mina-transaction/gen/v1/transaction-json.ts", "../../src/bindings/mina-transaction/gen/v1/transaction-bigint.ts", "../../src/bindings/mina-transaction/v1/transaction-leaves-bigint.ts", "../../src/lib/proof-system/circuit.ts", "../../src/lib/provable/option.ts", "../../src/lib/provable/dynamic-array.ts", "../../src/lib/provable/gadgets/runtime-table.ts", "../../src/lib/provable/packed.ts", "../../src/lib/provable/merkle-list.ts", "../../src/lib/provable/merkle-tree.ts", "../../src/lib/provable/merkle-tree-indexed.ts", "../../src/lib/mina/v1/mina-instance.ts", "../../src/lib/mina/v1/precondition.ts", "../../src/lib/provable/types/util.ts", "../../src/lib/proof-system/prover-keys.ts", "../../src/lib/proof-system/verification-key.ts", "../../src/lib/proof-system/zkprogram.ts", "../../src/mina-signer/src/memo.ts", "../../src/lib/mina/v1/base58-encodings.ts", "../../src/mina-signer/src/sign-zkapp-command.ts", "../../src/lib/mina/v1/transaction-context.ts", "../../src/lib/mina/v1/smart-contract-base.ts", "../../src/lib/mina/v1/smart-contract-context.ts", "../../src/lib/provable/types/auxiliary.ts", "../../src/lib/mina/v1/account-update.ts", "../../src/lib/mina/v1/mina.ts", "../../src/lib/mina/v1/account.ts", "../../src/lib/mina/v1/graphql.ts", "../../src/lib/mina/v1/fetch.ts", "../../src/lib/mina/v1/errors.ts", "../../src/lib/mina/v1/constants.ts", "../../src/lib/mina/v1/transaction-validation.ts", "../../src/lib/mina/v1/transaction.ts", "../../src/lib/ml/conversion.ts", "../../src/lib/mina/v1/transaction-logic/apply.ts", "../../src/lib/mina/v1/transaction-logic/ledger.ts", "../../src/lib/mina/v1/local-blockchain.ts", "../../src/lib/mina/v1/actions/reducer.ts", "../../src/lib/mina/v1/state.ts", "../../src/lib/mina/v1/zkapp.ts", "../../src/bindings/lib/encoding.ts", "../../src/lib/mina/v1/token/forest-iterator.ts", "../../src/lib/mina/v1/token/token-methods.ts", "../../src/lib/mina/v1/token/token-contract.ts", "../../src/lib/provable/crypto/encryption.ts", "../../src/lib/provable/merkle-map.ts", "../../src/lib/provable/string.ts", "../../src/lib/provable/crypto/nullifier.ts", "../../src/bindings/crypto/finite-field-examples.ts", "../../src/bindings/crypto/elliptic-curve-examples.ts", "../../src/lib/provable/crypto/crypto.ts", "../../src/lib/mina/v1/actions/action-types.ts", "../../src/lib/mina/v1/actions/batch-reducer.ts", "../../src/lib/mina/v1/actions/offchain-state-serialization.ts", "../../src/lib/mina/v1/actions/offchain-state-rollup.ts", "../../src/lib/mina/v1/actions/offchain-state.ts", "../../src/lib/proof-system/recursive.ts", "../../src/lib/proof-system/zkfunction.ts", "../../src/lib/provable/bigint.ts", "../../src/lib/mina/v2/index.ts", "../../src/bindings/mina-transaction/v2/leaves.ts", "../../src/bindings/mina-transaction/v2/util.ts", "../../src/bindings/mina-transaction/v2/schema.ts", "../../src/bindings/mina-transaction/gen/v2/js-layout.ts", "../../src/lib/mina/v2/authorization.ts", "../../src/lib/mina/v2/permissions.ts", "../../src/lib/mina/v2/core.ts", "../../src/lib/mina/v2/preconditions.ts", "../../src/lib/mina/v2/state.ts", "../../src/lib/mina/v2/account.ts", "../../src/lib/mina/v2/account-update.ts", "../../src/lib/mina/v2/errors.ts", "../../src/lib/mina/v2/zkapp-logic.ts", "../../src/lib/mina/v2/transaction.ts", "../../src/lib/mina/v2/views.ts", "../../src/lib/mina/v2/dsl/mina-program.ts", "../../src/lib/mina/v2/currency.ts", "../../src/bindings/index.ts"],
  "sourcesContent": ["/**\n * Include in this file all the exports that should be part of the public API.\n */\nexport { initializeBindings, Ledger } from './bindings.js';\nexport { createForeignCurve, ForeignCurve, toPoint } from './lib/provable/crypto/foreign-curve.js';\nexport type { FlexiblePoint } from './lib/provable/crypto/foreign-curve.js';\nexport { createEcdsa, EcdsaSignature } from './lib/provable/crypto/foreign-ecdsa.js';\nexport { Hash } from './lib/provable/crypto/hash.js';\nexport { Keccak } from './lib/provable/crypto/keccak.js';\nexport { Poseidon, ProvableHashable, TokenSymbol } from './lib/provable/crypto/poseidon.js';\nexport {\n  AlmostForeignField,\n  CanonicalForeignField,\n  createForeignField,\n  ForeignField,\n} from './lib/provable/foreign-field.js';\nexport { ScalarField } from './lib/provable/scalar-field.js';\nexport type { ProvablePure } from './lib/provable/types/provable-intf.js';\nexport { Bool, Field, Group, Scalar } from './lib/provable/wrapped.js';\nexport { TupleN } from './lib/util/types.js';\n\nexport { assert } from './lib/provable/gadgets/common.js';\n\nexport * from './lib/provable/crypto/signature.js';\nexport type {\n  FlexibleProvable,\n  FlexibleProvablePure,\n  InferProvable,\n  ProvableExtended,\n} from './lib/provable/types/struct.js';\n\nexport { provableFromClass } from './lib/provable/types/provable-derivers.js';\nexport type { ProvablePureExtended } from './lib/provable/types/struct.js';\n\nexport { From, InferJson, InferValue, IsPure } from './bindings/lib/provable-generic.js';\nexport { Types } from './bindings/mina-transaction/v1/types.js';\nexport { Circuit, circuitMain, Keypair, public_ } from './lib/proof-system/circuit.js';\nexport { DynamicArray } from './lib/provable/dynamic-array.js';\nexport { Gadgets } from './lib/provable/gadgets/gadgets.js';\nexport { RuntimeTable } from './lib/provable/gadgets/runtime-table.js';\nexport { Int64, Sign, UInt32, UInt64, UInt8 } from './lib/provable/int.js';\nexport { Hashed, Packed } from './lib/provable/packed.js';\nexport { Provable } from './lib/provable/provable.js';\nexport { provable, provablePure } from './lib/provable/types/provable-derivers.js';\nexport { ProvableType } from './lib/provable/types/provable-intf.js';\nexport { Struct } from './lib/provable/types/struct.js';\nexport { Unconstrained } from './lib/provable/types/unconstrained.js';\nexport { Bytes, FlexibleBytes } from './lib/provable/wrapped-classes.js';\n\nexport { MerkleList, MerkleListIterator } from './lib/provable/merkle-list.js';\nexport { Option } from './lib/provable/option.js';\nimport {\n  IndexedMerkleMap as IndexedMerkleMap_,\n  IndexedMerkleMapBase,\n} from './lib/provable/merkle-tree-indexed.js';\nexport let IndexedMerkleMap = IndexedMerkleMap_;\nexport type IndexedMerkleMap = IndexedMerkleMapBase;\n\nexport { Reducer } from './lib/mina/v1/actions/reducer.js';\nexport * as Mina from './lib/mina/v1/mina.js';\nexport { declareState, state, State } from './lib/mina/v1/state.js';\nexport {\n  Transaction,\n  type IncludedTransaction,\n  type PendingTransaction,\n  type PendingTransactionPromise,\n  type RejectedTransaction,\n  type TransactionPromise,\n} from './lib/mina/v1/transaction.js';\nexport { declareMethods, method, SmartContract } from './lib/mina/v1/zkapp.js';\nexport type { DeployArgs } from './lib/mina/v1/zkapp.js';\n\nexport { Cache, CacheHeader } from './lib/proof-system/cache.js';\nexport { FeatureFlags } from './lib/proof-system/feature-flags.js';\nexport { DynamicProof, Proof, type ProofBase } from './lib/proof-system/proof.js';\nexport { VerificationKey } from './lib/proof-system/verification-key.js';\nexport { Empty, SelfProof, Undefined, verify, Void } from './lib/proof-system/zkprogram.js';\nexport type { JsonProof } from './lib/proof-system/zkprogram.js';\n\nexport {\n  AccountUpdate,\n  AccountUpdateForest,\n  AccountUpdateTree,\n  Permissions,\n  TokenId,\n  TransactionVersion,\n  ZkappPublicInput,\n} from './lib/mina/v1/account-update.js';\nexport { Account } from './lib/mina/v1/account.js';\n\nexport { TokenAccountUpdateIterator } from './lib/mina/v1/token/forest-iterator.js';\nexport { TokenContract } from './lib/mina/v1/token/token-contract.js';\n\nexport * as Encoding from './bindings/lib/encoding.js';\nexport {\n  addCachedAccount,\n  checkZkappTransaction,\n  fetchAccount,\n  fetchEvents,\n  fetchLastBlock,\n  fetchTransactionStatus,\n  Lightnet,\n  sendZkapp,\n  setArchiveGraphqlEndpoint,\n  setGraphqlEndpoint,\n  setGraphqlEndpoints,\n} from './lib/mina/v1/fetch.js';\nexport type { TransactionStatus } from './lib/mina/v1/graphql.js';\nexport * as Encryption from './lib/provable/crypto/encryption.js';\nexport { MerkleMap, MerkleMapWitness } from './lib/provable/merkle-map.js';\nexport { MerkleTree, MerkleWitness } from './lib/provable/merkle-tree.js';\nexport { Character, CircuitString } from './lib/provable/string.js';\n\nexport { Nullifier } from './lib/provable/crypto/nullifier.js';\n\nexport { ZkProgram } from './lib/proof-system/zkprogram.js';\n\nexport { Crypto } from './lib/provable/crypto/crypto.js';\n\nexport type { NetworkId } from './mina-signer/mina-signer.js';\n\nexport { setNumberOfWorkers } from './lib/proof-system/workers.js';\nexport { Experimental };\n\n// experimental APIs\nimport * as BatchReducer_ from './lib/mina/v1/actions/batch-reducer.js';\nimport { Actionable } from './lib/mina/v1/actions/offchain-state-serialization.js';\nimport * as OffchainState_ from './lib/mina/v1/actions/offchain-state.js';\nimport { Recursive as Recursive_ } from './lib/proof-system/recursive.js';\nimport {\n  KimchiJsonProof as KimchiJsonProof_,\n  KimchiProof as KimchiProof_,\n  KimchiVerificationKey as KimchiVerificationKey_,\n  ZkFunction as ZkFunction_,\n} from './lib/proof-system/zkfunction.js';\nimport {\n  createProvableBigInt as createProvableBigInt_,\n  ProvableBigInt as ProvableBigInt_,\n} from './lib/provable/bigint.js';\nimport { memoizeWitness } from './lib/provable/provable.js';\nimport { InferProvable } from './lib/provable/types/struct.js';\n\nimport * as V2_ from './lib/mina/v2/index.js';\nimport { Field } from './lib/provable/wrapped.js';\n\nconst Experimental_ = {\n  memoizeWitness,\n  V2: V2_,\n};\n\n/**\n * This module exposes APIs that are unstable, in the sense that the API surface is expected to change.\n * (Not unstable in the sense that they are less functional or tested than other parts.)\n */\nnamespace Experimental {\n  export let V2 = Experimental_.V2;\n\n  export namespace V2 {\n    export type MinaProgramEnv<State extends V2_.StateLayout> = V2_.MinaProgramEnv<State>;\n    export type StateLayout = V2_.StateLayout;\n    export type MinaProgramMethodReturn<\n      State extends V2_.StateLayout = 'GenericState',\n      Event = Field[],\n      Action = Field[],\n    > = V2_.MinaProgramMethodReturn<State, Event, Action>;\n    export type StateDefinition<State extends V2_.StateLayout> = V2_.StateDefinition<State>;\n    export type ZkappCommandAuthorizationEnvironment = V2_.ZkappCommandAuthorizationEnvironment;\n    export type MinaProgram<\n      State extends StateLayout,\n      Event,\n      Action,\n      MethodPrivateInputs extends { [key: string]: V2_.ProvableTuple },\n    > = V2_.MinaProgram<State, Event, Action, MethodPrivateInputs>;\n    export type DynamicProvable<P> = V2_.DynamicProvable<P>;\n  }\n\n  export let memoizeWitness = Experimental_.memoizeWitness;\n\n  export let Recursive = Recursive_;\n\n  export let ProvableBigInt = ProvableBigInt_;\n  export let createProvableBigInt = createProvableBigInt_;\n\n  export let ZkFunction = ZkFunction_;\n  export type KimchiProof = KimchiProof_;\n  export type KimchiVerificationKey = KimchiVerificationKey_;\n  export let KimchiProof = KimchiProof_;\n  export let KimchiVerificationKey = KimchiVerificationKey_;\n\n  export type KimchiJsonProof = KimchiJsonProof_;\n\n  // offchain state\n  export let OffchainState = OffchainState_.OffchainState;\n\n  /**\n   * Commitments that keep track of the current state of an offchain Merkle tree constructed from actions.\n   * Intended to be stored on-chain.\n   *\n   * Fields:\n   * - `root`: The root of the current Merkle tree\n   * - `actionState`: The hash pointing to the list of actions that have been applied to form the current Merkle tree\n   */\n  export class OffchainStateCommitments extends OffchainState_.OffchainStateCommitments {}\n\n  // batch reducer\n\n  /**\n   * A reducer to process actions in fixed-size batches.\n   *\n   * ```ts\n   * let batchReducer = new BatchReducer({ actionType: Action, batchSize: 5 });\n   *\n   * // in contract: concurrent dispatching of actions\n   * batchReducer.dispatch(action);\n   *\n   * // reducer logic\n   * // outside contract: prepare a list of { batch, proof } objects which cover all pending actions\n   * let batches = await batchReducer.prepareBatches();\n   *\n   * // in contract: process a single batch\n   * // create one transaction that does this for each batch!\n   * batchReducer.processBatch({ batch, proof }, (action, isDummy) => {\n   *   // ...\n   * });\n   * ```\n   */\n  export class BatchReducer<\n    ActionType extends Actionable<any>,\n    BatchSize extends number = number,\n    Action = InferProvable<ActionType>,\n  > extends BatchReducer_.BatchReducer<ActionType, BatchSize, Action> {}\n\n  /**\n   * Provable type that represents a batch of actions.\n   */\n  export let ActionBatch = BatchReducer_.ActionBatch;\n  export type ActionBatch<Action> = BatchReducer_.ActionBatch<Action>;\n}\n\nError.stackTraceLimit = 100000;\n\n// export parts of the low-level bindings interface for advanced users\nexport * as Core from './bindings/index.js';\n", "// @gen this file is generated from `bindings/ocaml/o1js_constants.ml` - don't edit it directly\nexport {\n  mocks,\n  poseidonParamsKimchiFp,\n  poseidonParamsLegacyFp,\n  prefixHashes,\n  prefixHashesLegacy,\n  prefixes,\n  protocolVersions,\n  versionBytes,\n};\n\nlet prefixes = {\n  event: 'MinaZkappEvent******',\n  events: 'MinaZkappEvents*****',\n  sequenceEvents: 'MinaZkappSeqEvents**',\n  zkappBodyMainnet: 'MainnetZkappBody****',\n  zkappBodyTestnet: 'TestnetZkappBody****',\n  accountUpdateCons: 'MinaAcctUpdateCons**',\n  accountUpdateNode: 'MinaAcctUpdateNode**',\n  account: 'MinaAccount*********',\n  zkappAccount: 'MinaZkappAccount****',\n  zkappMemo: 'MinaZkappMemo*******',\n  signatureMainnet: 'MinaSignatureMainnet',\n  signatureTestnet: 'CodaSignature*******',\n  zkappUri: 'MinaZkappUri********',\n  deriveTokenId: 'MinaDeriveTokenId***',\n  sideLoadedVK: 'MinaSideLoadedVk****',\n  merkleTree: [\n    'MinaMklTree000******',\n    'MinaMklTree001******',\n    'MinaMklTree002******',\n    'MinaMklTree003******',\n    'MinaMklTree004******',\n    'MinaMklTree005******',\n    'MinaMklTree006******',\n    'MinaMklTree007******',\n    'MinaMklTree008******',\n    'MinaMklTree009******',\n    'MinaMklTree010******',\n    'MinaMklTree011******',\n    'MinaMklTree012******',\n    'MinaMklTree013******',\n    'MinaMklTree014******',\n    'MinaMklTree015******',\n    'MinaMklTree016******',\n    'MinaMklTree017******',\n    'MinaMklTree018******',\n    'MinaMklTree019******',\n    'MinaMklTree020******',\n    'MinaMklTree021******',\n    'MinaMklTree022******',\n    'MinaMklTree023******',\n    'MinaMklTree024******',\n    'MinaMklTree025******',\n    'MinaMklTree026******',\n    'MinaMklTree027******',\n    'MinaMklTree028******',\n    'MinaMklTree029******',\n    'MinaMklTree030******',\n    'MinaMklTree031******',\n    'MinaMklTree032******',\n    'MinaMklTree033******',\n    'MinaMklTree034******',\n  ],\n};\nlet prefixHashes = {\n  'CodaReceiptUC*******': [\n    '2930292359494829300271368860633580634815819151887078160583250237349129726103',\n    '15303314845540397914948764201521841781296890621466368017042313538410516382474',\n    '8520568699315305732843613022173524514377597839978192694761879649747314556194',\n  ],\n  'CodaReceiptZkapp****': [\n    '10173709693039436418323173817852473796760618468635274081106091878172355412495',\n    '8139892805413950771311540201181177376747817902069998595519899391903936767134',\n    '13514876620613630149351219463845257700223634963001020028151406467995275024594',\n  ],\n  'Coinbase************': [\n    '16825847102297458526359719396083434368788313103713242309655412848174457920423',\n    '21732702256017917816272795771734458959259892802453584375610183841451053027064',\n    '20669950187190141732603807229833302926112666951294341954340514712643194206110',\n  ],\n  'PendingCoinbases****': [\n    '16730315671906078134534118281698719603694322959719576832314142406897554025946',\n    '25168172107432119701402092802564698772609386283424806773354665411015030859956',\n    '20203823516569384790863281992678977204769111540506990077513414850340465376267',\n  ],\n  'CoinbaseStackData***': [\n    '23795978781100345043289806728009175185120094645976380845310050347461663815988',\n    '22848259504294538625391413055517172710405127059374914145881816600826824598643',\n    '8292468073974572410325570929211069869427868613763277519881895337391418731450',\n  ],\n  CoinbaseStackStaHash: [\n    '335203117218289187585524630708440909952721586869179589604793956147132569543',\n    '27066428515933869709871979311099618239824992817474733219473754649926311088531',\n    '21249847167218596842529246266817628519376871370045151307329588726090940941283',\n  ],\n  'CoinbaseStack*******': [\n    '10365018507282248303752506973112854406071106890516858854157506926717812932750',\n    '19289691782405010481159082968251292806607879795611766141901748131065655579721',\n    '8987039650233860747996941600635099179155585390854763935988086491644855810711',\n  ],\n  'MinaCheckpoints*****': [\n    '15873130589302091361863210575263731242593763730169570459166821652327279429416',\n    '27741778946681194402252199348726997679847260280438775383573755416459042152245',\n    '7598438620402360345138640933713109733801127070065255775405685972203496634081',\n  ],\n  'MinaMergeSnark******': [\n    '5465206932306554741198859294482250047374987110116571903153751264716396266207',\n    '28325265961862852836567844362114881306407823522046946129773393861560948847052',\n    '20049678444717746759028157787181298288785775657186008836042341914370292827996',\n  ],\n  'MinaBaseSnark*******': [\n    '15502310217431654911062859746106286672455410530942120153504175184205809302248',\n    '3469045624943527165009161295743804688154058669917024998601801713171804105078',\n    '16667965011323249535055526937874001443515091810412343722400939445165393857780',\n  ],\n  'MinaProtoState******': [\n    '5218970939948495870036503265499543025475317910763049867270287867667146978870',\n    '7663210626148314949787033187186036425676070286961909238040356477815169631084',\n    '19859188289320816036969227839574854326171440874550138016648548415357198703337',\n  ],\n  'MinaProtoStateBody**': [\n    '3548547909990922956559515810876765435326873020883079662683136168632773655275',\n    '134182536761489093478066959027928272525080293912190881939140820794450385287',\n    '18910449726094816833941350890285540874861148441082116020102338532207375519343',\n  ],\n  'MinaVrfMessage******': [\n    '24101363367502572671624471609928959797353672294440762288404204895418767914646',\n    '5171820881164007689309616183632792746219180909518238150637460314245246143263',\n    '10979796915023089328772347959806029121878467684484216605075459818053899045444',\n  ],\n  MinaSignatureMainnet: [\n    '28597293842583882050529337819282358444728515448690248936274177901465134844489',\n    '13029865398778858891320837481651890827971447635226272051516204921834229015884',\n    '2324960771278703080070347074343683653953770644553957353754880132143131569147',\n  ],\n  'CodaSignature*******': [\n    '6547874669265470003564181123405173756111990160585052594027544303901364349512',\n    '22191763046611062479784309793717481299019591714391827084400612211604078633201',\n    '15360317550574394687602808211901764964514686767298144053612144955373862517277',\n  ],\n  'MinaVrfOutput*******': [\n    '2251514781415689779315070305878469259850299612928948069881728941286436529416',\n    '28445424317765931437563566658155841532256907311948842353165636913979445243675',\n    '1697103740469522139030362533818365124680980524626250761960654638291888644330',\n  ],\n  'MinaVrfEvaluation***': [\n    '28080055385183205248434069314913715411795750554846638282391132356635075327118',\n    '25018718747831549163470950235902703474807728450690404911050923194299837536932',\n    '3256623657773355300700179149632147114566124258546613752475489953689825740823',\n  ],\n  'MinaEpochSeed*******': [\n    '7920024158807749362970659876749181530334941449960381128739613586571256360405',\n    '13756862713999441076472977832321298402266591073703520273734381195492800342833',\n    '16931743843465107540110860558687538825985475311420101960428698400767332393906',\n  ],\n  'MinaTransitionSnark*': [\n    '11049595972041980914958840531625028328602860712038036656362464370121336040984',\n    '24369517789348117364784880800333031735213111703459853079908318927717982912175',\n    '996573540734206293061884582007205418029995442386259428924494388795357965385',\n  ],\n  'MinaAccount*********': [\n    '21547009634669789644192675386133007766042650219024716227935570378579547706642',\n    '3869977418072959680344087467966431440327948593054069717779845397512987438978',\n    '17591003611016737523041467644989399067682599282318802410210271366172380277153',\n  ],\n  'MinaZkappAccount****': [\n    '11742420651603425685690711434636216727968618158667382343736587130720645535016',\n    '20917169788479399921968659996772666237321879817943938162255353371266230737562',\n    '20221577186851444354528754069740362935513598751580381763045954351047955571417',\n  ],\n  'MinaSideLoadedVk****': [\n    '27153629295534844750482612843518005572402188741101822965689207110291504095805',\n    '11073437601016088346212553894160581939150688827288603152461976873708720172824',\n    '9169013693168830396847022454402673046094697740892173219744332585469764409612',\n  ],\n  'MinaZkappPayload****': [\n    '15735138827391397348912010094577234813869450438840158969759900004702547928125',\n    '25095612872941242247876048162039143509752212627701285511972307921367391645919',\n    '7245494597725009330136300549232949784423520250577599502394596645257342395146',\n  ],\n  'MainnetZkappBody****': [\n    '10214915150831852734808709087755641273868350720962413399868532305813227181967',\n    '19231103515031626108540280352804904215178644233964839448405623573586547300771',\n    '3202185325412846279878024015439663797323768206239602518916650099275135615824',\n  ],\n  'TestnetZkappBody****': [\n    '20037733640875789833090442509053816933966165101372309054048970230906793051053',\n    '1106678471497583468621635190733109842219273971961053291385773425960251864224',\n    '25565387364959491931899708566015584890804577695743228799735258954982776499278',\n  ],\n  'MinaZkappPred*******': [\n    '1288860557840839698672685006364179285130411098848600694737282320588924548492',\n    '24648295833336558525603848295184424886548932461541421142783307792871113347031',\n    '1330615836835056811243082335077124866238751435915242573993316916713469087050',\n  ],\n  'MinaZkappPredAcct***': [\n    '16247099195538206941970428186933809576049890124762896310373916059400681012938',\n    '15171999803179862436296250357712424012107969488385552487664863256867849154640',\n    '4695118160519310765712802705640939163487421977728313886668234870398464448283',\n  ],\n  'MinaZkappPredPS*****': [\n    '28115844434401213157045670864292277190427496512916771660477513364996586226191',\n    '17764239860871865704512758086410304367016330694375482081848267812860896213477',\n    '2608563583120825722034995217249250504732387097295075568312443453761249924462',\n  ],\n  'MinaAcctUpdAcctPred*': [\n    '11173347481325879282537380504137543614432174467122278589147153842480174214350',\n    '22433785030516935555884954114999194863743668497200511950547006360846720681436',\n    '4261224905860522407514587942832658209487173552801239748203234114069543449134',\n  ],\n  'MinaAcctUpdateCons**': [\n    '7974184247425786365466969127827083941281743695327546149120833518746435921046',\n    '1079147682067570431747049877519099849334832444581201545961023544596733431550',\n    '9670106619202136718451303928765479503313491401619698334696903962327538130992',\n  ],\n  'MinaAcctUpdateNode**': [\n    '15921812961830232432174711488904180713275251781093575291539345321597011303739',\n    '5852213322332241594845871336918115662219071361771346507406094569679662937607',\n    '21122827334147180286039671993443893600964526985496742826857975683524856341379',\n  ],\n  'MinaAcctUpdStckFrm**': [\n    '1223279431820750727612295994589444883292600761079562536688416996919972234987',\n    '1873141333924103856860857609363983758885824745969813373245393521390926426683',\n    '3550105212452130151915860825756512345408015936295894584118372238840612023788',\n  ],\n  MinaActUpStckFrmCons: [\n    '2363089775097766730570162674460603870980415123701610894146069429352874281636',\n    '8717086429614898734892919627864489205116600585932141922995487227707208282057',\n    '14660270392332597302006144557344641683528071714290878702086758222477469533211',\n  ],\n  'MinaZkappUri********': [\n    '534822897390732927195976832726937157108052596941484097303405936433225931144',\n    '21308674973525253012607500915181592359821899373849668837401701284134790635210',\n    '19235616568963430752220890547731083898076295596325584947617173371158207986317',\n  ],\n  'MinaZkappEvent******': [\n    '4144672248660824652311280789227568759501644435839088465487215978090977152836',\n    '16580012705864177241905923711864666027965216928284588602669501632136706453456',\n    '28268897103231723777184618409092967932555901943057586428182153116992131011025',\n  ],\n  'MinaZkappEvents*****': [\n    '22941690192200157010958144262626906691861453230235765939870625581651903942109',\n    '8085194290973996063041942057794139208480036474122767282118588735695477304146',\n    '26729904183313179836453835886592671283117737890095730465188585661277543615385',\n  ],\n  'MinaZkappSeqEvents**': [\n    '20111532619758468729019280527752703188436440291616049387250019116440725105679',\n    '28272901079534355755544153990297346241256584111406088887261772513761686581936',\n    '11593971643819429831651280663135869674712971584194549509498204047075895747923',\n  ],\n  'MinaZkappMemo*******': [\n    '2662735671148484138098041239517130399444285195614926917304994766121342901330',\n    '1889560324711062089177091328630260720221153765601231238715650562289804935970',\n    '4150523804923664151142435309968051550133270766858171566059780615187901817023',\n  ],\n  'MinaZkappTest*******': [\n    '23523101868899742954180674496902908392567863852999903167375927084079494055612',\n    '4491786955849351692402874941062803293792761915358826996649017458255778371918',\n    '18160445324611651688025194683090940451613686777550031421971998315243738422364',\n  ],\n  'MinaDeriveTokenId***': [\n    '6192019453766080264591455948244350296532066491511280821771403784079613278630',\n    '3474280028978446563781013959252007045004226094384968366087940198662654278266',\n    '20434002876694963787609307807174199928279086350854834006718281273564667456637',\n  ],\n  CodaReceiptEmpty: [\n    '14564582992068613478915821183083107733064540968050799295374021047658500056219',\n    '21765043973285063733734239399942750176857972907855721619600674857294623000734',\n    '18519955733587546799174091248819038069762857427193969217428957100491271613694',\n  ],\n  MinaZkappEventsEmpty: [\n    '11558119263070965853863267079253872832625419457395008685779236645292569607921',\n    '25458142203119307439619503192644060065091275427503371449742352140981637359577',\n    '28343474290528262467651243371210869540984529302238754668057531270656874883506',\n  ],\n  MinaZkappActionsEmpty: [\n    '2965377540200775924504968637505084669999360240500907972788072774778139588064',\n    '17888733104410001265760460027725887240172765470923695174284923303416908725309',\n    '6155733123951817300356401771271939707310716210385193729101357561319788034953',\n  ],\n  MinaZkappActionStateEmptyElt: [\n    '25079927036070901246064867767436987657692091363973573142121686150614948079097',\n    '26431778411571512074795067173224334387034335867358343719815640998216694007738',\n    '25080775363764450744501815075506845022058095277795060631172637381645274354727',\n  ],\n  CoinbaseStack: [\n    '13478948633790621346997153068092516261975764161208078295837519850718904039733',\n    '23794571567771902109532327523992257297445027552423990566905688786749549749640',\n    '12437776415960587857483436445253285567999534294199440886476575966193776753527',\n  ],\n  PendingCoinbaseMerkleTree: [\n    '21962074494103541153175746450273873003299668759086391980006382367241943398196',\n    '2903435713642676558047328375873609628346075739786101737671585224825766548393',\n    '25831764682100331646870313396659195191400312071282528592914032765816857800473',\n  ],\n  'MinaMklTree000******': [\n    '8397268313679062041369959431253823194029931472150942928062160502284391094281',\n    '24767884761786058961844271624848183563027832662151526765582126547150580343286',\n    '15520161476079946346223794435136450862321049619449569410496603974021593252201',\n  ],\n  'MinaMklTree001******': [\n    '12373852158717286419843731546435335382149645091717657472272709119680142489615',\n    '13564003298811293044133692367818358732199958610489782205113648738971877309993',\n    '5337043262085238844960907983211959910580364187637104432942748885155441259131',\n  ],\n  'MinaMklTree002******': [\n    '15051812550454916172932351641588540140427950452718257831984749683884179659477',\n    '28383195182051628320454520194171815630993209993126957580698595309541504912011',\n    '4277691878710291748308373204686233213493236676960343422888557635834505390473',\n  ],\n  'MinaMklTree003******': [\n    '6575607106027019342374634884807079936125440627705088279356425488661046931690',\n    '526224612349672274315011399400566806883023700724847451269254308717318755497',\n    '4003207773096098875040917033101823533304203798100315080652105415888406223352',\n  ],\n  'MinaMklTree004******': [\n    '24963240007694741581504536598446662705874548366155724154174858737449434658477',\n    '3025643334447992593201368502593388460692780911680818037147500927887943605498',\n    '17577291971615136405466944877064852825800866932005309965300049909875838083076',\n  ],\n  'MinaMklTree005******': [\n    '11625519336224216740433997623839523639549293720171430638848267458495647838261',\n    '14197827690168556134026805733901328807809311762374992007209622464122527394871',\n    '24909546339148248646747762490876591451430974658068769530058833648954096301456',\n  ],\n  'MinaMklTree006******': [\n    '20496141241824212441237352225390586578798287226209999878764321364949616437960',\n    '4155590369081069691345914612081918410248481482116023511739814856893535749559',\n    '25280235590916436988517501437699802702512719636909687680088402215172012465734',\n  ],\n  'MinaMklTree007******': [\n    '10298068926909347382132883731000773194312572157088286708479172422210086260995',\n    '14412862431845107093626156618901720148499279341044373322107997590840338638158',\n    '18738278293927842151520671915277777211638038066182255367951771829184874598427',\n  ],\n  'MinaMklTree008******': [\n    '28632592040294076899303724277173923788865287530305670556694222869732793988004',\n    '14134336299867672225741933845142646509776280694779004162993533642733541282015',\n    '28037399410478206961594894531712592987717708818866863005767179190210518183828',\n  ],\n  'MinaMklTree009******': [\n    '28322440793030270460307522165077799886504360112793805560745845785393893720792',\n    '3680990636041985093510751436516424061735738733660682549379374982251492126646',\n    '7896824890513378496611723513283689788600212799489558200026291296328182622221',\n  ],\n  'MinaMklTree010******': [\n    '1478825754917601949043978332728751378179798684550333324122027096810422078645',\n    '19955446483411426559697602372431961972639316232014088927090908136220581190127',\n    '22937261898125224845285209761802309482795401959887338893419704202246881755471',\n  ],\n  'MinaMklTree011******': [\n    '3025669655948979260146450778546273335663805909503078623788468939889184085065',\n    '15993847354573651974906488175776892699808218007882158173582011967178852672755',\n    '6728962834255630075044411175238909144357249010478126045082535701512206099100',\n  ],\n  'MinaMklTree012******': [\n    '4677165292950275428044379611682530196143565581952109747023715412205031133122',\n    '21513899673761352699672092079955767010402365369617552725870531290648558067173',\n    '5823386711670711136557441661686775439019939642112594994252954772574341048476',\n  ],\n  'MinaMklTree013******': [\n    '4137450619603133353679529278148472140169709465994051450094506977210968350741',\n    '20777878603100506442428451439085789382190751853558867746947762486311334171694',\n    '27969424486066619381654224557897167292901506145568220790334189049235066613665',\n  ],\n  'MinaMklTree014******': [\n    '7462353831830439752760657933641455151117269082035084708085558232378403435178',\n    '1787244519320006617494344121814759180988090836648336932002915182844592150859',\n    '7682306724592829108592527309756770669512991144597346665572702844909814248134',\n  ],\n  'MinaMklTree015******': [\n    '12849982892801603879697133836957604723592408109307896931233575279534184819695',\n    '27109175861581264256359157262042451197946512419680432940872313012019233881553',\n    '13815104575456051899693190094329831931582197916170277640933492195480185919492',\n  ],\n  'MinaMklTree016******': [\n    '6644594317394622409746632037064067639690803096240195936787541353591870145229',\n    '11503303739151441813791807558499068063822922776334355558577285976158398952971',\n    '9337125879737469121869180649342064063336965090821029559184624332617319461193',\n  ],\n  'MinaMklTree017******': [\n    '16104414183099799176590675567463444044322697144434744941137050377134055108298',\n    '17358877713925634221311853575857896650017793698150943722268889332978652414223',\n    '7234126597295300967301107936467282549695978865424211233580228640451399578381',\n  ],\n  'MinaMklTree018******': [\n    '17030714373021103124485584722642520216144771996601835120521405613273080127695',\n    '26509950438240323122836106956137067463028271669140328718474012128935499432293',\n    '9818889955393545543887790759741008577636326202190253983607321653665940190431',\n  ],\n  'MinaMklTree019******': [\n    '2270411531086562128123060093007384197084198453711890037231329803621300858719',\n    '21192327485899043676835708468201514580084416399939158033379551466586666938111',\n    '16033989106273371309578845565218498940092011786025881685960320194668952032796',\n  ],\n  'MinaMklTree020******': [\n    '24198821385641779512630219367024089801694762674171638444197433117564329069692',\n    '17399215024068249103454892742127252703846599060950907551709080066119343928674',\n    '6797496550859701647209308902606013125966581359799331801777446461476502619719',\n  ],\n  'MinaMklTree021******': [\n    '15260363122901687259348044007172490341059494245069079855983853109440904252201',\n    '21842382560395200222478365766257143008580907092198481707074219770380221343296',\n    '19876442709041612567866226719534012751674476537343454328432936802993088542055',\n  ],\n  'MinaMklTree022******': [\n    '10163265845587027789352563667609980510844248093141311984644246724416434726269',\n    '13369107363202464111086659762824590159914641657154062683624651983805608000703',\n    '259175261445126704640807316250901216510411826120741654939526054707099272571',\n  ],\n  'MinaMklTree023******': [\n    '25461412540439968937539737336272713843660028687121793297700520674608023616092',\n    '10755893000209302712577283259218096030828962406298481790491258793159046533447',\n    '8866387537961409494137849949417794325538964245944495058838310355591599158861',\n  ],\n  'MinaMklTree024******': [\n    '10609060102237336747496673704618826236585593118726760088941627829244492026235',\n    '6641853671926028367004819143507613339775735721213578606129119394262986889972',\n    '9176598236393962999771652301435919857376442200780273350376009302991599772639',\n  ],\n  'MinaMklTree025******': [\n    '8743110049886111146439413671080530377154252710287926017043338548443560750915',\n    '18208706295395849104423491533560000448355322792628322573027110778397939938163',\n    '2334327064299326913052261993744862803507079864714736582625500368508312407812',\n  ],\n  'MinaMklTree026******': [\n    '5402818389523730021623225031229797943489634186744070457165886896537635439065',\n    '3692115584159570188352953749250318597861823862334166671448537184963748474804',\n    '6395188055016804845192781987569287073677422173381065069566010090740896063910',\n  ],\n  'MinaMklTree027******': [\n    '23003820738793392288354347717848227276238967632076473726115713990146403158695',\n    '1543444712754301638361713310613005045560110448825211620606741790481631721785',\n    '25595274127363608001744519321284450036093000747866790144244029941400855918414',\n  ],\n  'MinaMklTree028******': [\n    '1371490494959146551400088557556657100677286767912367568372761029147549710248',\n    '9732076291970119043155961140210107725581877672949581468560495192803834949972',\n    '25880816593631896400945395886425311206250378130295778852027160152013445398428',\n  ],\n  'MinaMklTree029******': [\n    '5026966843162353429404633270081859806361860129654116093869475139616692501822',\n    '14399077456078098196809897303466976088446801284524532382221120510698115179718',\n    '19173688776848337916142856590169111672948615917148745778746830767290062051975',\n  ],\n  'MinaMklTree030******': [\n    '28464430208663194459267079800760461073547794864536029383346306150717295227411',\n    '28914474904259440678682001469840084119186056954595456498123242804122927256626',\n    '26203211860047183178968105249611310661035109372798510229151816437426414875870',\n  ],\n  'MinaMklTree031******': [\n    '10406444365958122823322321566809921419619436370846100318015238317663537713508',\n    '19324027736939870254907794657369430751886546066724762856165204189536200502231',\n    '27910908481683556223061499853457824695327274417786658997051526597466420105059',\n  ],\n  'MinaMklTree032******': [\n    '1799233325885428173215288721205732918055309618518578057591098186182492814731',\n    '9573156486615047627167271384099786785626031045209045718144391096893253044237',\n    '21011100500969260736212187791129169911216589801480194154796681238630801173303',\n  ],\n  'MinaMklTree033******': [\n    '3148460134537259154192780209825660438770489205065565102219398141630842726179',\n    '10416076901773723654263170420888517757942744365709722512723508899712187445722',\n    '9749070751601048371099954046702168187173097100747088073519924283619949053060',\n  ],\n  'MinaMklTree034******': [\n    '16036605154418397696690227738898261818934103448455753144542686857246049934251',\n    '13116195790811852398580983299275910910260911290232634459841017490947920635760',\n    '20914357145334136112903459144371894839046767011252485660349261543687439240515',\n  ],\n};\nlet prefixHashesLegacy = {\n  'CodaReceiptUC*******': [\n    '17081977821176270994512651394491195177111442160604726653596300537904083542874',\n    '22524836078442467808299966370016521142448937585030982609163888361124501146539',\n    '12924279821307137198726349959646209575189430925513631516289320462608412110369',\n  ],\n  MinaSignatureMainnet: [\n    '25220214331362653986409717908235786107802222826119905443072293294098933388948',\n    '7563646774167489166725044360539949525624365058064455335567047240620397351731',\n    '171774671134240704318655896509797243441784148630375331692878460323037832932',\n  ],\n  'CodaSignature*******': [\n    '28132119227444686413214523693400847740858213284875453355294308721084881982354',\n    '24895072146662946646133617369498198544578131474807621989761680811592073367193',\n    '3216013753133880902260672769141972972810073620591719805178695684388949134646',\n  ],\n};\nlet versionBytes = {\n  tokenIdKey: 28,\n  receiptChainHash: 12,\n  ledgerHash: 5,\n  epochSeed: 13,\n  stateHash: 16,\n  publicKey: 203,\n  userCommandMemo: 20,\n  privateKey: 90,\n  signature: 154,\n  transactionHash: 29,\n  signedCommandV1: 19,\n};\nlet protocolVersions = { txnVersion: 3 };\nlet poseidonParamsKimchiFp = {\n  mds: [\n    [\n      '12035446894107573964500871153637039653510326950134440362813193268448863222019',\n      '25461374787957152039031444204194007219326765802730624564074257060397341542093',\n      '27667907157110496066452777015908813333407980290333709698851344970789663080149',\n    ],\n    [\n      '4491931056866994439025447213644536587424785196363427220456343191847333476930',\n      '14743631939509747387607291926699970421064627808101543132147270746750887019919',\n      '9448400033389617131295304336481030167723486090288313334230651810071857784477',\n    ],\n    [\n      '10525578725509990281643336361904863911009900817790387635342941550657754064843',\n      '27437632000253211280915908546961303399777448677029255413769125486614773776695',\n      '27566319851776897085443681456689352477426926500749993803132851225169606086988',\n    ],\n  ],\n  roundConstants: [\n    [\n      '21155079691556475130150866428468322463125560312786319980770950159250751855431',\n      '16883442198399350202652499677723930673110172289234921799701652810789093522349',\n      '17030687036425314703519085065002231920937594822150793091243263847382891822670',\n    ],\n    [\n      '25216718237129482752721276445368692059997901880654047883630276346421457427360',\n      '9054264347380455706540423067244764093107767235485930776517975315876127782582',\n      '26439087121446593160953570192891907825526260324480347638727375735543609856888',\n    ],\n    [\n      '15251000790817261169639394496851831733819930596125214313084182526610855787494',\n      '10861916012597714684433535077722887124099023163589869801449218212493070551767',\n      '18597653523270601187312528478986388028263730767495975370566527202946430104139',\n    ],\n    [\n      '15831416454198644276563319006805490049460322229057756462580029181847589006611',\n      '15171856919255965617705854914448645702014039524159471542852132430360867202292',\n      '15488495958879593647482715143904752785889816789652405888927117106448507625751',\n    ],\n    [\n      '19039802679983063488134304670998725949842655199289961967801223969839823940152',\n      '4720101937153217036737330058775388037616286510783561045464678919473230044408',\n      '10226318327254973427513859412126640040910264416718766418164893837597674300190',\n    ],\n    [\n      '20878756131129218406920515859235137275859844638301967889441262030146031838819',\n      '7178475685651744631172532830973371642652029385893667810726019303466125436953',\n      '1996970955918516145107673266490486752153434673064635795711751450164177339618',\n    ],\n    [\n      '15205545916434157464929420145756897321482314798910153575340430817222504672630',\n      '25660296961552699573824264215804279051322332899472350724416657386062327210698',\n      '13842611741937412200312851417353455040950878279339067816479233688850376089318',\n    ],\n    [\n      '1383799642177300432144836486981606294838630135265094078921115713566691160459',\n      '1135532281155277588005319334542025976079676424839948500020664227027300010929',\n      '4384117336930380014868572224801371377488688194169758696438185377724744869360',\n    ],\n    [\n      '21725577575710270071808882335900370909424604447083353471892004026180492193649',\n      '676128913284806802699862508051022306366147359505124346651466289788974059668',\n      '25186611339598418732666781049829183886812651492845008333418424746493100589207',\n    ],\n    [\n      '10402240124664763733060094237696964473609580414190944671778761753887884341073',\n      '11918307118590866200687906627767559273324023585642003803337447146531313172441',\n      '16895677254395661024186292503536662354181715337630376909778003268311296637301',\n    ],\n    [\n      '23818602699032741669874498456696325705498383130221297580399035778119213224810',\n      '4285193711150023248690088154344086684336247475445482883105661485741762600154',\n      '19133204443389422404056150665863951250222934590192266371578950735825153238612',\n    ],\n    [\n      '5515589673266504033533906836494002702866463791762187140099560583198974233395',\n      '11830435563729472715615302060564876527985621376031612798386367965451821182352',\n      '7510711479224915247011074129666445216001563200717943545636462819681638560128',\n    ],\n    [\n      '24694843201907722940091503626731830056550128225297370217610328578733387733444',\n      '27361655066973784653563425664091383058914302579694897188019422193564924110528',\n      '21606788186194534241166833954371013788633495786419718955480491478044413102713',\n    ],\n    [\n      '19934060063390905409309407607814787335159021816537006003398035237707924006757',\n      '8495813630060004961768092461554180468161254914257386012937942498774724649553',\n      '27524960680529762202005330464726908693944660961000958842417927307941561848461',\n    ],\n    [\n      '15178481650950399259757805400615635703086255035073919114667254549690862896985',\n      '16164780354695672259791105197274509251141405713012804937107314962551600380870',\n      '10529167793600778056702353412758954281652843049850979705476598375597148191979',\n    ],\n    [\n      '721141070179074082553302896292167103755384741083338957818644728290501449040',\n      '22044408985956234023934090378372374883099115753118261312473550998188148912041',\n      '27068254103241989852888872162525066148367014691482601147536314217249046186315',\n    ],\n    [\n      '3880429241956357176819112098792744584376727450211873998699580893624868748961',\n      '17387097125522937623262508065966749501583017524609697127088211568136333655623',\n      '6256814421247770895467770393029354017922744712896100913895513234184920631289',\n    ],\n    [\n      '2942627347777337187690939671601251987500285937340386328746818861972711408579',\n      '24031654937764287280548628128490074801809101323243546313826173430897408945397',\n      '14401457902976567713827506689641442844921449636054278900045849050301331732143',\n    ],\n    [\n      '20170632877385406450742199836933900257692624353889848352407590794211839130727',\n      '24056496193857444725324410428861722338174099794084586764867109123681727290181',\n      '11257913009612703357266904349759250619633397075667824800196659858304604714965',\n    ],\n    [\n      '22228158921984425749199071461510152694025757871561406897041788037116931009246',\n      '9152163378317846541430311327336774331416267016980485920222768197583559318682',\n      '13906695403538884432896105059360907560653506400343268230130536740148070289175',\n    ],\n    [\n      '7220714562509721437034241786731185291972496952091254931195414855962344025067',\n      '27608867305903811397208862801981345878179337369367554478205559689592889691927',\n      '13288465747219756218882697408422850918209170830515545272152965967042670763153',\n    ],\n    [\n      '8251343892709140154567051772980662609566359215743613773155065627504813327653',\n      '22035238365102171608166944627493632660244312563934708756134297161332908879090',\n      '13560937766273321037807329177749403409731524715067067740487246745322577571823',\n    ],\n    [\n      '21652518608959234550262559135285358020552897349934571164032339186996805408040',\n      '22479086963324173427634460342145551255011746993910136574926173581069603086891',\n      '13676501958531751140966255121288182631772843001727158043704693838707387130095',\n    ],\n    [\n      '5680310394102577950568930199056707827608275306479994663197187031893244826674',\n      '25125360450906166639190392763071557410047335755341060350879819485506243289998',\n      '22659254028501616785029594492374243581602744364859762239504348429834224676676',\n    ],\n    [\n      '23101411405087512171421838856759448177512679869882987631073569441496722536782',\n      '24149774013240355952057123660656464942409328637280437515964899830988178868108',\n      '5782097512368226173095183217893826020351125522160843964147125728530147423065',\n    ],\n    [\n      '13540762114500083869920564649399977644344247485313990448129838910231204868111',\n      '20421637734328811337527547703833013277831804985438407401987624070721139913982',\n      '7742664118615900772129122541139124149525273579639574972380600206383923500701',\n    ],\n    [\n      '1109643801053963021778418773196543643970146666329661268825691230294798976318',\n      '16580663920817053843121063692728699890952505074386761779275436996241901223840',\n      '14638514680222429058240285918830106208025229459346033470787111294847121792366',\n    ],\n    [\n      '17080385857812672649489217965285727739557573467014392822992021264701563205891',\n      '26176268111736737558502775993925696791974738793095023824029827577569530708665',\n      '4382756253392449071896813428140986330161215829425086284611219278674857536001',\n    ],\n    [\n      '13934033814940585315406666445960471293638427404971553891617533231178815348902',\n      '27054912732979753314774418228399230433963143177662848084045249524271046173121',\n      '28916070403698593376490976676534962592542013020010643734621202484860041243391',\n    ],\n    [\n      '24820015636966360150164458094894587765384135259446295278101998130934963922381',\n      '7969535238488580655870884015145760954416088335296905520306227531221721881868',\n      '7690547696740080985104189563436871930607055124031711216224219523236060212249',\n    ],\n    [\n      '9712576468091272384496248353414290908377825697488757134833205246106605867289',\n      '12148698031438398980683630141370402088785182722473169207262735228500190477924',\n      '14359657643133476969781351728574842164124292705609900285041476162075031948227',\n    ],\n    [\n      '23563839965372067275137992801035780013422228997724286060975035719045352435470',\n      '4184634822776323233231956802962638484057536837393405750680645555481330909086',\n      '16249511905185772125762038789038193114431085603985079639889795722501216492487',\n    ],\n    [\n      '11001863048692031559800673473526311616702863826063550559568315794438941516621',\n      '4702354107983530219070178410740869035350641284373933887080161024348425080464',\n      '23751680507533064238793742311430343910720206725883441625894258483004979501613',\n    ],\n    [\n      '28670526516158451470169873496541739545860177757793329093045522432279094518766',\n      '3568312993091537758218792253361873752799472566055209125947589819564395417072',\n      '1819755756343439646550062754332039103654718693246396323207323333948654200950',\n    ],\n    [\n      '5372129954699791301953948907349887257752247843844511069896766784624930478273',\n      '17512156688034945920605615850550150476471921176481039715733979181538491476080',\n      '25777105342317622165159064911913148785971147228777677435200128966844208883059',\n    ],\n    [\n      '25350392006158741749134238306326265756085455157012701586003300872637887157982',\n      '20096724945283767296886159120145376967480397366990493578897615204296873954844',\n      '8063283381910110762785892100479219642751540456251198202214433355775540036851',\n    ],\n    [\n      '4393613870462297385565277757207010824900723217720226130342463666351557475823',\n      '9874972555132910032057499689351411450892722671352476280351715757363137891038',\n      '23590926474329902351439438151596866311245682682435235170001347511997242904868',\n    ],\n    [\n      '17723373371137275859467518615551278584842947963894791032296774955869958211070',\n      '2350345015303336966039836492267992193191479606566494799781846958620636621159',\n      '27755207882790211140683010581856487965587066971982625511152297537534623405016',\n    ],\n    [\n      '6584607987789185408123601849106260907671314994378225066806060862710814193906',\n      '609759108847171587253578490536519506369136135254150754300671591987320319770',\n      '28435187585965602110074342250910608316032945187476441868666714022529803033083',\n    ],\n    [\n      '16016664911651770663938916450245705908287192964254704641717751103464322455303',\n      '17551273293154696089066968171579395800922204266630874071186322718903959339163',\n      '20414195497994754529479032467015716938594722029047207834858832838081413050198',\n    ],\n    [\n      '19773307918850685463180290966774465805537520595602496529624568184993487593855',\n      '24598603838812162820757838364185126333280131847747737533989799467867231166980',\n      '11040972566103463398651864390163813377135738019556270484707889323659789290225',\n    ],\n    [\n      '5189242080957784038860188184443287562488963023922086723850863987437818393811',\n      '1435203288979376557721239239445613396009633263160237764653161500252258220144',\n      '13066591163578079667911016543985168493088721636164837520689376346534152547210',\n    ],\n    [\n      '17345901407013599418148210465150865782628422047458024807490502489711252831342',\n      '22139633362249671900128029132387275539363684188353969065288495002671733200348',\n      '1061056418502836172283188490483332922126033656372467737207927075184389487061',\n    ],\n    [\n      '10241738906190857416046229928455551829189196941239601756375665129874835232299',\n      '27808033332417845112292408673209999320983657696373938259351951416571545364415',\n      '18820154989873674261497645724903918046694142479240549687085662625471577737140',\n    ],\n    [\n      '7983688435214640842673294735439196010654951226956101271763849527529940619307',\n      '17067928657801807648925755556866676899145460770352731818062909643149568271566',\n      '24472070825156236829515738091791182856425635433388202153358580534810244942762',\n    ],\n    [\n      '25752201169361795911258625731016717414310986450004737514595241038036936283227',\n      '26041505376284666160132119888949817249574689146924196064963008712979256107535',\n      '23977050489096115210391718599021827780049209314283111721864956071820102846008',\n    ],\n    [\n      '26678257097278788410676026718736087312816016749016738933942134600725962413805',\n      '10480026985951498884090911619636977502506079971893083605102044931823547311729',\n      '21126631300593007055117122830961273871167754554670317425822083333557535463396',\n    ],\n    [\n      '1564862894215434177641156287699106659379648851457681469848362532131406827573',\n      '13247162472821152334486419054854847522301612781818744556576865965657773174584',\n      '8673615954922496961704442777870253767001276027366984739283715623634850885984',\n    ],\n    [\n      '2794525076937490807476666942602262298677291735723129868457629508555429470085',\n      '4656175953888995612264371467596648522808911819700660048695373348629527757049',\n      '23221574237857660318443567292601561932489621919104226163978909845174616477329',\n    ],\n    [\n      '1878392460078272317716114458784636517603142716091316893054365153068227117145',\n      '2370412714505757731457251173604396662292063533194555369091306667486647634097',\n      '17409784861870189930766639925394191888667317762328427589153989811980152373276',\n    ],\n    [\n      '25869136641898166514111941708608048269584233242773814014385564101168774293194',\n      '11361209360311194794795494027949518465383235799633128250259863567683341091323',\n      '14913258820718821235077379851098720071902170702113538811112331615559409988569',\n    ],\n    [\n      '12957012022018304419868287033513141736995211906682903915897515954290678373899',\n      '17128889547450684566010972445328859295804027707361763477802050112063630550300',\n      '23329219085372232771288306767242735245018143857623151155581182779769305489903',\n    ],\n    [\n      '1607741027962933685476527275858938699728586794398382348454736018784568853937',\n      '2611953825405141009309433982109911976923326848135736099261873796908057448476',\n      '7372230383134982628913227482618052530364724821976589156840317933676130378411',\n    ],\n    [\n      '20203606758501212620842735123770014952499754751430660463060696990317556818571',\n      '4678361398979174017885631008335559529633853759463947250620930343087749944307',\n      '27176462634198471376002287271754121925750749676999036165457559387195124025594',\n    ],\n    [\n      '6361981813552614697928697527332318530502852015189048838072565811230204474643',\n      '13815234633287489023151647353581705241145927054858922281829444557905946323248',\n      '10888828634279127981352133512429657747610298502219125571406085952954136470354',\n    ],\n  ],\n  fullRounds: 55,\n  partialRounds: 0,\n  hasInitialRoundConstant: false,\n  stateSize: 3,\n  rate: 2,\n  power: 7,\n};\nlet poseidonParamsLegacyFp = {\n  mds: [\n    [\n      '5328350144166205084223774245058198666309664348635459768305312917086056785354',\n      '15214731724107930304595906373487084110291887262136882623959435918484004667388',\n      '22399519358931858664262538157042328690232277435337286643350379269028878354609',\n    ],\n    [\n      '10086628405675314879458652402278736459294354590428582803795166650930540770072',\n      '17127968360683744052278857147989507037142007029142438136689352416106177192235',\n      '14207324749280135281015658576564097509614634975132487654324863824516044294735',\n    ],\n    [\n      '3059104278162906687184746935153057867173086006783171716838577369156969739687',\n      '16755849208683706534025643823697988418063305979108082130624352443958404325985',\n      '16889774624482628108075965871448623911656600744832339664842346756371603433407',\n    ],\n  ],\n  roundConstants: [\n    [\n      '1346081094044643970582493287085428191977688221215786919106342366360741041016',\n      '10635969173348128974923358283368657934408577270968219574411363948927109531877',\n      '18431955373344919956072236142080066866861234899777299873162413437379924987003',\n    ],\n    [\n      '5797044060651575840084283729791357462720161727701814038830889113712361837236',\n      '931288489507796144596974766082847744938192694315568692730730202141894005205',\n      '13659894470945121760517769979107966886673294523737498361566285362771110125394',\n    ],\n    [\n      '6076231707445968054305995680347976771585015308155855387339303513025362636128',\n      '28822740034050339685362260108484262889265034407340240070058997651710236456303',\n      '23420266473857869790486107029614186913447272961845992963194006142267563993493',\n    ],\n    [\n      '13753917374184785903125509246122783296344288469304898921025291716613575849357',\n      '22396739346703340038555577564698139382745239004673153148674304627904081092826',\n      '13064238335532551154986111986409392866270911640785653458047811526842088084911',\n    ],\n    [\n      '23165923875642452719095776619341762858050322341374771345641255745672274104746',\n      '1876216571769482372914291210815859835162659440705283782713345335434924136736',\n      '25448252060136178247213604035267580231762596830634036926922217427938159849142',\n    ],\n    [\n      '2161875315509206970842862195937323600322108268401381254431163181777726747153',\n      '19159855698625842998331760283165907305622417625829203038229273729196960321630',\n      '24828563875172432296791053766778475681869974948122169083176331088266823626561',\n    ],\n    [\n      '15959479662608710141128458274961057999257961784282074767105536637788386907463',\n      '8006369581283017287449277389162056290714176164680299906116833200510117952858',\n      '18794336794618132129607701188430371953320538976527988886453665523008714542779',\n    ],\n    [\n      '19408271715954593722501381885401160867835377473312521553027032015227895029571',\n      '13654747284005184272412579731446984220568337794941823533879059135026064413631',\n      '14094055032353750931629930778481002727722804310855727808905931659115939920989',\n    ],\n    [\n      '13241818625838429282823260827177433104574315653706102174619924764342778921524',\n      '25709259239494174564705048436260891089407557689981668111890003079561388887725',\n      '26866626910239634723971078462134580196819809568632305020800296809092442642381',\n    ],\n    [\n      '23886826350713085163238005260075062110062681905356997481925492650252417143049',\n      '16853602711255261520713463306790360324679500458440235992292027384928526778856',\n      '18444710386168488194610417945072711530390091945738595259171890487504771614189',\n    ],\n    [\n      '16896789009769903615328691751424474161656500693270070895928499575572871141439',\n      '23842266984616972287898037872537536999393060934879414668030219493005225085992',\n      '24369698563802298585444760814856330583118549706483939267059237951238240608187',\n    ],\n    [\n      '25360195173713628054110426524260405937218170863260484655473435413697869858790',\n      '1486437708678506228822038923353468635394979165769861487132708983207562337116',\n      '18653498960429911228442559598959970807723487073275324556015861725806677047150',\n    ],\n    [\n      '18878179044241268037057256060083772636369783391816038647949347814518015576522',\n      '178715779905629247116805974152863592571182389085419970371289655361443016848',\n      '8381006794425876451998903949255801618132578446062133243427381291481465852184',\n    ],\n    [\n      '4176946262813877719206528849579392120806054050640974718891398605746592169324',\n      '16376345520728802444699629729684297833862527190772376028981704525651968727081',\n      '8399065769082251057361366626601550736334213197703006866551331927128775757919',\n    ],\n    [\n      '15435308585611812393531506745122614542196708285088622615406141986333182280857',\n      '4082259282787276939431186930090898350392871145699460879678141552997816391817',\n      '26348742719959309014730178326877937464605873211235784184917342950648457078699',\n    ],\n    [\n      '9707631711734344681918469569872517425107158187591261754498805460753455298868',\n      '27910768846011709391567916011595957279088224137468948238696800459136335473132',\n      '20407239095656434708569263842372155762970847207558227886302782130015730063802',\n    ],\n    [\n      '22726225412881182965250630589245572283256255052470345984553083359461473893802',\n      '12443967854426795490638709950679156338200426963050610832781263082981525248175',\n      '27102543658848146076219989119639465430524061997280788166887046421706499775415',\n    ],\n    [\n      '14427224233985680214097547669945064793149553513421479297921556194475574770861',\n      '22917454832925781549840198815703114840452733537799472739275668965081704937832',\n      '3455076056123630366063931123762198941796412458154689469887583689725886013901',\n    ],\n    [\n      '4513100023937785913596662867311227004762025658663076805918211014066645403017',\n      '18187619530784075723418065322038024507729605774832001333883311123910954334059',\n      '9447065431426150382325592560406989926365684509675374414068135115024495130938',\n    ],\n    [\n      '3227816098015819796753427754968234889554095489076864339942014527747604603014',\n      '14798316759185072116520458171957899889489461918408669809912344751222514418582',\n      '23013904852315603905843158448056763116188801262838729536210355401378476650033',\n    ],\n    [\n      '20979191509934291452182967564058656088941447895799901211038858159903580333267',\n      '20772973010251235271448378823573767262405703078344288856168565499702414379868',\n      '10105446427739226002497411811738001382334316505480517822035303561899927603685',\n    ],\n    [\n      '11079074761356717003579108002319997196881121172538617046865136940931215263187',\n      '4693927775411489288330326150094711670434597808961717172753867514688725690438',\n      '18581720304902876944842830383273503265470859268712618325357902881821721540119',\n    ],\n    [\n      '3065369948183164725765083504606321683481629263177690053939474679689088169185',\n      '18515622379147081456114962668688706121098539582467584736624699157043365677487',\n      '17563088600719312877716085528177751048248154461245613291986010180187238198006',\n    ],\n    [\n      '26199746176994924146211004840756471702409132230831594954444947705902602287290',\n      '7576136600627345523051497639367002272003104458453478964661395239732811642605',\n      '20058687874612168338994287374025378897088936171250328231848098497610185784281',\n    ],\n    [\n      '16894722532414195606958290526999761110785277556463400588047573469106594850228',\n      '13961730805696859614283621225672002906734926278118993580398533742874863598733',\n      '25256842011135514243352951950573936602906198374305137963222382546140030647211',\n    ],\n    [\n      '18530360047537856737482157200091774590035773602620205695980247565433703032532',\n      '23014819965938599260086897799541446473887833964178378497976832161473586995397',\n      '27911426213258307990762460361663504655967992659180759140364181941291843542489',\n    ],\n    [\n      '1067338118323302017358103178057182291035336430305886255160210378977812067042',\n      '17219092885519007424608854460610388434712113621163885775309496940189894433620',\n      '16432921127615937542183846559291144733339643093361323334499888895135356545408',\n    ],\n    [\n      '28608851042959977114787048070153637607786033079364369200270218128830983558707',\n      '10121629780013165888398831090128011045011860641816380162950736555305748332191',\n      '2348036340843128746981122630521268144839343500596932561106759754644596320722',\n    ],\n    [\n      '16619881370356823200358060093334065394764987467483650323706184068451904156452',\n      '2302436627861989749837563733434625231689351276818486757748445924305258835336',\n      '27514536540953539473280001431110316405453388911725550380123851609652679788049',\n    ],\n    [\n      '9459277727420672604737117687200019308525004979918488827092207438664125039815',\n      '23425670740358068509956137586663046763224562225383386726193078231034380596217',\n      '7641885067011661443791509688937280323563328029517832788240965464798835873658',\n    ],\n    [\n      '9579420382351699601929202663836555665702024548386778299996961509578687980280',\n      '18513671386572584282611234979588379470994484682444053600751415262497237017703',\n      '24923151431234706142737221165378041700050312199585085101919834422744926421604',\n    ],\n    [\n      '21131320841803068139502705966375283830095161079635803028011171241658723560073',\n      '19208476595309656066589572658712717685014329237892885950958199953675225096566',\n      '24023185216737416080949689106968568821656545490748664446389634158498624398204',\n    ],\n    [\n      '7510552996848634969347937904645640209946785877619890235458182993413526028718',\n      '3694415017252995094553868781762548289196990492336482360084813900937464847638',\n      '9219021070107873028263141554048987416559034633883158827414043929220388719352',\n    ],\n    [\n      '5058327241234443421111591959922712922949620710493120384930391763032694640881',\n      '13148252221647574076185511663661016015859769210867362839817254885265598775418',\n      '15186790492457240277904880519227706403545816456632095870015828239411033220638',\n    ],\n    [\n      '2775942914650502409705888572245750999561427024488403026572311267798009048466',\n      '6277965230841030155341171319927732572492215818164736949144854827643964384893',\n      '24144742149845235561087977558785057713814731737434473021812189457617252043745',\n    ],\n    [\n      '25789129719327437503403457598813971826156253950521984610569937361506914183550',\n      '21500534320778995945845999974779950304491968082325255355181901574840373597824',\n      '17185359848218837018503091932245529880546896465437232425673134558221638601375',\n    ],\n    [\n      '12253896579078110143384981818031883112606762215016553811786428215758384195713',\n      '12956658260778456372481429232709881794962204180363200699121804724437678625542',\n      '3023603786717368708677300377055384474816569333060487675635618249403832078921',\n    ],\n    [\n      '4186492855716808019562789862833898284927736051002588766326482010810259565130',\n      '4263939782228419774639068267872291539552889472311225829898746091327730032923',\n      '24068843626280451423530509388397151179174104901782990365720205643492047328816',\n    ],\n    [\n      '14564937827374621319716285527475223392664010281568256859627186463065876537730',\n      '28367596550218705971881480694115935470211319172596432472834880507822452927283',\n      '28712267437482356021504544448225827500268648754270274754623969882031853409874',\n    ],\n    [\n      '4542596163006916397403529184431773692747461300288194722982487051249951403191',\n      '2530461821259252672899452671728393208543894014761816288817584587718369998371',\n      '12886393063011539390567049190923398676964700147222878509238966758839020897414',\n    ],\n    [\n      '21593897590707514492037699253654745501762191795293908682495110982956631870528',\n      '13233005790593128135480716846773978578237145313006994631606474472023504621256',\n      '21621863098292803642478350494794106282518362577273973885587684567452726939909',\n    ],\n    [\n      '26068620073001644720969640099644251616742620988609091568084348314770436291745',\n      '18248589586787935500122854210401321966459127818593446990365211078521058875685',\n      '21247134484403265289037859533347798468858819117600251067578809852124865474448',\n    ],\n    [\n      '7947383127165915366383984718363902897504221803836013123394785749404572432524',\n      '22173041014621867335598230447618036223462011647696367239478182269973488867154',\n      '16773227734018849308448505860847939069870370055633571816925675705713088305139',\n    ],\n    [\n      '10708707957340055662073314227607620808612686977606082605219160019699644826999',\n      '21249897193797038261479589555720746994050836195265348846222835266344091683000',\n      '12581195059139097540117398803363514148192715293133623516709277290477633379593',\n    ],\n    [\n      '19779599816866992123290302397082614570282926215253589712189610064229996603178',\n      '21749216503901548676985371189807470207364320167486559936962401093285243029177',\n      '17600045923623503357380202389718735904174992978547372448837488832457719009224',\n    ],\n    [\n      '2732872979548118117758016335601225525660858727422778256671975055129965858636',\n      '13703031005128062046175331918702218558750713240446179585947851411173844703597',\n      '28447710105386636841938034820015573492556750872924193415447818187228356409281',\n    ],\n    [\n      '28539960355005748517007309210788803416171161412204526246799800716567376494244',\n      '21329318452221893900731030722137844458345358926323127858742388587761302609863',\n      '28135302149599894709369178097439582767613940517471323224020113411362601191873',\n    ],\n    [\n      '24980774120400248734054527936006392540889095705961960837980443629260392758683',\n      '20339911045808632098936066397942175169549806052128535543540543556255197716643',\n      '7929293103930252545581851978492699598413941396422930641071359388697302362494',\n    ],\n    [\n      '8911092207145893152276662096451247820054843777071569723455408545101628926203',\n      '19648860643145256523615441075182036100116634560394529500146405733687718224516',\n      '14635387208623683806428528837466762532853903031263830054986064902455379735903',\n    ],\n    [\n      '11555212214346132926966321609673228184079851030522218543981385635403167028692',\n      '20896918157639814425520058178561910811657326967880217845710779511927814874973',\n      '4650158165912007049140499755153804318686705949436165235742106170124284287326',\n    ],\n    [\n      '13880660273492757167295696447853232191657893303250187467329180558670697369810',\n      '8043529172463774320604378774840863923445982272478964686447801046272917236836',\n      '2134399296482715903442913099374581981696436050603410080564843555725771329441',\n    ],\n    [\n      '27320952903412641133501507962185246982787769547770982814240701526492601978122',\n      '23417491374379751329394424924400186404791519133465537872457405970098902747611',\n      '17612427354278346772575179176139417348059847375297761006336024476146551185903',\n    ],\n    [\n      '10710998507064742997612080847223278109404482930427999113323732519626499166548',\n      '14958094513415797513745395709487730603918953350067504982704138489305723550923',\n      '24096319595904213497633343966229498735553590589105811393277073274927955202995',\n    ],\n    [\n      '17983724131200292654039765185049138356840415443160477259330748730019147254309',\n      '17598096800487588874709548646068838880468456205252324677357706597166777506441',\n      '27420647821110229619898200875848631488422182349567475956209153112306555222281',\n    ],\n    [\n      '448538544835457571662601142415301047108854812427100562339376187510452313026',\n      '23494184556634922103535803143214434479598067155171780264810485708203176455201',\n      '22626342941879801989161990529511235538216563009907378573817996229389756621777',\n    ],\n    [\n      '26128268137723417163973860961686381960826033145738852158792607959175787222856',\n      '20225791828042873305317281581105429726352058325970107209484198122707862156597',\n      '7538871133759632802857159609785118198934349221046986784429069814655215585732',\n    ],\n    [\n      '26184554861259642274153262777073624024579929401668865520166966302070394487366',\n      '28755259264665180745537307265993667261709206143628938749669440804401623257679',\n      '11896066093033549470312328497237649508068258723531931099214795928200015717321',\n    ],\n    [\n      '21657721599978732693249012287058163532690942515202465984736373311077240614059',\n      '9214914097169852704753116653702415951907628005986883140609006971322091003693',\n      '18710111680849814325169297240208687402588261569152088592693815711857504371037',\n    ],\n    [\n      '6813635166770764528979084175325709935892248249948967889926276426090222296643',\n      '20546585456429436268067726231902751119458200511988152296570567167520382569278',\n      '20087466019194902429054761607398988292568594301671509779549344754172952693871',\n    ],\n    [\n      '28185105286740691904534067831357491310995891986363455251895371651360605333143',\n      '10108348212894231193041286244259038275269464277821588425688314560368589986063',\n      '11433633215392393209829215018579238412423821563056156785641278458497271271546',\n    ],\n    [\n      '27870881917195016999862550657996865268956893566432995492427618003637597051321',\n      '102309803677783876701097881491240456320211833502658383473112057006867019389',\n      '22844040227595875612525628393174357057929113317578127744718774517498324646590',\n    ],\n    [\n      '18364790233947478619325319418813215212267974311771564959136180502266118026133',\n      '2480624341921718230432383518425561514824501138863702825916674641657321180841',\n      '16778939567530361665956758171503829349658551798564323167725356065198936433124',\n    ],\n    [\n      '11947564511486966895926950599696532964589539443187518177489990556481125699966',\n      '3133187646540385483015602955087323554103587039123577645562801570574691666057',\n      '27704797101265438206569218421707753788081674727344603874614391656565567951541',\n    ],\n    [\n      '13001484695584753475562184349533365512515447041450030471627087395341039487710',\n      '477322000667279478600757543806155989948171541982639893984064422067850617496',\n      '13913755821658634147813329813115566967428755223601185963529801459396673113438',\n    ],\n    [\n      '16621869429023470107454028095846067937827722393398508604914831452950874033411',\n      '21755744236927410239079501831014076529931327263341620300431356747367343619046',\n      '26538666591151124505694487799121414506088199961481579132019627484065014831180',\n    ],\n    [\n      '3066480818457008068617042549071052338581291837882909165666223566402713429090',\n      '16182268213934119294035309949459684472027705439038023775276926916166831108357',\n      '28907604876608422892474268478706783033050951245339691569015166507728369585190',\n    ],\n    [\n      '27973960109508292680965426133498827831691369851701664449575719912259359998113',\n      '1456924360278399121996742356757866616312146358469991014696110099534285524446',\n      '8234248752911525485438611255163504976087091103090603316695312869292347668495',\n    ],\n    [\n      '8716078950082339630026654067608811496722305720644485560320987802533380421009',\n      '19016744645809919602099479306503354923553336014593353020688463619133130053825',\n      '24379650661051444982012238084495990858827340608012118841005379796362233056432',\n    ],\n    [\n      '2245379544097631382062919677963998259142792890502492881341386639439507471783',\n      '28788137434161061988371619554419440748189388934884757179010092973102292086583',\n      '7187000185648741287953633167647835668543536354944774631102766873251849991238',\n    ],\n    [\n      '18319349500538500800225762827448369057030532278398270164660609327776487168142',\n      '2622932985948021877314529887962683530522545893985767148345336304947201715671',\n      '13805188629797792210337544360632964855143280581052079479249966961215582531026',\n    ],\n    [\n      '27457600993464082637917106210690168172469473943609357897393615707457194410878',\n      '15448646156961779103834447043970817898237835202826003934642165760908058355399',\n      '9396792545729486882231669677795667529746274932273033601723318032992363022062',\n    ],\n    [\n      '9927877141952679457141759789181418464292082444806533413864151258248124544859',\n      '23827901395971835838179844085051957393677906360196119690926757794561937573142',\n      '3273544693673216914876067527455588276979859627093391584406340272737391174619',\n    ],\n    [\n      '19571510438350300564152393820251652609646082150148656806391655428002614034315',\n      '4458840243585913642400750597703353770666314833058197517675446022682775625834',\n      '6452218213610300363069953741424106105609715382419342511693148495219793324457',\n    ],\n    [\n      '14558167930891460678441266912176752652821641543245953113671886345167213541771',\n      '10650967986920075561478528461783351160938460620955779955379459848889204404950',\n      '19990009778942542934049216419052172134625404062770188357110708518621145688588',\n    ],\n    [\n      '26855242974447190235826233682457047761532515293146087151296725996543442567035',\n      '22785340043356532865086769889360674409753343398766563441587096485751538658065',\n      '28603049427449348335651629195385434188071937908693764500052489540779792538285',\n    ],\n    [\n      '20545812864989828913452616721240947168977365844984763819184465128164378967167',\n      '23234068381345797209897730226956922073109641728569353961504167817770340037954',\n      '26031714567641615877877111172701145299483019910006153132858512509897185854695',\n    ],\n    [\n      '9512221744061419790435674197238913998387834650389922233458121639503195504983',\n      '12587458000103271975978240683793268604398305885278203470492658961734100340536',\n      '9670291694005369437277651504604785512303147991710650505302465204429311229197',\n    ],\n    [\n      '26995526763045548800439747262386290359229145489609341602564040676717570935439',\n      '23742712112104280264401317024221734961713400615669958343926511931219510484675',\n      '27931469778579449247589315744656633392873808631802461175539563849884447358271',\n    ],\n    [\n      '20669006894143187877081688942720159738269397552445286314270368345994751825389',\n      '26891772301075275370472640177651637211280740381619976926886106618375467277414',\n      '28387986011980449959047232529988203397251084614417760995257355718700961696092',\n    ],\n    [\n      '6579105010484741592730389416372694666279917604793318157514380025250233913402',\n      '11007035767869292700964744408562802781669930023548892567535397874932420229930',\n      '981148366863906885900456473323410468923514528856216824044152942069412627408',\n    ],\n    [\n      '22213671088722307302576907504985884923571642958053627659840326928319445671280',\n      '1318836216310789598614608105109389429335273432455224127576823891011367206122',\n      '25586582796990779718352441955439394949194222626688223867952982491529809559257',\n    ],\n    [\n      '4923739488579452777913681531125585976446366144127161879759262506690369040090',\n      '23505612338866210737103599484620591026802005128655081877133994175016351514827',\n      '323887003859465324514901860965142186539600668250760639664361851354147799637',\n    ],\n    [\n      '10198923064967306784017949469108033682156920551672348936591491217255268794658',\n      '9593680688139131432883442351722730169325112619984238956948153423155998917175',\n      '27027988263960602112273050725720071355535922812577299127302015348825197871870',\n    ],\n    [\n      '14419883951157390867695097127684346981136020111885301573583640959136319507752',\n      '5104414988075833278683649298543440897371415916271358703850262680431809374355',\n      '24739655595299332818980677669648719986462429574612913501586844601377825836782',\n    ],\n    [\n      '28522818684103966731129743408029731246564480741348128436668680764518115102581',\n      '21520350704208288978690888796633940487888044365108767319141211249242880355961',\n      '17391005598311948834360476853940353239444383292422171321575043660157438608537',\n    ],\n    [\n      '15367833944125677011173327826570204350687925236257190051755087781855930646142',\n      '21715073802090413714601069529558707101797361591183718695054701329871284436172',\n      '8994093285353831008525761670339342200997965950202092028313103110478252647618',\n    ],\n    [\n      '8370824693889782161629525898408725452177580012023459750897244954935682978671',\n      '16123253540853556024347150096993154278773652905830608614979368087152152043083',\n      '3535380953353495025888433493640531836449699255364366295870140701379497967423',\n    ],\n    [\n      '6954518484798178646508803478426114267143074508396663899281411171704702743829',\n      '28903134801897070276701950388422104654018369750191967384271618837091859516942',\n      '20872505363530172448468374920196608937030884647150175861507911076568784054834',\n    ],\n    [\n      '6902861581703501105786795670676641959401710346423594578401934671029571262513',\n      '10124161387604183369443890585742198433184078889862870469507328332805848271064',\n      '10488004060799269337071647841224034919633445750252076195310163972966405029030',\n    ],\n    [\n      '507704911991278613147490289466075160618843900088471236546244459176211783848',\n      '7252739745607302667257774481690407709040936359589867974787811552896597703097',\n      '23278073497974004442836030100920157527910770509761505828038443336325476654930',\n    ],\n    [\n      '22766285055433137793164317120096790621982728188995759745859222009100808389090',\n      '23129058299483468195787339200845749049960038336751758017949899311636830205152',\n      '16665333681978951552434356320651834889869437822496200946959897681307959400425',\n    ],\n    [\n      '12145699202182574939376505075528461451757079041659894988784442097333218352048',\n      '26340666275844437932755852805027863696219004039301187587209926587657008948704',\n      '19208771804191839410002226941825269105677187954811130189835856228258013753206',\n    ],\n    [\n      '21957102494792377508237608216278079874536155315851198461024084071231867104453',\n      '6933367436450995525851693784691226222726503560893470094614235356287049091852',\n      '15707767379191450768747057313641112321773921923533732633534831270357733757271',\n    ],\n    [\n      '27661963645951389261638591385668507557739541354225916772550248746235106571003',\n      '19699458096897937575096494582288688995241392471402204995195057374756282223421',\n      '902873385171181344315871113842580653512118892800584003934454469411716098791',\n    ],\n    [\n      '17184835876565576154014372215369798779520343573944211203710896053325717110660',\n      '664657295519303589036289440053175741110032988007278988577620229144220576240',\n      '10803972669668998371638869508774217165881281885838503958226056357738500321396',\n    ],\n    [\n      '2329846733754251453632375727999372856194157027336139087170310553870624325301',\n      '14139944357035048486675740400655356660678187875721949218090128899571575479791',\n      '18368148273419807418427674359327442879484531833435081951870369910704734685351',\n    ],\n    [\n      '10480273665080572189328459165704340191901489646067580012574464138528963201459',\n      '21773636700078124500346009061678153597323236568110076029811348966753228682835',\n      '18184268307211429260956076021417309535471438696101133218049142374847151474905',\n    ],\n    [\n      '25957533025669311312382992376854735734491934602484112256289764602447226406852',\n      '22223261506176684934865714490719116745135417403915426392159449667435294570739',\n      '22937309162832499167063076416585504361695925730111272512450449042837586253575',\n    ],\n    [\n      '16956181785481598286719868503945127919581091625126206673934113115358441284347',\n      '8497782777197814773596870810881707148695901557289856910220737358078100998191',\n      '21135503731586600979470064722475007625236017670426339278983640892218291297054',\n    ],\n    [\n      '17809297343844488723046665739910571149089769215421130894378638450427880983923',\n      '72435395972188389387093550708873189001876361107443937983754878061522372356',\n      '7511239878692099209014947248389283109997289411550315391143819429585903287870',\n    ],\n  ],\n  fullRounds: 63,\n  partialRounds: 0,\n  hasInitialRoundConstant: true,\n  stateSize: 3,\n  rate: 2,\n  power: 5,\n};\nlet mocks = {\n  dummyVerificationKeyHash:\n    '3392518251768960475377392625298437850623664973002200885669375116181514017494',\n};\n", "import { TupleN } from '../util/types.js';\n\n/**\n * This module contains basic methods for interacting with OCaml\n */\nexport {\n  MlArray,\n  MlPair,\n  MlList,\n  MlOption,\n  MlBool,\n  MlBytes,\n  MlResult,\n  MlUnit,\n  MlString,\n  MlTuple,\n  MlArrayOptionalElements,\n};\n\n// ocaml types\n\ntype MlPair<X, Y> = [0, X, Y];\ntype MlArray<T> = [0, ...T[]];\ntype MlList<T> = [0, T, 0 | MlList<T>];\ntype MlOption<T> = 0 | [0, T];\ntype MlBool = 0 | 1;\ntype MlResult<T, E> = [0, T] | [1, E];\ntype MlUnit = 0;\n\n// custom types\ntype MlArrayOptionalElements<MlArray extends any[]> = {\n  [K in keyof MlArray]: MlArray[K] extends 0 ? 0 : MlOption<MlArray[K]>;\n};\n\n/**\n * js_of_ocaml representation of a byte array,\n * see https://github.com/ocsigen/js_of_ocaml/blob/master/runtime/mlBytes.js\n */\ntype MlBytes = { t: number; c: string; l: number };\ntype MlString = MlBytes;\n\nconst MlArray = {\n  to<T>(arr: T[]): MlArray<T> {\n    return [0, ...arr];\n  },\n  from<T>([, ...arr]: MlArray<T>): T[] {\n    return arr;\n  },\n  map<T, S>([, ...arr]: MlArray<T>, map: (t: T) => S): MlArray<S> {\n    return [0, ...arr.map(map)];\n  },\n  mapTo<T, S>(arr: T[], map: (t: T) => S): MlArray<S> {\n    return [0, ...arr.map(map)];\n  },\n  mapFrom<T, S>([, ...arr]: MlArray<T>, map: (t: T) => S): S[] {\n    return arr.map(map);\n  },\n};\n\nconst MlPair = Object.assign(\n  function MlTuple<X, Y>(x: X, y: Y): MlPair<X, Y> {\n    return [0, x, y];\n  },\n  {\n    from<X, Y>([, x, y]: MlPair<X, Y>): [X, Y] {\n      return [x, y];\n    },\n    first<X>(t: MlPair<X, unknown>): X {\n      return t[1];\n    },\n    second<Y>(t: MlPair<unknown, Y>): Y {\n      return t[2];\n    },\n  }\n);\n\nconst MlBool = Object.assign(\n  function MlBool(b: boolean): MlBool {\n    return b ? 1 : 0;\n  },\n  {\n    from(b: MlBool) {\n      return !!b;\n    },\n  }\n);\n\nconst MlOption = Object.assign(\n  function MlOption<T>(x?: T): MlOption<T> {\n    return x === undefined ? 0 : [0, x];\n  },\n  {\n    from<T>(option: MlOption<T>): T | undefined {\n      return option === 0 ? undefined : option[1];\n    },\n    map<T, S>(option: MlOption<T>, map: (t: T) => S): MlOption<S> {\n      if (option === 0) return 0;\n      return [0, map(option[1])];\n    },\n    mapFrom<T, S>(option: MlOption<T>, map: (t: T) => S): S | undefined {\n      if (option === 0) return undefined;\n      return map(option[1]);\n    },\n    mapTo<T, S>(option: T | undefined, map: (t: T) => S): MlOption<S> {\n      if (option === undefined) return 0;\n      return [0, map(option)];\n    },\n    isNone(option: MlOption<unknown>): option is 0 {\n      return option === 0;\n    },\n    isSome<T>(option: MlOption<T>): option is [0, T] {\n      return option !== 0;\n    },\n  }\n);\n\nconst MlResult = {\n  ok<T, E>(t: T): MlResult<T, E> {\n    return [0, t];\n  },\n  unitError<T>(): MlResult<T, 0> {\n    return [1, 0];\n  },\n};\n\n/**\n * tuple type that has the length as generic parameter\n */\ntype MlTuple<T, N extends number> = N extends N\n  ? number extends N\n    ? [0, ...T[]] // N is not typed as a constant => fall back to array\n    : [0, ...TupleRec<T, N, []>]\n  : never;\n\ntype TupleRec<T, N extends number, R extends unknown[]> = R['length'] extends N\n  ? R\n  : TupleRec<T, N, [T, ...R]>;\n\ntype Tuple<T> = [T, ...T[]] | [];\n\nconst MlTuple = {\n  map<T extends Tuple<any>, B>(\n    [, ...mlTuple]: [0, ...T],\n    f: (a: T[number]) => B\n  ): [0, ...{ [i in keyof T]: B }] {\n    return [0, ...mlTuple.map(f)] as any;\n  },\n\n  mapFrom<T, N extends number, B>([, ...mlTuple]: MlTuple<T, N>, f: (a: T) => B): B[] {\n    return mlTuple.map(f);\n  },\n\n  mapTo<T extends Tuple<any> | TupleN<any, any>, B>(\n    tuple: T,\n    f: (a: T[number]) => B\n  ): [0, ...{ [i in keyof T]: B }] {\n    return [0, ...tuple.map(f)] as any;\n  },\n};\n", "export { withPrefix, mapTuple };\n\nfunction withPrefix<prefix extends string, T extends Record<string, any>>(prefix: prefix, obj: T) {\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v]) => {\n      return [`${prefix}_${k}`, v];\n    })\n  ) as {\n    [k in keyof T & string as `${prefix}_${k}`]: T[k];\n  };\n}\n\ntype Tuple<T> = [T, ...T[]] | [];\n\nfunction mapTuple<T extends Tuple<any>, B>(\n  tuple: T,\n  f: (a: T[number]) => B\n): { [i in keyof T]: B } {\n  return tuple.map(f) as any;\n}\n", "import { MlBool } from '../../../lib/ml/base.js';\nimport { withPrefix } from './util.js';\n\n/**\n * TS implementation of Pasta_bindings.BigInt256\n */\nexport {\n  Bigint256Bindings,\n  Bigint256,\n  toMlStringAscii,\n  fromMlString,\n  MlBytes,\n  mlBytesFromUint8Array,\n  mlBytesToUint8Array,\n};\n\ntype Bigint256 = [0, bigint];\n\nconst Bigint256Bindings = withPrefix('caml_bigint_256', {\n  // TODO\n  of_numeral(s: MlBytes, i: number, j: number): Bigint256 {\n    throw Error('caml_bigint_256_of_numeral not implemented');\n  },\n  of_decimal_string(s: MlBytes): Bigint256 {\n    return [0, BigInt(fromMlString(s))];\n  },\n  num_limbs(): number {\n    return 4;\n  },\n  bytes_per_limb(): number {\n    return 8;\n  },\n  div([, x]: Bigint256, [, y]: Bigint256): Bigint256 {\n    return [0, x / y];\n  },\n  compare([, x]: Bigint256, [, y]: Bigint256): number {\n    if (x < y) return -1;\n    if (x === y) return 0;\n    return 1;\n  },\n  print([, x]: Bigint256): void {\n    console.log(x.toString());\n  },\n  to_string(x: Bigint256) {\n    return toMlStringAscii(x[1].toString());\n  },\n  // TODO performance critical\n  test_bit(b: Bigint256, i: number): MlBool {\n    return MlBool(!!(b[1] & (1n << BigInt(i))));\n  },\n  to_bytes([, x]: Bigint256) {\n    let ocamlBytes = caml_create_bytes(32);\n    for (let i = 0; i < 32; i++) {\n      let byte = Number(x & 0xffn);\n      caml_bytes_unsafe_set(ocamlBytes, i, byte);\n      x >>= 8n;\n    }\n    if (x !== 0n) throw Error(\"bigint256 doesn't fit into 32 bytes.\");\n    return ocamlBytes;\n  },\n  of_bytes(ocamlBytes: MlBytes): Bigint256 {\n    let length = ocamlBytes.l;\n    if (length > 32) throw Error(length + \" bytes don't fit into bigint256\");\n    let x = 0n;\n    let bitPosition = 0n;\n    for (let i = 0; i < length; i++) {\n      let byte = caml_bytes_unsafe_get(ocamlBytes, i);\n      x |= BigInt(byte) << bitPosition;\n      bitPosition += 8n;\n    }\n    return [0, x];\n  },\n  deep_copy([, x]: Bigint256): Bigint256 {\n    return [0, x];\n  },\n});\n\n// TODO clean up all this / make type-safe and match JSOO in all relevant cases\n\nfunction fromMlString(s: MlBytes) {\n  // TODO doesn't handle all cases\n  return s.c;\n}\nfunction toMlStringAscii(s: string) {\n  return new MlBytes(9, s, s.length);\n}\n\nfunction caml_bytes_unsafe_get(s: MlBytes, i: number): number {\n  switch (s.t & 6) {\n    default: /* PARTIAL */\n      if (i >= s.c.length) return 0;\n    case 0 /* BYTES */:\n      return s.c.charCodeAt(i);\n    case 4 /* ARRAY */:\n      return s.c[i] as any as number;\n  }\n}\n\nfunction caml_bytes_unsafe_set(s: MlBytes, i: number, c: number) {\n  // The OCaml compiler uses Char.unsafe_chr on integers larger than 255!\n  c &= 0xff;\n  if (s.t != 4 /* ARRAY */) {\n    if (i == s.c.length) {\n      s.c += String.fromCharCode(c);\n      if (i + 1 == s.l) s.t = 0; /*BYTES | UNKNOWN*/\n      return 0;\n    }\n    caml_convert_bytes_to_array(s);\n  }\n  // TODO\n  (s.c as any)[i] = c;\n  return 0;\n}\n\nfunction caml_create_bytes(len: number) {\n  return new MlBytes(2, '', len);\n}\n\nfunction caml_convert_bytes_to_array(s: MlBytes) {\n  /* Assumes not ARRAY */\n  let a = new Uint8Array(s.l);\n  let b = s.c,\n    l = b.length,\n    i = 0;\n  for (; i < l; i++) a[i] = b.charCodeAt(i);\n  for (l = s.l; i < l; i++) a[i] = 0;\n  (s as any).c = a;\n  // TODO\n  s.t = 4; /* ARRAY */\n  return a;\n}\n\nfunction mlBytesFromUint8Array(uint8array: Uint8Array | number[]) {\n  let length = uint8array.length;\n  let ocaml_bytes = caml_create_bytes(length);\n  for (let i = 0; i < length; i++) {\n    // No need to convert here: OCaml Char.t is just an int under the hood.\n    caml_bytes_unsafe_set(ocaml_bytes, i, uint8array[i]);\n  }\n  return ocaml_bytes;\n}\n\nfunction mlBytesToUint8Array(ocaml_bytes: MlBytes) {\n  let length = ocaml_bytes.l;\n  let bytes = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    // No need to convert here: OCaml Char.t is just an int under the hood.\n    bytes[i] = caml_bytes_unsafe_get(ocaml_bytes, i);\n  }\n  return bytes;\n}\n\nclass MlBytes {\n  t: number;\n  c: string;\n  l: number;\n\n  constructor(tag: number, content: string, length: number) {\n    this.t = tag;\n    this.c = content;\n    this.l = length;\n  }\n\n  toString() {\n    if (this.t === 9) return this.c;\n    throw Error('todo');\n  }\n\n  toUtf16() {\n    return this.toString();\n  }\n\n  slice() {\n    let content = this.t == 4 ? this.c.slice() : this.c;\n    return new MlBytes(this.t, content, this.l);\n  }\n}\n", "import { bigIntToBits } from './bigint-helpers.js';\nimport { FiniteField, Fp, createField, inverse, mod, p, q } from './finite-field.js';\nimport { Endomorphism } from './elliptic-curve-endomorphism.js';\nexport {\n  Pallas,\n  PallasAffine,\n  Vesta,\n  CurveParams,\n  GroupAffine,\n  GroupProjective,\n  GroupMapPallas,\n  createCurveProjective,\n  createCurveAffine,\n  CurveAffine,\n  ProjectiveCurve,\n  affineAdd,\n  affineDouble,\n  affineScale,\n  projectiveFromAffine,\n  projectiveToAffine,\n  projectiveZero,\n  projectiveAdd,\n  getProjectiveDouble,\n  projectiveNeg,\n};\n\n// TODO: constants, like generator points and cube roots for endomorphisms, should be drawn from\n// a common source, i.e. generated from the Rust code\nconst pallasGeneratorProjective = {\n  x: 1n,\n  y: 12418654782883325593414442427049395787963493412651469444558597405572177144507n,\n};\nconst vestaGeneratorProjective = {\n  x: 1n,\n  y: 11426906929455361843568202299992114520848200991084027513389447476559454104162n,\n};\nconst vestaEndoBase = 2942865608506852014473558576493638302197734138389222805617480874486368177743n;\nconst pallasEndoBase =\n  20444556541222657078399132219657928148671392403212669005631716460534733845831n;\nconst vestaEndoScalar =\n  8503465768106391777493614032514048814691664078728891710322960303815233784505n;\nconst pallasEndoScalar =\n  26005156700822196841419187675678338661165322343552424574062261873906994770353n;\n\n// the b and a in y^2 = x^3 + ax + b\nconst b = 5n;\nconst a = 0n;\n\nconst projectiveZero = { x: 1n, y: 1n, z: 0n };\n\ntype GroupProjective = { x: bigint; y: bigint; z: bigint };\ntype PointAtInfinity = { x: bigint; y: bigint; infinity: true };\ntype FinitePoint = { x: bigint; y: bigint; infinity: false };\ntype GroupAffine = PointAtInfinity | FinitePoint;\n\n/**\n * Parameters defining an elliptic curve in short Weierstra\u00DF form\n * y^2 = x^3 + ax + b\n */\ntype CurveParams = {\n  /**\n   * Human-friendly name for the curve\n   */\n  name: string;\n  /**\n   * Base field modulus\n   */\n  modulus: bigint;\n  /**\n   * Scalar field modulus = group order\n   */\n  order: bigint;\n  /**\n   * Cofactor = size of EC / order\n   *\n   * This can be left undefined if the cofactor is 1.\n   */\n  cofactor?: bigint;\n  /**\n   * Generator point\n   */\n  generator: { x: bigint; y: bigint };\n  /**\n   * The `a` parameter in the curve equation y^2 = x^3 + ax + b\n   */\n  a: bigint;\n  /**\n   * The `b` parameter in the curve equation y^2 = x^3 + ax + b\n   */\n  b: bigint;\n  endoBase?: bigint;\n  endoScalar?: bigint;\n};\n\ntype GroupMapParams = {\n  u: bigint;\n  u_over_2: bigint;\n  conic_c: bigint;\n  projection_point: {\n    z: bigint;\n    y: bigint;\n  };\n  spec: { a: bigint; b: bigint };\n};\n\ntype Conic = { z: bigint; y: bigint };\n\ntype STuple = { u: bigint; v: bigint; y: bigint };\n\n// reference implementation https://github.com/o1-labs/snarky/blob/78e0d952518f75b5382f6d735adb24eef7a0fa90/group_map/group_map.ml\nconst GroupMap = {\n  create: (F: FiniteField, params: GroupMapParams) => {\n    const { a, b } = params.spec;\n    if (a !== 0n) throw Error('GroupMap only supports a = 0');\n    function tryDecode(x: bigint): { x: bigint; y: bigint } | undefined {\n      // x^3\n      const pow3 = F.power(x, 3n);\n      // a * x - since a = 0, ax will be 0 as well\n      // const ax = F.mul(a, x);\n\n      // x^3 + ax + b, but since ax = 0 we can write x^3 + b\n      const y = F.add(pow3, b);\n\n      if (!F.isSquare(y)) return undefined;\n      return { x, y: F.sqrt(y)! };\n    }\n\n    function sToVTruncated(s: STuple): [bigint, bigint, bigint] {\n      const { u, v, y } = s;\n      return [v, F.negate(F.add(u, v)), F.add(u, F.square(y))];\n    }\n\n    function conic_to_s(c: Conic): STuple {\n      const d = F.div(c.z, c.y);\n      if (d === undefined) throw Error(`Division undefined! ${c.z}/${c.y}`);\n      const v = F.sub(d, params.u_over_2);\n\n      return { u: params.u, v, y: c.y };\n    }\n\n    function field_to_conic(t: bigint): Conic {\n      const { z: z0, y: y0 } = params.projection_point;\n\n      const ct = F.mul(params.conic_c, t);\n\n      const d1 = F.add(F.mul(ct, y0), z0);\n      const d2 = F.add(F.mul(ct, t), 1n);\n\n      const d = F.div(d1, d2);\n\n      if (d === undefined) throw Error(`Division undefined! ${d1}/${d2}`);\n\n      const s = F.mul(2n, d);\n\n      return {\n        z: F.sub(z0, s),\n        y: F.sub(y0, F.mul(s, t)),\n      };\n    }\n\n    return {\n      potentialXs: (t: bigint) => sToVTruncated(conic_to_s(field_to_conic(t))),\n      tryDecode,\n    };\n  },\n};\n\n// https://github.com/MinaProtocol/mina/blob/af7bc89270b66c06e2cc8d1bb093ba31d6a7b372/src/lib/crypto_params/gen/gen.ml#L8-L11\nconst GroupMapParamsFp = {\n  u: 2n,\n  u_over_2: 1n,\n  conic_c: 3n,\n  projection_point: {\n    z: 12196889842669319921865617096620076994180062626450149327690483414064673774441n,\n    y: 1n,\n  },\n  spec: {\n    a: 0n,\n    b: 5n,\n  },\n};\n\nconst GroupMapPallas = GroupMap.create(Fp, GroupMapParamsFp);\n\nfunction projectiveNeg({ x, y, z }: GroupProjective, p: bigint) {\n  return { x, y: y === 0n ? 0n : p - y, z };\n}\n\nfunction projectiveAdd(g: GroupProjective, h: GroupProjective, p: bigint, a: bigint) {\n  if (g.z === 0n) return h;\n  if (h.z === 0n) return g;\n  let X1 = g.x,\n    Y1 = g.y,\n    Z1 = g.z,\n    X2 = h.x,\n    Y2 = h.y,\n    Z2 = h.z;\n  // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n  // Z1Z1 = Z1^2\n  let Z1Z1 = mod(Z1 * Z1, p);\n  // Z2Z2 = Z2^2\n  let Z2Z2 = mod(Z2 * Z2, p);\n  // U1 = X1*Z2Z2\n  let U1 = mod(X1 * Z2Z2, p);\n  // U2 = X2*Z1Z1\n  let U2 = mod(X2 * Z1Z1, p);\n  // S1 = Y1*Z2*Z2Z2\n  let S1 = mod(Y1 * Z2 * Z2Z2, p);\n  // S2 = Y2*Z1*Z1Z1\n  let S2 = mod(Y2 * Z1 * Z1Z1, p);\n  // H = U2-U1\n  let H = mod(U2 - U1, p);\n  // H = 0 <==> x1 = X1/Z1^2 = X2/Z2^2 = x2 <==> degenerate case (Z3 would become 0)\n  if (H === 0n) {\n    // if S1 = S2 <==> y1 = y2, the points are equal, so we double instead\n    if (S1 === S2) return projectiveDouble(g, p, a);\n    // if S1 = -S2, the points are inverse, so return zero\n    if (mod(S1 + S2, p) === 0n) return projectiveZero;\n    throw Error('projectiveAdd: invalid point');\n  }\n  // I = (2*H)^2\n  let I = mod((H * H) << 2n, p);\n  // J = H*I\n  let J = mod(H * I, p);\n  // r = 2*(S2-S1)\n  let r = 2n * (S2 - S1);\n  // V = U1*I\n  let V = mod(U1 * I, p);\n  // X3 = r^2-J-2*V\n  let X3 = mod(r * r - J - 2n * V, p);\n  // Y3 = r*(V-X3)-2*S1*J\n  let Y3 = mod(r * (V - X3) - 2n * S1 * J, p);\n  // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n  let Z3 = mod(((Z1 + Z2) * (Z1 + Z2) - Z1Z1 - Z2Z2) * H, p);\n  return { x: X3, y: Y3, z: Z3 };\n}\n\n/**\n * Projective doubling in Jacobian coordinates, specialized to a=0\n *\n * Cost: 2M + 5S\n */\nfunction projectiveDoubleA0(g: GroupProjective, p: bigint) {\n  if (g.z === 0n) return g;\n  let X1 = g.x,\n    Y1 = g.y,\n    Z1 = g.z;\n  if (Y1 === 0n) throw Error('projectiveDouble: unhandled case');\n  // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n  // A = X1^2\n  let A = mod(X1 * X1, p);\n  // B = Y1^2\n  let B = mod(Y1 * Y1, p);\n  // C = B^2\n  let C = mod(B * B, p);\n  // D = 2*((X1+B)^2-A-C)\n  let D = mod(2n * ((X1 + B) * (X1 + B) - A - C), p);\n  // E = 3*A\n  let E = 3n * A;\n  // F = E^2\n  let F = mod(E * E, p);\n  // X3 = F-2*D\n  let X3 = mod(F - 2n * D, p);\n  // Y3 = E*(D-X3)-8*C\n  let Y3 = mod(E * (D - X3) - 8n * C, p);\n  // Z3 = 2*Y1*Z1\n  let Z3 = mod(2n * Y1 * Z1, p);\n  return { x: X3, y: Y3, z: Z3 };\n}\n\n/**\n * Projective doubling in Jacobian coordinates, specialized to a=-3\n *\n * Cost: 3M + 5S\n */\nfunction projectiveDoubleAminus3(g: GroupProjective, p: bigint) {\n  if (g.z === 0n) return g;\n  let X1 = g.x,\n    Y1 = g.y,\n    Z1 = g.z;\n  if (Y1 === 0n) throw Error('projectiveDouble: unhandled case');\n\n  // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n  // delta = Z1^2\n  let delta = mod(Z1 * Z1, p);\n  // gamma = Y1^2\n  let gamma = mod(Y1 * Y1, p);\n  // beta = X1*gamma\n  let beta = mod(X1 * gamma, p);\n  // alpha = 3*(X1-delta)*(X1+delta)\n  let alpha = mod((X1 - delta) * (X1 + delta), p);\n  alpha = alpha + alpha + alpha;\n  // X3 = alpha^2-8*beta\n  let X3 = mod(alpha * alpha - 8n * beta, p);\n  // Z3 = (Y1+Z1)^2-gamma-delta\n  let Z3 = mod((Y1 + Z1) * (Y1 + Z1) - gamma - delta, p);\n  // Y3 = alpha*(4*beta-X3)-8*gamma^2\n  let Y3 = mod(alpha * (4n * beta - X3) - 8n * gamma * gamma, p);\n  return { x: X3, y: Y3, z: Z3 };\n}\n\nfunction projectiveDouble(g: GroupProjective, p: bigint, a: bigint) {\n  if (a === 0n) return projectiveDoubleA0(g, p);\n  if (a + 3n === p) return projectiveDoubleAminus3(g, p);\n  throw Error(\n    'Projective doubling is not implemented for general curve parameter a, only a = 0 and a = -3'\n  );\n}\n\nfunction getProjectiveDouble(p: bigint, a: bigint) {\n  if (a === 0n) return projectiveDoubleA0;\n  if (a + 3n === p) return projectiveDoubleAminus3;\n  throw Error(\n    'Projective doubling is not implemented for general curve parameter a, only a = 0 and a = -3'\n  );\n}\n\nfunction projectiveSub(g: GroupProjective, h: GroupProjective, p: bigint, a: bigint) {\n  return projectiveAdd(g, projectiveNeg(h, p), p, a);\n}\n\nfunction projectiveScale(g: GroupProjective, x: bigint | boolean[], p: bigint, a: bigint) {\n  let double = getProjectiveDouble(p, a);\n  let bits = typeof x === 'bigint' ? bigIntToBits(x) : x;\n  let h = projectiveZero;\n  for (let bit of bits) {\n    if (bit) h = projectiveAdd(h, g, p, a);\n    g = double(g, p);\n  }\n  return h;\n}\n\nfunction projectiveFromAffine({ x, y, infinity }: GroupAffine): GroupProjective {\n  if (infinity) return projectiveZero;\n  return { x, y, z: 1n };\n}\n\nfunction projectiveToAffine(g: GroupProjective, p: bigint): GroupAffine {\n  let z = g.z;\n  if (z === 0n) {\n    // infinity\n    return { x: 0n, y: 0n, infinity: true };\n  } else if (z === 1n) {\n    // already normalized affine form\n    return { x: g.x, y: g.y, infinity: false };\n  } else {\n    let zinv = inverse(z, p)!; // we checked for z === 0, so inverse exists\n    let zinv_squared = mod(zinv * zinv, p);\n    // x/z^2\n    let x = mod(g.x * zinv_squared, p);\n    // y/z^3\n    let y = mod(g.y * zinv * zinv_squared, p);\n    return { x: x, y: y, infinity: false };\n  }\n}\n\nfunction projectiveEqual(g: GroupProjective, h: GroupProjective, p: bigint) {\n  // special case: z=0 can only be equal to another z=0; protects against (0,0,0) being equal to any point\n  if ((g.z === 0n || h.z === 0n) && g.z !== h.z) return false;\n  // multiply out with z^2, z^3\n  let gz2 = mod(g.z * g.z, p);\n  let hz2 = mod(h.z * h.z, p);\n  // early return if gx !== hx\n  if (mod(g.x * hz2 - h.x * gz2, p) !== 0n) return false;\n  let gz3 = mod(gz2 * g.z, p);\n  let hz3 = mod(hz2 * h.z, p);\n  return mod(g.y * hz3, p) === mod(h.y * gz3, p);\n}\n\nfunction projectiveOnCurve({ x, y, z }: GroupProjective, p: bigint, b: bigint, a: bigint) {\n  // substitution x -> x/z^2 and y -> y/z^3 gives\n  // the equation y^2 = x^3 + a*x*z^4 + b*z^6\n  // (note: we allow a restricted set of x,y for z==0; this seems fine)\n  let x3 = mod(mod(x * x, p) * x, p);\n  let y2 = mod(y * y, p);\n  let z2 = mod(z * z, p);\n  let z4 = mod(z2 * z2, p);\n  let z6 = mod(z4 * z2, p);\n  return mod(y2 - x3 - a * x * z4 - b * z6, p) === 0n;\n}\n\n// checks whether the elliptic curve point g is in the subgroup defined by [order]g = 0\nfunction projectiveInSubgroup(g: GroupProjective, p: bigint, order: bigint, a: bigint) {\n  let orderTimesG = projectiveScale(g, order, p, a);\n  return projectiveEqual(orderTimesG, projectiveZero, p);\n}\n\n/**\n * Projective curve arithmetic in Jacobian coordinates\n */\nfunction createCurveProjective({\n  name,\n  modulus: p,\n  order,\n  cofactor,\n  generator,\n  b,\n  a,\n  endoBase,\n  endoScalar,\n}: CurveParams) {\n  let double = getProjectiveDouble(p, a);\n  cofactor ??= 1n;\n  let hasCofactor = cofactor !== 1n;\n  return {\n    name,\n    modulus: p,\n    order,\n    cofactor,\n    zero: projectiveZero,\n    one: { ...generator, z: 1n },\n    hasEndomorphism: endoBase !== undefined && endoScalar !== undefined,\n    get endoBase() {\n      if (endoBase === undefined) throw Error('`endoBase` for this curve was not provided.');\n      return endoBase;\n    },\n    get endoScalar() {\n      if (endoScalar === undefined) throw Error('`endoScalar` for this curve was not provided.');\n      return endoScalar;\n    },\n    a,\n    b,\n    hasCofactor,\n\n    equal(g: GroupProjective, h: GroupProjective) {\n      return projectiveEqual(g, h, p);\n    },\n    isOnCurve(g: GroupProjective) {\n      return projectiveOnCurve(g, p, b, a);\n    },\n    isInSubgroup(g: GroupProjective) {\n      return projectiveInSubgroup(g, p, order, a);\n    },\n    add(g: GroupProjective, h: GroupProjective) {\n      return projectiveAdd(g, h, p, a);\n    },\n    double(g: GroupProjective) {\n      return double(g, p);\n    },\n    negate(g: GroupProjective) {\n      return projectiveNeg(g, p);\n    },\n    sub(g: GroupProjective, h: GroupProjective) {\n      return projectiveSub(g, h, p, a);\n    },\n    scale(g: GroupProjective, s: bigint) {\n      return projectiveScale(g, s, p, a);\n    },\n    endomorphism({ x, y, z }: GroupProjective) {\n      if (endoBase === undefined) throw Error('endomorphism needs `endoBase` parameter.');\n      return { x: mod(endoBase * x, p), y, z };\n    },\n    toAffine(g: GroupProjective) {\n      return projectiveToAffine(g, p);\n    },\n    fromAffine(a: GroupAffine) {\n      return projectiveFromAffine(a);\n    },\n  };\n}\n\ntype ProjectiveCurve = ReturnType<typeof createCurveProjective>;\n\nconst Pallas = createCurveProjective({\n  name: 'Pallas',\n  modulus: p,\n  order: q,\n  generator: pallasGeneratorProjective,\n  b,\n  a,\n  endoBase: pallasEndoBase,\n  endoScalar: pallasEndoScalar,\n});\nconst Vesta = createCurveProjective({\n  name: 'Vesta',\n  modulus: q,\n  order: p,\n  generator: vestaGeneratorProjective,\n  b,\n  a,\n  endoBase: vestaEndoBase,\n  endoScalar: vestaEndoScalar,\n});\n\nconst affineZero: PointAtInfinity = { x: 0n, y: 0n, infinity: true };\n\nfunction affineOnCurve({ x, y, infinity }: GroupAffine, p: bigint, a: bigint, b: bigint) {\n  if (infinity) return true;\n  // y^2 = x^3 + ax + b\n  let x2 = mod(x * x, p);\n  return mod(y * y - x * x2 - a * x - b, p) === 0n;\n}\n\nfunction affineAdd(g: GroupAffine, h: GroupAffine, p: bigint, a: bigint): GroupAffine {\n  if (g.infinity) return h;\n  if (h.infinity) return g;\n\n  let { x: x1, y: y1 } = g;\n  let { x: x2, y: y2 } = h;\n\n  if (x1 === x2) {\n    // g + g --> we double\n    if (y1 === y2) return affineDouble(g, p, a);\n    // g - g --> return zero\n    return affineZero;\n  }\n  // m = (y2 - y1)/(x2 - x1)\n  let d = inverse(x2 - x1, p);\n  if (d === undefined) throw Error('impossible');\n  let m = mod((y2 - y1) * d, p);\n  // x3 = m^2 - x1 - x2\n  let x3 = mod(m * m - x1 - x2, p);\n  // y3 = m*(x1 - x3) - y1\n  let y3 = mod(m * (x1 - x3) - y1, p);\n  return { x: x3, y: y3, infinity: false };\n}\n\nfunction affineDouble({ x, y, infinity }: GroupAffine, p: bigint, a: bigint): GroupAffine {\n  if (infinity) return affineZero;\n  // m = (3*x^2 + a) / 2y\n  let d = inverse(2n * y, p);\n  if (d === undefined) throw Error('impossible');\n  let m = mod((3n * x * x + a) * d, p);\n  // x2 = m^2 - 2x\n  let x2 = mod(m * m - 2n * x, p);\n  // y2 = m*(x - x2) - y\n  let y2 = mod(m * (x - x2) - y, p);\n  return { x: x2, y: y2, infinity: false };\n}\n\nfunction affineNegate({ x, y, infinity }: GroupAffine, p: bigint): GroupAffine {\n  if (infinity) return affineZero;\n  return { x, y: y === 0n ? 0n : p - y, infinity };\n}\n\nfunction affineScale(g: GroupAffine, s: bigint | boolean[], p: bigint, a: bigint) {\n  let gProj = projectiveFromAffine(g);\n  let sgProj = projectiveScale(gProj, s, p, a);\n  return projectiveToAffine(sgProj, p);\n}\n\ntype CurveAffine = ReturnType<typeof createCurveAffine>;\n\nconst PallasAffine = createCurveAffine({\n  name: 'Pallas',\n  modulus: p,\n  order: q,\n  generator: pallasGeneratorProjective,\n  b,\n  a,\n  endoBase: pallasEndoBase,\n  endoScalar: pallasEndoScalar,\n});\n\nfunction createCurveAffine({\n  name,\n  modulus: p,\n  order,\n  cofactor,\n  generator,\n  a,\n  b,\n  endoScalar,\n  endoBase,\n}: CurveParams) {\n  let hasCofactor = cofactor !== undefined && cofactor !== 1n;\n\n  const Field = createField(p);\n  const Scalar = createField(order);\n  const one = { ...generator, infinity: false };\n  const Endo = Endomorphism(Field, Scalar, one, a, endoScalar, endoBase);\n\n  return {\n    name,\n    /**\n     * Arithmetic over the base field\n     */\n    Field,\n    /**\n     * Arithmetic over the scalar field\n     */\n    Scalar,\n\n    modulus: p,\n    order,\n    a,\n    b,\n    cofactor,\n    hasCofactor,\n\n    zero: affineZero,\n    one,\n\n    hasEndomorphism: Endo !== undefined,\n    get Endo() {\n      if (Endo === undefined) throw Error(`no endomorphism defined on ${name}`);\n      return Endo;\n    },\n\n    from(g: { x: bigint; y: bigint }): GroupAffine {\n      if (g.x === 0n && g.y === 0n) return affineZero;\n      return { ...g, infinity: false };\n    },\n\n    fromNonzero(g: { x: bigint; y: bigint }): GroupAffine {\n      if (g.x === 0n && g.y === 0n) {\n        throw Error('fromNonzero: got (0, 0), which is reserved for the zero point');\n      }\n      return { ...g, infinity: false };\n    },\n\n    equal(g: GroupAffine, h: GroupAffine) {\n      if (g.infinity && h.infinity) {\n        return true;\n      } else if (g.infinity || h.infinity) {\n        return false;\n      } else {\n        return mod(g.x - h.x, p) === 0n && mod(g.y - h.y, p) === 0n;\n      }\n    },\n    isOnCurve(g: GroupAffine) {\n      return affineOnCurve(g, p, a, b);\n    },\n    isInSubgroup(g: GroupAffine) {\n      return projectiveInSubgroup(projectiveFromAffine(g), p, order, a);\n    },\n    add(g: GroupAffine, h: GroupAffine) {\n      return affineAdd(g, h, p, a);\n    },\n    double(g: GroupAffine) {\n      return affineDouble(g, p, a);\n    },\n    negate(g: GroupAffine) {\n      return affineNegate(g, p);\n    },\n    sub(g: GroupAffine, h: GroupAffine) {\n      return affineAdd(g, affineNegate(h, p), p, a);\n    },\n    scale(g: GroupAffine, s: bigint | boolean[]) {\n      return affineScale(g, s, p, a);\n    },\n  };\n}\n", "export {\n  changeBase,\n  bytesToBigInt,\n  bigIntToBytes,\n  bigIntToBits,\n  parseHexString32,\n  log2,\n  max,\n  abs,\n  sign,\n  bytesToBigint32,\n  bigintToBytes32,\n};\n\nfunction bytesToBigint32(bytes: Uint8Array) {\n  let words = new BigUint64Array(bytes.buffer, bytes.byteOffset, 4);\n  return words[0] | (words[1] << 64n) | (words[2] << 128n) | (words[3] << 192n);\n}\n\nconst mask64 = (1n << 64n) - 1n;\n\nfunction bigintToBytes32(x: bigint, bytes: Uint8Array): Uint8Array {\n  let words = new BigUint64Array(bytes.buffer, bytes.byteOffset, 4);\n  words[0] = x & mask64;\n  words[1] = (x >> 64n) & mask64;\n  words[2] = (x >> 128n) & mask64;\n  words[3] = x >> 192n;\n  return bytes;\n}\n\nfunction bytesToBigInt(bytes: Uint8Array | number[]) {\n  let x = 0n;\n  let bitPosition = 0n;\n  for (let byte of bytes) {\n    x += BigInt(byte) << bitPosition;\n    bitPosition += 8n;\n  }\n  return x;\n}\n\nlet hexToNum: { [hexCharCode: number]: number } = {};\nfor (let i = 0; i < 16; i++) hexToNum[i.toString(16).charCodeAt(0)] = i;\nlet encoder = new TextEncoder();\n\nconst tmpBytes = new Uint8Array(64);\n\nfunction parseHexString32(input: string) {\n  // Parse the bytes explicitly, Bigint endianness is wrong\n  encoder.encodeInto(input, tmpBytes);\n  for (let j = 0; j < 32; j++) {\n    let n1 = hexToNum[tmpBytes[2 * j]];\n    let n0 = hexToNum[tmpBytes[2 * j + 1]];\n    tmpBytes[j] = (n1 << 4) | n0;\n  }\n  return bytesToBigint32(tmpBytes);\n}\n\n/**\n * Transforms bigint to little-endian array of bytes (numbers between 0 and 255) of a given length.\n * Throws an error if the bigint doesn't fit in the given number of bytes.\n */\nfunction bigIntToBytes(x: bigint, length?: number) {\n  if (x < 0n) {\n    throw Error(`bigIntToBytes: negative numbers are not supported, got ${x}`);\n  }\n  if (length === undefined) return bigintToBytesFlexible(x);\n  let bytes: number[] = Array(length);\n  for (let i = 0; i < length; i++, x >>= 8n) {\n    bytes[i] = Number(x & 0xffn);\n  }\n  if (x > 0n) {\n    throw Error(`bigIntToBytes: input does not fit in ${length} bytes`);\n  }\n  return bytes;\n}\n\nfunction bigintToBytesFlexible(x: bigint) {\n  let bytes: number[] = [];\n  for (; x > 0n; x >>= 8n) {\n    bytes.push(Number(x & 0xffn));\n  }\n  return bytes;\n}\n\n/**\n * Transforms bigint to little-endian array of bits (booleans).\n * The length of the bit array is determined as needed.\n */\nfunction bigIntToBits(x: bigint) {\n  if (x < 0n) {\n    throw Error(`bigIntToBits: negative numbers are not supported, got ${x}`);\n  }\n  let bits: boolean[] = [];\n  for (; x > 0n; x >>= 1n) {\n    let bit = !!(x & 1n);\n    bits.push(bit);\n  }\n  return bits;\n}\n\nfunction changeBase(digits: bigint[], base: bigint, newBase: bigint) {\n  // 1. accumulate digits into one gigantic bigint `x`\n  let x = fromBase(digits, base);\n  // 2. compute new digits from `x`\n  let newDigits = toBase(x, newBase);\n  return newDigits;\n}\n\n/**\n * the algorithm for toBase / fromBase is more complicated than it naively has to be,\n * but that is for performance reasons.\n *\n * we'll explain it for `fromBase`. this function is about taking an array of digits\n * `[x0, ..., xn]`\n * and returning the integer (bigint) that has those digits in the given `base`:\n * ```\n * let x = x0 + x1*base + x2*base**2 + ... + xn*base**n\n * ```\n *\n * naively, we could just accumulate digits from left to right:\n * ```\n * let x = 0n;\n * let p = 1n;\n * for (let i=0; i<n; i++) {\n *   x += X[i] * p;\n *   p *= base;\n * }\n * ```\n *\n * in the ith step, `p = base**i` which is multiplied with `xi` and added to the sum.\n * however, note that this algorithm is `O(n^2)`: let `l = log2(base)`. the base power `p` is a bigint of bit length `i*l`,\n * which is multiplied by a \"small\" number `xi` (length l), which takes `O(i)` time in every step.\n * since this is done for `i = 0,...,n`, we end up with an `O(n^2)` algorithm.\n *\n * HOWEVER, it turns out that there are fast multiplication algorithms, and JS bigints have them built in!\n * the Sch\u00F6nhage-Strassen algorithm (implemented in the V8 engine, see https://github.com/v8/v8/blob/main/src/bigint/mul-fft.cc)\n * can multiply two n-bit numbers in time `O(n log(n) loglog(n))`, when n is large.\n *\n * to take advantage of asymptotically fast multiplication, we need to re-structure our algorithm such that it multiplies roughly equal-sized\n * numbers with each other (there is no asymptotic boost for multiplying a small with a large number). so, what we do is to go from the\n * original digit array to arrays of successively larger digits:\n * ```\n * step 0:                  step 1:                              step 2:\n * [x0, x1, x2, x3, ...] -> [x0 + base*x1, x2 + base*x3, ...] -> [x0 + base*x1 + base^2*(x2 + base*x3), ...] -> ...\n * ```\n *\n * ...until after a log(n) number of steps we end up with a single \"digit\" which is equal to the entire sum.\n *\n * in the ith step, we multiply `n/2^i` pairs of numbers of bit length `2^i*l`. each of these multiplications takes\n * time `O(2^i log(2^i) loglog(2^i))`. if we bound that with `O(2^i log(n) loglog(n))`, we get a runtime bounded by\n * ```\n * O(n/2^i * 2^i log(n) loglog(n)) = O(n log(n) loglog(n))\n * ```\n * in each step. Since we have `log(n)` steps, the result is `O(n log(n)^2 loglog(n))`.\n *\n * empirically, this method is a huge improvement over the naive `O(n^2)` algorithm and scales much better with n (the number of digits).\n *\n * similar conclusions hold for `toBase`.\n */\nfunction fromBase(digits: bigint[], base: bigint) {\n  if (base <= 0n) throw Error('fromBase: base must be positive');\n  // compute powers base, base^2, base^4, ..., base^(2^k)\n  // with largest k s.t. n = 2^k < digits.length\n  let basePowers = [];\n  for (let power = base, n = 1; n < digits.length; power **= 2n, n *= 2) {\n    basePowers.push(power);\n  }\n  let k = basePowers.length;\n  // pad digits array with zeros s.t. digits.length === 2^k\n  digits = digits.concat(Array(2 ** k - digits.length).fill(0n));\n  // accumulate [x0, x1, x2, x3, ...] -> [x0 + base*x1, x2 + base*x3, ...] -> [x0 + base*x1 + base^2*(x2 + base*x3), ...] -> ...\n  // until we end up with a single element\n  for (let i = 0; i < k; i++) {\n    let newDigits = Array(digits.length >> 1);\n    let basePower = basePowers[i];\n    for (let j = 0; j < newDigits.length; j++) {\n      newDigits[j] = digits[2 * j] + basePower * digits[2 * j + 1];\n    }\n    digits = newDigits;\n  }\n  console.assert(digits.length === 1);\n  let [digit] = digits;\n  return digit;\n}\n\nfunction toBase(x: bigint, base: bigint) {\n  if (base <= 0n) throw Error('toBase: base must be positive');\n  // compute powers base, base^2, base^4, ..., base^(2^k)\n  // with largest k s.t. base^(2^k) < x\n  let basePowers = [];\n  for (let power = base; power < x; power **= 2n) {\n    basePowers.push(power);\n  }\n  let digits = [x]; // single digit w.r.t base^(2^(k+1))\n  // successively split digits w.r.t. base^(2^j) into digits w.r.t. base^(2^(j-1))\n  // until we arrive at digits w.r.t. base\n  let k = basePowers.length;\n  for (let i = 0; i < k; i++) {\n    let newDigits = Array(2 * digits.length);\n    let basePower = basePowers[k - 1 - i];\n    for (let j = 0; j < digits.length; j++) {\n      let x = digits[j];\n      let high = x / basePower;\n      newDigits[2 * j + 1] = high;\n      newDigits[2 * j] = x - high * basePower;\n    }\n    digits = newDigits;\n  }\n  // pop \"leading\" zero digits\n  while (digits[digits.length - 1] === 0n) {\n    digits.pop();\n  }\n  return digits;\n}\n\n/**\n * ceil(log2(n))\n * = smallest k such that n <= 2^k\n */\nfunction log2(n: number | bigint) {\n  if (typeof n === 'number') n = BigInt(n);\n  if (n === 1n) return 0;\n  return (n - 1n).toString(2).length;\n}\n\nfunction max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\nfunction abs(x: bigint) {\n  return x < 0n ? -x : x;\n}\n\nfunction sign(x: bigint): 1n | -1n {\n  return x >= 0 ? 1n : -1n;\n}\n", "import { assert } from '../../lib/util/assert.js';\nimport { bytesToBigInt, log2 } from './bigint-helpers.js';\nimport { randomBytes } from './random.js';\n\nexport { createField, Fp, Fq, FiniteField, p, q, mod, inverse };\n\n// CONSTANTS\n\n// the modulus. called `p` in most of our code.\nconst p = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;\nconst q = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;\n\n// this is `t`, where p = 2^32 * t + 1\nconst pMinusOneOddFactor = 0x40000000000000000000000000000000224698fc094cf91b992d30edn;\nconst qMinusOneOddFactor = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb21n;\n\n// primitive roots of unity, computed as (5^t mod p). this works because 5 generates the multiplicative group mod p\nconst twoadicRootFp = 0x2bce74deac30ebda362120830561f81aea322bf2b7bb7584bdad6fabd87ea32fn;\nconst twoadicRootFq = 0x2de6a9b8746d3f589e5c4dfd492ae26e9bb97ea3c106f049a70e2c1102b6d05fn;\n\n// GENERAL FINITE FIELD ALGORITHMS\n\nfunction mod(x: bigint, p: bigint) {\n  x = x % p;\n  if (x < 0) return x + p;\n  return x;\n}\n\n// modular exponentiation, a^n % p\nfunction power(a: bigint, n: bigint, p: bigint) {\n  a = mod(a, p);\n  let x = 1n;\n  for (; n > 0n; n >>= 1n) {\n    if (n & 1n) x = mod(x * a, p);\n    a = mod(a * a, p);\n  }\n  return x;\n}\n\n// inverting with EGCD, 1/a in Z_p\nfunction inverse(a: bigint, p: bigint) {\n  a = mod(a, p);\n  if (a === 0n) return undefined;\n  let b = p;\n  let x = 0n;\n  let y = 1n;\n  let u = 1n;\n  let v = 0n;\n  while (a !== 0n) {\n    let q = b / a;\n    let r = mod(b, a);\n    let m = x - u * q;\n    let n = y - v * q;\n    b = a;\n    a = r;\n    x = u;\n    y = v;\n    u = m;\n    v = n;\n  }\n  if (b !== 1n) return undefined;\n  return mod(x, p);\n}\n\n// faster inversion algorithm based on\n// Thomas Pornin, \"Optimized Binary GCD for Modular Inversion\", https://eprint.iacr.org/2020/972.pdf\n// about 3x faster than `inverse()`\nfunction fastInverse(x: bigint, p: bigint, n: number, kmax: bigint, twoToMinusKmax: bigint) {\n  x = mod(x, p);\n  if (x === 0n) return undefined;\n\n  // fixed constants\n  const w = 31;\n  const hiBits = 31;\n  const wn = BigInt(w);\n  const wMask = (1n << wn) - 1n;\n\n  let u = p;\n  let v = x;\n  let r = 0n;\n  let s = 1n;\n\n  let i = 0;\n\n  for (; i < 2 * n; i++) {\n    let f0 = 1;\n    let g0 = 0;\n    let f1 = 0;\n    let g1 = 1;\n\n    let ulo = Number(u & wMask);\n    let vlo = Number(v & wMask);\n\n    let len = Math.max(log2(u), log2(v));\n    let shift = BigInt(Math.max(len - hiBits, 0));\n\n    let uhi = Number(u >> shift);\n    let vhi = Number(v >> shift);\n\n    for (let j = 0; j < w; j++) {\n      if ((ulo & 1) === 0) {\n        uhi >>= 1;\n        ulo >>= 1;\n        f1 <<= 1;\n        g1 <<= 1;\n      } else if ((vlo & 1) === 0) {\n        vhi >>= 1;\n        vlo >>= 1;\n        f0 <<= 1;\n        g0 <<= 1;\n      } else {\n        if (vhi <= uhi) {\n          uhi = (uhi - vhi) >> 1;\n          ulo = (ulo - vlo) >> 1;\n          f0 = f0 + f1;\n          g0 = g0 + g1;\n          f1 <<= 1;\n          g1 <<= 1;\n        } else {\n          vhi = (vhi - uhi) >> 1;\n          vlo = (vlo - ulo) >> 1;\n          f1 = f0 + f1;\n          g1 = g0 + g1;\n          f0 <<= 1;\n          g0 <<= 1;\n        }\n      }\n    }\n\n    let f0n = BigInt(f0);\n    let g0n = BigInt(g0);\n    let f1n = BigInt(f1);\n    let g1n = BigInt(g1);\n\n    let unew = u * f0n - v * g0n;\n    let vnew = v * g1n - u * f1n;\n    u = unew >> wn;\n    v = vnew >> wn;\n\n    if (u < 0) ((u = -u), (f0n = -f0n), (g0n = -g0n));\n    if (v < 0) ((v = -v), (f1n = -f1n), (g1n = -g1n));\n\n    let rnew = r * f0n + s * g0n;\n    let snew = s * g1n + r * f1n;\n    r = rnew;\n    s = snew;\n\n    // these assertions are all true, enable when debugging:\n    // let lin = v * r + u * s;\n    // assert(lin === p || lin === -p, 'linear combination');\n    // let k = BigInt((i + 1) * w);\n    // assert(mod(x * r + u * 2n ** k, p) === 0n, 'mod p, r');\n    // assert(mod(x * s - v * 2n ** k, p) === 0n, 'mod p, s');\n\n    if (u === 0n) break;\n\n    // empirically this never happens, but there might be unlucky edge cases where it does, due to sign flips\n    if (v === 0n) {\n      assert(u === 1n, 'u = 1');\n      s = mod(-r, p);\n      break;\n    }\n  }\n  let k = BigInt((i + 1) * w);\n\n  // now s = 2^k/x mod p\n  // correction step to go from 2^k/x to 1/x\n  s = mod(s * twoToMinusKmax, p); // s <- s * 2^(-kmax) = 2^(k - kmax)/x\n  s = mod(s << (kmax - k), p); // s <- s * 2^(kmax - k) = 1/x\n\n  // yes this has a slight cost and the assert is never triggered,\n  // but it's worth having for the sake of assurance\n  assert(mod(x * s - 1n, p) === 0n, 'mod p');\n  return s;\n}\n\nfunction sqrt(n_: bigint, p: bigint, Q: bigint, c: bigint, M: bigint) {\n  // https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm#The_algorithm\n  // variable naming is the same as in that link ^\n  // Q is what we call `t` elsewhere - the odd factor in p - 1\n  // c is a known primitive root of unity\n  // M is the twoadicity = exponent of 2 in factorization of p - 1\n  let n = mod(n_, p);\n  if (n === 0n) return 0n;\n  let t = power(n, (Q - 1n) >> 1n, p); // n^(Q - 1)/2\n  let R = mod(t * n, p); // n^((Q - 1)/2 + 1) = n^((Q + 1)/2)\n  t = mod(t * R, p); // n^((Q - 1)/2 + (Q + 1)/2) = n^Q\n  while (true) {\n    if (t === 1n) return R;\n    // use repeated squaring to find the least i, 0 < i < M, such that t^(2^i) = 1\n    let i = 0n;\n    let s = t;\n    while (s !== 1n) {\n      s = mod(s * s, p);\n      i = i + 1n;\n    }\n    if (i === M) return undefined; // no solution\n    let b = power(c, 1n << (M - i - 1n), p); // c^(2^(M-i-1))\n    M = i;\n    c = mod(b * b, p);\n    t = mod(t * c, p);\n    R = mod(R * b, p);\n  }\n}\n\nfunction isSquare(x_: bigint, p: bigint) {\n  let x = mod(x_, p);\n  if (x === 0n) return true;\n  let sqrt1 = power(x, (p - 1n) / 2n, p);\n  return sqrt1 === 1n;\n}\n\nfunction randomField(p: bigint, sizeInBytes: number, hiBitMask: number) {\n  // strategy: find random 255-bit bigints and use the first that's smaller than p\n  while (true) {\n    let bytes = randomBytes(sizeInBytes);\n    bytes[sizeInBytes - 1] &= hiBitMask; // zero highest bit, so we get 255 random bits\n    let x = bytesToBigInt(bytes);\n    if (x < p) return x;\n  }\n}\n\n// SPECIALIZATIONS TO FP, FQ\n// these should be mostly trivial\n\nconst Fp = createField(p, {\n  oddFactor: pMinusOneOddFactor,\n  twoadicRoot: twoadicRootFp,\n  twoadicity: 32n,\n});\nconst Fq = createField(q, {\n  oddFactor: qMinusOneOddFactor,\n  twoadicRoot: twoadicRootFq,\n  twoadicity: 32n,\n});\ntype FiniteField = ReturnType<typeof createField>;\n\nfunction createField(\n  p: bigint,\n  constants?: { oddFactor: bigint; twoadicRoot: bigint; twoadicity: bigint }\n) {\n  let { oddFactor, twoadicRoot, twoadicity } = constants ?? computeFieldConstants(p);\n  let sizeInBits = log2(p);\n  let sizeInBytes = Math.ceil(sizeInBits / 8);\n  let sizeHighestByte = sizeInBits - 8 * (sizeInBytes - 1);\n  let hiBitMask = (1 << sizeHighestByte) - 1;\n\n  // parameters for fast inverse\n  const w = 31;\n  const n = Math.ceil(sizeInBits / w);\n  const kmax = BigInt(2 * n * w);\n\n  // constant for correcting 2^k/x -> 1/x, by multiplying with 2^-kmax * 2^(kmax - k)\n  const twoToMinusKmax = inverse(1n << kmax, p);\n  const exportedInverse =\n    twoToMinusKmax !== undefined\n      ? (x: bigint) => fastInverse(x, p, n, kmax, twoToMinusKmax)\n      : (x: bigint) => inverse(x, p);\n\n  return {\n    modulus: p,\n    sizeInBits,\n    t: oddFactor,\n    M: twoadicity,\n    twoadicRoot,\n    mod(x: bigint) {\n      return mod(x, p);\n    },\n    add(x: bigint, y: bigint) {\n      return mod(x + y, p);\n    },\n    not(x: bigint, bits: number) {\n      return mod(2n ** BigInt(bits) - (x + 1n), p);\n    },\n    negate(x: bigint) {\n      return x === 0n ? 0n : mod(-x, p);\n    },\n    sub(x: bigint, y: bigint) {\n      return mod(x - y, p);\n    },\n    mul(x: bigint, y: bigint) {\n      return mod(x * y, p);\n    },\n    inverse: exportedInverse,\n    div(x: bigint, y: bigint) {\n      let yinv = exportedInverse(y);\n      if (yinv === undefined) return;\n      return mod(x * yinv, p);\n    },\n    square(x: bigint) {\n      return mod(x * x, p);\n    },\n    isSquare(x: bigint) {\n      return isSquare(x, p);\n    },\n    sqrt(x: bigint) {\n      return sqrt(x, p, oddFactor, twoadicRoot, twoadicity);\n    },\n    power(x: bigint, n: bigint) {\n      return power(x, n, p);\n    },\n    dot(x: bigint[], y: bigint[]) {\n      let z = 0n;\n      let n = x.length;\n      for (let i = 0; i < n; i++) {\n        z += x[i] * y[i];\n      }\n      return mod(z, p);\n    },\n    equal(x: bigint, y: bigint) {\n      // We check if x and y are both in the range [0, p). If they are, can do a simple comparison. Otherwise, we need to reduce them to the proper canonical field range.\n      let x_ = x >= 0n && x < p ? x : mod(x, p);\n      let y_ = y >= 0n && y < p ? y : mod(y, p);\n      return x_ === y_;\n    },\n    isEven(x: bigint) {\n      return !(mod(x, p) & 1n);\n    },\n    random() {\n      return randomField(p, sizeInBytes, hiBitMask);\n    },\n    fromNumber(x: number) {\n      return mod(BigInt(x), p);\n    },\n    fromBigint(x: bigint) {\n      return mod(x, p);\n    },\n    rot(x: bigint, bits: bigint, direction: 'left' | 'right' = 'left', maxBits = 64n) {\n      if (direction === 'right') bits = maxBits - bits;\n      let full = x << bits;\n      let excess = full >> maxBits;\n      let shifted = full & ((1n << maxBits) - 1n);\n      return shifted | excess;\n    },\n    leftShift(x: bigint, bits: number, maxBitSize: number = 64) {\n      let shifted = x << BigInt(bits);\n      return shifted & ((1n << BigInt(maxBitSize)) - 1n);\n    },\n    rightShift(x: bigint, bits: number) {\n      return x >> BigInt(bits);\n    },\n  };\n}\n\n/**\n * Compute constants to instantiate a finite field just from the modulus\n */\nfunction computeFieldConstants(p: bigint) {\n  // figure out the factorization p - 1 = 2^M * t\n  let oddFactor = p - 1n;\n  let twoadicity = 0n;\n  while ((oddFactor & 1n) === 0n) {\n    oddFactor >>= 1n;\n    twoadicity++;\n  }\n\n  // find z = non-square\n  // start with 2 and increment until we find one\n  let z = 2n;\n  while (isSquare(z, p)) z++;\n\n  // primitive root of unity is z^t\n  let twoadicRoot = power(z, oddFactor, p);\n\n  return { oddFactor, twoadicRoot, twoadicity };\n}\n", "export { assert, assertPromise, assertDefined };\n\nfunction assert(stmt: boolean, message?: string): asserts stmt {\n  if (!stmt) {\n    throw Error(message ?? 'Assertion failed');\n  }\n}\n\nfunction assertPromise<T>(value: Promise<T>, message?: string): Promise<T> {\n  assert(value instanceof Promise, message ?? 'Expected a promise');\n  return value;\n}\n\n/**\n * Assert that the value is not undefined, return the value.\n */\nfunction assertDefined<T>(value: T | undefined, message = 'Input value is undefined.'): T {\n  if (value === undefined) throw Error(message);\n  return value as T;\n}\n", "import { randomBytes as randomBytesNode } from 'crypto';\nexport { randomBytes };\n\nfunction randomBytes(n: number) {\n  return new Uint8Array(randomBytesNode(n));\n}\n", "export {\n  CatchAndPrettifyStacktraceForAllMethods,\n  CatchAndPrettifyStacktrace,\n  prettifyStacktrace,\n  prettifyStacktracePromise,\n  assert,\n  assert as assertInternal,\n};\n\n/**\n * A class decorator that applies the CatchAndPrettifyStacktrace decorator function\n * to all methods of the target class.\n *\n * @param constructor - The target class constructor.\n */\nfunction CatchAndPrettifyStacktraceForAllMethods<T extends { new (...args: any[]): {} }>(\n  constructor: T\n) {\n  // Iterate through all properties (including methods) of the class prototype\n  for (const propertyName of Object.getOwnPropertyNames(constructor.prototype)) {\n    // Skip the constructor\n    if (propertyName === 'constructor') continue;\n\n    // Get the property descriptor\n    const descriptor = Object.getOwnPropertyDescriptor(constructor.prototype, propertyName);\n\n    // Check if the property is a method\n    if (descriptor && typeof descriptor.value === 'function') {\n      // Apply the CatchAndPrettifyStacktrace decorator to the method\n      CatchAndPrettifyStacktrace(constructor.prototype, propertyName, descriptor);\n\n      // Update the method descriptor\n      Object.defineProperty(constructor.prototype, propertyName, descriptor);\n    }\n  }\n  // do the same thing for static methods\n  for (let [propertyName, descriptor] of Object.entries(\n    Object.getOwnPropertyDescriptors(constructor)\n  )) {\n    if (descriptor && typeof descriptor.value === 'function') {\n      CatchAndPrettifyStacktrace(constructor, propertyName, descriptor);\n      Object.defineProperty(constructor, propertyName, descriptor);\n    }\n  }\n}\n\n/**\n * A decorator function that wraps the target method with error handling logic.\n * It catches errors thrown by the method, prettifies the stack trace, and then\n * rethrows the error with the updated stack trace.\n *\n * @param _target - The target object.\n * @param _propertyName - The name of the property being decorated.\n * @param descriptor - The property descriptor of the target method.\n */\nfunction CatchAndPrettifyStacktrace(\n  _target: any,\n  _propertyName: string,\n  descriptor: PropertyDescriptor\n) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    try {\n      const result = originalMethod.apply(this, args);\n      return handleResult(result);\n    } catch (error) {\n      throw prettifyStacktrace(error);\n    }\n  };\n}\n\n/**\n * Handles the result of a function call, wrapping a Promise with error handling logic\n * that prettifies the stack trace before rethrowing the error. For non-Promise results,\n * the function returns the result unchanged. This function is intended for internal usage\n * and not exposed to users.\n *\n * @param result - The result of the function call, which can be a Promise or any other value.\n * @returns A Promise with error handling logic for prettifying the stack trace, or the original result if it's not a Promise.\n */\nfunction handleResult(result: any) {\n  if (result instanceof Promise) {\n    return result.catch((error: Error) => {\n      throw prettifyStacktrace(error);\n    });\n  }\n  return result;\n}\n\n/**\n * A list of keywords used to filter out unwanted lines from the error stack trace.\n */\nconst lineRemovalKeywords = [\n  'o1js_node.bc.cjs',\n  '/builtin/',\n  'CatchAndPrettifyStacktrace', // Decorator name to remove from stacktrace (covers both class and method decorator)\n] as const;\n\n/**\n * Prettifies the stack trace of an error by removing unwanted lines and trimming paths.\n *\n * @param error - The error object with a stack trace to prettify.\n * @returns The same error with the prettified stack trace\n */\nfunction prettifyStacktrace(error: unknown) {\n  error = unwrapMlException(error);\n  if (!(error instanceof Error) || !error.stack) return error;\n\n  const stacktrace = error.stack;\n  const stacktraceLines = stacktrace.split('\\n');\n  const newStacktrace: string[] = [];\n\n  for (let i = 0; i < stacktraceLines.length; i++) {\n    const shouldRemoveLine = lineRemovalKeywords.some((lineToRemove) =>\n      stacktraceLines[i].includes(lineToRemove)\n    );\n    if (shouldRemoveLine) {\n      continue;\n    }\n    const trimmedLine = trimPaths(stacktraceLines[i]);\n    newStacktrace.push(trimmedLine);\n  }\n  error.stack = newStacktrace.join('\\n');\n  return error;\n}\n\nasync function prettifyStacktracePromise<T>(result: Promise<T>): Promise<T> {\n  try {\n    return await result;\n  } catch (error) {\n    throw prettifyStacktrace(error);\n  }\n}\n\nfunction unwrapMlException<E extends unknown>(error: E) {\n  if (error instanceof Error) return error;\n  // ocaml exception re-thrown from JS\n  if (Array.isArray(error) && error[2] instanceof Error) return error[2];\n  return error;\n}\n\n/**\n * Trims paths in the stack trace line based on whether it includes 'o1js' or 'opam'.\n *\n * @param stacktracePath - The stack trace line containing the path to trim.\n * @returns The trimmed stack trace line.\n */\nfunction trimPaths(stacktracePath: string) {\n  const includesO1js = stacktracePath.includes('o1js');\n  if (includesO1js) {\n    return trimO1jsPath(stacktracePath);\n  }\n\n  const includesOpam = stacktracePath.includes('opam');\n  if (includesOpam) {\n    return trimOpamPath(stacktracePath);\n  }\n\n  const includesWorkspace = stacktracePath.includes('workspace_root');\n  if (includesWorkspace) {\n    return trimWorkspacePath(stacktracePath);\n  }\n\n  return stacktracePath;\n}\n\n/**\n * Trims the 'o1js' portion of the stack trace line's path.\n *\n * @param stacktraceLine - The stack trace line containing the 'o1js' path to trim.\n * @returns The stack trace line with the trimmed 'o1js' path.\n */\nfunction trimO1jsPath(stacktraceLine: string) {\n  const fullPath = getDirectoryPath(stacktraceLine);\n  if (!fullPath) {\n    return stacktraceLine;\n  }\n  const o1jsIndex = fullPath.indexOf('o1js');\n  if (o1jsIndex === -1) {\n    return stacktraceLine;\n  }\n\n  // Grab the text before the parentheses as the prefix\n  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf('(') + 1);\n  // Grab the text including and after the o1js path\n  const updatedPath = fullPath.slice(o1jsIndex);\n  return `${prefix}${updatedPath})`;\n}\n\n/**\n * Trims the 'opam' portion of the stack trace line's path.\n *\n * @param stacktraceLine - The stack trace line containing the 'opam' path to trim.\n * @returns The stack trace line with the trimmed 'opam' path.\n */\nfunction trimOpamPath(stacktraceLine: string) {\n  const fullPath = getDirectoryPath(stacktraceLine);\n  if (!fullPath) {\n    return stacktraceLine;\n  }\n  const opamIndex = fullPath.indexOf('opam');\n  if (opamIndex === -1) {\n    return stacktraceLine;\n  }\n\n  const updatedPathArray = fullPath.slice(opamIndex).split('/');\n  const libIndex = updatedPathArray.lastIndexOf('lib');\n  if (libIndex === -1) {\n    return stacktraceLine;\n  }\n\n  // Grab the text before the parentheses as the prefix\n  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf('(') + 1);\n  // Grab the text including and after the opam path, removing the lib directory\n  const trimmedPath = updatedPathArray.slice(libIndex + 1);\n  // Add the ocaml directory to the beginning of the path\n  trimmedPath.unshift('ocaml');\n  return `${prefix}${trimmedPath.join('/')})`;\n}\n\n/**\n * Trims the 'workspace_root' portion of the stack trace line's path.\n *\n * @param stacktraceLine - The stack trace line containing the 'workspace_root' path to trim.\n * @returns The stack trace line with the trimmed 'workspace_root' path.\n */\nfunction trimWorkspacePath(stacktraceLine: string) {\n  const fullPath = getDirectoryPath(stacktraceLine);\n  if (!fullPath) {\n    return stacktraceLine;\n  }\n  const workspaceIndex = fullPath.indexOf('workspace_root');\n  if (workspaceIndex === -1) {\n    return stacktraceLine;\n  }\n\n  const updatedPathArray = fullPath.slice(workspaceIndex).split('/');\n  const prefix = stacktraceLine.slice(0, stacktraceLine.indexOf('(') + 1);\n  const trimmedPath = updatedPathArray.slice(workspaceIndex);\n  return `${prefix}${trimmedPath.join('/')})`;\n}\n\n/**\n * Extracts the directory path from a stack trace line.\n *\n * @param stacktraceLine - The stack trace line to extract the path from.\n * @returns The extracted directory path or undefined if not found.\n */\nfunction getDirectoryPath(stacktraceLine: string) {\n  // Regex to match the path inside the parentheses (e.g. (/home/../o1js/../*.ts))\n  const fullPathRegex = /\\(([^)]+)\\)/;\n  const matchedPaths = stacktraceLine.match(fullPathRegex);\n  if (matchedPaths) {\n    return matchedPaths[1];\n  }\n}\n\n/**\n * An error that was assumed cannot happen, and communicates to users that it's not their fault but an internal bug.\n */\nfunction Bug(message: string) {\n  return Error(`${message}\\nThis shouldn't have happened and indicates an internal bug.`);\n}\n/**\n * Make an assertion. When failing, this will communicate to users it's not their fault but indicates an internal bug.\n */\nfunction assert(condition: boolean, message = 'Failed assertion.'): asserts condition {\n  if (!condition) throw Bug(message);\n}\n", "import { assert } from '../../lib/util/errors.js';\nimport { abs, bigIntToBits, log2, max, sign } from './bigint-helpers.js';\nimport {\n  GroupAffine,\n  GroupProjective,\n  affineScale,\n  projectiveAdd,\n  getProjectiveDouble,\n  projectiveFromAffine,\n  projectiveNeg,\n  projectiveToAffine,\n  projectiveZero,\n} from './elliptic-curve.js';\nimport { FiniteField, mod } from './finite-field.js';\n\nexport { Endomorphism, decompose, computeEndoConstants, computeGlvData, GlvData };\n\n/**\n * Define methods leveraging a curve endomorphism\n */\nfunction Endomorphism(\n  Field: FiniteField,\n  Scalar: FiniteField,\n  generator: GroupAffine,\n  a: bigint,\n  endoScalar?: bigint,\n  endoBase?: bigint\n) {\n  if (endoScalar === undefined || endoBase === undefined) {\n    try {\n      ({ endoScalar, endoBase } = computeEndoConstants(Field, Scalar, generator, a));\n    } catch (e: any) {\n      return undefined;\n    }\n  }\n  let endoBase_: bigint = endoBase;\n  let glvData = computeGlvData(Scalar.modulus, endoScalar);\n\n  return {\n    scalar: endoScalar,\n    base: endoBase,\n\n    decomposeMaxBits: glvData.maxBits,\n\n    decompose(s: bigint) {\n      return decompose(s, glvData);\n    },\n\n    endomorphism(P: GroupAffine) {\n      return endomorphism(P, endoBase_, Field.modulus);\n    },\n\n    scaleProjective(g: GroupProjective, s: bigint) {\n      return glvScaleProjective(g, s, Field.modulus, a, endoBase_, glvData);\n    },\n    scale(g: GroupAffine, s: bigint) {\n      let gProj = projectiveFromAffine(g);\n      let sGProj = glvScaleProjective(gProj, s, Field.modulus, a, endoBase_, glvData);\n      return projectiveToAffine(sGProj, Field.modulus);\n    },\n  };\n}\n\n/**\n * GLV decomposition, named after the authors Gallant, Lambert and Vanstone who introduced it:\n * https://iacr.org/archive/crypto2001/21390189.pdf\n *\n * decompose scalar as s = s0 + s1 * lambda where |s0|, |s1| are small\n *\n * this relies on scalars v00, v01, v10, v11 which satisfy\n * - v00 + v10 * lambda = 0 (mod q)\n * - v01 + v11 * lambda = 0 (mod q)\n * - |vij| ~ sqrt(q), i.e. each vij has only about half the bits of the max scalar size\n *\n * the vij are computed in {@link egcdStopEarly}.\n *\n * for a scalar s, we pick x0, x1 (see below) and define\n * s0 = x0 v00 + x1 v01 + s\n * s1 = x0 v10 + x1 v11\n *\n * this yields a valid decomposition for _any_ choice of x0, x1, because\n * s0 + s1 * lambda = x0 (v00 + v10 * lambda) + x1 (v01 + v11 * lambda) + s = s (mod q)\n *\n * to ensure s0, s1 are small, x0, x1 are chosen as integer approximations to the rational solutions x0*, x1* of\n * x0* v00 + x1* v01 = -s\n * x0* v10 + x1* v11 = 0\n *\n * picking the integer xi that's closest to xi* gives us |xi - xi*| <= 0.5\n *\n * now, |vij| being small ensures that s0, s1 are small:\n *\n * |s0| = |(x0 - x0*) v00 + (x1 - x1*) v01| <= 0.5 * (|v00| + |v01|)\n * |s1| = |(x0 - x0*) v10 + (x1 - x1*) v11| <= 0.5 * (|v10| + |v11|)\n *\n * given |vij| ~ sqrt(q), we also get |s0|, |s1| ~ sqrt(q).\n */\nfunction decompose(s: bigint, data: GlvData) {\n  let { v00, v01, v10, v11, det } = data;\n  let x0 = divideAndRound(-v11 * s, det);\n  let x1 = divideAndRound(v10 * s, det);\n  let s0 = v00 * x0 + v01 * x1 + s;\n  let s1 = v10 * x0 + v11 * x1;\n  return [\n    { value: s0, isNegative: s0 < 0n, abs: abs(s0) },\n    { value: s1, isNegative: s1 < 0n, abs: abs(s1) },\n  ] as const;\n}\n\n/**\n * Cheaply compute endomorphism((x,y)) = endoScalar * (x,y) = (endoBase * x, y)\n */\nfunction endomorphism(P: GroupAffine, endoBase: bigint, p: bigint) {\n  return { x: mod(endoBase * P.x, p), y: P.y };\n}\n\nfunction endomorphismProjective(P: GroupProjective, endoBase: bigint, p: bigint) {\n  return { x: mod(endoBase * P.x, p), y: P.y, z: P.z };\n}\n\n/**\n * Faster scalar multiplication leveraging the GLV decomposition (see {@link decompose}).\n *\n * This method to speed up plain, non-provable scalar multiplication was the original application of GLV\n *\n * Instead of scaling a single point, we apply the decomposition to scale two points, with two scalars of half the original length:\n *\n * `s*G = s0*G + s1*lambda*G = s0*G + s1*endo(G)`, where endo(G) is cheap to compute\n *\n * Because we can do doubling on both points at once, we save half the double()` operations,\n * while the number of `add()` operations stays the same.\n */\nfunction glvScaleProjective(\n  g: GroupProjective,\n  s: bigint,\n  p: bigint,\n  a: bigint,\n  endoBase: bigint,\n  data: GlvData\n) {\n  let endoG = endomorphismProjective(g, endoBase, p);\n  let double = getProjectiveDouble(p, a);\n\n  let [s0, s1] = decompose(s, data);\n  let S0 = bigIntToBits(s0.abs);\n  let S1 = bigIntToBits(s1.abs);\n  if (s0.isNegative) g = projectiveNeg(g, p);\n  if (s1.isNegative) endoG = projectiveNeg(endoG, p);\n\n  let h = projectiveZero;\n\n  for (let i = data.maxBits - 1; i >= 0; i--) {\n    if (S0[i]) h = projectiveAdd(h, g, p, a);\n    if (S1[i]) h = projectiveAdd(h, endoG, p, a);\n    if (i === 0) break;\n    h = double(h, p);\n  }\n\n  return h;\n}\n\n/**\n * Compute constants for curve endomorphism (cube roots of unity in base and scalar field)\n *\n * Throws if conditions for a cube root-based endomorphism are not met.\n */\nfunction computeEndoConstants(Field: FiniteField, Scalar: FiniteField, G: GroupAffine, a: bigint) {\n  let p = Field.modulus;\n  let q = Scalar.modulus;\n  // if there is a cube root of unity, it generates a subgroup of order 3\n  assert(p % 3n === 1n, 'Base field has a cube root of unity');\n  assert(q % 3n === 1n, 'Scalar field has a cube root of unity');\n\n  // find a cube root of unity in Fq (endo scalar)\n  // we need lambda^3 = 1 and lambda != 1, which implies the quadratic equation\n  // lambda^2 + lambda + 1 = 0\n  // solving for lambda, we get lambda = (-1 +- sqrt(-3)) / 2\n  let sqrtMinus3 = Scalar.sqrt(Scalar.negate(3n));\n  assert(sqrtMinus3 !== undefined, 'Scalar field has a square root of -3');\n  let lambda = Scalar.div(Scalar.sub(sqrtMinus3, 1n), 2n);\n  assert(lambda !== undefined, 'Scalar field has a cube root of unity');\n\n  // sanity check\n  assert(Scalar.power(lambda, 3n) === 1n, 'lambda is a cube root');\n  assert(lambda !== 1n, 'lambda is not 1');\n\n  // compute beta such that lambda * (x, y) = (beta * x, y) (endo base)\n  let lambdaG = affineScale(G, lambda, p, a);\n  assert(lambdaG.y === G.y, 'multiplication by lambda is a cheap endomorphism');\n\n  let beta = Field.div(lambdaG.x, G.x);\n  assert(beta !== undefined, 'Gx is invertible');\n  assert(Field.power(beta, 3n) === 1n, 'beta is a cube root');\n  assert(beta !== 1n, 'beta is not 1');\n\n  // confirm endomorphism at random point\n  // TODO would be nice to have some theory instead of this heuristic\n  let R = affineScale(G, Scalar.random(), p, a);\n  let lambdaR = affineScale(R, lambda, p, a);\n  assert(lambdaR.x === Field.mul(beta, R.x), 'confirm endomorphism');\n  assert(lambdaR.y === R.y, 'confirm endomorphism');\n\n  return { endoScalar: lambda, endoBase: beta };\n}\n\n/**\n * compute constants for GLV decomposition and upper bounds on s0, s1\n *\n * see {@link decompose}\n */\nfunction computeGlvData(q: bigint, lambda: bigint) {\n  let [[v00, v01], [v10, v11]] = egcdStopEarly(lambda, q);\n  let det = v00 * v11 - v10 * v01;\n\n  // upper bounds for\n  // |s0| <= 0.5 * (|v00| + |v01|)\n  // |s1| <= 0.5 * (|v10| + |v11|)\n  let maxS0 = ((abs(v00) + abs(v01)) >> 1n) + 1n;\n  let maxS1 = ((abs(v10) + abs(v11)) >> 1n) + 1n;\n  let maxBits = log2(max(maxS0, maxS1));\n\n  return { v00, v01, v10, v11, det, maxS0, maxS1, maxBits };\n}\n\ntype GlvData = ReturnType<typeof computeGlvData>;\n\n/**\n * Extended Euclidean algorithm which stops when r1 < sqrt(p)\n *\n * Input: positive integers l, p\n *\n * Output: matrix V = [[v00,v01],[v10,v11]] of field elements satisfying\n * (1, l)^T V = v0j + l*v1j = 0 (mod p)\n *\n * For random / \"typical\" l, we will have |vij| ~ sqrt(p) for all vij\n */\nfunction egcdStopEarly(l: bigint, p: bigint): [[bigint, bigint], [bigint, bigint]] {\n  if (l > p) throw Error('a > p');\n  let [r0, r1] = [p, l];\n  let [s0, s1] = [1n, 0n];\n  let [t0, t1] = [0n, 1n];\n  while (r1 * r1 > p) {\n    let quotient = r0 / r1; // bigint division, cuts off remainder\n    [r0, r1] = [r1, r0 - quotient * r1];\n    [s0, s1] = [s1, s0 - quotient * s1];\n    [t0, t1] = [t1, t0 - quotient * t1];\n  }\n  // compute r2, t2\n  let quotient = r0 / r1;\n  let r2 = r0 - quotient * r1;\n  let t2 = t0 - quotient * t1;\n\n  let [v00, v10] = [r1, -t1];\n  let [v01, v11] = max(r0, abs(t0)) <= max(r2, abs(t2)) ? [r0, -t0] : [r2, -t2];\n\n  // we always have si * p + ti * l = ri\n  // => ri + (-ti)*l === 0 (mod p)\n  // => we can use ri as the first row of V and -ti as the second\n  return [\n    [v00, v01],\n    [v10, v11],\n  ];\n}\n\n// round(x / y)\nfunction divideAndRound(x: bigint, y: bigint) {\n  let signz = sign(x) * sign(y);\n  x = abs(x);\n  y = abs(y);\n  let z = x / y;\n  // z is rounded down. round up if it brings z*y closer to x\n  // (z+1)*y - x <= x - z*y\n  if (2n * (x - z * y) >= y) z++;\n  return signz * z;\n}\n", "/**\n * TS implementation of Pasta_bindings.{Pallas, Vesta}\n */\nimport { MlPair } from '../../../lib/ml/base.js';\nimport { Field } from './field.js';\nimport { Pallas, Vesta, ProjectiveCurve, GroupProjective, GroupAffine } from '../elliptic-curve.js';\nimport { withPrefix } from './util.js';\n\nexport {\n  VestaBindings,\n  PallasBindings,\n  Infinity,\n  OrInfinity,\n  OrInfinityJson,\n  toMlOrInfinity,\n  fromMlOrInfinity,\n};\n\nconst VestaBindings = withPrefix('caml_vesta', createCurveBindings(Vesta));\nconst PallasBindings = withPrefix('caml_pallas', createCurveBindings(Pallas));\n\nfunction createCurveBindings(Curve: ProjectiveCurve) {\n  return {\n    one(): GroupProjective {\n      return Curve.one;\n    },\n    add: Curve.add,\n    sub: Curve.sub,\n    negate: Curve.negate,\n    double: Curve.double,\n    scale(g: GroupProjective, [, s]: Field): GroupProjective {\n      return Curve.scale(g, s);\n    },\n    random(): GroupProjective {\n      throw Error('random not implemented');\n    },\n    rng(i: number): GroupProjective {\n      throw Error('rng not implemented');\n    },\n    endo_base(): Field {\n      return [0, Curve.endoBase];\n    },\n    endo_scalar(): Field {\n      return [0, Curve.endoScalar];\n    },\n    to_affine(g: GroupProjective): OrInfinity {\n      return toMlOrInfinity(Curve.toAffine(g));\n    },\n    of_affine(g: OrInfinity): GroupProjective {\n      return Curve.fromAffine(fromMlOrInfinity(g));\n    },\n    of_affine_coordinates(x: Field, y: Field): GroupProjective {\n      // allows to create in points not on the curve - matches Rust impl\n      return { x: x[1], y: y[1], z: 1n };\n    },\n    affine_deep_copy(g: OrInfinity): OrInfinity {\n      return toMlOrInfinity(fromMlOrInfinity(g));\n    },\n  };\n}\n\nconst affineZero = { x: 0n, y: 0n, infinity: true };\n\n// Kimchi_types.or_infinity\ntype Infinity = 0;\nconst Infinity = 0;\ntype Finite<T> = [0, T];\ntype OrInfinity = Infinity | Finite<MlPair<Field, Field>>;\n\nfunction toMlOrInfinity(g: GroupAffine): OrInfinity {\n  if (g.infinity) return 0;\n  return [0, [0, [0, g.x], [0, g.y]]];\n}\n\nfunction fromMlOrInfinity(g: OrInfinity): GroupAffine {\n  if (g === 0) return affineZero;\n  return { x: g[1][1][1], y: g[1][2][1], infinity: false };\n}\n\ntype OrInfinityJson = 'Infinity' | { x: string; y: string };\n\nconst OrInfinity = {\n  toJSON(g: OrInfinity): OrInfinityJson {\n    if (g === 0) return 'Infinity';\n    return { x: g[1][1][1].toString(), y: g[1][2][1].toString() };\n  },\n  fromJSON(g: OrInfinityJson): OrInfinity {\n    if (g === 'Infinity') return 0;\n    return [0, [0, [0, BigInt(g.x)], [0, BigInt(g.y)]]];\n  },\n};\n", "/**\n * TS implementation of Pasta_bindings.{Fp, Fq}\n */\nimport { FiniteField, Fp, Fq, mod } from '../finite-field.js';\nimport {\n  Bigint256Bindings,\n  Bigint256,\n  MlBytes,\n  fromMlString,\n  toMlStringAscii,\n} from './bigint256.js';\nimport { MlOption, MlBool } from '../../../lib/ml/base.js';\nimport { withPrefix } from './util.js';\n\ntype Field = [0, bigint];\n\nexport { FpBindings, FqBindings, Field };\n\nconst FpBindings = withPrefix('caml_pasta_fp', createFieldBindings(Fp));\nconst FqBindings = withPrefix('caml_pasta_fq', createFieldBindings(Fq));\n\nfunction createFieldBindings(Field: FiniteField) {\n  return {\n    size_in_bits(): number {\n      return Field.sizeInBits;\n    },\n    size(): Bigint256 {\n      return [0, Field.modulus];\n    },\n    add([, x]: Field, [, y]: Field): Field {\n      return [0, Field.add(x, y)];\n    },\n    sub([, x]: Field, [, y]: Field): Field {\n      return [0, Field.sub(x, y)];\n    },\n    negate([, x]: Field): Field {\n      return [0, Field.negate(x)];\n    },\n    mul([, x]: Field, [, y]: Field): Field {\n      return [0, Field.mul(x, y)];\n    },\n    div([, x]: Field, [, y]: Field): Field {\n      let z = Field.div(x, y);\n      if (z === undefined) throw Error('division by zero');\n      return [0, z];\n    },\n    inv([, x]: Field): MlOption<Field> {\n      return toMlOption(Field.inverse(x));\n    },\n    square([, x]: Field): Field {\n      return [0, Field.square(x)];\n    },\n    is_square([, x]: Field): MlBool {\n      return MlBool(Field.isSquare(x));\n    },\n    sqrt([, x]: Field): MlOption<Field> {\n      return toMlOption(Field.sqrt(x));\n    },\n    of_int(x: number): Field {\n      // avoid unnatural behaviour in Rust which treats negative numbers as uint64,\n      // e.g. -1 becomes 2^64 - 1\n      if (x < 0) throw Error('of_int: inputs must be non-negative');\n      return [0, Field.fromNumber(x)];\n    },\n    to_string([, x]: Field): MlBytes {\n      return toMlStringAscii(x.toString());\n    },\n    of_string(s: MlBytes): Field {\n      return [0, Field.fromBigint(BigInt(fromMlString(s)))];\n    },\n    print(x: Field): void {\n      console.log(x[0].toString());\n    },\n    copy(x: Field, [, y]: Field): void {\n      x[1] = y;\n    },\n    mut_add(x: Field, [, y]: Field): void {\n      x[1] = Field.add(x[1], y);\n    },\n    mut_sub(x: Field, [, y]: Field): void {\n      x[1] = Field.sub(x[1], y);\n    },\n    mut_mul(x: Field, [, y]: Field): void {\n      x[1] = Field.mul(x[1], y);\n    },\n    mut_square(x: Field): void {\n      x[1] = Field.square(x[1]);\n    },\n    compare(x: Field, y: Field): number {\n      return Bigint256Bindings.caml_bigint_256_compare(x, y);\n    },\n    equal([, x]: Field, [, y]: Field): MlBool {\n      return MlBool(x === y);\n    },\n    random(): Field {\n      return [0, Field.random()];\n    },\n    rng(i: number): Field {\n      // not used in js\n      throw Error('rng: not implemented');\n    },\n    to_bigint([, x]: Field): Bigint256 {\n      // copying to a new array to break mutable reference\n      return [0, x];\n    },\n    of_bigint([, x]: Bigint256): Field {\n      if (x >= Field.modulus) throw Error('of_bigint: input exceeds field size');\n      // copying to a new array to break mutable reference\n      return [0, x];\n    },\n    two_adic_root_of_unity(): Field {\n      return [0, Field.twoadicRoot];\n    },\n    domain_generator(i: number): Field {\n      // this takes an integer i and returns a 2^ith root of unity, i.e. a number `w` with\n      // w^(2^i) = 1, w^(2^(i-1)) = -1\n      // computed by taking the 2^32th root and squaring 32-i times\n      if (i > 32 || i < 0)\n        throw Error('log2 size of evaluation domain must be in [0, 32], got ' + i);\n      if (i === 0) return [0, 1n];\n      let generator = Field.twoadicRoot;\n      for (let j = 32; j > i; j--) {\n        generator = mod(generator * generator, Field.modulus);\n      }\n      return [0, generator];\n    },\n    to_bytes(x: Field): MlBytes {\n      return Bigint256Bindings.caml_bigint_256_to_bytes(x);\n    },\n    of_bytes(bytes: MlBytes): Field {\n      // not used in js\n      throw Error('of_bytes: not implemented');\n    },\n    deep_copy([, x]: Field): Field {\n      return [0, x];\n    },\n  };\n}\n\nfunction toMlOption<T>(x: undefined | T): MlOption<[0, T]> {\n  if (x === undefined) return 0; // None\n  return [0, [0, x]]; // Some(x)\n}\n", "/**\n * TS implementation of Kimchi_bindings.FieldVectors\n */\nimport { MlArray } from '../../../lib/ml/base.js';\nimport { Field } from './field.js';\nimport { withPrefix } from './util.js';\n\nexport { FpVectorBindings, FqVectorBindings };\nexport { FieldVector };\n\ntype FieldVector = MlArray<Field>;\n\nconst FieldVectorBindings = {\n  create(): FieldVector {\n    // OCaml tag for arrays, so that we can use the same utility fns on both\n    return [0];\n  },\n  length(v: FieldVector): number {\n    return v.length - 1;\n  },\n  emplace_back(v: FieldVector, x: Field): void {\n    v.push(x);\n  },\n  get(v: FieldVector, i: number): Field {\n    let value = v[i + 1] as Field | undefined;\n    if (value === undefined) {\n      throw Error(`FieldVector.get(): Index out of bounds, got ${i}/${v.length - 1}`);\n    }\n    // copying to a new array to break mutable reference\n    return [...value];\n  },\n  set(v: FieldVector, i: number, x: Field): void {\n    v[i + 1] = x;\n  },\n};\n\nconst FpVectorBindings = withPrefix('caml_fp_vector', FieldVectorBindings);\nconst FqVectorBindings = withPrefix('caml_fq_vector', FieldVectorBindings);\n", "import { Field } from './field.js';\nimport { bigintToBytes32, bytesToBigint32 } from '../bigint-helpers.js';\nimport type {\n  WasmGPallas,\n  WasmGVesta,\n  WasmPallasGProjective,\n  WasmVestaGProjective,\n} from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport type { MlArray } from '../../../lib/ml/base.js';\nimport { OrInfinity, Infinity } from './curve.js';\n\nexport {\n  fieldToRust,\n  fieldFromRust,\n  fieldsToRustFlat,\n  fieldsFromRustFlat,\n  maybeFieldToRust,\n  affineToRust,\n  affineFromRust,\n  WasmAffine,\n  WasmProjective,\n};\n\n// TODO: Hardcoding this is a little brittle\n// TODO read from field\nconst fieldSizeBytes = 32;\n\n// field, field vectors\n\nfunction fieldToRust([, x]: Field, dest = new Uint8Array(32)): Uint8Array {\n  return bigintToBytes32(x, dest);\n}\nfunction fieldFromRust(x: Uint8Array): Field {\n  return [0, bytesToBigint32(x)];\n}\n\nfunction fieldsToRustFlat([, ...fields]: MlArray<Field>): Uint8Array {\n  let n = fields.length;\n  let flatBytes = new Uint8Array(n * fieldSizeBytes);\n  for (let i = 0, offset = 0; i < n; i++, offset += fieldSizeBytes) {\n    fieldToRust(fields[i], flatBytes.subarray(offset, offset + fieldSizeBytes));\n  }\n  return flatBytes;\n}\n\nfunction fieldsFromRustFlat(fieldBytes: Uint8Array): MlArray<Field> {\n  let n = fieldBytes.length / fieldSizeBytes;\n  if (!Number.isInteger(n)) {\n    throw Error('fieldsFromRustFlat: invalid bytes');\n  }\n  let fields: Field[] = Array(n);\n  for (let i = 0, offset = 0; i < n; i++, offset += fieldSizeBytes) {\n    let fieldView = new Uint8Array(fieldBytes.buffer, offset, fieldSizeBytes);\n    fields[i] = fieldFromRust(fieldView);\n  }\n  return [0, ...fields];\n}\n\nfunction maybeFieldToRust(x?: Field): Uint8Array | undefined {\n  return x && fieldToRust(x);\n}\n\n// affine\n\ntype WasmAffine = WasmGVesta | WasmGPallas;\n\nfunction affineFromRust<A extends WasmAffine>(pt: A): OrInfinity {\n  if (pt.infinity) {\n    pt.free();\n    return 0;\n  } else {\n    let x = fieldFromRust(pt.x);\n    let y = fieldFromRust(pt.y);\n    pt.free();\n    return [0, [0, x, y]];\n  }\n}\n\nconst tmpBytes = new Uint8Array(32);\n\nfunction affineToRust<A extends WasmAffine>(pt: OrInfinity, makeAffine: () => A) {\n  let res = makeAffine();\n  if (pt === Infinity) {\n    res.infinity = true;\n  } else {\n    let [, [, x, y]] = pt;\n    // we can use the same bytes here every time,\n    // because x and y setters copy the bytes into wasm memory\n    res.x = fieldToRust(x, tmpBytes);\n    res.y = fieldToRust(y, tmpBytes);\n  }\n  return res;\n}\n\n// projective\n\ntype WasmProjective = WasmVestaGProjective | WasmPallasGProjective;\n", "import type {\n  WasmFpGate,\n  WasmFpPolyComm,\n  WasmFqGate,\n  WasmFqPolyComm,\n  WasmGPallas,\n  WasmGVesta,\n} from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport { OrInfinity, Gate, PolyComm, Wire } from './kimchi-types.js';\nimport type * as wasmNamespace from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport { MlArray } from '../../../lib/ml/base.js';\nimport { mapTuple } from './util.js';\nimport {\n  WasmAffine,\n  affineFromRust,\n  affineToRust,\n  fieldsFromRustFlat,\n  fieldsToRustFlat,\n} from './conversion-base.js';\n\nexport {\n  ConversionCore,\n  ConversionCores,\n  conversionCore,\n  freeOnFinalize,\n  wrap,\n  unwrap,\n  mapFromUintArray,\n  mapToUint32Array,\n};\n\n// basic conversion functions for each field\n\ntype wasm = typeof wasmNamespace;\n\ntype WasmPolyComm = WasmFpPolyComm | WasmFqPolyComm;\n\ntype WasmClasses = {\n  CommitmentCurve: typeof WasmGVesta | typeof WasmGPallas;\n  makeAffine: () => WasmAffine;\n  Gate: typeof WasmFpGate | typeof WasmFqGate;\n  PolyComm: typeof WasmFpPolyComm | typeof WasmFqPolyComm;\n};\n\ntype ConversionCore = ReturnType<typeof conversionCorePerField>;\ntype ConversionCores = ReturnType<typeof conversionCore>;\n\nfunction conversionCore(wasm: wasm) {\n  const fp = conversionCorePerField(wasm, {\n    CommitmentCurve: wasm.WasmGVesta,\n    makeAffine: wasm.caml_vesta_affine_one,\n    Gate: wasm.WasmFpGate,\n    PolyComm: wasm.WasmFpPolyComm,\n  });\n  const fq = conversionCorePerField(wasm, {\n    CommitmentCurve: wasm.WasmGPallas,\n    makeAffine: wasm.caml_pallas_affine_one,\n    Gate: wasm.WasmFqGate,\n    PolyComm: wasm.WasmFqPolyComm,\n  });\n\n  return {\n    fp,\n    fq,\n    wireToRust: fp.wireToRust, // doesn't depend on the field\n    mapMlArrayToRustVector<TMl, TRust extends {}>(\n      [, ...array]: MlArray<TMl>,\n      map: (x: TMl) => TRust\n    ): Uint32Array {\n      return mapToUint32Array(array, (x) => unwrap(map(x)));\n    },\n  };\n}\n\nfunction conversionCorePerField(\n  wasm: wasm,\n  { CommitmentCurve, makeAffine, Gate, PolyComm }: WasmClasses\n) {\n  let self = {\n    wireToRust([, row, col]: Wire) {\n      return wasm.Wire.create(row, col);\n    },\n\n    vectorToRust: fieldsToRustFlat,\n    vectorFromRust: fieldsFromRustFlat,\n\n    gateToRust(gate: Gate) {\n      let [, typ, [, ...wires], coeffs] = gate;\n      let rustWires = new wasm.WasmGateWires(...mapTuple(wires, self.wireToRust));\n      let rustCoeffs = fieldsToRustFlat(coeffs);\n      return new Gate(typ, rustWires, rustCoeffs);\n    },\n    gateFromRust(wasmGate: WasmFpGate | WasmFqGate) {\n      // note: this was never used and the old implementation was wrong\n      // (accessed non-existent fields on wasmGate)\n      throw Error('gateFromRust not implemented');\n    },\n\n    pointToRust(point: OrInfinity) {\n      return affineToRust(point, makeAffine);\n    },\n    pointFromRust: affineFromRust,\n\n    pointsToRust([, ...points]: MlArray<OrInfinity>): Uint32Array {\n      return mapToUint32Array(points, (point) => unwrap(self.pointToRust(point)));\n    },\n    pointsFromRust(points: Uint32Array): MlArray<OrInfinity> {\n      let arr = mapFromUintArray(points, (ptr) => affineFromRust(wrap(ptr, CommitmentCurve)));\n      return [0, ...arr];\n    },\n\n    polyCommToRust(polyComm: PolyComm): WasmPolyComm {\n      let [, camlElems] = polyComm;\n      let rustShifted = undefined;\n      let rustUnshifted = self.pointsToRust(camlElems);\n      return new PolyComm(rustUnshifted, rustShifted);\n    },\n    polyCommFromRust(polyComm: WasmPolyComm): PolyComm {\n      let rustUnshifted = polyComm.unshifted;\n      let mlUnshifted = mapFromUintArray(rustUnshifted, (ptr) => {\n        return affineFromRust(wrap(ptr, CommitmentCurve));\n      });\n      return [0, [0, ...mlUnshifted]];\n    },\n\n    polyCommsToRust([, ...comms]: MlArray<PolyComm>): Uint32Array {\n      return mapToUint32Array(comms, (c) => unwrap(self.polyCommToRust(c)));\n    },\n    polyCommsFromRust(rustComms: Uint32Array): MlArray<PolyComm> {\n      let comms = mapFromUintArray(rustComms, (ptr) => self.polyCommFromRust(wrap(ptr, PolyComm)));\n      return [0, ...comms];\n    },\n  };\n\n  return self;\n}\n\n// generic rust helpers\n\ntype Freeable = { free(): void };\ntype Constructor<T> = new (...args: any[]) => T;\n\nfunction wrap<T>(ptr: number, Class: Constructor<T>): T {\n  const obj = Object.create(Class.prototype);\n  obj.__wbg_ptr = ptr;\n  return obj;\n}\nfunction unwrap<T extends {}>(obj: T): number {\n  // Beware: caller may need to do finalizer things to avoid these\n  // pointers disappearing out from under us.\n  let ptr = (obj as any).__wbg_ptr;\n  if (ptr === undefined) throw Error('unwrap: missing ptr');\n  return ptr;\n}\n\nconst registry = new FinalizationRegistry((ptr: Freeable) => {\n  ptr.free();\n});\nfunction freeOnFinalize<T extends Freeable>(instance: T) {\n  // This is an unfortunate hack: we're creating a second instance of the\n  // class to be able to call free on it. We can't pass the value itself,\n  // since the registry holds a strong reference to the representative value.\n  //\n  // However, the class is only really a wrapper around a pointer, with a\n  // reference to the class' prototype as its __prototype__.\n  //\n  // It might seem cleaner to call the destructor here on the pointer\n  // directly, but unfortunately the destructor name is some mangled internal\n  // string generated by wasm_bindgen. For now, this is the best,\n  // least-brittle way to free once the original class instance gets collected.\n  let instanceRepresentative = wrap<T>((instance as any).__wbg_ptr, (instance as any).constructor);\n  registry.register(instance, instanceRepresentative, instance);\n  return instance;\n}\n\nfunction mapFromUintArray<T>(array: Uint32Array | Uint8Array, map: (i: number) => T) {\n  let n = array.length;\n  let result: T[] = Array(n);\n  for (let i = 0; i < n; i++) {\n    result[i] = map(array[i]);\n  }\n  return result;\n}\n\nfunction mapToUint32Array<T>(array: T[], map: (t: T) => number) {\n  let n = array.length;\n  let result = new Uint32Array(n);\n  for (let i = 0; i < n; i++) {\n    result[i] = map(array[i]);\n  }\n  return result;\n}\n", "import type {\n  WasmFpLookupCommitments,\n  WasmPastaFpLookupTable,\n  WasmFpOpeningProof,\n  WasmFpProverCommitments,\n  WasmFpProverProof,\n  WasmFpRuntimeTable,\n  WasmPastaFpRuntimeTableCfg,\n  WasmFqLookupCommitments,\n  WasmFqOpeningProof,\n  WasmFqProverCommitments,\n  WasmPastaFqLookupTable,\n  WasmFqProverProof,\n  WasmFqRuntimeTable,\n  WasmPastaFqRuntimeTableCfg,\n  WasmVecVecFp,\n  WasmVecVecFq,\n} from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport type * as wasmNamespace from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport type {\n  OrInfinity,\n  PointEvaluations,\n  PolyComm,\n  ProverProof,\n  ProofWithPublic,\n  ProofEvaluations,\n  ProverCommitments,\n  OpeningProof,\n  RecursionChallenge,\n  LookupCommitments,\n  RuntimeTable,\n  RuntimeTableCfg,\n  LookupTable,\n  Field,\n} from './kimchi-types.js';\nimport { MlArray, MlOption, MlTuple } from '../../../lib/ml/base.js';\nimport {\n  fieldToRust,\n  fieldFromRust,\n  fieldsToRustFlat,\n  fieldsFromRustFlat,\n} from './conversion-base.js';\nimport { ConversionCore, ConversionCores, mapToUint32Array, unwrap } from './conversion-core.js';\n\nexport { proofConversion };\n\nconst fieldToRust_ = (x: Field) => fieldToRust(x);\nconst proofEvaluationsToRust = mapProofEvaluations(fieldToRust_);\nconst proofEvaluationsFromRust = mapProofEvaluations(fieldFromRust);\nconst pointEvalsOptionToRust = mapPointEvalsOption(fieldToRust_);\nconst pointEvalsOptionFromRust = mapPointEvalsOption(fieldFromRust);\n\ntype WasmProofEvaluations = [\n  0,\n  MlOption<PointEvaluations<Uint8Array>>,\n  ...RemoveLeadingZero<ProofEvaluations<Uint8Array>>,\n];\n\ntype wasm = typeof wasmNamespace;\n\ntype WasmProverCommitments = WasmFpProverCommitments | WasmFqProverCommitments;\ntype WasmOpeningProof = WasmFpOpeningProof | WasmFqOpeningProof;\ntype WasmProverProof = WasmFpProverProof | WasmFqProverProof;\ntype WasmLookupCommitments = WasmFpLookupCommitments | WasmFqLookupCommitments;\ntype WasmRuntimeTable = WasmFpRuntimeTable | WasmFqRuntimeTable;\ntype WasmRuntimeTableCfg = WasmPastaFpRuntimeTableCfg | WasmPastaFqRuntimeTableCfg;\ntype WasmLookupTable = WasmPastaFpLookupTable | WasmPastaFqLookupTable;\n\ntype WasmClasses = {\n  ProverCommitments: typeof WasmFpProverCommitments | typeof WasmFqProverCommitments;\n  OpeningProof: typeof WasmFpOpeningProof | typeof WasmFqOpeningProof;\n  VecVec: typeof WasmVecVecFp | typeof WasmVecVecFq;\n  ProverProof: typeof WasmFpProverProof | typeof WasmFqProverProof;\n  LookupCommitments: typeof WasmFpLookupCommitments | typeof WasmFqLookupCommitments;\n  RuntimeTable: typeof WasmFpRuntimeTable | typeof WasmFqRuntimeTable;\n  RuntimeTableCfg: typeof WasmPastaFpRuntimeTableCfg | typeof WasmPastaFqRuntimeTableCfg;\n  LookupTable: typeof WasmPastaFpLookupTable | typeof WasmPastaFqLookupTable;\n};\n\nfunction proofConversion(wasm: wasm, core: ConversionCores) {\n  return {\n    fp: proofConversionPerField(core.fp, {\n      ProverCommitments: wasm.WasmFpProverCommitments,\n      OpeningProof: wasm.WasmFpOpeningProof,\n      VecVec: wasm.WasmVecVecFp,\n      ProverProof: wasm.WasmFpProverProof,\n      LookupCommitments: wasm.WasmFpLookupCommitments,\n      RuntimeTable: wasm.WasmFpRuntimeTable,\n      RuntimeTableCfg: wasm.WasmPastaFpRuntimeTableCfg,\n      LookupTable: wasm.WasmPastaFpLookupTable,\n    }),\n    fq: proofConversionPerField(core.fq, {\n      ProverCommitments: wasm.WasmFqProverCommitments,\n      OpeningProof: wasm.WasmFqOpeningProof,\n      VecVec: wasm.WasmVecVecFq,\n      ProverProof: wasm.WasmFqProverProof,\n      LookupCommitments: wasm.WasmFqLookupCommitments,\n      RuntimeTable: wasm.WasmFqRuntimeTable,\n      RuntimeTableCfg: wasm.WasmPastaFqRuntimeTableCfg,\n      LookupTable: wasm.WasmPastaFqLookupTable,\n    }),\n  };\n}\n\nfunction proofConversionPerField(\n  core: ConversionCore,\n  {\n    ProverCommitments,\n    OpeningProof,\n    VecVec,\n    ProverProof,\n    LookupCommitments,\n    RuntimeTable,\n    RuntimeTableCfg,\n    LookupTable,\n  }: WasmClasses\n) {\n  function commitmentsToRust(commitments: ProverCommitments): WasmProverCommitments {\n    let wComm = core.polyCommsToRust(commitments[1]);\n    let zComm = core.polyCommToRust(commitments[2]);\n    let tComm = core.polyCommToRust(commitments[3]);\n    let lookup = MlOption.mapFrom(commitments[4], lookupCommitmentsToRust);\n    return new ProverCommitments(wComm, zComm, tComm, lookup);\n  }\n  function commitmentsFromRust(commitments: WasmProverCommitments): ProverCommitments {\n    let wComm = core.polyCommsFromRust(commitments.w_comm);\n    let zComm = core.polyCommFromRust(commitments.z_comm);\n    let tComm = core.polyCommFromRust(commitments.t_comm);\n    let lookup = MlOption.mapTo(commitments.lookup, lookupCommitmentsFromRust);\n    commitments.free();\n    return [0, wComm as MlTuple<PolyComm, 15>, zComm, tComm, lookup];\n  }\n\n  function lookupCommitmentsToRust(lookup: LookupCommitments): WasmLookupCommitments {\n    let sorted = core.polyCommsToRust(lookup[1]);\n    let aggreg = core.polyCommToRust(lookup[2]);\n    let runtime = MlOption.mapFrom(lookup[3], core.polyCommToRust);\n    return new LookupCommitments(sorted, aggreg, runtime);\n  }\n  function lookupCommitmentsFromRust(lookup: WasmLookupCommitments): LookupCommitments {\n    let sorted = core.polyCommsFromRust(lookup.sorted);\n    let aggreg = core.polyCommFromRust(lookup.aggreg);\n    let runtime = MlOption.mapTo(lookup.runtime, core.polyCommFromRust);\n    lookup.free();\n    return [0, sorted, aggreg, runtime];\n  }\n\n  function openingProofToRust(proof: OpeningProof): WasmOpeningProof {\n    let [_, [, ...lr], delta, z1, z2, sg] = proof;\n    // We pass l and r as separate vectors over the FFI\n    let l: MlArray<OrInfinity> = [0];\n    let r: MlArray<OrInfinity> = [0];\n    for (let [, li, ri] of lr) {\n      l.push(li);\n      r.push(ri);\n    }\n    return new OpeningProof(\n      core.pointsToRust(l),\n      core.pointsToRust(r),\n      core.pointToRust(delta),\n      fieldToRust(z1),\n      fieldToRust(z2),\n      core.pointToRust(sg)\n    );\n  }\n  function openingProofFromRust(proof: WasmOpeningProof): OpeningProof {\n    let [, ...l] = core.pointsFromRust(proof.lr_0);\n    let [, ...r] = core.pointsFromRust(proof.lr_1);\n    let n = l.length;\n    if (n !== r.length) throw Error('openingProofFromRust: l and r length mismatch.');\n    let lr = l.map<[0, OrInfinity, OrInfinity]>((li, i) => [0, li, r[i]]);\n    let delta = core.pointFromRust(proof.delta);\n    let z1 = fieldFromRust(proof.z1);\n    let z2 = fieldFromRust(proof.z2);\n    let sg = core.pointFromRust(proof.sg);\n    proof.free();\n    return [0, [0, ...lr], delta, z1, z2, sg];\n  }\n\n  function runtimeTableToRust([, id, data]: RuntimeTable): WasmRuntimeTable {\n    return new RuntimeTable(id, core.vectorToRust(data));\n  }\n\n  function runtimeTableCfgToRust([, id, firstColumn]: RuntimeTableCfg): WasmRuntimeTableCfg {\n    return new RuntimeTableCfg(id, core.vectorToRust(firstColumn));\n  }\n\n  function lookupTableToRust([, id, [, ...data]]: LookupTable): WasmLookupTable {\n    let n = data.length;\n    let wasmData = new VecVec(n);\n    for (let i = 0; i < n; i++) {\n      wasmData.push(fieldsToRustFlat(data[i]));\n    }\n    return new LookupTable(id, wasmData);\n  }\n\n  return {\n    proofToRust([, public_evals, proof]: ProofWithPublic): WasmProverProof {\n      let commitments = commitmentsToRust(proof[1]);\n      let openingProof = openingProofToRust(proof[2]);\n      let [, ...evals] = proofEvaluationsToRust(proof[3]);\n      let publicEvals = pointEvalsOptionToRust(public_evals);\n      // TODO typed as `any` in wasm-bindgen, this has the correct type\n      let evalsActual: WasmProofEvaluations = [0, publicEvals, ...evals];\n\n      let ftEval1 = fieldToRust(proof[4]);\n      let public_ = fieldsToRustFlat(proof[5]);\n      let [, ...prevChallenges] = proof[6];\n      let n = prevChallenges.length;\n      let prevChallengeScalars = new VecVec(n);\n      let prevChallengeCommsMl: MlArray<PolyComm> = [0];\n      for (let [, scalars, comms] of prevChallenges) {\n        prevChallengeScalars.push(fieldsToRustFlat(scalars));\n        prevChallengeCommsMl.push(comms);\n      }\n      let prevChallengeComms = core.polyCommsToRust(prevChallengeCommsMl);\n      return new ProverProof(\n        commitments,\n        openingProof,\n        evalsActual,\n        ftEval1,\n        public_,\n        prevChallengeScalars,\n        prevChallengeComms\n      );\n    },\n    proofFromRust(wasmProof: WasmProverProof): ProofWithPublic {\n      let commitments = commitmentsFromRust(wasmProof.commitments);\n      let openingProof = openingProofFromRust(wasmProof.proof);\n      // TODO typed as `any` in wasm-bindgen, this is the correct type\n      let [, wasmPublicEvals, ...wasmEvals]: WasmProofEvaluations = wasmProof.evals;\n      let publicEvals = pointEvalsOptionFromRust(wasmPublicEvals);\n      let evals = proofEvaluationsFromRust([0, ...wasmEvals]);\n\n      let ftEval1 = fieldFromRust(wasmProof.ft_eval1);\n      let public_ = fieldsFromRustFlat(wasmProof.public_);\n      let prevChallengeScalars = wasmProof.prev_challenges_scalars;\n      let [, ...prevChallengeComms] = core.polyCommsFromRust(wasmProof.prev_challenges_comms);\n      let prevChallenges = prevChallengeComms.map<RecursionChallenge>((comms, i) => {\n        let scalars = fieldsFromRustFlat(prevChallengeScalars.get(i));\n        return [0, scalars, comms];\n      });\n      wasmProof.free();\n      let proof: ProverProof = [\n        0,\n        commitments,\n        openingProof,\n        evals,\n        ftEval1,\n        public_,\n        [0, ...prevChallenges],\n      ];\n      return [0, publicEvals, proof];\n    },\n\n    runtimeTablesToRust([, ...tables]: MlArray<RuntimeTable>): Uint32Array {\n      return mapToUint32Array(tables, (table) => unwrap(runtimeTableToRust(table)));\n    },\n\n    runtimeTableCfgsToRust([, ...tableCfgs]: MlArray<RuntimeTableCfg>): Uint32Array {\n      return mapToUint32Array(tableCfgs, (tableCfg) => unwrap(runtimeTableCfgToRust(tableCfg)));\n    },\n\n    lookupTablesToRust([, ...tables]: MlArray<LookupTable>) {\n      return mapToUint32Array(tables, (table) => unwrap(lookupTableToRust(table)));\n    },\n  };\n}\n\nfunction createMapPointEvals<Field1, Field2>(map: (x: Field1) => Field2) {\n  return (evals: PointEvaluations<Field1>): PointEvaluations<Field2> => {\n    let [, zeta, zeta_omega] = evals;\n    return [0, MlArray.map(zeta, map), MlArray.map(zeta_omega, map)];\n  };\n}\n\nfunction mapPointEvalsOption<Field1, Field2>(map: (x: Field1) => Field2) {\n  return (evals: MlOption<PointEvaluations<Field1>>) =>\n    MlOption.map(evals, createMapPointEvals(map));\n}\n\nfunction mapProofEvaluations<Field1, Field2>(map: (x: Field1) => Field2) {\n  const mapPointEvals = createMapPointEvals(map);\n\n  const mapPointEvalsOption = (\n    evals: MlOption<PointEvaluations<Field1>>\n  ): MlOption<PointEvaluations<Field2>> => MlOption.map(evals, mapPointEvals);\n\n  return function mapProofEvaluations(evals: ProofEvaluations<Field1>): ProofEvaluations<Field2> {\n    let [\n      ,\n      w,\n      z,\n      s,\n      coeffs,\n      genericSelector,\n      poseidonSelector,\n      completeAddSelector,\n      mulSelector,\n      emulSelector,\n      endomulScalarSelector,\n      rangeCheck0Selector,\n      rangeCheck1Selector,\n      foreignFieldAddSelector,\n      foreignFieldMulSelector,\n      xorSelector,\n      rotSelector,\n      lookupAggregation,\n      lookupTable,\n      lookupSorted,\n      runtimeLookupTable,\n      runtimeLookupTableSelector,\n      xorLookupSelector,\n      lookupGateLookupSelector,\n      rangeCheckLookupSelector,\n      foreignFieldMulLookupSelector,\n    ] = evals;\n    return [\n      0,\n      MlTuple.map(w, mapPointEvals),\n      mapPointEvals(z),\n      MlTuple.map(s, mapPointEvals),\n      MlTuple.map(coeffs, mapPointEvals),\n      mapPointEvals(genericSelector),\n      mapPointEvals(poseidonSelector),\n      mapPointEvals(completeAddSelector),\n      mapPointEvals(mulSelector),\n      mapPointEvals(emulSelector),\n      mapPointEvals(endomulScalarSelector),\n      mapPointEvalsOption(rangeCheck0Selector),\n      mapPointEvalsOption(rangeCheck1Selector),\n      mapPointEvalsOption(foreignFieldAddSelector),\n      mapPointEvalsOption(foreignFieldMulSelector),\n      mapPointEvalsOption(xorSelector),\n      mapPointEvalsOption(rotSelector),\n      mapPointEvalsOption(lookupAggregation),\n      mapPointEvalsOption(lookupTable),\n      MlArray.map(lookupSorted, mapPointEvalsOption),\n      mapPointEvalsOption(runtimeLookupTable),\n      mapPointEvalsOption(runtimeLookupTableSelector),\n      mapPointEvalsOption(xorLookupSelector),\n      mapPointEvalsOption(lookupGateLookupSelector),\n      mapPointEvalsOption(rangeCheckLookupSelector),\n      mapPointEvalsOption(foreignFieldMulLookupSelector),\n    ];\n  };\n}\n\n// helper\n\ntype RemoveLeadingZero<T extends [0, ...any]> = T extends [0, ...infer U] ? U : never;\n", "import type {\n  WasmFpDomain,\n  WasmFpLookupSelectors,\n  WasmFpLookupVerifierIndex,\n  WasmFpPlonkVerificationEvals,\n  WasmFpPlonkVerifierIndex,\n  WasmFpShifts,\n  WasmFqDomain,\n  WasmFqLookupSelectors,\n  WasmFqLookupVerifierIndex,\n  WasmFqPlonkVerificationEvals,\n  WasmFqPlonkVerifierIndex,\n  WasmFqShifts,\n  LookupInfo as WasmLookupInfo,\n} from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport type * as wasmNamespace from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport { MlBool, MlArray, MlOption } from '../../../lib/ml/base.js';\nimport { Field, VerifierIndex, Domain, VerificationEvals, PolyComm } from './kimchi-types.js';\nimport { fieldFromRust, fieldToRust } from './conversion-base.js';\nimport { ConversionCore, ConversionCores, freeOnFinalize } from './conversion-core.js';\nimport { Lookup, LookupInfo, LookupSelectors } from './lookup.js';\n\nexport { verifierIndexConversion };\n\ntype wasm = typeof wasmNamespace;\n\ntype WasmDomain = WasmFpDomain | WasmFqDomain;\ntype WasmVerificationEvals = WasmFpPlonkVerificationEvals | WasmFqPlonkVerificationEvals;\ntype WasmShifts = WasmFpShifts | WasmFqShifts;\ntype WasmVerifierIndex = WasmFpPlonkVerifierIndex | WasmFqPlonkVerifierIndex;\n\ntype WasmLookupVerifierIndex = WasmFpLookupVerifierIndex | WasmFqLookupVerifierIndex;\ntype WasmLookupSelector = WasmFpLookupSelectors | WasmFqLookupSelectors;\n\ntype WasmClasses = {\n  Domain: typeof WasmFpDomain | typeof WasmFqDomain;\n  VerificationEvals: typeof WasmFpPlonkVerificationEvals | typeof WasmFqPlonkVerificationEvals;\n  Shifts: typeof WasmFpShifts | typeof WasmFqShifts;\n  VerifierIndex: typeof WasmFpPlonkVerifierIndex | typeof WasmFqPlonkVerifierIndex;\n  LookupVerifierIndex: typeof WasmFpLookupVerifierIndex | typeof WasmFqLookupVerifierIndex;\n  LookupSelector: typeof WasmFpLookupSelectors | typeof WasmFqLookupSelectors;\n};\n\nfunction verifierIndexConversion(wasm: wasm, core: ConversionCores) {\n  return {\n    fp: verifierIndexConversionPerField(wasm, core.fp, {\n      Domain: wasm.WasmFpDomain,\n      VerificationEvals: wasm.WasmFpPlonkVerificationEvals,\n      Shifts: wasm.WasmFpShifts,\n      VerifierIndex: wasm.WasmFpPlonkVerifierIndex,\n      LookupVerifierIndex: wasm.WasmFpLookupVerifierIndex,\n      LookupSelector: wasm.WasmFpLookupSelectors,\n    }),\n    fq: verifierIndexConversionPerField(wasm, core.fq, {\n      Domain: wasm.WasmFqDomain,\n      VerificationEvals: wasm.WasmFqPlonkVerificationEvals,\n      Shifts: wasm.WasmFqShifts,\n      VerifierIndex: wasm.WasmFqPlonkVerifierIndex,\n      LookupVerifierIndex: wasm.WasmFqLookupVerifierIndex,\n      LookupSelector: wasm.WasmFqLookupSelectors,\n    }),\n  };\n}\n\nfunction verifierIndexConversionPerField(\n  wasm: wasm,\n  core: ConversionCore,\n  {\n    Domain,\n    VerificationEvals,\n    Shifts,\n    VerifierIndex,\n    LookupVerifierIndex,\n    LookupSelector,\n  }: WasmClasses\n) {\n  function domainToRust([, logSizeOfGroup, groupGen]: Domain): WasmDomain {\n    return new Domain(logSizeOfGroup, fieldToRust(groupGen));\n  }\n  function domainFromRust(domain: WasmDomain): Domain {\n    let logSizeOfGroup = domain.log_size_of_group;\n    let groupGen = fieldFromRust(domain.group_gen);\n    domain.free();\n    return [0, logSizeOfGroup, groupGen];\n  }\n\n  function verificationEvalsToRust(evals: VerificationEvals): WasmVerificationEvals {\n    let sigmaComm = core.polyCommsToRust(evals[1]);\n    let coefficientsComm = core.polyCommsToRust(evals[2]);\n    let genericComm = core.polyCommToRust(evals[3]);\n    let psmComm = core.polyCommToRust(evals[4]);\n    let completeAddComm = core.polyCommToRust(evals[5]);\n    let mulComm = core.polyCommToRust(evals[6]);\n    let emulComm = core.polyCommToRust(evals[7]);\n    let endomulScalarComm = core.polyCommToRust(evals[8]);\n    let xorComm = MlOption.mapFrom(evals[9], core.polyCommToRust);\n    let rangeCheck0Comm = MlOption.mapFrom(evals[10], core.polyCommToRust);\n    let rangeCheck1Comm = MlOption.mapFrom(evals[11], core.polyCommToRust);\n    let foreignFieldAddComm = MlOption.mapFrom(evals[12], core.polyCommToRust);\n    let foreignFieldMulComm = MlOption.mapFrom(evals[13], core.polyCommToRust);\n    let rotComm = MlOption.mapFrom(evals[14], core.polyCommToRust);\n    return new VerificationEvals(\n      sigmaComm,\n      coefficientsComm,\n      genericComm,\n      psmComm,\n      completeAddComm,\n      mulComm,\n      emulComm,\n      endomulScalarComm,\n      xorComm,\n      rangeCheck0Comm,\n      rangeCheck1Comm,\n      foreignFieldAddComm,\n      foreignFieldMulComm,\n      rotComm\n    );\n  }\n  function verificationEvalsFromRust(evals: WasmVerificationEvals): VerificationEvals {\n    let mlEvals: VerificationEvals = [\n      0,\n      core.polyCommsFromRust(evals.sigma_comm),\n      core.polyCommsFromRust(evals.coefficients_comm),\n      core.polyCommFromRust(evals.generic_comm),\n      core.polyCommFromRust(evals.psm_comm),\n      core.polyCommFromRust(evals.complete_add_comm),\n      core.polyCommFromRust(evals.mul_comm),\n      core.polyCommFromRust(evals.emul_comm),\n      core.polyCommFromRust(evals.endomul_scalar_comm),\n      MlOption.mapTo(evals.xor_comm, core.polyCommFromRust),\n      MlOption.mapTo(evals.range_check0_comm, core.polyCommFromRust),\n      MlOption.mapTo(evals.range_check1_comm, core.polyCommFromRust),\n      MlOption.mapTo(evals.foreign_field_add_comm, core.polyCommFromRust),\n      MlOption.mapTo(evals.foreign_field_mul_comm, core.polyCommFromRust),\n      MlOption.mapTo(evals.rot_comm, core.polyCommFromRust),\n    ];\n    evals.free();\n    return mlEvals;\n  }\n\n  function lookupVerifierIndexToRust(lookup: Lookup<PolyComm>): WasmLookupVerifierIndex {\n    let [\n      ,\n      joint_lookup_used,\n      lookup_table,\n      selectors,\n      table_ids,\n      lookup_info,\n      runtime_tables_selector,\n    ] = lookup;\n    return new LookupVerifierIndex(\n      MlBool.from(joint_lookup_used),\n      core.polyCommsToRust(lookup_table),\n      lookupSelectorsToRust(selectors),\n      MlOption.mapFrom(table_ids, core.polyCommToRust),\n      lookupInfoToRust(lookup_info),\n      MlOption.mapFrom(runtime_tables_selector, core.polyCommToRust)\n    );\n  }\n  function lookupVerifierIndexFromRust(lookup: WasmLookupVerifierIndex): Lookup<PolyComm> {\n    let mlLookup: Lookup<PolyComm> = [\n      0,\n      MlBool(lookup.joint_lookup_used),\n      core.polyCommsFromRust(lookup.lookup_table),\n      lookupSelectorsFromRust(lookup.lookup_selectors),\n      MlOption.mapTo(lookup.table_ids, core.polyCommFromRust),\n      lookupInfoFromRust(lookup.lookup_info),\n      MlOption.mapTo(lookup.runtime_tables_selector, core.polyCommFromRust),\n    ];\n    lookup.free();\n    return mlLookup;\n  }\n\n  function lookupSelectorsToRust([\n    ,\n    lookup,\n    xor,\n    range_check,\n    ffmul,\n  ]: LookupSelectors<PolyComm>): WasmLookupSelector {\n    return new LookupSelector(\n      MlOption.mapFrom(xor, core.polyCommToRust),\n      MlOption.mapFrom(lookup, core.polyCommToRust),\n      MlOption.mapFrom(range_check, core.polyCommToRust),\n      MlOption.mapFrom(ffmul, core.polyCommToRust)\n    );\n  }\n  function lookupSelectorsFromRust(selector: WasmLookupSelector): LookupSelectors<PolyComm> {\n    let lookup = MlOption.mapTo(selector.lookup, core.polyCommFromRust);\n    let xor = MlOption.mapTo(selector.xor, core.polyCommFromRust);\n    let range_check = MlOption.mapTo(selector.range_check, core.polyCommFromRust);\n    let ffmul = MlOption.mapTo(selector.ffmul, core.polyCommFromRust);\n    selector.free();\n    return [0, lookup, xor, range_check, ffmul];\n  }\n\n  function lookupInfoToRust([, maxPerRow, maxJointSize, features]: LookupInfo): WasmLookupInfo {\n    let [, patterns, joint_lookup_used, uses_runtime_tables] = features;\n    let [, xor, lookup, range_check, foreign_field_mul] = patterns;\n    let wasmPatterns = new wasm.LookupPatterns(\n      MlBool.from(xor),\n      MlBool.from(lookup),\n      MlBool.from(range_check),\n      MlBool.from(foreign_field_mul)\n    );\n    let wasmFeatures = new wasm.LookupFeatures(\n      wasmPatterns,\n      MlBool.from(joint_lookup_used),\n      MlBool.from(uses_runtime_tables)\n    );\n    return new wasm.LookupInfo(maxPerRow, maxJointSize, wasmFeatures);\n  }\n  function lookupInfoFromRust(info: WasmLookupInfo): LookupInfo {\n    let features = info.features;\n    let patterns = features.patterns;\n    let mlInfo: LookupInfo = [\n      0,\n      info.max_per_row,\n      info.max_joint_size,\n      [\n        0,\n        [\n          0,\n          MlBool(patterns.xor),\n          MlBool(patterns.lookup),\n          MlBool(patterns.range_check),\n          MlBool(patterns.foreign_field_mul),\n        ],\n        MlBool(features.joint_lookup_used),\n        MlBool(features.uses_runtime_tables),\n      ],\n    ];\n    info.free();\n    return mlInfo;\n  }\n\n  let self = {\n    shiftsToRust([, ...shifts]: MlArray<Field>): WasmShifts {\n      let s = shifts.map((s) => fieldToRust(s));\n      return new Shifts(s[0], s[1], s[2], s[3], s[4], s[5], s[6]);\n    },\n    shiftsFromRust(s: WasmShifts): MlArray<Field> {\n      let shifts = [s.s0, s.s1, s.s2, s.s3, s.s4, s.s5, s.s6];\n      s.free();\n      return [0, ...shifts.map(fieldFromRust)];\n    },\n\n    verifierIndexToRust(vk: VerifierIndex): WasmVerifierIndex {\n      let domain = domainToRust(vk[1]);\n      let maxPolySize = vk[2];\n      let nPublic = vk[3];\n      let prevChallenges = vk[4];\n      let srs = vk[5];\n      let evals = verificationEvalsToRust(vk[6]);\n      let shifts = self.shiftsToRust(vk[7]);\n      let lookupIndex = MlOption.mapFrom(vk[8], lookupVerifierIndexToRust);\n      let zkRows = vk[9];\n      return new VerifierIndex(\n        domain,\n        maxPolySize,\n        nPublic,\n        prevChallenges,\n        srs,\n        evals,\n        shifts,\n        lookupIndex,\n        zkRows\n      );\n    },\n    verifierIndexFromRust(vk: WasmVerifierIndex): VerifierIndex {\n      let mlVk: VerifierIndex = [\n        0,\n        domainFromRust(vk.domain),\n        vk.max_poly_size,\n        vk.public_,\n        vk.prev_challenges,\n        freeOnFinalize(vk.srs),\n        verificationEvalsFromRust(vk.evals),\n        self.shiftsFromRust(vk.shifts),\n        MlOption.mapTo(vk.lookup_index, lookupVerifierIndexFromRust),\n        vk.zk_rows,\n      ];\n      vk.free();\n      return mlVk;\n    },\n  };\n\n  return self;\n}\n", "import type {\n  WasmFpOracles,\n  WasmFpRandomOracles,\n  WasmFqOracles,\n  WasmFqRandomOracles,\n} from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport type * as wasmNamespace from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport { MlOption } from '../../../lib/ml/base.js';\nimport { Field, Oracles, RandomOracles, ScalarChallenge } from './kimchi-types.js';\nimport {\n  fieldFromRust,\n  fieldToRust,\n  fieldsFromRustFlat,\n  fieldsToRustFlat,\n  maybeFieldToRust,\n} from './conversion-base.js';\n\nexport { oraclesConversion };\n\ntype wasm = typeof wasmNamespace;\n\ntype WasmRandomOracles = WasmFpRandomOracles | WasmFqRandomOracles;\ntype WasmOracles = WasmFpOracles | WasmFqOracles;\n\ntype WasmClasses = {\n  RandomOracles: typeof WasmFpRandomOracles | typeof WasmFqRandomOracles;\n  Oracles: typeof WasmFpOracles | typeof WasmFqOracles;\n};\n\nfunction oraclesConversion(wasm: wasm) {\n  return {\n    fp: oraclesConversionPerField({\n      RandomOracles: wasm.WasmFpRandomOracles,\n      Oracles: wasm.WasmFpOracles,\n    }),\n    fq: oraclesConversionPerField({\n      RandomOracles: wasm.WasmFqRandomOracles,\n      Oracles: wasm.WasmFqOracles,\n    }),\n  };\n}\n\nfunction oraclesConversionPerField({ RandomOracles, Oracles }: WasmClasses) {\n  function randomOraclesToRust(ro: RandomOracles): WasmRandomOracles {\n    let jointCombinerMl = MlOption.from(ro[1]);\n    let jointCombinerChal = maybeFieldToRust(jointCombinerMl?.[1][1]);\n    let jointCombiner = maybeFieldToRust(jointCombinerMl?.[2]);\n    let beta = fieldToRust(ro[2]);\n    let gamma = fieldToRust(ro[3]);\n    let alphaChal = fieldToRust(ro[4][1]);\n    let alpha = fieldToRust(ro[5]);\n    let zeta = fieldToRust(ro[6]);\n    let v = fieldToRust(ro[7]);\n    let u = fieldToRust(ro[8]);\n    let zetaChal = fieldToRust(ro[9][1]);\n    let vChal = fieldToRust(ro[10][1]);\n    let uChal = fieldToRust(ro[11][1]);\n    return new RandomOracles(\n      jointCombinerChal,\n      jointCombiner,\n      beta,\n      gamma,\n      alphaChal,\n      alpha,\n      zeta,\n      v,\n      u,\n      zetaChal,\n      vChal,\n      uChal\n    );\n  }\n  function randomOraclesFromRust(ro: WasmRandomOracles): RandomOracles {\n    let jointCombinerChal = ro.joint_combiner_chal;\n    let jointCombiner = ro.joint_combiner;\n    let jointCombinerOption = MlOption<[0, ScalarChallenge, Field]>(\n      jointCombinerChal &&\n        jointCombiner && [0, [0, fieldFromRust(jointCombinerChal)], fieldFromRust(jointCombiner)]\n    );\n    let mlRo: RandomOracles = [\n      0,\n      jointCombinerOption,\n      fieldFromRust(ro.beta),\n      fieldFromRust(ro.gamma),\n      [0, fieldFromRust(ro.alpha_chal)],\n      fieldFromRust(ro.alpha),\n      fieldFromRust(ro.zeta),\n      fieldFromRust(ro.v),\n      fieldFromRust(ro.u),\n      [0, fieldFromRust(ro.zeta_chal)],\n      [0, fieldFromRust(ro.v_chal)],\n      [0, fieldFromRust(ro.u_chal)],\n    ];\n    // TODO: do we not want to free?\n    // ro.free();\n    return mlRo;\n  }\n\n  return {\n    oraclesToRust(oracles: Oracles): WasmOracles {\n      let [, o, pEval, openingPrechallenges, digestBeforeEvaluations] = oracles;\n      return new Oracles(\n        randomOraclesToRust(o),\n        fieldToRust(pEval[1]),\n        fieldToRust(pEval[2]),\n        fieldsToRustFlat(openingPrechallenges),\n        fieldToRust(digestBeforeEvaluations)\n      );\n    },\n    oraclesFromRust(oracles: WasmOracles): Oracles {\n      let mlOracles: Oracles = [\n        0,\n        randomOraclesFromRust(oracles.o),\n        [0, fieldFromRust(oracles.p_eval0), fieldFromRust(oracles.p_eval1)],\n        fieldsFromRustFlat(oracles.opening_prechallenges),\n        fieldFromRust(oracles.digest_before_evaluations),\n      ];\n      // TODO: do we not want to free?\n      // oracles.free();\n      return mlOracles;\n    },\n  };\n}\n", "export const jsEnvironment = 'node';\n", "import cachedir from 'cachedir';\n\nexport { writeFileSync, readFileSync, mkdirSync } from 'node:fs';\nexport { resolve } from 'node:path';\nexport { cachedir as cacheDir };\n", "import { writeFileSync, readFileSync, mkdirSync, resolve, cacheDir } from '../util/fs.js';\nimport { jsEnvironment } from '../../bindings/crypto/bindings/env.js';\n\n// external API\nexport { Cache, CacheHeader };\n\n// internal API\nexport { readCache, writeCache, withVersion, cacheHeaderVersion, LAGRANGE_BASIS_PREFIX };\n\n/**\n * Interface for storing and retrieving values, for caching.\n * `read()` and `write()` can just throw errors on failure.\n *\n * The data that will be passed to the cache for writing is exhaustively described by the {@link CacheHeader} type.\n * It represents one of the following:\n * - The SRS. This is a deterministic lists of curve points (one per curve) that needs to be generated just once,\n *   to be used for polynomial commitments.\n * - Lagrange basis commitments. Similar to the SRS, this will be created once for every power-of-2 circuit size.\n * - Prover and verifier keys for every compiled circuit.\n *\n * Per smart contract or ZkProgram, several different keys are created:\n * - a step prover key (`step-pk`) and verification key (`step-vk`) _for every method_.\n * - a wrap prover key (`wrap-pk`) and verification key (`wrap-vk`) for the entire contract.\n */\ntype Cache = {\n  /**\n   * Read a value from the cache.\n   *\n   * @param header A small header to identify what is read from the cache.\n   */\n  read(header: CacheHeader): Uint8Array | undefined;\n\n  /**\n   * Write a value to the cache.\n   *\n   * @param header A small header to identify what is written to the cache. This will be used by `read()` to retrieve the data.\n   * @param value The value to write to the cache, as a byte array.\n   */\n  write(header: CacheHeader, value: Uint8Array): void;\n\n  /**\n   * Indicates whether the cache is writable.\n   */\n  canWrite: boolean;\n\n  /**\n   * If `debug` is toggled, `read()` and `write()` errors are logged to the console.\n   *\n   * By default, cache errors are silent, because they don't necessarily represent an error condition,\n   * but could just be a cache miss, or file system permissions incompatible with writing data.\n   */\n  debug?: boolean;\n  /**\n   * The directory where cache files are stored. Only applicable for file system caches.\n   */\n  cacheDirectory?: string;\n};\n\nconst cacheHeaderVersion = 1;\n\ntype CommonHeader = {\n  /**\n   * Header version to avoid parsing incompatible headers.\n   */\n  version: number;\n  /**\n   * An identifier that is persistent even as versions of the data change. Safe to use as a file path.\n   */\n  persistentId: string;\n  /**\n   * A unique identifier for the data to be read. Safe to use as a file path.\n   */\n  uniqueId: string;\n  /**\n   * Specifies whether the data to be read is a utf8-encoded string or raw binary data. This was added\n   * because node's `fs.readFileSync` returns garbage when reading string files without specifying the encoding.\n   */\n  dataType: 'string' | 'bytes';\n};\n\ntype StepKeyHeader<Kind> = {\n  kind: Kind;\n  programName: string;\n  methodName: string;\n  methodIndex: number;\n  hash: string;\n};\ntype WrapKeyHeader<Kind> = { kind: Kind; programName: string; hash: string };\ntype PlainHeader<Kind> = { kind: Kind };\n\nconst LAGRANGE_BASIS_PREFIX = 'lagrange-basis' as const;\n\n/**\n * A header that is passed to the caching layer, to support rich caching strategies.\n *\n * Both `uniqueId` and `programId` can safely be used as a file path.\n */\ntype CacheHeader = (\n  | StepKeyHeader<'step-pk'>\n  | StepKeyHeader<'step-vk'>\n  | WrapKeyHeader<'wrap-pk'>\n  | WrapKeyHeader<'wrap-vk'>\n  | PlainHeader<'srs'>\n  | PlainHeader<typeof LAGRANGE_BASIS_PREFIX>\n) &\n  CommonHeader;\n\nfunction withVersion(\n  header: Omit<CacheHeader, 'version'>,\n  version = cacheHeaderVersion\n): CacheHeader {\n  let uniqueId = `${header.uniqueId}-${version}`;\n  return { ...header, version, uniqueId } as CacheHeader;\n}\n\n// default methods to interact with a cache\n\nfunction readCache(cache: Cache, header: CacheHeader): Uint8Array | undefined;\nfunction readCache<T>(\n  cache: Cache,\n  header: CacheHeader,\n  transform: (x: Uint8Array) => T\n): T | undefined;\nfunction readCache<T>(\n  cache: Cache,\n  header: CacheHeader,\n  transform?: (x: Uint8Array) => T\n): T | undefined {\n  try {\n    let result = cache.read(header);\n    if (result === undefined) {\n      if (cache.debug) console.trace('cache miss');\n      return undefined;\n    }\n    if (transform === undefined) return result as any as T;\n    return transform(result);\n  } catch (e) {\n    if (cache.debug) console.log('Failed to read cache', e);\n    return undefined;\n  }\n}\n\nfunction writeCache(cache: Cache, header: CacheHeader, value: Uint8Array) {\n  if (!cache.canWrite) return false;\n  try {\n    cache.write(header, value);\n    return true;\n  } catch (e) {\n    if (cache.debug) console.log('Failed to write cache', e);\n    return false;\n  }\n}\n\nconst None: Cache = {\n  read() {\n    throw Error('not available');\n  },\n  write() {\n    throw Error('not available');\n  },\n  canWrite: false,\n};\n\nconst FileSystem = (cacheDirectory: string, debug?: boolean): Cache => ({\n  read({ persistentId, uniqueId, dataType }) {\n    if (jsEnvironment !== 'node') throw Error('file system not available');\n\n    // read current uniqueId, return data if it matches\n    let currentId = readFileSync(resolve(cacheDirectory, `${persistentId}.header`), 'utf8');\n    if (currentId !== uniqueId) return undefined;\n\n    if (dataType === 'string') {\n      let string = readFileSync(resolve(cacheDirectory, persistentId), 'utf8');\n      return new TextEncoder().encode(string);\n    } else {\n      let buffer = readFileSync(resolve(cacheDirectory, persistentId));\n      return new Uint8Array(buffer.buffer);\n    }\n  },\n  write({ persistentId, uniqueId, dataType }, data) {\n    if (jsEnvironment !== 'node') throw Error('file system not available');\n    mkdirSync(cacheDirectory, { recursive: true });\n    writeFileSync(resolve(cacheDirectory, `${persistentId}.header`), uniqueId, {\n      encoding: 'utf8',\n    });\n    writeFileSync(resolve(cacheDirectory, persistentId), data, {\n      encoding: dataType === 'string' ? 'utf8' : undefined,\n    });\n  },\n  canWrite: jsEnvironment === 'node',\n  debug,\n  cacheDirectory\n});\n\nconst FileSystemDefault = FileSystem(cacheDir('o1js'));\n\nconst Cache = {\n  /**\n   * Store data on the file system, in a directory of your choice.\n   *\n   * Data will be stored in two files per cache entry: a data file and a `.header` file.\n   * The header file just contains a unique string which is used to determine whether we can use the cached data.\n   *\n   * Note: this {@link Cache} only caches data in Node.js.\n   */\n  FileSystem,\n  /**\n   * Store data on the file system, in a standard cache directory depending on the OS.\n   *\n   * Data will be stored in two files per cache entry: a data file and a `.header` file.\n   * The header file just contains a unique string which is used to determine whether we can use the cached data.\n   *\n   * Note: this {@link Cache} only caches data in Node.js.\n   */\n  FileSystemDefault,\n  /**\n   * Don't store anything.\n   */\n  None,\n};\n", "import type { Wasm, RustConversion } from '../bindings.js';\nimport { type WasmFpSrs, type WasmFqSrs } from '../../compiled/node_bindings/plonk_wasm.cjs';\nimport { PolyComm } from './kimchi-types.js';\nimport {\n  type CacheHeader,\n  type Cache,\n  withVersion,\n  writeCache,\n  readCache,\n} from '../../../lib/proof-system/cache.js';\nimport { assert } from '../../../lib/util/errors.js';\nimport { MlArray } from '../../../lib/ml/base.js';\nimport { OrInfinity, OrInfinityJson } from './curve.js';\n\nexport { srs, setSrsCache, unsetSrsCache };\n\ntype WasmSrs = WasmFpSrs | WasmFqSrs;\n\ntype SrsStore = Record<number, WasmSrs>;\n\nfunction empty(): SrsStore {\n  return {};\n}\n\nconst srsStore = { fp: empty(), fq: empty() };\n\nconst CacheReadRegister = new Map<string, boolean>();\n\nlet cache: Cache | undefined;\n\nfunction setSrsCache(c: Cache) {\n  cache = c;\n}\nfunction unsetSrsCache() {\n  cache = undefined;\n}\n\nconst srsVersion = 1;\n\nfunction cacheHeaderLagrange(f: 'fp' | 'fq', domainSize: number): CacheHeader {\n  let id = `lagrange-basis-${f}-${domainSize}`;\n  return withVersion(\n    {\n      kind: 'lagrange-basis',\n      persistentId: id,\n      uniqueId: id,\n      dataType: 'string',\n    },\n    srsVersion\n  );\n}\nfunction cacheHeaderSrs(f: 'fp' | 'fq', domainSize: number): CacheHeader {\n  let id = `srs-${f}-${domainSize}`;\n  return withVersion(\n    {\n      kind: 'srs',\n      persistentId: id,\n      uniqueId: id,\n      dataType: 'string',\n    },\n    srsVersion\n  );\n}\n\nfunction srs(wasm: Wasm, conversion: RustConversion) {\n  return {\n    fp: srsPerField('fp', wasm, conversion),\n    fq: srsPerField('fq', wasm, conversion),\n  };\n}\n\nfunction srsPerField(f: 'fp' | 'fq', wasm: Wasm, conversion: RustConversion) {\n  // note: these functions are properly typed, thanks to TS template literal types\n  let createSrs = (s: number) => wasm[`caml_${f}_srs_create_parallel`](s);\n  let getSrs = wasm[`caml_${f}_srs_get`];\n  let setSrs = wasm[`caml_${f}_srs_set`];\n\n  let maybeLagrangeCommitment = wasm[`caml_${f}_srs_maybe_lagrange_commitment`];\n  let lagrangeCommitment = (srs: WasmFpSrs, domain_size: number, i: number) =>\n    wasm[`caml_${f}_srs_lagrange_commitment`](srs, domain_size, i);\n  let lagrangeCommitmentsWholeDomainPtr = (srs: WasmSrs, domain_size: number) =>\n    wasm[`caml_${f}_srs_lagrange_commitments_whole_domain_ptr`](srs, domain_size);\n  let setLagrangeBasis = wasm[`caml_${f}_srs_set_lagrange_basis`];\n  let getLagrangeBasis = (srs: WasmSrs, n: number) =>\n    wasm[`caml_${f}_srs_get_lagrange_basis`](srs, n);\n  let getCommitmentsWholeDomainByPtr =\n    wasm[`caml_${f}_srs_lagrange_commitments_whole_domain_read_from_ptr`];\n  return {\n    /**\n     * returns existing stored SRS or falls back to creating a new one\n     */\n    create(size: number): WasmSrs {\n      let srs = srsStore[f][size] satisfies WasmSrs as WasmSrs | undefined;\n\n      if (srs === undefined) {\n        if (cache === undefined) {\n          // if there is no cache, create SRS in memory\n          srs = createSrs(size);\n        } else {\n          let header = cacheHeaderSrs(f, size);\n\n          // try to read SRS from cache / recompute and write if not found\n          srs = readCache(cache, header, (bytes) => {\n            // TODO: this takes a bit too long, about 300ms for 2^16\n            // `pointsToRust` is the clear bottleneck\n            let jsonSrs: OrInfinityJson[] = JSON.parse(new TextDecoder().decode(bytes));\n            let mlSrs = MlArray.mapTo(jsonSrs, OrInfinity.fromJSON);\n            let wasmSrs = conversion[f].pointsToRust(mlSrs);\n            return setSrs(wasmSrs);\n          });\n\n          if (srs === undefined) {\n            // not in cache\n            srs = createSrs(size);\n\n            if (cache.canWrite) {\n              let wasmSrs = getSrs(srs);\n              let mlSrs = conversion[f].pointsFromRust(wasmSrs);\n              let jsonSrs = MlArray.mapFrom(mlSrs, OrInfinity.toJSON);\n              let bytes = new TextEncoder().encode(JSON.stringify(jsonSrs));\n\n              writeCache(cache, header, bytes);\n            }\n          }\n        }\n\n        srsStore[f][size] = srs;\n      }\n\n      // TODO should we call freeOnFinalize() and expose a function to clean the SRS cache?\n      return srsStore[f][size];\n    },\n\n    /**\n     * returns ith Lagrange basis commitment for a given domain size\n     */\n    lagrangeCommitment(srs: WasmSrs, domainSize: number, i: number): PolyComm {\n      // happy, fast case: if basis is already stored on the srs, return the ith commitment\n      let commitment = maybeLagrangeCommitment(srs, domainSize, i);\n\n      if (commitment === undefined) {\n        if (cache === undefined) {\n          // if there is no cache, recompute and store basis in memory\n          commitment = lagrangeCommitment(srs, domainSize, i);\n        } else {\n          // try to read lagrange basis from cache / recompute and write if not found\n          let header = cacheHeaderLagrange(f, domainSize);\n          let didRead = readCacheLazy(\n            cache,\n            header,\n            conversion,\n            f,\n            srs,\n            domainSize,\n            setLagrangeBasis\n          );\n          if (didRead !== true) {\n            // not in cache\n            if (cache.canWrite) {\n              // TODO: this code path will throw on the web since `caml_${f}_srs_get_lagrange_basis` is not properly implemented\n              // using a writable cache in the browser seems to be fairly uncommon though, so it's at least an 80/20 solution\n              let wasmComms = getLagrangeBasis(srs, domainSize);\n              let mlComms = conversion[f].polyCommsFromRust(wasmComms);\n              let comms = polyCommsToJSON(mlComms);\n              let bytes = new TextEncoder().encode(JSON.stringify(comms));\n              writeCache(cache, header, bytes);\n            } else {\n              lagrangeCommitment(srs, domainSize, i);\n            }\n          }\n          // here, basis is definitely stored on the srs\n          let c = maybeLagrangeCommitment(srs, domainSize, i);\n          assert(c !== undefined, 'commitment exists after setting');\n          commitment = c;\n        }\n      }\n\n      // edge case for when we have a writeable cache and the basis was already stored on the srs\n      // but we didn't store it in the cache separately yet\n      if (commitment && cache && cache.canWrite) {\n        let header = cacheHeaderLagrange(f, domainSize);\n        let didRead = readCacheLazy(\n          cache,\n          header,\n          conversion,\n          f,\n          srs,\n          domainSize,\n          setLagrangeBasis\n        );\n        // only proceed for entries we haven't written to the cache yet\n        if (didRead !== true) {\n          // same code as above - write the lagrange basis to the cache if it wasn't there already\n          // currently we re-generate the basis via `getLagrangeBasis` - we could derive this from the\n          // already existing `commitment` instead, but this is simpler and the performance impact is negligible\n          let wasmComms = getLagrangeBasis(srs, domainSize);\n          let mlComms = conversion[f].polyCommsFromRust(wasmComms);\n          let comms = polyCommsToJSON(mlComms);\n          let bytes = new TextEncoder().encode(JSON.stringify(comms));\n\n          writeCache(cache, header, bytes);\n        }\n      }\n      return conversion[f].polyCommFromRust(commitment);\n    },\n\n    /**\n     * Returns the Lagrange basis commitments for the whole domain\n     */\n    lagrangeCommitmentsWholeDomain(srs: WasmSrs, domainSize: number) {\n      // instead of getting the entire commitment directly (which works for nodejs/servers), we get a pointer to the commitment\n      // and then read the commitment from the pointer\n      // this is because the web worker implementation currently does not support returning UintXArray's directly\n      // hence we return a pointer from wasm, funnel it through the web worker\n      // and then read the commitment from the pointer in the main thread (where UintXArray's are supported)\n      // see https://github.com/o1-labs/o1js-bindings/blob/09e17b45e0c2ca2b51cd9ed756106e17ca1cf36d/js/web/worker-spec.js#L110-L115\n      let ptr = lagrangeCommitmentsWholeDomainPtr(srs, domainSize);\n      let wasmComms = getCommitmentsWholeDomainByPtr(ptr);\n      let mlComms = conversion[f].polyCommsFromRust(wasmComms);\n      return mlComms;\n    },\n\n    /**\n     * adds Lagrange basis for a given domain size\n     */\n    addLagrangeBasis(srs: WasmSrs, logSize: number) {\n      // this ensures that basis is stored on the srs, no need to duplicate caching logic\n      this.lagrangeCommitment(srs, 1 << logSize, 0);\n    },\n  };\n}\n\ntype PolyCommJson = {\n  shifted: OrInfinityJson[];\n  unshifted: OrInfinityJson | undefined;\n};\n\nfunction polyCommsToJSON(comms: MlArray<PolyComm>): PolyCommJson[] {\n  return MlArray.mapFrom(comms, ([, elems]) => {\n    return {\n      shifted: MlArray.mapFrom(elems, OrInfinity.toJSON),\n      unshifted: undefined,\n    };\n  });\n}\n\nfunction polyCommsFromJSON(json: PolyCommJson[]): MlArray<PolyComm> {\n  return MlArray.mapTo(json, ({ shifted, unshifted }) => {\n    return [0, MlArray.mapTo(shifted, OrInfinity.fromJSON)];\n  });\n}\n\nfunction readCacheLazy(\n  cache: Cache,\n  header: CacheHeader,\n  conversion: RustConversion,\n  f: 'fp' | 'fq',\n  srs: WasmSrs,\n  domainSize: number,\n  setLagrangeBasis: (srs: WasmSrs, domainSize: number, comms: Uint32Array) => void\n) {\n  if (CacheReadRegister.get(header.uniqueId) === true) return true;\n  return readCache(cache, header, (bytes) => {\n    let comms: PolyCommJson[] = JSON.parse(new TextDecoder().decode(bytes));\n    let mlComms = polyCommsFromJSON(comms);\n    let wasmComms = conversion[f].polyCommsToRust(mlComms);\n\n    setLagrangeBasis(srs, domainSize, wasmComms);\n    CacheReadRegister.set(header.uniqueId, true);\n    return true;\n  });\n}\n", "/**\n * This file contains bindings for JSOO written in TS and integrated with our normal code base.\n * It is exposed to JSOO by populating a global variable with an object.\n * It gets imported as the first thing in ../../bindings.js so that the global variable is ready by the time JSOO code gets executed.\n */\nimport { prefixHashes, prefixHashesLegacy } from '../crypto/constants.js';\nimport { Bigint256Bindings } from './bindings/bigint256.js';\nimport { PallasBindings, VestaBindings } from './bindings/curve.js';\nimport { FpBindings, FqBindings } from './bindings/field.js';\nimport { FpVectorBindings, FqVectorBindings } from './bindings/vector.js';\nimport type * as wasmNamespace from '../compiled/node_bindings/plonk_wasm.cjs';\nimport { fieldsFromRustFlat, fieldsToRustFlat } from './bindings/conversion-base.js';\nimport { proofConversion } from './bindings/conversion-proof.js';\nimport { conversionCore } from './bindings/conversion-core.js';\nimport { verifierIndexConversion } from './bindings/conversion-verifier-index.js';\nimport { oraclesConversion } from './bindings/conversion-oracles.js';\nimport { jsEnvironment } from './bindings/env.js';\nimport { srs } from './bindings/srs.js';\n\nexport { getRustConversion, RustConversion, Wasm };\n\nconst tsBindings = {\n  jsEnvironment,\n  prefixHashes,\n  prefixHashesLegacy,\n  ...Bigint256Bindings,\n  ...FpBindings,\n  ...FqBindings,\n  ...VestaBindings,\n  ...PallasBindings,\n  ...FpVectorBindings,\n  ...FqVectorBindings,\n  rustConversion: createRustConversion,\n  srs: (wasm: Wasm) => srs(wasm, getRustConversion(wasm)),\n};\n\n// this is put in a global variable so that mina/src/lib/crypto/kimchi_bindings/js/bindings.js finds it\n(globalThis as any).__snarkyTsBindings = tsBindings;\n\ntype Wasm = typeof wasmNamespace;\n\nfunction createRustConversion(wasm: Wasm) {\n  let core = conversionCore(wasm);\n  let verifierIndex = verifierIndexConversion(wasm, core);\n  let oracles = oraclesConversion(wasm);\n  let proof = proofConversion(wasm, core);\n\n  return {\n    fp: { ...core.fp, ...verifierIndex.fp, ...oracles.fp, ...proof.fp },\n    fq: { ...core.fq, ...verifierIndex.fq, ...oracles.fq, ...proof.fq },\n    fieldsToRustFlat,\n    fieldsFromRustFlat,\n    wireToRust: core.wireToRust,\n    mapMlArrayToRustVector: core.mapMlArrayToRustVector,\n  };\n}\n\ntype RustConversion = ReturnType<typeof createRustConversion>;\n\nlet rustConversion: RustConversion | undefined;\n\nfunction getRustConversion(wasm: Wasm) {\n  return rustConversion ?? (rustConversion = createRustConversion(wasm));\n}\n", "import os from 'os';\nimport { fileURLToPath } from 'url';\nimport { Worker, isMainThread, parentPort, workerData } from 'worker_threads';\nimport { WithThreadPool, workers } from '../../../lib/proof-system/workers.js';\nimport wasm_ from '../../compiled/node_bindings/plonk_wasm.cjs';\nlet url = import.meta.url;\nlet filename = url !== undefined ? fileURLToPath(url) : __filename;\n\n/**\n * @type {import(\"../../compiled/node_bindings/plonk_wasm.cjs\")}\n */\nconst wasm = wasm_;\n\nexport { wasm, withThreadPool };\n\nlet workersReadyResolve;\nlet workersReady;\n\n// expose this globally so that it can be referenced from wasm\nglobalThis.startWorkers = startWorkers;\nglobalThis.terminateWorkers = terminateWorkers;\n\nif (!isMainThread) {\n  parentPort.postMessage({ type: 'wasm_bindgen_worker_ready' });\n  wasm.wbg_rayon_start_worker(workerData.receiver);\n}\n\n// state machine to enable calling multiple functions that need a thread pool at once\nconst withThreadPool = WithThreadPool({ initThreadPool, exitThreadPool });\n\nasync function initThreadPool() {\n  if (!isMainThread) return;\n  workersReady = new Promise((resolve) => (workersReadyResolve = resolve));\n  await wasm.initThreadPool(\n    Math.max(1, workers.numWorkers ?? (os.availableParallelism() ?? 1) - 1),\n    filename\n  );\n  await workersReady;\n  workersReady = undefined;\n}\n\nasync function exitThreadPool() {\n  if (!isMainThread) return;\n  await wasm.exitThreadPool();\n}\n\n/**\n * @type {Worker[]}\n */\nlet wasmWorkers = [];\n\nasync function startWorkers(src, memory, builder) {\n  wasmWorkers = [];\n  await Promise.all(\n    Array.from({ length: builder.numThreads() }, () => {\n      let worker = new Worker(src, {\n        workerData: { memory, receiver: builder.receiver() },\n      });\n      wasmWorkers.push(worker);\n      let target = worker;\n      let type = 'wasm_bindgen_worker_ready';\n      return new Promise((resolve) => {\n        let done = false;\n        target.on('message', function onMsg(data) {\n          if (data == null || data.type !== type || done) return;\n          done = true;\n          resolve(worker);\n        });\n      });\n    })\n  );\n  builder.build();\n  workersReadyResolve();\n}\n\nasync function terminateWorkers() {\n  return Promise.all(wasmWorkers.map((w) => w.terminate())).then(() => (wasmWorkers = undefined));\n}\n", "export { workers, setNumberOfWorkers, WithThreadPool };\n\nconst workers = {\n  numWorkers: undefined as number | undefined,\n};\n\n/**\n * Set the number of workers to use for parallelizing the proof generation. By default the number of workers is set to the number of physical CPU cores on your machine, but there may be some instances where you want to set the number of workers manually. Some machines may have a large number of cores, but not enough memory to support that many workers. In that case, you can set the number of workers to a lower number to avoid running out of memory. On the other hand, some machines with heterogeneous cores may benefit from setting the number of workers to a lower number to avoid contention between core types if load-link/store-conditional multithreading is used. Feel free to experiment and see what works best for your use case. Maybe you can squeeze slightly more performance out by tweaking this value :)\n\n * @example\n * ```typescript\n * setNumberOfWorkers(2); // set the number of workers to 2\n * ```\n */\nconst setNumberOfWorkers = (numWorkers: number) => {\n  workers.numWorkers = numWorkers;\n};\n\ntype ThreadPoolState =\n  | { type: 'none' }\n  | { type: 'initializing'; initPromise: Promise<void> }\n  | { type: 'running' }\n  | { type: 'exiting'; exitPromise: Promise<void> };\n\nfunction WithThreadPool({\n  initThreadPool,\n  exitThreadPool,\n}: {\n  initThreadPool: () => Promise<void>;\n  exitThreadPool: () => Promise<void>;\n}) {\n  // state machine to enable calling multiple functions that need a thread pool at once\n  let state: ThreadPoolState = { type: 'none' };\n  let isNeededBy = 0;\n\n  return async function withThreadPool<T>(run: () => Promise<T>): Promise<T> {\n    isNeededBy++;\n    // none, exiting -> initializing\n    switch (state.type) {\n      case 'none': {\n        let initPromise = initThreadPool();\n        state = { type: 'initializing', initPromise };\n        break;\n      }\n      case 'initializing':\n      case 'running':\n        break;\n      case 'exiting': {\n        let initPromise = state.exitPromise.then(initThreadPool);\n        state = { type: 'initializing', initPromise };\n        break;\n      }\n    }\n    // initializing -> running\n    if (state.type === 'initializing') await state.initPromise;\n    state = { type: 'running' };\n\n    let result: T;\n    try {\n      result = await run();\n    } finally {\n      // running -> exiting IF we don't need to run longer\n      isNeededBy--;\n\n      if (state.type !== 'running') {\n        throw Error('bug in ThreadPool state machine');\n      }\n\n      if (isNeededBy < 1) {\n        let exitPromise = exitThreadPool();\n        state = { type: 'exiting', exitPromise };\n\n        // exiting -> none IF we didn't move exiting -> initializing\n        await exitPromise;\n        if (state.type === 'exiting') {\n          state = { type: 'none' };\n        }\n      }\n    }\n    return result;\n  };\n}\n", "import './bindings/crypto/bindings.js';\nimport { wasm, withThreadPool } from './bindings/js/node/node-backend.js';\n\nlet Snarky, Ledger, Pickles, Test_;\nlet isInitialized = false;\nlet initializingPromise;\n\nasync function initializeBindings() {\n  if (isInitialized) return;\n  if (initializingPromise) {\n    await initializingPromise;\n    return;\n  }\n  let snarky;\n  let resolve;\n  initializingPromise = new Promise((r) => (resolve = r));\n\n  // this dynamic import makes jest respect the import order\n  // otherwise the cjs file gets imported before its implicit esm dependencies and fails\n  CJS: if (typeof require !== 'undefined') {\n    snarky = require('./bindings/compiled/node_bindings/o1js_node.bc.cjs');\n  }\n  ESM: snarky = (await import('./bindings/compiled/node_bindings/o1js_node.bc.cjs')).default;\n  ({ Snarky, Ledger, Pickles, Test: Test_ } = snarky);\n  resolve();\n  initializingPromise = undefined;\n  isInitialized = true;\n}\n\nasync function Test() {\n  await initializeBindings();\n  return Test_;\n}\n\nexport {\n  isInitialized as areBindingsInitialized,\n  initializeBindings, Ledger,\n  Pickles,\n  Snarky,\n  Test, wasm,\n  withThreadPool\n};\n\n", "import {\n  GenericHashInput,\n  GenericProvable,\n  GenericProvablePure,\n  GenericProvableExtended,\n  GenericProvableExtendedPure,\n  GenericSignable,\n} from './generic.js';\n\nexport {\n  createDerivers,\n  createHashInput,\n  ProvableConstructor,\n  SignableConstructor,\n  NonMethods,\n  InferProvable,\n  InferJson,\n  InferValue,\n  InferredProvable,\n  IsPure,\n  From,\n  Constructor,\n  NestedProvable,\n  InferProvableNested,\n  InferJsonNested,\n  InferValueNested,\n};\n\ntype ProvableConstructor<Field> = <A>(\n  typeObj: A,\n  /**\n   * @deprecated\n   */\n  options?: { isPure?: boolean }\n) => InferredProvable<A, Field>;\ntype SignableConstructor<Field> = <A>(typeObj: A) => InferredSignable<A, Field>;\n\nlet complexTypes = new Set(['object', 'function']);\nlet primitives = new Set([Number, String, Boolean, BigInt, null, undefined]);\n\nfunction createDerivers<Field>(): {\n  provable: ProvableConstructor<Field>;\n  signable: SignableConstructor<Field>;\n} {\n  type Signable<T, TJson = JSONValue> = GenericSignable<T, TJson, Field>;\n  type ProvableExtended<T, TValue = any, TJson = JSONValue> = GenericProvableExtended<\n    T,\n    TValue,\n    TJson,\n    Field\n  >;\n  type HashInput = GenericHashInput<Field>;\n  const HashInput = createHashInput<Field>();\n\n  /**\n   * A function that gives us a hint that the input type is a `Provable` and we shouldn't continue\n   * recursing into its properties, when computing methods that aren't required by the `Provable` interface.\n   */\n  function isProvable(typeObj: object): typeObj is GenericProvable<any, any, Field> {\n    return (\n      'sizeInFields' in typeObj &&\n      'toFields' in typeObj &&\n      'fromFields' in typeObj &&\n      'check' in typeObj &&\n      'toValue' in typeObj &&\n      'fromValue' in typeObj &&\n      'toAuxiliary' in typeObj\n    );\n  }\n\n  /**\n   * Accepts objects of the form { provable: Provable }\n   */\n  function hasProvable(typeObj: object): typeObj is { provable: GenericProvable<any, any, Field> } {\n    return (\n      'provable' in typeObj &&\n      (typeof typeObj.provable === 'object' || typeof typeObj.provable === 'function') &&\n      typeObj.provable !== null &&\n      isProvable(typeObj.provable)\n    );\n  }\n\n  function provable<A>(typeObj: A): InferredProvable<A, Field> {\n    type T = InferProvable<A, Field>;\n    type V = InferValue<A>;\n    type J = InferJson<A>;\n\n    if (!isPrimitive(typeObj) && !complexTypes.has(typeof typeObj)) {\n      throw Error(`provable: unsupported type \"${typeObj}\"`);\n    }\n\n    function sizeInFields(typeObj: NestedProvable<Field>): number {\n      if (isPrimitive(typeObj)) return 0;\n\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj)) return typeObj.provable.sizeInFields();\n\n      if (Array.isArray(typeObj)) return typeObj.map(sizeInFields).reduce((a, b) => a + b, 0);\n\n      if (isProvable(typeObj)) return typeObj.sizeInFields();\n\n      return Object.values(typeObj)\n        .map(sizeInFields)\n        .reduce((a, b) => a + b, 0);\n    }\n\n    function toFields(typeObj: NestedProvable<Field>, obj: any): Field[] {\n      if (isPrimitive(typeObj)) return [];\n\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj)) return typeObj.provable.toFields(obj);\n\n      if (Array.isArray(typeObj)) {\n        if (!Array.isArray(obj)) {\n          if (typeof obj === 'object') {\n            return typeObj.map((t, i) => toFields(t, obj[i])).flat();\n          }\n          throw Error(`Expected an array for type, but got ${typeof obj}`);\n        }\n        if (typeObj.length !== obj.length) {\n          throw Error(`Expected array length ${typeObj.length}, but got ${obj.length}`);\n        }\n        return typeObj.map((t, i) => toFields(t, obj[i])).flat();\n      }\n\n      if (isProvable(typeObj)) return typeObj.toFields(obj);\n\n      return Object.keys(typeObj)\n        .map((k) => toFields(typeObj[k], obj[k]))\n        .flat();\n    }\n\n    function toAuxiliary(typeObj: NestedProvable<Field>, obj?: any): any[] {\n      if (typeObj === Number) return [obj ?? 0];\n      if (typeObj === String) return [obj ?? ''];\n      if (typeObj === Boolean) return [obj ?? false];\n      if (typeObj === BigInt) return [obj ?? 0n];\n      if (typeObj === undefined || typeObj === null) return [];\n\n      if (isPrimitive(typeObj) || !complexTypes.has(typeof typeObj))\n        throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj)) return typeObj.provable.toAuxiliary(obj);\n\n      if (Array.isArray(typeObj)) return typeObj.map((t, i) => toAuxiliary(t, obj?.[i]));\n\n      if (isProvable(typeObj)) return typeObj.toAuxiliary(obj);\n\n      return Object.keys(typeObj).map((k) => toAuxiliary(typeObj[k], obj?.[k]));\n    }\n\n    function fromFields(typeObj: NestedProvable<Field>, fields: Field[], aux: any[] = []): any {\n      if (typeObj === Number || typeObj === String || typeObj === Boolean || typeObj === BigInt)\n        return aux[0];\n      if (typeObj === undefined || typeObj === null) return typeObj;\n\n      if (isPrimitive(typeObj) || !complexTypes.has(typeof typeObj))\n        throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj)) return typeObj.provable.fromFields(fields, aux);\n\n      if (Array.isArray(typeObj)) {\n        let array: any[] = [];\n        let i = 0;\n        let offset = 0;\n        for (let subObj of typeObj) {\n          let size = sizeInFields(subObj);\n          array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i]));\n          offset += size;\n          i++;\n        }\n        return array;\n      }\n\n      if (isProvable(typeObj)) return typeObj.fromFields(fields, aux);\n\n      let keys = Object.keys(typeObj);\n      let values = fromFields(\n        keys.map((k) => typeObj[k]),\n        fields,\n        aux\n      );\n      return Object.fromEntries(keys.map((k, i) => [k, values[i]]));\n    }\n\n    function check(typeObj: NestedProvable<Field>, obj: any): void {\n      if (isPrimitive(typeObj)) return;\n\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj)) return typeObj.provable.check(obj);\n\n      if (Array.isArray(typeObj)) return typeObj.forEach((t, i) => check(t, obj[i]));\n\n      if (isProvable(typeObj)) return typeObj.check(obj);\n\n      if (display(typeObj) === 'Struct') {\n        throw new Error(\n          `provable: cannot run check() on 'Struct' type. ` +\n            `Instead of using 'Struct' directly, extend 'Struct' to create a specific type.\\n\\n` +\n            `Example:\\n` +\n            `// Incorrect Usage:\\n` +\n            `class MyStruct extends Struct({\\n` +\n            `  fieldA: Struct, // This is incorrect\\n` +\n            `}) {}\\n\\n` +\n            `// Correct Usage:\\n` +\n            `class MyStruct extends Struct({\\n` +\n            `  fieldA: MySpecificStruct, // Use the specific struct type\\n` +\n            `}) {}\\n`\n        );\n      }\n\n      if (typeof typeObj === 'function') {\n        throw new Error(\n          `provable: invalid type detected. Functions are not supported as types. ` +\n            `Ensure you are passing an instance of a supported type or an anonymous object.\\n`\n        );\n      }\n\n      // Only recurse into the object if it's an object and not a function\n      return Object.keys(typeObj).forEach((k) => check(typeObj[k], obj[k]));\n    }\n\n    function toCanonical(typeObj: NestedProvable<Field>, value: any): any {\n      if (isPrimitive(typeObj)) return value;\n\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj)) return typeObj.provable.toCanonical?.(value) ?? value;\n\n      if (Array.isArray(typeObj)) {\n        return typeObj.forEach((t, i) => toCanonical(t, value[i]));\n      }\n\n      if (isProvable(typeObj)) return typeObj.toCanonical?.(value) ?? value;\n\n      return Object.fromEntries(\n        Object.keys(typeObj).map((k) => {\n          return [k, toCanonical(typeObj[k], value[k])];\n        })\n      );\n    }\n\n    const toValue = createMap('toValue');\n    const fromValue = createMap('fromValue');\n\n    let { empty, fromJSON, toJSON, toInput } = signable(\n      typeObj,\n      // if one of these is true, we don't want to continue searching for 'signable' methods\n      (obj) => isProvable(obj) || hasProvable(obj)\n    );\n\n    type S = InferSignable<A, Field>;\n\n    const type = typeObj as NestedProvable<Field>;\n\n    return {\n      sizeInFields: () => sizeInFields(type),\n      toFields: (obj: T) => toFields(type, obj),\n      toAuxiliary: (obj?: T) => toAuxiliary(type, obj),\n      fromFields: (fields: Field[], aux: any[]) => fromFields(type, fields, aux) as T,\n      check: (obj: T) => check(type, obj),\n      toValue(x) {\n        return toValue(type, x);\n      },\n      fromValue(v) {\n        return fromValue(type, v);\n      },\n      toCanonical(x) {\n        return toCanonical(type, x);\n      },\n      toInput: (obj: T) => toInput(obj as S),\n      toJSON: (obj: T) => toJSON(obj as S) satisfies J,\n      fromJSON: (json: J) => fromJSON(json) as T,\n      empty: () => empty() as T,\n    } satisfies ProvableExtended<T, V, J> as InferredProvable<A, Field>;\n  }\n\n  function signable<A>(\n    typeObj: A,\n    shouldTerminate?: (typeObj: object) => boolean\n  ): InferredSignable<A, Field> {\n    type T = InferSignable<A, Field>;\n    type J = InferJson<A>;\n    let objectKeys = typeof typeObj === 'object' && typeObj !== null ? Object.keys(typeObj) : [];\n    let primitives = new Set([Number, String, Boolean, BigInt, null, undefined]);\n    if (!primitives.has(typeObj as any) && !complexTypes.has(typeof typeObj)) {\n      throw Error(`provable: unsupported type \"${typeObj}\"`);\n    }\n\n    function toInput(typeObj: any, obj: any): HashInput {\n      if (primitives.has(typeObj)) return {};\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if ('provable' in typeObj) return toInput(typeObj.provable, obj);\n\n      if (Array.isArray(typeObj)) {\n        return typeObj.map((t, i) => toInput(t, obj[i])).reduce(HashInput.append, HashInput.empty);\n      }\n      if ('toInput' in typeObj) return typeObj.toInput(obj) as HashInput;\n      if ('toFields' in typeObj) {\n        return { fields: typeObj.toFields(obj) };\n      }\n      return Object.keys(typeObj)\n        .map((k) => toInput(typeObj[k], obj[k]))\n        .reduce(HashInput.append, HashInput.empty);\n    }\n    function toJSON(typeObj: any, obj: any): JSONValue {\n      if (typeObj === BigInt) return obj.toString();\n      if (typeObj === String || typeObj === Number || typeObj === Boolean) return obj;\n      if (typeObj === undefined || typeObj === null) return null;\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if ('provable' in typeObj) return toJSON(typeObj.provable, obj);\n\n      if (Array.isArray(typeObj)) return typeObj.map((t, i) => toJSON(t, obj[i]));\n      if ('toJSON' in typeObj) return typeObj.toJSON(obj);\n\n      if (shouldTerminate?.(typeObj) === true) {\n        throw Error(`Expected \\`toJSON()\\` method on ${display(typeObj)}`);\n      }\n\n      return Object.fromEntries(Object.keys(typeObj).map((k) => [k, toJSON(typeObj[k], obj[k])]));\n    }\n\n    function fromJSON(typeObj: any, json: any): any {\n      if (typeObj === BigInt) return BigInt(json as string);\n      if (typeObj === String || typeObj === Number || typeObj === Boolean) return json;\n      if (typeObj === null || typeObj === undefined) return undefined;\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if ('provable' in typeObj) return fromJSON(typeObj.provable, json);\n\n      if (Array.isArray(typeObj)) return typeObj.map((t, i) => fromJSON(t, json[i]));\n      if ('fromJSON' in typeObj) return typeObj.fromJSON(json);\n\n      if (shouldTerminate?.(typeObj) === true) {\n        throw Error(`Expected \\`fromJSON()\\` method on ${display(typeObj)}`);\n      }\n\n      let keys = Object.keys(typeObj);\n      let values = fromJSON(\n        keys.map((k) => typeObj[k]),\n        keys.map((k) => json[k])\n      );\n      return Object.fromEntries(keys.map((k, i) => [k, values[i]]));\n    }\n\n    function empty(typeObj: any): any {\n      if (typeObj === Number) return 0;\n      if (typeObj === String) return '';\n      if (typeObj === Boolean) return false;\n      if (typeObj === BigInt) return 0n;\n      if (typeObj === null || typeObj === undefined) return typeObj;\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if ('provable' in typeObj) return empty(typeObj.provable);\n\n      if (Array.isArray(typeObj)) return typeObj.map(empty);\n      if ('empty' in typeObj) return typeObj.empty();\n\n      if (shouldTerminate?.(typeObj) === true) {\n        throw Error(`Expected \\`empty()\\` method on ${display(typeObj)}`);\n      }\n\n      return Object.fromEntries(Object.keys(typeObj).map((k) => [k, empty(typeObj[k])]));\n    }\n\n    return {\n      toInput: (obj: T) => toInput(typeObj, obj),\n      toJSON: (obj: T) => toJSON(typeObj, obj) as J,\n      fromJSON: (json: J) => fromJSON(typeObj, json),\n      empty: () => empty(typeObj) as T,\n    } satisfies Signable<T, J> as InferredSignable<A, Field>;\n  }\n\n  function display(typeObj: object) {\n    if ('name' in typeObj) return typeObj.name;\n    return 'anonymous type object';\n  }\n\n  function createMap<S extends string>(name: S) {\n    function map(typeObj: any, obj: any): any {\n      if (primitives.has(typeObj)) return obj;\n      if (!complexTypes.has(typeof typeObj)) throw Error(`provable: unsupported type \"${typeObj}\"`);\n\n      if (hasProvable(typeObj) && name in typeObj.provable)\n        return (typeObj.provable as any)[name](obj);\n\n      if (Array.isArray(typeObj)) return typeObj.map((t, i) => map(t, obj[i]));\n      if (name in typeObj) return typeObj[name](obj);\n      return Object.fromEntries(Object.keys(typeObj).map((k) => [k, map(typeObj[k], obj[k])]));\n    }\n    return map;\n  }\n\n  return { provable, signable };\n}\n\nfunction isPrimitive(typeObj: any): typeObj is Primitive {\n  return primitives.has(typeObj);\n}\n\nfunction createHashInput<Field>() {\n  type HashInput = GenericHashInput<Field>;\n  return {\n    get empty() {\n      return {};\n    },\n    append(input1: HashInput, input2: HashInput): HashInput {\n      return {\n        fields: (input1.fields ?? []).concat(input2.fields ?? []),\n        packed: (input1.packed ?? []).concat(input2.packed ?? []),\n      };\n    },\n  };\n}\n\n// some type inference helpers\n\ntype JSONValue = number | string | boolean | null | Array<JSONValue> | { [key: string]: JSONValue };\n\ntype Struct<T, Field> = GenericProvableExtended<NonMethods<T>, any, any, Field> &\n  Constructor<T> & { _isStruct: true };\n\ntype NonMethodKeys<T> = {\n  [K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];\ntype NonMethods<T> = Pick<T, NonMethodKeys<T>>;\n\ntype Constructor<T> = new (...args: any) => T;\n\ntype Tuple<T> = [T, ...T[]] | [];\n\ntype Primitive = typeof String | typeof Number | typeof Boolean | typeof BigInt | null | undefined;\ntype InferPrimitive<P extends Primitive> = P extends typeof String\n  ? string\n  : P extends typeof Number\n    ? number\n    : P extends typeof Boolean\n      ? boolean\n      : P extends typeof BigInt\n        ? bigint\n        : P extends null\n          ? null\n          : P extends undefined\n            ? undefined\n            : any;\n\ntype InferPrimitiveValue<P extends Primitive> = P extends typeof String\n  ? string\n  : P extends typeof Number\n    ? number\n    : P extends typeof Boolean\n      ? boolean\n      : P extends typeof BigInt\n        ? bigint\n        : P extends null\n          ? null\n          : P extends undefined\n            ? undefined\n            : any;\n\ntype InferPrimitiveJson<P extends Primitive> = P extends typeof String\n  ? string\n  : P extends typeof Number\n    ? number\n    : P extends typeof Boolean\n      ? boolean\n      : P extends typeof BigInt\n        ? string\n        : P extends null\n          ? null\n          : P extends undefined\n            ? null\n            : any;\n\ntype NestedProvable<Field> =\n  | Primitive\n  | { provable: GenericProvable<any, any, Field> }\n  | GenericProvable<any, any, Field>\n  | [NestedProvable<Field>, ...NestedProvable<Field>[]]\n  | NestedProvable<Field>[]\n  | { [key: string]: NestedProvable<Field> };\n\ntype InferProvable<A, Field> = A extends { provable: Constructor<infer U> }\n  ? A extends { provable: GenericProvable<U, any, Field> }\n    ? U\n    : A extends { provable: Struct<U, Field> }\n      ? U\n      : InferProvableBase<A, Field>\n  : A extends Constructor<infer U>\n    ? A extends GenericProvable<U, any, Field>\n      ? U\n      : A extends Struct<U, Field>\n        ? U\n        : InferProvableBase<A, Field>\n    : InferProvableBase<A, Field>;\n\ntype InferProvableBase<A, Field> = A extends {\n  provable: GenericProvable<infer U, any, Field>;\n}\n  ? U\n  : A extends GenericProvable<infer U, any, Field>\n    ? U\n    : A extends Primitive\n      ? InferPrimitive<A>\n      : A extends Tuple<any>\n        ? {\n            [I in keyof A]: InferProvable<A[I], Field>;\n          }\n        : A extends (infer U)[]\n          ? InferProvable<U, Field>[]\n          : A extends Record<any, any>\n            ? {\n                [K in keyof A]: InferProvable<A[K], Field>;\n              }\n            : never;\n\ntype InferValue<A> = A extends { provable: GenericProvable<any, infer U, any> }\n  ? U\n  : A extends GenericProvable<any, infer U, any>\n    ? U\n    : A extends Primitive\n      ? InferPrimitiveValue<A>\n      : A extends Tuple<any>\n        ? {\n            [I in keyof A]: InferValue<A[I]>;\n          }\n        : A extends (infer U)[]\n          ? InferValue<U>[]\n          : A extends Record<any, any>\n            ? {\n                [K in keyof A]: InferValue<A[K]>;\n              }\n            : never;\n\ntype WithJson<J> = { toJSON: (x: any) => J };\n\ntype InferJson<A> = A extends { provable: WithJson<infer J> }\n  ? J\n  : A extends WithJson<infer J>\n    ? J\n    : A extends Primitive\n      ? InferPrimitiveJson<A>\n      : A extends Tuple<any>\n        ? {\n            [I in keyof A]: InferJson<A[I]>;\n          }\n        : A extends (infer U)[]\n          ? InferJson<U>[]\n          : A extends Record<any, any>\n            ? {\n                [K in keyof A]: InferJson<A[K]>;\n              }\n            : JSONValue;\n\ntype IsPure<A, Field> = IsPureBase<A, Field> extends true ? true : false;\n\ntype IsPureBase<A, Field> = A extends {\n  provable: GenericProvablePure<any, any, Field>;\n}\n  ? true\n  : A extends GenericProvablePure<any, any, Field>\n    ? true\n    : A extends { provable: GenericProvable<any, any, Field> }\n      ? false\n      : A extends GenericProvable<any, any, Field>\n        ? false\n        : A extends Primitive\n          ? false\n          : A extends (infer U)[]\n            ? IsPure<U, Field>\n            : A extends Record<any, any>\n              ? {\n                  [K in keyof A]: IsPure<A[K], Field>;\n                }[keyof A]\n              : false;\n\ntype InferredProvable<A, Field> =\n  IsPure<A, Field> extends true\n    ? GenericProvableExtendedPure<InferProvable<A, Field>, InferValue<A>, InferJson<A>, Field>\n    : GenericProvableExtended<InferProvable<A, Field>, InferValue<A>, InferJson<A>, Field>;\n\n// signable\n\ntype InferSignable<A, Field> = A extends {\n  provable: GenericSignable<infer U, any, Field>;\n}\n  ? U\n  : A extends GenericSignable<infer U, any, Field>\n    ? U\n    : A extends Primitive\n      ? InferPrimitive<A>\n      : A extends Tuple<any>\n        ? {\n            [I in keyof A]: InferSignable<A[I], Field>;\n          }\n        : A extends (infer U)[]\n          ? InferSignable<U, Field>[]\n          : A extends Record<any, any>\n            ? {\n                [K in keyof A]: InferSignable<A[K], Field>;\n              }\n            : never;\n\ntype InferredSignable<A, Field> = GenericSignable<InferSignable<A, Field>, InferJson<A>, Field>;\n\n// deep union type for flexible fromValue\n\ntype From<A> = A extends {\n  provable: {\n    fromValue: (x: infer U) => any;\n  } & GenericProvable<any, any, any>;\n}\n  ? U | InferProvable<A, any>\n  : A extends {\n        fromValue: (x: infer U) => any;\n      } & GenericProvable<any, any, any>\n    ? U | InferProvable<A, any>\n    : A extends GenericProvable<any, any, any>\n      ? InferProvable<A, any> | InferValue<A>\n      : A extends Primitive\n        ? InferPrimitiveValue<A>\n        : A extends Tuple<any>\n          ? {\n              [I in keyof A]: From<A[I]>;\n            }\n          : A extends (infer U)[]\n            ? From<U>[]\n            : A extends Record<any, any>\n              ? {\n                  [K in keyof A]: From<A[K]>;\n                }\n              : never;\n\n// nested\n\ntype InferProvableNested<Field, A extends NestedProvable<Field>> = A extends Primitive\n  ? InferPrimitive<A>\n  : A extends { provable: GenericProvable<infer P, any, any> }\n    ? P\n    : A extends GenericProvable<infer P, any, any>\n      ? P\n      : A extends [NestedProvable<Field>, ...NestedProvable<Field>[]]\n        ? {\n            [I in keyof A & number]: InferProvableNested<Field, A[I]>;\n          }\n        : A extends (infer U extends NestedProvable<Field>)[]\n          ? InferProvableNested<Field, U>[]\n          : A extends Record<string, NestedProvable<Field>>\n            ? {\n                [K in keyof A]: InferProvableNested<Field, A[K]>;\n              }\n            : never;\n\ntype InferValueNested<Field, A extends NestedProvable<Field>> = A extends Primitive\n  ? InferPrimitiveValue<A>\n  : A extends { provable: GenericProvable<any, infer U, any> }\n    ? U\n    : A extends GenericProvable<any, infer U, any>\n      ? U\n      : A extends [NestedProvable<Field>, ...NestedProvable<Field>[]]\n        ? {\n            [I in keyof A & number]: InferValueNested<Field, A[I]>;\n          }\n        : A extends (infer U extends NestedProvable<Field>)[]\n          ? InferValueNested<Field, U>[]\n          : A extends Record<string, NestedProvable<Field>>\n            ? {\n                [K in keyof A]: InferValueNested<Field, A[K]>;\n              }\n            : never;\n\ntype InferJsonNested<Field, A extends NestedProvable<Field>> = A extends Primitive\n  ? InferPrimitiveJson<A>\n  : A extends { provable: GenericProvable<any, any, Field> }\n    ? A['provable'] extends WithJson<infer J>\n      ? J\n      : never\n    : A extends GenericProvable<any, any, Field>\n      ? A extends WithJson<infer J>\n        ? J\n        : never\n      : A extends [NestedProvable<Field>, ...NestedProvable<Field>[]]\n        ? {\n            [I in keyof A & number]: InferJsonNested<Field, A[I]>;\n          }\n        : A extends (infer U extends NestedProvable<Field>)[]\n          ? InferJsonNested<Field, U>[]\n          : A extends Record<string, NestedProvable<Field>>\n            ? {\n                [K in keyof A]: InferJsonNested<Field, A[K]>;\n              }\n            : never;\n", "export {\n  Integer,\n  NonNegativeInteger,\n  PositiveInteger,\n  isInteger,\n  isNonNegativeInteger,\n  isPositiveInteger,\n  assertInteger,\n  assertNonNegativeInteger,\n  assertPositiveInteger,\n  asInteger,\n  asNonNegativeInteger,\n  asPositiveInteger,\n};\n\nfunction asInteger<N extends number>(n: Integer<N>) {\n  return n;\n}\nfunction asNonNegativeInteger<N extends number>(n: NonNegativeInteger<N>) {\n  return n;\n}\nfunction asPositiveInteger<N extends number>(n: PositiveInteger<N>) {\n  return n;\n}\n\nfunction isInteger<N extends number>(n: N): n is Integer<N> {\n  return Number.isInteger(n);\n}\nfunction isNonNegativeInteger<N extends number>(n: N): n is NonNegativeInteger<N> {\n  return Number.isInteger(n) && n >= 0;\n}\nfunction isPositiveInteger<N extends number>(n: N): n is PositiveInteger<N> {\n  return Number.isInteger(n) && n > 0;\n}\n\nfunction assertInteger(n: number, message: string) {\n  if (!Number.isInteger(n)) throw Error(message);\n}\nfunction assertNonNegativeInteger(n: number, message: string) {\n  if (!Number.isInteger(n) || n < 0) throw Error(message);\n}\nfunction assertPositiveInteger(n: number, message: string) {\n  if (!Number.isInteger(n) || n <= 0) throw Error(message);\n}\n\ntype Integer<T extends number> = number extends T\n  ? never\n  : `${T}` extends `${string}.${string}` | `${string}e-${string}`\n    ? never\n    : T;\ntype NonNegativeInteger<T extends number> = number extends T\n  ? never\n  : `${T}` extends `-${string}` | `${string}.${string}` | `${string}e-${string}`\n    ? never\n    : T;\ntype PositiveInteger<T extends number> = number extends T\n  ? never\n  : `${T}` extends `-${string}` | `${string}.${string}` | `${string}e-${string}` | `0`\n    ? never\n    : T;\n", "// generic encoding infrastructure\nimport {\n  assertNonNegativeInteger,\n  NonNegativeInteger,\n  PositiveInteger,\n} from '../crypto/non-negative.js';\nimport { bytesToBigInt, bigIntToBytes } from '../crypto/bigint-helpers.js';\nimport { GenericSignableField } from './generic.js';\n\nexport {\n  Binable,\n  defineBinable,\n  withVersionNumber,\n  tuple,\n  record,\n  enumWithArgument,\n  prefixToField,\n  bytesToBits,\n  bitsToBytes,\n  withBits,\n  withCheck,\n  BinableWithBits,\n  stringToBytes,\n  stringFromBytes,\n  stringLengthInBytes,\n  BinableString,\n  BinableInt32,\n  BinableInt64,\n  BinableUint32,\n  BinableUint64,\n};\n\ntype Binable<T> = {\n  toBytes(t: T): number[];\n  readBytes<N extends number>(\n    bytes: number[],\n    offset: NonNegativeInteger<N>\n  ): [value: T, offset: number];\n  fromBytes(bytes: number[]): T;\n};\ntype BinableWithBits<T> = Binable<T> & {\n  toBits(t: T): boolean[];\n  fromBits(bits: boolean[]): T;\n  sizeInBytes: number;\n  sizeInBits: number;\n};\n\nfunction defineBinable<T>({\n  toBytes,\n  readBytes,\n}: {\n  toBytes(t: T): number[];\n  readBytes<N extends number>(\n    bytes: number[],\n    offset: NonNegativeInteger<N>\n  ): [value: T, offset: number];\n}): Binable<T> {\n  // spec: input offset has to be a non-negative integer, and be smaller than the bytes length\n  // output offset has to be greater or equal input, and not exceed the bytes length\n  let readBytes_ = <N extends number>(bytes: number[], offset: NonNegativeInteger<N>) => {\n    assertNonNegativeInteger(offset, 'readBytes: offset must be integer >= 0');\n    if (offset >= bytes.length) throw Error('readBytes: offset must be within bytes length');\n    let [value, end] = readBytes(bytes, offset);\n    if (end < offset)\n      throw Error('offset returned by readBytes must be greater than initial offset');\n    if (end > bytes.length)\n      throw Error('offset returned by readBytes must not exceed bytes length');\n    return [value, end] as [T, number];\n  };\n  return {\n    toBytes,\n    readBytes: readBytes_,\n    // spec: fromBytes throws if the input bytes are not all used\n    fromBytes(bytes) {\n      let [value, offset] = readBytes_(bytes, 0);\n      if (offset < bytes.length) throw Error('fromBytes: input bytes left over');\n      return value;\n    },\n  };\n}\n\nfunction withVersionNumber<T>(binable: Binable<T>, versionNumber: number): Binable<T> {\n  return defineBinable({\n    toBytes(t) {\n      let bytes = binable.toBytes(t);\n      bytes.unshift(versionNumber);\n      return bytes;\n    },\n    readBytes(bytes, offset) {\n      let version = bytes[offset++];\n      if (version !== versionNumber) {\n        throw Error(`fromBytes: Invalid version byte. Expected ${versionNumber}, got ${version}.`);\n      }\n      return binable.readBytes(bytes, offset);\n    },\n  });\n}\n\nfunction withCheck<T>({ toBytes, readBytes }: Binable<T>, check: (t: T) => void): Binable<T> {\n  return defineBinable({\n    toBytes,\n    readBytes(bytes, start) {\n      let [value, end] = readBytes(bytes, start);\n      check(value);\n      return [value, end];\n    },\n  });\n}\n\ntype Tuple<T> = [T, ...T[]] | [];\n\nfunction record<Types extends Record<string, any>>(\n  binables: {\n    [i in keyof Types]: Binable<Types[i]>;\n  },\n  keys: Tuple<keyof Types>\n): Binable<Types> {\n  let binablesTuple = keys.map((key) => binables[key]) as Tuple<Binable<any>>;\n  let tupleBinable = tuple<Tuple<any>>(binablesTuple);\n  return defineBinable({\n    toBytes(t) {\n      let array = keys.map((key) => t[key]) as Tuple<any>;\n      return tupleBinable.toBytes(array);\n    },\n    readBytes(bytes, start) {\n      let [tupleValue, end] = tupleBinable.readBytes(bytes, start);\n      let value = Object.fromEntries(keys.map((key, i) => [key, tupleValue[i]])) as any;\n      return [value, end];\n    },\n  });\n}\n\nfunction tuple<Types extends Tuple<any>>(binables: {\n  [i in keyof Types]: Binable<Types[i]>;\n}): Binable<Types> {\n  let n = (binables as any[]).length;\n  return defineBinable({\n    toBytes(t) {\n      let bytes: number[] = [];\n      for (let i = 0; i < n; i++) {\n        let subBytes = binables[i].toBytes(t[i]);\n        bytes.push(...subBytes);\n      }\n      return bytes;\n    },\n    readBytes(bytes, offset) {\n      let values = [];\n      for (let i = 0; i < n; i++) {\n        let [value, newOffset] = binables[i].readBytes(bytes, offset);\n        offset = newOffset as any;\n        values.push(value);\n      }\n      return [values as Types, offset];\n    },\n  });\n}\n\ntype EnumNoArgument<T extends string> = { type: T };\ntype EnumWithArgument<T extends string, V> = { type: T; value: V };\ntype AnyEnum = EnumNoArgument<string> | EnumWithArgument<string, any>;\n\nfunction enumWithArgument<Enum_ extends Tuple<AnyEnum>>(types: {\n  [i in number]: Enum_[i] extends EnumWithArgument<string, any>\n    ? {\n        type: Enum_[i]['type'];\n        value: Binable<Enum_[i]['value']>;\n      }\n    : { type: Enum_[i]['type'] };\n}): Binable<Enum_[number]> {\n  let typeToIndex = Object.fromEntries(\n    (types as { type: string; value: any }[]).map(({ type }, i) => [type, i])\n  );\n  return defineBinable({\n    toBytes(en) {\n      let i = typeToIndex[en.type];\n      let type = types[i];\n      if ('value' in type) {\n        let binable = type.value;\n        return [i, ...binable.toBytes((en as any).value)];\n      }\n      return [i];\n    },\n    readBytes(bytes, offset) {\n      let i = bytes[offset];\n      offset++;\n      let type = types[i];\n      if ('value' in type) {\n        let [value, end] = type.value.readBytes(bytes, offset);\n        return [{ type: type.type, value }, end];\n      }\n      return [{ type: type.type }, offset];\n    },\n  });\n}\n\nconst BinableString = defineBinable({\n  toBytes(t: string) {\n    return [stringLengthInBytes(t), ...stringToBytes(t)];\n  },\n  readBytes(bytes, offset) {\n    let length = bytes[offset++];\n    let end = offset + length;\n    let string = stringFromBytes(bytes.slice(offset, end));\n    return [string, end];\n  },\n});\n\nconst CODE_NEG_INT8 = 0xff;\nconst CODE_INT16 = 0xfe;\nconst CODE_INT32 = 0xfd;\nconst CODE_INT64 = 0xfc;\n\nfunction BinableInt<N extends number>(bits: PositiveInteger<N>) {\n  let maxValue = 1n << BigInt(bits - 1);\n  let nBytes = bits >> 3;\n  if (nBytes * 8 !== bits) throw Error('bits must be evenly divisible by 8');\n  return defineBinable({\n    toBytes(n: bigint) {\n      if (n < -maxValue || n >= maxValue) throw Error(`int${bits} out of range, got ${n}`);\n      if (n >= 0) {\n        if (n < 0x80n) return bigIntToBytes(n, 1);\n        if (n < 0x8000n) return [CODE_INT16, ...bigIntToBytes(n, 2)];\n        if (n < 0x80000000) return [CODE_INT32, ...bigIntToBytes(n, 4)];\n        else return [CODE_INT64, ...bigIntToBytes(n, 8)];\n      } else {\n        let M = 1n << 64n;\n        if (n >= -0x80n) return [CODE_NEG_INT8, ...bigIntToBytes((M + n) & 0xffn, 1)];\n        if (n >= -0x8000n) return [CODE_INT16, ...bigIntToBytes((M + n) & 0xffffn, 2)];\n        if (n >= -0x80000000) return [CODE_INT32, ...bigIntToBytes((M + n) & 0xffff_ffffn, 4)];\n        else return [CODE_INT64, ...bigIntToBytes(M + n, 8)];\n      }\n    },\n    readBytes(bytes, offset) {\n      let code = bytes[offset++];\n      if (code < 0x80) return [BigInt(code), offset];\n      let size = {\n        [CODE_NEG_INT8]: 1,\n        [CODE_INT16]: 2,\n        [CODE_INT32]: 4,\n        [CODE_INT64]: 8,\n      }[code];\n      if (size === undefined) {\n        throw Error('binable integer: invalid start byte');\n      }\n      let end = offset + size;\n      let x = fillUInt(bytes.slice(offset, end), nBytes);\n      // map from uint to int range\n      if (x >= maxValue) {\n        x -= 2n * maxValue;\n      }\n      if (x < -maxValue || x >= maxValue) {\n        throw Error(`int${bits} out of range, got ${x}`);\n      }\n      return [x, end];\n    },\n  });\n}\n\nfunction fillUInt(startBytes: number[], nBytes: number) {\n  let n = startBytes.length;\n  // fill up int with the highest bit of startBytes\n  let lastBit = startBytes[n - 1] >> 7;\n  let fillByte = lastBit === 1 ? 0xff : 0x00;\n  let intBytes = startBytes.concat(Array(nBytes - n).fill(fillByte));\n  // interpret result as a bigint > 0\n  let x = bytesToBigInt(intBytes);\n  return x;\n}\n\nfunction BinableUint<N extends number>(bits: PositiveInteger<N>) {\n  let binableInt = BinableInt(bits);\n  let maxValue = 1n << BigInt(bits - 1);\n  return iso(binableInt, {\n    to(uint: bigint) {\n      if (uint < 0n || uint >= 2n * maxValue) throw Error(`uint${bits} out of range, got ${uint}`);\n      let ret = uint >= maxValue ? uint - 2n * maxValue : uint;\n      return ret;\n    },\n    from(int: bigint) {\n      let uint = int < 0n ? int + 2n * maxValue : int;\n      if (uint < 0n || uint >= 2n * maxValue) throw Error(`uint${bits} out of range, got ${uint}`);\n      return uint;\n    },\n  });\n}\n\nconst BinableInt64 = BinableInt(64);\nconst BinableInt32 = BinableInt(32);\nconst BinableUint64 = BinableUint(64);\nconst BinableUint32 = BinableUint(32);\n\n// same as Random_oracle.prefix_to_field in OCaml\n// converts string to bytes and bytes to field; throws if bytes don't fit in one field\nfunction prefixToField<Field>(Field: GenericSignableField<Field>, prefix: string) {\n  let fieldSize = Field.sizeInBytes;\n  if (prefix.length >= fieldSize) throw Error('prefix too long');\n  let stringBytes = stringToBytes(prefix);\n  return Field.fromBytes(stringBytes.concat(Array(fieldSize - stringBytes.length).fill(0)));\n}\n\nfunction bitsToBytes([...bits]: boolean[]) {\n  let bytes: number[] = [];\n  while (bits.length > 0) {\n    let byteBits = bits.splice(0, 8);\n    let byte = 0;\n    for (let i = 0; i < 8; i++) {\n      if (!byteBits[i]) continue;\n      byte |= 1 << i;\n    }\n    bytes.push(byte);\n  }\n  return bytes;\n}\n\nfunction bytesToBits(bytes: number[]) {\n  return bytes\n    .map((byte) => {\n      let bits: boolean[] = Array(8);\n      for (let i = 0; i < 8; i++) {\n        bits[i] = !!(byte & 1);\n        byte >>= 1;\n      }\n      return bits;\n    })\n    .flat();\n}\n\n/**\n * This takes a `Binable<T>` plus an optional `sizeInBits`, and derives toBits() / fromBits() functions.\n * - `sizeInBits` has to observe `Math.ceil(sizeInBits / 8) === sizeInBytes`, so the bit size can be slightly smaller than the byte size\n * - If `sizeInBits` is `< sizeInBytes * 8`, then we assume that toBytes() returns a byte sequence where the bits\n *   higher than `sizeInBits` are all 0. This assumption manifests in toBits(), where we slice off those higher bits,\n *   to return a result that is of length `sizeInBits`.\n *\n * This is useful for serializing field elements, where -- depending on the circumstance -- we either want a\n * 32-byte (= 256-bit) serialization, or a 255-bit serialization\n */\nfunction withBits<T>(binable: Binable<T>, sizeInBits: number): BinableWithBits<T> {\n  return {\n    ...binable,\n    toBits(t: T) {\n      return bytesToBits(binable.toBytes(t)).slice(0, sizeInBits);\n    },\n    fromBits(bits: boolean[]) {\n      return binable.fromBytes(bitsToBytes(bits));\n    },\n    sizeInBytes: Math.ceil(sizeInBits / 8),\n    sizeInBits,\n  };\n}\n\nfunction iso<T, S>(binable: Binable<T>, { to, from }: { to(s: S): T; from(t: T): S }): Binable<S> {\n  return defineBinable({\n    toBytes(s: S) {\n      return binable.toBytes(to(s));\n    },\n    readBytes(bytes, offset) {\n      let [value, end] = binable.readBytes(bytes, offset);\n      return [from(value), end];\n    },\n  });\n}\n\nlet encoder = new TextEncoder();\nlet decoder = new TextDecoder();\n\nfunction stringToBytes(s: string) {\n  return [...encoder.encode(s)];\n}\nfunction stringFromBytes(bytes: number[]) {\n  return decoder.decode(Uint8Array.from(bytes));\n}\nfunction stringLengthInBytes(s: string) {\n  return encoder.encode(s).length;\n}\n", "import { bigIntToBytes } from '../../bindings/crypto/bigint-helpers.js';\nimport { createDerivers } from '../../bindings/lib/provable-generic.js';\nimport { GenericHashInput, GenericSignable } from '../../bindings/lib/generic.js';\nimport { BinableWithBits, defineBinable, withBits } from '../../bindings/lib/binable.js';\n\nexport { signable, SignableBigint, BinableBigint, BinableBool, HashInput, Signable };\n\ntype Field = bigint;\n\nlet { signable } = createDerivers<Field>();\n\ntype Signable<T, J> = GenericSignable<T, J, Field>;\ntype HashInput = GenericHashInput<Field>;\n\nfunction SignableBigint<T extends bigint = bigint, TJSON extends string = string>(\n  check: (x: bigint) => void\n): Signable<T, TJSON> {\n  return {\n    toInput(x) {\n      return { fields: [x], packed: [] };\n    },\n    toJSON(x) {\n      return x.toString() as TJSON;\n    },\n    fromJSON(json) {\n      if (isNaN(json as any) || isNaN(parseFloat(json))) {\n        throw Error(`fromJSON: expected a numeric string, got \"${json}\"`);\n      }\n      let x = BigInt(json) as T;\n      check(x);\n      return x;\n    },\n    empty() {\n      return 0n as T;\n    },\n  };\n}\n\nfunction BinableBigint<T extends bigint = bigint>(\n  sizeInBits: number,\n  check: (x: bigint) => void\n): BinableWithBits<T> {\n  let sizeInBytes = Math.ceil(sizeInBits / 8);\n  return withBits(\n    defineBinable({\n      toBytes(x) {\n        return bigIntToBytes(x, sizeInBytes);\n      },\n      readBytes(bytes, start) {\n        let x = 0n;\n        let bitPosition = 0n;\n        let end = Math.min(start + sizeInBytes, bytes.length);\n        for (let i = start; i < end; i++) {\n          x += BigInt(bytes[i]) << bitPosition;\n          bitPosition += 8n;\n        }\n        check(x);\n        return [x as T, end];\n      },\n    }),\n    sizeInBits\n  );\n}\n\nfunction BinableBool(check: (x: number) => void): BinableWithBits<boolean> {\n  return withBits(\n    defineBinable({\n      toBytes(x) {\n        return [x ? 1 : 0];\n      },\n      readBytes(bytes, start) {\n        let byte = bytes[start];\n        check(byte);\n        return [byte === 1, start + 1];\n      },\n    }),\n    1\n  );\n}\n", "import { randomBytes } from '../../bindings/crypto/random.js';\nimport { Fp, mod } from '../../bindings/crypto/finite-field.js';\nimport { BinableBigint, HashInput, SignableBigint, BinableBool } from './derivers-bigint.js';\n\nexport { Field, Bool, UInt32, UInt64, Sign };\nexport { BinableFp, SignableFp };\nexport { pseudoClass, sizeInBits, checkRange, checkField };\n\ntype Field = bigint;\ntype Bool = boolean;\ntype UInt32 = bigint;\ntype UInt64 = bigint;\n\nconst sizeInBits = Fp.sizeInBits;\n\ntype minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;\nconst minusOne: minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;\ntype Sign = 1n | minusOne;\n\nconst checkField = checkRange(0n, Fp.modulus, 'Field');\nconst checkBool = checkAllowList(new Set([0n, 1n]), 'Bool');\nconst checkBoolBytes = checkAllowList(new Set([0, 1]), 'Bool');\nconst checkSign = checkAllowList(new Set([1n, minusOne]), 'Sign');\n\nconst BinableFp = BinableBigint(Fp.sizeInBits, checkField);\nconst SignableFp = SignableBigint(checkField);\n\n/**\n * The base field of the Pallas curve\n */\nconst Field = pseudoClass(\n  function Field(value: bigint | number | string): Field {\n    return mod(BigInt(value), Fp.modulus);\n  },\n  { ...SignableFp, ...BinableFp, ...Fp, toBigint: (x: Field) => x }\n);\n\n/**\n * A field element which is either 0 or 1\n */\nconst Bool = pseudoClass(\n  function Bool(value: boolean): Bool {\n    return value;\n  },\n  {\n    ...BinableBool(checkBoolBytes),\n    fromBigint(x: Field) {\n      checkBool(x);\n      return x === 0n ? false : true;\n    },\n    toBigint(x: Bool) {\n      return x ? 1n : 0n;\n    },\n    toInput(x: Bool): HashInput {\n      return { fields: [], packed: [[Bool.toBigint(x), 1]] };\n    },\n    toBoolean(x: Bool) {\n      return x;\n    },\n    toJSON(x: Bool) {\n      return x;\n    },\n    fromJSON(b: boolean) {\n      return b;\n    },\n    empty() {\n      return false;\n    },\n    sizeInBytes: 1,\n    fromField(x: Field) {\n      return Bool.fromBigint(x);\n    },\n  }\n);\n\nfunction Unsigned(bits: number) {\n  let maxValue = (1n << BigInt(bits)) - 1n;\n  let checkUnsigned = checkRange(0n, 1n << BigInt(bits), `UInt${bits}`);\n  let binable = BinableBigint(bits, checkUnsigned);\n  let bytes = Math.ceil(bits / 8);\n\n  return pseudoClass(\n    function Unsigned(value: bigint | number | string) {\n      let x = BigInt(value);\n      checkUnsigned(x);\n      return x;\n    },\n    {\n      ...SignableBigint(checkUnsigned),\n      ...binable,\n      toInput(x: bigint): HashInput {\n        return { fields: [], packed: [[x, bits]] };\n      },\n      maxValue,\n      random() {\n        return binable.fromBytes([...randomBytes(bytes)]);\n      },\n    }\n  );\n}\nconst UInt32 = Unsigned(32);\nconst UInt64 = Unsigned(64);\n\nconst Sign = pseudoClass(\n  function Sign(value: 1 | -1): Sign {\n    if (value !== 1 && value !== -1) throw Error('Sign: input must be 1 or -1.');\n    return mod(BigInt(value), Fp.modulus) as Sign;\n  },\n  {\n    ...SignableBigint<Sign, 'Positive' | 'Negative'>(checkSign),\n    ...BinableBigint<Sign>(1, checkSign),\n    empty() {\n      return 1n;\n    },\n    toInput(x: Sign): HashInput {\n      return { fields: [], packed: [[x === 1n ? 1n : 0n, 1]] };\n    },\n    fromFields([x]: Field[]): Sign {\n      if (x === 0n) return 1n;\n      checkSign(x);\n      return x as Sign;\n    },\n    toJSON(x: Sign) {\n      return x === 1n ? 'Positive' : 'Negative';\n    },\n    fromJSON(x: 'Positive' | 'Negative'): Sign {\n      if (x !== 'Positive' && x !== 'Negative') throw Error('Sign: invalid input');\n      return x === 'Positive' ? 1n : minusOne;\n    },\n  }\n);\n\n// helper\n\nfunction pseudoClass<\n  F extends (...args: any) => any,\n  M,\n  // M extends Provable<ReturnType<F>>\n>(constructor: F, module: M) {\n  return Object.assign<F, M>(constructor, module);\n}\n\n// validity checks\n\nfunction checkRange(lower: bigint, upper: bigint, name: string) {\n  return (x: bigint) => {\n    if (x < lower) throw Error(`${name}: inputs smaller than ${lower} are not allowed, got ${x}`);\n    if (x >= upper)\n      throw Error(`${name}: inputs larger than ${upper - 1n} are not allowed, got ${x}`);\n  };\n}\n\nfunction checkAllowList<T>(valid: Set<T>, name: string) {\n  return (x: T) => {\n    if (!valid.has(x)) {\n      throw Error(`${name}: input must be one of ${[...valid].join(', ')}, got ${x}`);\n    }\n  };\n}\n", "export { Context };\n\nnamespace Context {\n  export type id = number;\n\n  export type t<Context> = (() => Context | undefined) & {\n    data: { context: Context; id: id; trace?: string }[];\n    allowsNesting: boolean;\n\n    get(): Context;\n    has(): boolean;\n    runWith<C extends Context, Result>(context: Context, func: (context: C) => Result): [C, Result];\n    runWithAsync<Result>(\n      context: Context,\n      func: (context: Context) => Promise<Result>\n    ): Promise<[Context, Result]>;\n    enter(context: Context): id;\n    leave(id: id): Context;\n    id: () => id;\n  };\n}\nconst Context = { create };\n\nfunction create<C>(\n  options = {\n    allowsNesting: true,\n    default: undefined,\n  } as { allowsNesting?: boolean; default?: C }\n): Context.t<C> {\n  let t: Context.t<C> = Object.assign(\n    function (): C | undefined {\n      return t.data[t.data.length - 1]?.context;\n    },\n    {\n      data: [],\n      allowsNesting: options.allowsNesting ?? true,\n      get: () => get(t),\n      has: () => t.data.length !== 0,\n      runWith<C0 extends C, Result>(context: C0, func: (context: C0) => Result): [C0, Result] {\n        let id = enter(t, context);\n        let result: Result;\n        let resultContext: C;\n        try {\n          result = func(context);\n        } finally {\n          resultContext = leave(t, id);\n        }\n        return [resultContext as C0, result];\n      },\n      async runWithAsync<Result>(\n        context: C,\n        func: (context: C) => Promise<Result>\n      ): Promise<[C, Result]> {\n        let id = enter(t, context);\n        let result: Result;\n        let resultContext: C;\n        try {\n          result = await func(context);\n        } finally {\n          resultContext = leave(t, id);\n        }\n        return [resultContext, result];\n      },\n      enter: (context: C) => enter(t, context),\n      leave: (id: Context.id) => leave(t, id),\n      id: () => {\n        if (t.data.length === 0) throw Error(contextConflictMessage);\n        return t.data[t.data.length - 1].id;\n      },\n    }\n  );\n  if (options.default !== undefined) enter(t, options.default);\n  return t;\n}\n\nfunction enter<C>(t: Context.t<C>, context: C): Context.id {\n  if (t.data.length > 0 && !t.allowsNesting) {\n    throw Error(contextConflictMessage);\n  }\n  let id = Math.random();\n  let trace = Error().stack?.slice(5);\n  t.data.push({ context, id, trace });\n  return id;\n}\n\nfunction leave<C>(t: Context.t<C>, id: Context.id): C {\n  let current = t.data.pop();\n  if (current === undefined) throw Error(contextConflictMessage);\n  if (current.id !== id) {\n    let message = contextConflictMessage;\n    let expected = t.data.find((c) => c.id === id);\n    if (expected?.trace) {\n      message += `\\n\\nWe wanted to leave the global context entered here:${expected.trace}`;\n      if (current.trace) {\n        message += `\\n\\nBut we actually would have left the global context entered here:${current.trace}`;\n        message += `\\n\\nOur first recommendation is to check for a missing 'await' in the second stack trace.`;\n      }\n      message += `\\n\\n`;\n    }\n    throw Error(message);\n  }\n  return current.context;\n}\n\nfunction get<C>(t: Context.t<C>): C {\n  if (t.data.length === 0) throw Error(contextConflictMessage);\n  let current = t.data[t.data.length - 1];\n  return current.context;\n}\n\n// FIXME there are many common scenarios where this error occurs, which weren't expected when this was written\n// it should list them and help to resolve them\nlet contextConflictMessage = `The global context managed by o1js reached an inconsistent state. This could be caused by one of the following reasons:\n\n- You are missing an 'await' somewhere, which causes a new global context to be entered before we finished the last one.\n\n- You are importing two different instances of o1js, which leads to inconsistent tracking of the global context in one of those instances.\n  - This is a common problem in projects that use o1js as part of a UI!\n\n- You are running multiple async operations concurrently, which conflict in using the global context.\n  - Running async o1js operations (like proving) in parallel is not supported! Try running everything serially.\n  \nInvestigate the stack traces below for more hints about the problem.`;\n", "import { Context } from '../../util/global-context.js';\nimport { Gate, GateType, JsonGate, Snarky, initializeBindings } from '../../../bindings.js';\nimport { parseHexString32 } from '../../../bindings/crypto/bigint-helpers.js';\nimport { prettifyStacktrace } from '../../util/errors.js';\nimport { Fp } from '../../../bindings/crypto/finite-field.js';\nimport { MlBool } from '../../ml/base.js';\n\n// internal API\nexport {\n  snarkContext,\n  SnarkContext,\n  asProver,\n  synchronousRunners,\n  generateWitness,\n  constraintSystem,\n  inProver,\n  inAnalyze,\n  inCheckedComputation,\n  inCompile,\n  inCompileMode,\n  gatesFromJson,\n  printGates,\n  summarizeGates,\n  MlConstraintSystem,\n  ConstraintSystemSummary,\n};\n\n// global circuit-related context\n\ntype ConstraintSystemSummary = {\n  /**\n   * Number of rows in the constraint system\n   */\n  rows: number;\n  digest: string;\n  /**\n   * List of gates which make up the constraint system\n   */\n  gates: Gate[];\n  publicInputSize: number;\n  print(): void;\n  summary(): Record<string, number>;\n};\n\ntype SnarkContext = {\n  witnesses?: unknown[];\n  proverData?: any;\n  inProver?: boolean;\n  inCompile?: boolean;\n  inCheckedComputation?: boolean;\n  inAnalyze?: boolean;\n  inWitnessBlock?: boolean;\n  auxInputData?: any[];\n};\nlet snarkContext = Context.create<SnarkContext>({ default: {} });\n\nclass MlConstraintSystem {\n  // opaque\n}\n\n// helpers to read circuit context\n\nfunction inProver() {\n  return !!snarkContext.get().inProver;\n}\nfunction inCheckedComputation() {\n  let ctx = snarkContext.get();\n  return !!ctx.inCompile || !!ctx.inProver || !!ctx.inCheckedComputation;\n}\nfunction inCompile() {\n  return !!snarkContext.get().inCompile;\n}\nfunction inAnalyze() {\n  return !!snarkContext.get().inAnalyze;\n}\n\nfunction inCompileMode() {\n  let ctx = snarkContext.get();\n  return !!ctx.inCompile || !!ctx.inAnalyze;\n}\n\n// runners for provable code\n\nfunction asProver(f: () => void) {\n  if (inCheckedComputation()) {\n    // TODO make this start a \"witness block\" context\n    Snarky.run.asProver(f);\n  } else {\n    f();\n  }\n}\n\nasync function generateWitness(\n  f: (() => Promise<void>) | (() => void),\n  { checkConstraints = true } = {}\n) {\n  await initializeBindings();\n  let id = snarkContext.enter({ inCheckedComputation: true });\n  try {\n    let finish = Snarky.run.enterGenerateWitness();\n    if (!checkConstraints) Snarky.run.setEvalConstraints(MlBool(false));\n    await f();\n    return finish();\n  } catch (error) {\n    throw prettifyStacktrace(error);\n  } finally {\n    if (!checkConstraints) Snarky.run.setEvalConstraints(MlBool(true));\n    snarkContext.leave(id);\n  }\n}\n\nasync function constraintSystem(f: (() => Promise<void>) | (() => void)) {\n  await initializeBindings();\n  let id = snarkContext.enter({ inAnalyze: true, inCheckedComputation: true });\n  try {\n    let finish = Snarky.run.enterConstraintSystem();\n    await f();\n    let cs = finish();\n    return constraintSystemToJS(cs);\n  } catch (error) {\n    throw prettifyStacktrace(error);\n  } finally {\n    snarkContext.leave(id);\n  }\n}\n\n/**\n * helpers to run circuits in synchronous tests\n */\nasync function synchronousRunners() {\n  await initializeBindings();\n\n  function runAndCheckSync(f: () => void) {\n    let id = snarkContext.enter({ inCheckedComputation: true });\n    try {\n      let finish = Snarky.run.enterGenerateWitness();\n      f();\n      finish();\n    } catch (error) {\n      throw prettifyStacktrace(error);\n    } finally {\n      snarkContext.leave(id);\n    }\n  }\n\n  function constraintSystemSync(f: () => void) {\n    let id = snarkContext.enter({\n      inAnalyze: true,\n      inCheckedComputation: true,\n    });\n    try {\n      let finish = Snarky.run.enterConstraintSystem();\n      f();\n      let cs = finish();\n      return constraintSystemToJS(cs);\n    } catch (error) {\n      throw prettifyStacktrace(error);\n    } finally {\n      snarkContext.leave(id);\n    }\n  }\n\n  return { runAndCheckSync, constraintSystemSync };\n}\n\nfunction constraintSystemToJS(cs: MlConstraintSystem): ConstraintSystemSummary {\n  // toJson also \"finalizes\" the constraint system, which means\n  // locking in a potential pending single generic gate\n  let json = Snarky.constraintSystem.toJson(cs);\n  let rows = Snarky.constraintSystem.rows(cs);\n  let digest = Snarky.constraintSystem.digest(cs);\n  let { gates, publicInputSize } = gatesFromJson(json);\n  return {\n    rows,\n    digest,\n    gates,\n    publicInputSize,\n    print() {\n      printGates(gates);\n    },\n    summary() {\n      return summarizeGates(gates);\n    },\n  };\n}\n\n// helpers\n\nfunction gatesFromJson(cs: { gates: JsonGate[]; public_input_size: number }) {\n  let gates: Gate[] = cs.gates.map(({ typ, wires, coeffs: hexCoeffs }) => {\n    let coeffs = hexCoeffs.map((hex) => parseHexString32(hex).toString());\n    return { type: typ, wires, coeffs };\n  });\n  return { publicInputSize: cs.public_input_size, gates };\n}\n\n// collect a summary of the constraint system\n\nfunction summarizeGates(gates: Gate[]) {\n  let gateTypes: Partial<Record<GateType | 'Total rows', number>> = {};\n  gateTypes['Total rows'] = gates.length;\n  for (let gate of gates) {\n    gateTypes[gate.type] ??= 0;\n    gateTypes[gate.type]!++;\n  }\n  return gateTypes;\n}\n\n// print a constraint system\n\nfunction printGates(gates: Gate[]) {\n  for (let i = 0, n = gates.length; i < n; i++) {\n    let { type, wires, coeffs } = gates[i];\n    console.log(\n      i.toString().padEnd(4, ' '),\n      type.padEnd(15, ' '),\n      coeffsToPretty(type, coeffs).padEnd(30, ' '),\n      wiresToPretty(wires, i)\n    );\n  }\n  console.log();\n}\n\nlet minusRange = Fp.modulus - (1n << 64n);\n\nfunction coeffsToPretty(type: Gate['type'], coeffs: Gate['coeffs']): string {\n  if (coeffs.length === 0) return '';\n  if (type === 'Generic' && coeffs.length > 5) {\n    let first = coeffsToPretty(type, coeffs.slice(0, 5));\n    let second = coeffsToPretty(type, coeffs.slice(5));\n    return `${first} ${second}`;\n  }\n  if (type === 'Poseidon' && coeffs.length > 3) {\n    return `${coeffsToPretty(type, coeffs.slice(0, 3)).slice(0, -1)} ...]`;\n  }\n  let str = coeffs\n    .map((c) => {\n      let c0 = BigInt(c);\n      if (c0 > minusRange) c0 -= Fp.modulus;\n      let cStr = c0.toString();\n      if (cStr.length > 4) return `${cStr.slice(0, 4)}..`;\n      return cStr;\n    })\n    .join(' ');\n  return `[${str}]`;\n}\n\nfunction wiresToPretty(wires: Gate['wires'], row: number) {\n  let strWires: string[] = [];\n  let n = wires.length;\n  for (let col = 0; col < n; col++) {\n    let wire = wires[col];\n    if (wire.row === row && wire.col === col) continue;\n    if (wire.row === row) {\n      strWires.push(`${col}->${wire.col}`);\n    } else {\n      strWires.push(`${col}->(${wire.row},${wire.col})`);\n    }\n  }\n  return strWires.join(', ');\n}\n", "import { Fp } from '../../../bindings/crypto/finite-field.js';\n\n// internal API\nexport { FieldType, FieldVar, FieldConst, ConstantFieldVar, VarFieldVar };\n\ntype FieldConst = [0, bigint];\n\nfunction constToBigint(x: FieldConst): bigint {\n  return x[1];\n}\nfunction constFromBigint(x: bigint): FieldConst {\n  return [0, Fp.mod(x)];\n}\n\nconst FieldConst = {\n  fromBigint: constFromBigint,\n  toBigint: constToBigint,\n  equal(x: FieldConst, y: FieldConst) {\n    return x[1] === y[1];\n  },\n  [0]: constFromBigint(0n),\n  [1]: constFromBigint(1n),\n  [-1]: constFromBigint(-1n),\n};\n\nenum FieldType {\n  Constant,\n  Var,\n  Add,\n  Scale,\n}\n\n/**\n * `FieldVar` is the core data type in snarky. It is equivalent to `Cvar.t` in OCaml.\n * It represents a field element that is part of provable code - either a constant or a variable.\n *\n * **Variables** end up filling the witness columns of a constraint system.\n * Think of a variable as a value that has to be provided by the prover, and that has to satisfy all the\n * constraints it is involved in.\n *\n * **Constants** end up being hard-coded into the constraint system as gate coefficients.\n * Think of a constant as a value that is known publicly, at compile time, and that defines the constraint system.\n *\n * Both constants and variables can be combined into an AST using the Add and Scale combinators.\n */\ntype FieldVar =\n  | [FieldType.Constant, FieldConst]\n  | [FieldType.Var, number]\n  | [FieldType.Add, FieldVar, FieldVar]\n  | [FieldType.Scale, FieldConst, FieldVar];\n\ntype ConstantFieldVar = [FieldType.Constant, FieldConst];\ntype VarFieldVar = [FieldType.Var, number];\n\nconst FieldVar = {\n  // constructors\n  Constant(x: FieldConst): ConstantFieldVar {\n    return [FieldType.Constant, x];\n  },\n  Var(x: number): VarFieldVar {\n    return [FieldType.Var, x];\n  },\n  Add(x: FieldVar, y: FieldVar): [FieldType.Add, FieldVar, FieldVar] {\n    return [FieldType.Add, x, y];\n  },\n  Scale(c: FieldConst, x: FieldVar): [FieldType.Scale, FieldConst, FieldVar] {\n    return [FieldType.Scale, c, x];\n  },\n\n  constant(x: bigint | FieldConst): ConstantFieldVar {\n    let x0 = typeof x === 'bigint' ? FieldConst.fromBigint(x) : x;\n    return [FieldType.Constant, x0];\n  },\n  add(x: FieldVar, y: FieldVar): FieldVar {\n    if (FieldVar.isConstant(x) && x[1][1] === 0n) return y;\n    if (FieldVar.isConstant(y) && y[1][1] === 0n) return x;\n    if (FieldVar.isConstant(x) && FieldVar.isConstant(y)) {\n      return FieldVar.constant(Fp.add(x[1][1], y[1][1]));\n    }\n    return [FieldType.Add, x, y];\n  },\n  scale(c: bigint | FieldConst, x: FieldVar): FieldVar {\n    let c0 = typeof c === 'bigint' ? FieldConst.fromBigint(c) : c;\n    if (c0[1] === 0n) return FieldVar.constant(0n);\n    if (c0[1] === 1n) return x;\n    if (FieldVar.isConstant(x)) {\n      return FieldVar.constant(Fp.mul(c0[1], x[1][1]));\n    }\n    if (FieldVar.isScale(x)) {\n      return [FieldType.Scale, FieldConst.fromBigint(Fp.mul(c0[1], x[1][1])), x[2]];\n    }\n    return [FieldType.Scale, c0, x];\n  },\n\n  // type guards\n  isConstant(x: FieldVar): x is ConstantFieldVar {\n    return x[0] === FieldType.Constant;\n  },\n  isVar(x: FieldVar): x is VarFieldVar {\n    return x[0] === FieldType.Var;\n  },\n  isAdd(x: FieldVar): x is [FieldType.Add, FieldVar, FieldVar] {\n    return x[0] === FieldType.Add;\n  },\n  isScale(x: FieldVar): x is [FieldType.Scale, FieldConst, FieldVar] {\n    return x[0] === FieldType.Scale;\n  },\n\n  [0]: [FieldType.Constant, FieldConst[0]] satisfies ConstantFieldVar,\n  [1]: [FieldType.Constant, FieldConst[1]] satisfies ConstantFieldVar,\n  [-1]: [FieldType.Constant, FieldConst[-1]] satisfies ConstantFieldVar,\n};\n", "/**\n * Stub module to break dependency cycle between Field and Bool classes and\n * core gadgets which they depend on but which need to create Fields and Bools,\n * or check if a value is a Field or a Bool.\n */\nimport type { Field } from '../field.js';\nimport type { Bool } from '../bool.js';\nimport type { FieldVar, FieldConst } from './fieldvar.js';\n\nexport {\n  createField,\n  createBool,\n  createBoolUnsafe,\n  isField,\n  isBool,\n  getField,\n  getBool,\n  setFieldConstructor,\n  setBoolConstructor,\n};\n\nlet fieldConstructor: typeof Field | undefined;\nlet boolConstructor: typeof Bool | undefined;\n\nfunction setFieldConstructor(constructor: typeof Field) {\n  fieldConstructor = constructor;\n}\nfunction setBoolConstructor(constructor: typeof Bool) {\n  boolConstructor = constructor;\n}\n\nfunction createField(value: string | number | bigint | Field | FieldVar | FieldConst): Field {\n  if (fieldConstructor === undefined)\n    throw Error('Cannot construct a Field before the class was defined.');\n  return new fieldConstructor(value);\n}\n\nfunction createBool(value: boolean | Bool): Bool {\n  if (boolConstructor === undefined)\n    throw Error('Cannot construct a Bool before the class was defined.');\n  return new boolConstructor(value);\n}\n\nfunction createBoolUnsafe(value: Field): Bool {\n  return getBool().Unsafe.fromField(value);\n}\n\nfunction isField(x: unknown): x is Field {\n  if (fieldConstructor === undefined)\n    throw Error('Cannot check for instance of Field before the class was defined.');\n  return x instanceof fieldConstructor;\n}\n\nfunction isBool(x: unknown): x is Bool {\n  if (boolConstructor === undefined)\n    throw Error('Cannot check for instance of Bool before the class was defined.');\n  return x instanceof boolConstructor;\n}\n\nfunction getField(): typeof Field {\n  if (fieldConstructor === undefined) throw Error('Field class not defined yet.');\n  return fieldConstructor;\n}\n\nfunction getBool(): typeof Bool {\n  if (boolConstructor === undefined) throw Error('Bool class not defined yet.');\n  return boolConstructor;\n}\n", "import { assert } from './errors.js';\n\nexport { AnyFunction, Tuple, TupleN, AnyTuple, TupleMap, Subclass, Get };\n\ntype AnyFunction = (...args: any) => any;\n\ntype Tuple<T> = [T, ...T[]] | [];\ntype AnyTuple = Tuple<any>;\n\ntype TupleMap<T extends Tuple<any>, B> = [\n  ...{\n    [i in keyof T]: B;\n  }\n];\n\nconst Tuple = {\n  map<T extends Tuple<any>, B>(tuple: T, f: (a: T[number]) => B): TupleMap<T, B> {\n    return tuple.map(f) as any;\n  },\n};\n\n/**\n * tuple type that has the length as generic parameter\n */\ntype TupleN<T, N extends number> = N extends N\n  ? number extends N\n    ? [...T[]] // N is not typed as a constant => fall back to array\n    : [...TupleRec<T, N, []>]\n  : never;\n\nconst TupleN = {\n  map<T extends Tuple<any>, B>(tuple: T, f: (a: T[number]) => B): TupleMap<T, B> {\n    return tuple.map(f) as any;\n  },\n\n  fromArray<T, N extends number>(n: N, arr: T[]): TupleN<T, N> {\n    assert(arr.length === n, `Expected array of length ${n}, got ${arr.length}`);\n    return arr as any;\n  },\n\n  hasLength<T, N extends number>(n: N, tuple: T[]): tuple is TupleN<T, N> {\n    return tuple.length === n;\n  },\n};\n\ntype TupleRec<T, N extends number, R extends unknown[]> = R['length'] extends N\n  ? R\n  : TupleRec<T, N, [T, ...R]>;\n\n// classes\n\ntype Subclass<Class extends new (...args: any) => any> = (new (\n  ...args: any\n) => InstanceType<Class>) & {\n  [K in keyof Class]: Class[K];\n} & { prototype: InstanceType<Class> };\n\n/**\n * helper to get property type from an object, in place of `T[Key]`\n *\n * assume `T extends { Key?: Something }`.\n * if we use `Get<T, Key>` instead of `T[Key]`, we allow `T` to be inferred _without_ the `Key` key,\n * and thus retain the precise type of `T` during inference\n */\ntype Get<T, Key extends string> = T extends { [K in Key]: infer _Value } ? _Value : undefined;\n", "import { Snarky } from '../../../bindings.js';\nimport { FieldConst, VarFieldVar } from './fieldvar.js';\nimport type { VarField } from '../field.js';\nimport { MlArray, MlOption } from '../../ml/base.js';\nimport { createField } from './field-constructor.js';\nimport { TupleN } from '../../util/types.js';\n\nexport { createVarField, exists, existsAsync, existsOne };\n\n/**\n * Witness `size` field element variables by passing a callback that returns `size` bigints.\n *\n * Note: this is called \"exists\" because in a proof, you use it like this:\n * > \"I prove that there exists x, such that (some statement)\"\n */\nfunction exists<N extends number, C extends () => TupleN<bigint, N>>(\n  size: N,\n  compute: C\n): TupleN<VarField, N> {\n  // enter prover block\n  let finish = Snarky.run.enterAsProver(size);\n\n  if (!Snarky.run.inProver()) {\n    // step outside prover block and create vars: compile case\n    let vars = MlArray.mapFrom(finish(MlOption()), createVarField);\n    return TupleN.fromArray(size, vars);\n  }\n\n  // run the callback to get values to witness\n  let values = compute();\n  if (values.length !== size)\n    throw Error(`Expected witnessed values of length ${size}, got ${values.length}.`);\n\n  // note: here, we deliberately reduce the bigint values modulo the field size\n  // this makes it easier to use normal arithmetic in low-level gadgets,\n  // i.e. you can just witness x - y and it will be a field subtraction\n  let inputValues = MlArray.mapTo(values, FieldConst.fromBigint);\n\n  // step outside prover block and create vars: prover case\n  let fieldVars = finish(MlOption(inputValues));\n  let vars = MlArray.mapFrom(fieldVars, createVarField);\n  return TupleN.fromArray(size, vars);\n}\n\n/**\n * Variant of {@link exists} that witnesses 1 field element.\n */\nfunction existsOne(compute: () => bigint): VarField {\n  return exists(1, () => [compute()])[0];\n}\n\n/**\n * Async variant of {@link exists}, which allows an async callback.\n */\nasync function existsAsync<N extends number, C extends () => Promise<TupleN<bigint, N>>>(\n  size: N,\n  compute: C\n): Promise<TupleN<VarField, N>> {\n  // enter prover block\n  let finish = Snarky.run.enterAsProver(size);\n\n  if (!Snarky.run.inProver()) {\n    let vars = MlArray.mapFrom(finish(MlOption()), createVarField);\n    return TupleN.fromArray(size, vars);\n  }\n\n  // run the async callback to get values to witness\n  let values = await compute();\n  if (values.length !== size)\n    throw Error(`Expected witnessed values of length ${size}, got ${values.length}.`);\n\n  // note: here, we deliberately reduce the bigint values modulo the field size\n  // this makes it easier to use normal arithmetic in low-level gadgets,\n  // i.e. you can just witness x - y and it will be a field subtraction\n  let inputValues = MlArray.mapTo(values, FieldConst.fromBigint);\n\n  let fieldVars = finish(MlOption(inputValues));\n  let vars = MlArray.mapFrom(fieldVars, createVarField);\n  return TupleN.fromArray(size, vars);\n}\n\n// helpers for varfields\n\nfunction createVarField(x: VarFieldVar): VarField {\n  return createField(x) as VarField;\n}\n", "import { Snarky } from '../../bindings.js';\nimport type { Field } from './field.js';\nimport { FieldVar, FieldConst } from './core/fieldvar.js';\nimport { MlArray, MlTuple } from '../ml/base.js';\nimport { exists } from './core/exists.js';\nimport { TupleN } from '../util/types.js';\n\nexport {\n  Gates,\n  rangeCheck0,\n  rangeCheck1,\n  xor,\n  zero,\n  rotate,\n  generic,\n  lookup,\n  foreignFieldAdd,\n  foreignFieldMul,\n  KimchiGateType,\n  addRuntimeTableConfig,\n};\n\nexport { fieldVar };\n\nconst Gates = {\n  rangeCheck0,\n  rangeCheck1,\n  xor,\n  zero,\n  rotate,\n  generic,\n  lookup,\n  foreignFieldAdd,\n  foreignFieldMul,\n  raw,\n  addRuntimeTableConfig,\n};\n\nfunction rangeCheck0(\n  x: Field,\n  xLimbs12: TupleN<Field, 6>,\n  xLimbs2: TupleN<Field, 8>,\n  isCompact: boolean\n) {\n  Snarky.gates.rangeCheck0(\n    x.value,\n    MlTuple.mapTo(xLimbs12, (x) => x.value),\n    MlTuple.mapTo(xLimbs2, (x) => x.value),\n    isCompact ? FieldConst[1] : FieldConst[0]\n  );\n}\n\n/**\n * the rangeCheck1 gate is used in combination with the rangeCheck0,\n * for doing a 3x88-bit range check\n */\nfunction rangeCheck1(v2: Field, v12: Field, vCurr: TupleN<Field, 13>, vNext: TupleN<Field, 15>) {\n  Snarky.gates.rangeCheck1(\n    v2.value,\n    v12.value,\n    MlTuple.mapTo(vCurr, (x) => x.value),\n    MlTuple.mapTo(vNext, (x) => x.value)\n  );\n}\n\nfunction rotate(\n  field: Field,\n  rotated: Field,\n  excess: Field,\n  limbs: [Field, Field, Field, Field],\n  crumbs: [Field, Field, Field, Field, Field, Field, Field, Field],\n  two_to_rot: bigint\n) {\n  Snarky.gates.rotate(\n    field.value,\n    rotated.value,\n    excess.value,\n    MlArray.to(limbs.map((x) => x.value)),\n    MlArray.to(crumbs.map((x) => x.value)),\n    FieldConst.fromBigint(two_to_rot)\n  );\n}\n\n/**\n * Asserts that 16 bit limbs of input two elements are the correct XOR output\n */\nfunction xor(\n  input1: Field,\n  input2: Field,\n  outputXor: Field,\n  in1_0: Field,\n  in1_1: Field,\n  in1_2: Field,\n  in1_3: Field,\n  in2_0: Field,\n  in2_1: Field,\n  in2_2: Field,\n  in2_3: Field,\n  out0: Field,\n  out1: Field,\n  out2: Field,\n  out3: Field\n) {\n  Snarky.gates.xor(\n    input1.value,\n    input2.value,\n    outputXor.value,\n    in1_0.value,\n    in1_1.value,\n    in1_2.value,\n    in1_3.value,\n    in2_0.value,\n    in2_1.value,\n    in2_2.value,\n    in2_3.value,\n    out0.value,\n    out1.value,\n    out2.value,\n    out3.value\n  );\n}\n\n/**\n * [Generic gate](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=foreignfield#double-generic-gate)\n * The vanilla PLONK gate that allows us to do operations like:\n * * addition of two registers (into an output register)\n * * multiplication of two registers\n * * equality of a register with a constant\n *\n * More generally, the generic gate controls the coefficients (denoted `c_`) in the equation:\n *\n * `c_l*l + c_r*r + c_o*o + c_m*l*r + c_c === 0`\n */\nfunction generic(\n  coefficients: {\n    left: bigint | FieldConst;\n    right: bigint | FieldConst;\n    out: bigint | FieldConst;\n    mul: bigint | FieldConst;\n    const: bigint | FieldConst;\n  },\n  inputs: {\n    left: Field | FieldVar;\n    right: Field | FieldVar;\n    out: Field | FieldVar;\n  }\n) {\n  Snarky.gates.generic(\n    fieldConst(coefficients.left),\n    fieldVar(inputs.left),\n    fieldConst(coefficients.right),\n    fieldVar(inputs.right),\n    fieldConst(coefficients.out),\n    fieldVar(inputs.out),\n    fieldConst(coefficients.mul),\n    fieldConst(coefficients.const)\n  );\n}\n\n/**\n * **[lookup constraint](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=lookup%20gate#lookup)**\n *\n * Lookups allow you to check if a single value, or a series of values, are part of a table. The first case is useful to check for checking if a value belongs to a range (from 0 to 1,000, for example), whereas the second case is useful to check truth tables (for example, checking that three values can be found in the rows of an XOR table) or write and read from a memory vector (where one column is an index, and the other is the value stored at that index).\n *\n * @param tableId the [id](https://github.com/o1-labs/proof-systems/blob/master/kimchi/src/circuits/lookup/tables/mod.rs) of the lookup table.\n * @param index0 the index of the first value to lookup.\n * @param value0 the first value to lookup.\n * @param index1 the index of the second value to lookup.\n * @param value1 the second value to lookup.\n * @param index2 the index of the third value to lookup.\n * @param value2 the third value to lookup.\n *\n */\nfunction lookup(\n  tableId: Field,\n  index0: Field,\n  value0: Field,\n  index1: Field,\n  value1: Field,\n  index2: Field,\n  value2: Field\n) {\n  Snarky.gates.lookup([\n    0,\n    tableId.value,\n    index0.value,\n    value0.value,\n    index1.value,\n    value1.value,\n    index2.value,\n    value2.value,\n  ]);\n}\n\nfunction zero(a: Field, b: Field, c: Field) {\n  raw(KimchiGateType.Zero, [a, b, c], []);\n}\n\n/**\n * bigint addition which allows for field overflow and carry\n *\n * - `l01 + sign*r01 - overflow*f01 - carry*2^2l === r01`\n * - `l2  + sign*r2  - overflow*f2  + carry      === r2`\n * - overflow is 0 or sign\n * - carry is 0, 1 or -1\n *\n * assumes that the result is placed in the first 3 cells of the next row!\n */\nfunction foreignFieldAdd({\n  left,\n  right,\n  overflow,\n  carry,\n  modulus,\n  sign,\n}: {\n  left: TupleN<Field, 3>;\n  right: TupleN<Field, 3>;\n  overflow: Field;\n  carry: Field;\n  modulus: TupleN<bigint, 3>;\n  sign: 1n | -1n;\n}) {\n  Snarky.gates.foreignFieldAdd(\n    MlTuple.mapTo(left, (x) => x.value),\n    MlTuple.mapTo(right, (x) => x.value),\n    overflow.value,\n    carry.value,\n    MlTuple.mapTo(modulus, FieldConst.fromBigint),\n    FieldConst.fromBigint(sign)\n  );\n}\n\n/**\n * Foreign field multiplication\n */\nfunction foreignFieldMul(inputs: {\n  left: TupleN<Field, 3>;\n  right: TupleN<Field, 3>;\n  remainder: TupleN<Field, 2>;\n  quotient: TupleN<Field, 3>;\n  quotientHiBound: Field;\n  product1: TupleN<Field, 3>;\n  carry0: Field;\n  carry1p: TupleN<Field, 7>;\n  carry1c: TupleN<Field, 4>;\n  foreignFieldModulus2: bigint;\n  negForeignFieldModulus: TupleN<bigint, 3>;\n}) {\n  let {\n    left,\n    right,\n    remainder,\n    quotient,\n    quotientHiBound,\n    product1,\n    carry0,\n    carry1p,\n    carry1c,\n    foreignFieldModulus2,\n    negForeignFieldModulus,\n  } = inputs;\n\n  Snarky.gates.foreignFieldMul(\n    MlTuple.mapTo(left, (x) => x.value),\n    MlTuple.mapTo(right, (x) => x.value),\n    MlTuple.mapTo(remainder, (x) => x.value),\n    MlTuple.mapTo(quotient, (x) => x.value),\n    quotientHiBound.value,\n    MlTuple.mapTo(product1, (x) => x.value),\n    carry0.value,\n    MlTuple.mapTo(carry1p, (x) => x.value),\n    MlTuple.mapTo(carry1c, (x) => x.value),\n    FieldConst.fromBigint(foreignFieldModulus2),\n    MlTuple.mapTo(negForeignFieldModulus, FieldConst.fromBigint)\n  );\n}\n\nfunction raw(kind: KimchiGateType, values: Field[], coefficients: bigint[]) {\n  let n = values.length;\n  let padding = exists(15 - n, () => Array(15 - n).fill(0n));\n  Snarky.gates.raw(\n    kind,\n    MlArray.to(values.concat(padding).map((x) => x.value)),\n    MlArray.to(coefficients.map(FieldConst.fromBigint))\n  );\n}\n\n/**\n * Configures a runtime table with identifier `id` and indices `firstColumn`.\n *\n * **Note**: id 0 and 1 are reserved values, do not use them.\n *\n * @param id\n * @param firstColumn\n * \n * @deprecated {@link addRuntimeTableConfig} is deprecated in favor of RuntimeTable\n * class, which provides a more ergonomic API.\n */\nfunction addRuntimeTableConfig(id: number, firstColumn: bigint[]) {\n  Snarky.gates.addRuntimeTableConfig(\n    id,\n    MlArray.to(firstColumn.map((x) => FieldConst.fromBigint(x)))\n  );\n}\n\nenum KimchiGateType {\n  Zero,\n  Generic,\n  Poseidon,\n  CompleteAdd,\n  VarBaseMul,\n  EndoMul,\n  EndoMulScalar,\n  Lookup,\n  CairoClaim,\n  CairoInstruction,\n  CairoFlags,\n  CairoTransition,\n  RangeCheck0,\n  RangeCheck1,\n  ForeignFieldAdd,\n  ForeignFieldMul,\n  Xor16,\n  Rot64,\n}\n\n// helper\n\nfunction fieldVar(x: Field | FieldVar | bigint): FieldVar {\n  if (typeof x === 'bigint') return FieldVar.constant(x);\n  return Array.isArray(x) ? x : x.value;\n}\nfunction fieldConst(x: bigint | FieldConst): FieldConst {\n  return typeof x === 'bigint' ? FieldConst.fromBigint(x) : x;\n}\n", "import type { Field, VarField } from '../field.js';\nimport { FieldVar, VarFieldVar } from '../core/fieldvar.js';\nimport { Tuple } from '../../util/types.js';\nimport type { Bool } from '../bool.js';\nimport { fieldVar } from '../gates.js';\nimport { existsOne } from '../core/exists.js';\nimport { createField, isBool } from '../core/field-constructor.js';\n\nexport { toVars, toVar, isVar, assert, bitSlice, bit, divideWithRemainder, packBits, isConstant };\n\n/**\n * @internal\n * Given a Field, collapse its AST to a pure Var. See {@link FieldVar}.\n *\n * This is useful to prevent rogue Generic gates added in the middle of gate chains,\n * which are caused by snarky auto-resolving constants, adds and scales to vars.\n *\n * Same as `Field.seal()` with the difference that `seal()` leaves constants as is.\n */\nfunction toVar(x_: Field | FieldVar | bigint): VarField {\n  let x = createField(x_);\n  // don't change existing vars\n  if (isVar(x)) return x;\n  let xVar = existsOne(() => x.toBigInt());\n  xVar.assertEquals(x);\n  return xVar;\n}\n\nfunction isVar(x: FieldVar | bigint): x is VarFieldVar;\nfunction isVar(x: Field | bigint): x is VarField;\nfunction isVar(x: Field | FieldVar | bigint) {\n  return FieldVar.isVar(fieldVar(x));\n}\n\n/**\n * Apply {@link toVar} to each element of a tuple.\n */\nfunction toVars<T extends Tuple<Field | bigint>>(fields: T): { [k in keyof T]: VarField } {\n  return Tuple.map(fields, toVar);\n}\n\n/**\n * Assert that a statement is true. If the statement is false, throws an error with the given message.\n * Can be used in provable code.\n */\nfunction assert(stmt: boolean | Bool, message?: string): asserts stmt {\n  if (typeof stmt === 'boolean') {\n    if (!stmt) throw Error(message ?? 'Assertion failed');\n  } else {\n    stmt.assertTrue(message ?? 'Assertion failed');\n  }\n}\n\nfunction bitSlice(x: bigint, start: number, length: number) {\n  return (x >> BigInt(start)) & ((1n << BigInt(length)) - 1n);\n}\n\nfunction bit(x: bigint, i: number) {\n  return (x >> BigInt(i)) & 1n;\n}\n\nfunction divideWithRemainder(numerator: bigint, denominator: bigint) {\n  const quotient = numerator / denominator;\n  const remainder = numerator - denominator * quotient;\n  return { quotient, remainder };\n}\n\n// pack bools into a single field element\n\n/**\n * Helper function to provably pack bits into a single field element.\n * Just returns the sum without any boolean checks.\n */\nfunction packBits(bits: (Field | Bool)[]): Field {\n  let n = bits.length;\n  let sum = createField(0n);\n  for (let i = 0; i < n; i++) {\n    let bit = bits[i];\n    if (isBool(bit)) bit = bit.toField();\n    sum = sum.add(bit.mul(1n << BigInt(i)));\n  }\n  return sum.seal();\n}\n\nfunction isConstant(...args: (Field | Bool)[]): boolean {\n  return args.every((x) => x.isConstant());\n}\n", "import { createField } from '../core/field-constructor.js';\nimport type { Field } from '../field.js';\n\nexport {\n  Provable,\n  ProvablePure,\n  ProvableWithEmpty,\n  ProvableHashable,\n  ProvableType,\n  ProvableTypePure,\n  ToProvable,\n  WithProvable,\n};\n\n/**\n * `Provable<T>` is the general interface for provable types in o1js.\n *\n * `Provable<T>` describes how a type `T` is made up of {@link Field} elements and \"auxiliary\" (non-provable) data.\n *\n * `Provable<T>` is the required input type in several methods in o1js.\n * One convenient way to create a `Provable<T>` is using `Struct`.\n *\n * All built-in provable types in o1js ({@link Field}, {@link Bool}, etc.) are instances of `Provable<T>` as well.\n *\n * Note: These methods are meant to be used by the library internally and are not directly when writing provable code.\n */\ntype Provable<T, TValue = any> = {\n  /**\n   * A function that takes `value`, an element of type `T`, as argument and returns\n   * an array of {@link Field} elements that make up the provable data of `value`.\n   *\n   * @param value - the element of type `T` to generate the {@link Field} array from.\n   *\n   * @return A {@link Field} array describing how this `T` element is made up of {@link Field} elements.\n   */\n  toFields: (value: T) => Field[];\n\n  /**\n   * A function that takes `value` (optional), an element of type `T`, as argument and\n   * returns an array of any type that make up the \"auxiliary\" (non-provable) data of `value`.\n   *\n   * @param value - the element of type `T` to generate the auxiliary data array from, optional.\n   * If not provided, a default value for auxiliary data is returned.\n   *\n   * @return An array of any type describing how this `T` element is made up of \"auxiliary\" (non-provable) data.\n   */\n  toAuxiliary: (value?: T) => any[];\n\n  /**\n   * A function that returns an element of type `T` from the given provable and \"auxiliary\" data.\n   *\n   * This function is the reverse operation of calling {@link toFields} and {@link toAuxiliary} methods on an element of type `T`.\n   *\n   * @param fields - an array of {@link Field} elements describing the provable data of the new `T` element.\n   * @param aux - an array of any type describing the \"auxiliary\" data of the new `T` element, optional.\n   *\n   * @return An element of type `T` generated from the given provable and \"auxiliary\" data.\n   */\n  fromFields: (fields: Field[], aux: any[]) => T;\n\n  /**\n   * Return the size of the `T` type in terms of {@link Field} type, as {@link Field} is the primitive type.\n   *\n   * @return A `number` representing the size of the `T` type in terms of {@link Field} type.\n   */\n  sizeInFields(): number;\n\n  /**\n   * Add assertions to the proof to check if `value` is a valid member of type `T`.\n   * This function does not return anything, instead it creates any number of assertions to prove that `value` is a valid member of the type `T`.\n   *\n   * For instance, calling check function on the type {@link Bool} asserts that the value of the element is either 1 or 0.\n   *\n   * @param value - the element of type `T` to put assertions on.\n   */\n  check: (value: T) => void;\n\n  /**\n   * Convert provable type to a normal JS type.\n   */\n  toValue: (x: T) => TValue;\n\n  /**\n   * Convert provable type from a normal JS type.\n   */\n  fromValue: (x: TValue | T) => T;\n\n  /**\n   * Optional method which transforms a provable type into its canonical representation.\n   *\n   * This is needed for types that have multiple representations of the same underlying value,\n   * and might even not have perfect completeness for some of those representations.\n   *\n   * An example is the `ForeignField` class, which allows non-native field elements to exist in unreduced form.\n   * The unreduced form is not perfectly complete, for example, addition of two unreduced field elements can cause a prover error.\n   *\n   * Specific protocols need to be able to protect themselves against incomplete operations at all costs.\n   * For example, when using actions and reducer, the reducer must be able to produce a proof regardless of the input action.\n   * `toCanonical()` converts any input into a safe form and enables us to handle cases like this generically.\n   *\n   * Note: For most types, this method is the identity function.\n   * The identity function will also be used when the `toCanonical()` is not present on a type.\n   */\n  toCanonical?: (x: T) => T;\n};\n\n/**\n * `ProvablePure<T>` is a special kind of {@link Provable} interface, where the \"auxiliary\" (non-provable) data is empty.\n * This means the type consists only of field elements, in that sense it is \"pure\".\n * Any instance of `ProvablePure<T>` is also an instance of `Provable<T>` where the \"auxiliary\" data is empty.\n *\n * Examples where `ProvablePure<T>` is required are types of on-chain state, events and actions.\n */\ntype ProvablePure<T, TValue = any> = Omit<Provable<T, TValue>, 'fromFields'> & {\n  fromFields: (fields: Field[]) => T;\n};\n\ntype ProvableWithEmpty<T, TValue = any> = Provable<T, TValue> & {\n  empty: () => T;\n};\n\ntype HashInput = { fields?: Field[]; packed?: [Field, number][] };\n\ntype ProvableHashable<T, TValue = any> = ProvableWithEmpty<T, TValue> & {\n  toInput: (x: T) => HashInput;\n};\n\n// helpers to accept { provable: Type } instead of Type\n\ntype WithProvable<A> = { provable: A } | A;\n\ntype ProvableType<T = any, V = any> = WithProvable<Provable<T, V>>;\ntype ProvableTypePure<T = any, V = any> = WithProvable<ProvablePure<T, V>>;\n\ntype ToProvable<A extends WithProvable<any>> = A extends {\n  provable: infer P;\n}\n  ? P\n  : A;\n\nconst ProvableType = {\n  get<A extends WithProvable<any>>(type: A): ToProvable<A> {\n    return (\n      (typeof type === 'object' || typeof type === 'function') &&\n      type !== null &&\n      'provable' in type\n        ? type.provable\n        : type\n    ) as ToProvable<A>;\n  },\n  /**\n   * Create some value of type `T` from its provable type description.\n   */\n  synthesize<T>(type: ProvableType<T>): T {\n    let provable = ProvableType.get(type);\n    return provable.fromFields(\n      Array(provable.sizeInFields()).fill(createField(0)),\n      provable.toAuxiliary()\n    );\n  },\n};\n", "import {\n  Provable,\n  ProvableHashable,\n  ProvablePure,\n  ProvableType,\n  ToProvable,\n} from './provable-intf.js';\nimport type { Field } from '../wrapped.js';\nimport {\n  createDerivers,\n  NonMethods,\n  InferProvable as GenericInferProvable,\n  InferJson,\n  InferredProvable as GenericInferredProvable,\n  IsPure as GenericIsPure,\n  NestedProvable as GenericNestedProvable,\n  createHashInput,\n  Constructor,\n  InferValue,\n  InferJsonNested,\n  InferValueNested,\n  InferProvableNested,\n} from '../../../bindings/lib/provable-generic.js';\nimport { Tuple } from '../../util/types.js';\nimport { GenericHashInput } from '../../../bindings/lib/generic.js';\n\n// external API\nexport {\n  ProvableExtended,\n  ProvableInferPureFrom,\n  provable,\n  provablePure,\n  provableTuple,\n  provableFromClass,\n  provableExtends,\n};\n\n// internal API\nexport {\n  NonMethods,\n  HashInput,\n  InferProvable,\n  InferProvableType,\n  InferJson,\n  InferredProvable,\n  IsPure,\n  NestedProvable,\n  mapValue,\n};\n\ntype ProvableExtension<T, TJson = any> = {\n  toInput: (x: T) => { fields?: Field[]; packed?: [Field, number][] };\n  toJSON: (x: T) => TJson;\n  fromJSON: (x: TJson) => T;\n  empty: () => T;\n};\ntype ProvableExtended<T, TValue = any, TJson = any> = Provable<T, TValue> &\n  ProvableExtension<T, TJson>;\ntype ProvablePureExtended<T, TValue = any, TJson = any> = ProvablePure<T, TValue> &\n  ProvableExtension<T, TJson>;\n\ntype InferProvable<T> = GenericInferProvable<T, Field>;\ntype InferProvableType<T extends ProvableType> = InferProvable<ToProvable<T>>;\ntype InferredProvable<T> = GenericInferredProvable<T, Field>;\ntype IsPure<T> = GenericIsPure<T, Field>;\ntype ProvableInferPureFrom<A, T, V> = IsPure<A> extends true ? ProvablePure<T, V> : Provable<T, V>;\n\ntype HashInput = GenericHashInput<Field>;\nconst HashInput = createHashInput<Field>();\n\ntype NestedProvable = GenericNestedProvable<Field>;\n\nconst { provable } = createDerivers<Field>();\n\nfunction provablePure<A>(\n  typeObj: A\n): ProvablePureExtended<InferProvable<A>, InferValue<A>, InferJson<A>> {\n  return provable(typeObj, { isPure: true }) as any;\n}\n\nfunction provableTuple<T extends Tuple<any>>(types: T): InferredProvable<T> {\n  return provable(types) as any;\n}\n\nfunction provableFromClass<\n  A extends NestedProvable,\n  T extends InferProvableNested<Field, A>,\n  V extends InferValueNested<Field, A>,\n  J extends InferJsonNested<Field, A>,\n>(\n  Class: Constructor<T> & { check?: (x: T) => void; empty?: () => T },\n  typeObj: A\n): IsPure<A> extends true ? ProvablePureExtended<T, V, J> : ProvableExtended<T, V, J> {\n  let raw: ProvableExtended<T, V, J> = provable(typeObj) as any;\n  return {\n    sizeInFields: raw.sizeInFields,\n    toFields: raw.toFields,\n    toAuxiliary: raw.toAuxiliary,\n    fromFields(fields, aux) {\n      return construct(Class, raw.fromFields(fields, aux));\n    },\n    check(value) {\n      if (Class.check !== undefined) {\n        Class.check(value);\n      } else {\n        raw.check(value);\n      }\n    },\n    toValue: raw.toValue,\n    fromValue(x) {\n      return construct(Class, raw.fromValue(x));\n    },\n    toInput: raw.toInput,\n    toJSON: raw.toJSON,\n    fromJSON(x) {\n      return construct(Class, raw.fromJSON(x));\n    },\n    empty() {\n      return Class.empty !== undefined ? Class.empty() : construct(Class, raw.empty());\n    },\n  } satisfies ProvableExtended<T, V, J> as any;\n}\n\nfunction construct<Raw, T extends Raw>(Class: Constructor<T>, value: Raw): T {\n  let instance = Object.create(Class.prototype);\n  return Object.assign(instance, value);\n}\n\nfunction provableExtends<A extends ProvableHashable<any>, T extends InferProvable<A>, S extends T>(\n  S: new (t: T) => S,\n  base: A\n) {\n  return {\n    sizeInFields() {\n      return base.sizeInFields();\n    },\n    toFields(value: S | T) {\n      return base.toFields(value);\n    },\n    toAuxiliary(value?: S | T) {\n      return base.toAuxiliary(value);\n    },\n    fromFields(fields, aux) {\n      return new S(base.fromFields(fields, aux));\n    },\n    check(value: S | T) {\n      base.check(value);\n    },\n    toValue(value: S | T) {\n      return base.toValue(value);\n    },\n    fromValue(value) {\n      return new S(base.fromValue(value));\n    },\n    empty() {\n      return new S(base.empty());\n    },\n    toInput(value: S | T) {\n      return base.toInput(value);\n    },\n  } satisfies ProvableHashable<S, InferValue<A>>;\n}\n\nfunction mapValue<\n  A extends ProvableHashable<any>,\n  V extends InferValue<A>,\n  W,\n  T extends InferProvable<A>,\n>(provable: A, there: (x: V) => W, back: (x: W | T) => V | T): ProvableHashable<T, W> {\n  return {\n    sizeInFields() {\n      return provable.sizeInFields();\n    },\n    toFields(value) {\n      return provable.toFields(value);\n    },\n    toAuxiliary(value) {\n      return provable.toAuxiliary(value);\n    },\n    fromFields(fields, aux) {\n      return provable.fromFields(fields, aux);\n    },\n    check(value) {\n      provable.check(value);\n    },\n    toValue(value) {\n      return there(provable.toValue(value));\n    },\n    fromValue(value) {\n      return provable.fromValue(back(value));\n    },\n    empty() {\n      return provable.empty();\n    },\n    toInput(value) {\n      return provable.toInput(value);\n    },\n  };\n}\n", "import type { Field } from '../field.js';\nimport type { FlexibleProvable, InferProvable } from './struct.js';\nimport { Provable, ProvableType, ToProvable } from './provable-intf.js';\nimport { inCheckedComputation, snarkContext } from '../core/provable-context.js';\nimport { exists, existsAsync } from '../core/exists.js';\nimport { From } from '../../../bindings/lib/provable-generic.js';\nimport { TupleN } from '../../util/types.js';\nimport { createField } from '../core/field-constructor.js';\n\nexport { witness, witnessAsync, witnessFields };\n\nfunction witness<\n  A extends ProvableType<any, any>,\n  T extends From<ToProvable<A>> = From<ToProvable<A>>,\n>(type: A, compute: () => T): InferProvable<ToProvable<A>> {\n  type S = InferProvable<ToProvable<A>>;\n  const provable: Provable<S> = ProvableType.get(type);\n  let ctx = snarkContext.get();\n\n  // outside provable code, we just call the callback and return its cloned result\n  if (!inCheckedComputation() || ctx.inWitnessBlock) {\n    return clone(provable, provable.fromValue(compute()));\n  }\n  let proverValue: S | undefined = undefined;\n  let fields: Field[];\n\n  let id = snarkContext.enter({ ...ctx, inWitnessBlock: true });\n  try {\n    fields = exists(provable.sizeInFields(), () => {\n      let value = provable.fromValue(compute());\n      proverValue = value;\n      let fields = provable.toFields(value);\n      return fields.map((x) => x.toBigInt());\n    });\n  } finally {\n    snarkContext.leave(id);\n  }\n\n  // rebuild the value from its fields (which are now variables) and aux data\n  let aux = provable.toAuxiliary(proverValue);\n  let value = provable.fromFields(fields, aux);\n\n  // add type-specific constraints\n  provable.check(value);\n\n  return value;\n}\n\nasync function witnessAsync<\n  A extends ProvableType<any, any>,\n  T extends From<ToProvable<A>> = From<ToProvable<A>>,\n>(type: A, compute: () => Promise<T>): Promise<T> {\n  type S = InferProvable<ToProvable<A>>;\n  const provable: Provable<S> = ProvableType.get(type);\n\n  let ctx = snarkContext.get();\n\n  // outside provable code, we just call the callback and return its cloned result\n  if (!inCheckedComputation() || ctx.inWitnessBlock) {\n    let value: T = await compute();\n    return clone(provable, provable.fromValue(value));\n  }\n  let proverValue: S | undefined = undefined;\n  let fields: Field[];\n\n  // call into `existsAsync` to witness the raw field elements\n  let id = snarkContext.enter({ ...ctx, inWitnessBlock: true });\n  try {\n    fields = await existsAsync(provable.sizeInFields(), async () => {\n      let value: S = provable.fromValue(await compute());\n      proverValue = value;\n      let fields = provable.toFields(value);\n      return fields.map((x) => x.toBigInt());\n    });\n  } finally {\n    snarkContext.leave(id);\n  }\n\n  // rebuild the value from its fields (which are now variables) and aux data\n  let aux = provable.toAuxiliary(proverValue);\n  let value = provable.fromFields(fields, aux);\n\n  // add type-specific constraints\n  provable.check(value);\n\n  return value;\n}\n\nfunction witnessFields<N extends number, C extends () => TupleN<bigint | Field, N>>(\n  size: N,\n  compute: C\n): TupleN<Field, N> {\n  // outside provable code, we just call the callback and return its cloned result\n  if (!inCheckedComputation() || snarkContext.get().inWitnessBlock) {\n    let fields = compute().map((x) => createField(x));\n    return TupleN.fromArray(size, fields);\n  }\n\n  // call into `exists` to witness the field elements\n  return exists(size, () => {\n    let fields = compute().map((x) => (typeof x === 'bigint' ? x : x.toBigInt()));\n    return TupleN.fromArray(size, fields);\n  });\n}\n\nfunction clone<T, S extends FlexibleProvable<T>>(type: S, value: T): T {\n  let fields = type.toFields(value);\n  let aux = type.toAuxiliary?.(value) ?? [];\n  return (type as Provable<T>).fromFields(fields, aux);\n}\n", "/**\n * {@link Provable} is\n * - a namespace with tools for writing provable code\n * - the main interface for types that can be used in provable code\n */\nimport { Bool } from './bool.js';\nimport { Field } from './field.js';\nimport { Provable as Provable_, ProvableType } from './types/provable-intf.js';\nimport type { FlexibleProvable, FlexibleProvableType, ProvableExtended } from './types/struct.js';\nimport { Context } from '../util/global-context.js';\nimport {\n  HashInput,\n  InferJson,\n  InferProvableType,\n  InferredProvable,\n} from './types/provable-derivers.js';\nimport {\n  inCheckedComputation,\n  inProver,\n  asProver,\n  constraintSystem,\n  generateWitness,\n} from './core/provable-context.js';\nimport { witness, witnessAsync, witnessFields } from './types/witness.js';\nimport { InferValue } from '../../bindings/lib/provable-generic.js';\nimport { ToProvable } from '../../lib/provable/types/provable-intf.js';\n\n// external API\nexport { Provable };\n\n// internal API\nexport { memoizationContext, MemoizationContext, memoizeWitness, getBlindingValue };\n\n/**\n * `Provable<T>` is the general interface for provable types in o1js.\n *\n * `Provable<T>` describes how a type `T` is made up of {@link Field} elements and \"auxiliary\" (non-provable) data.\n *\n * `Provable<T>` is the required input type in several methods in o1js.\n * One convenient way to create a `Provable<T>` is using `Struct`.\n *\n * All built-in provable types in o1js ({@link Field}, {@link Bool}, etc.) are instances of `Provable<T>` as well.\n *\n * Note: These methods are meant to be used by the library internally and are not directly when writing provable code.\n */\ntype Provable<T, TValue = any> = Provable_<T, TValue>;\n\nconst Provable = {\n  /**\n   * Create a new witness. A witness, or variable, is a value that is provided as input\n   * by the prover. This provides a flexible way to introduce values from outside into the circuit.\n   * However, note that nothing about how the value was created is part of the proof - `Provable.witness`\n   * behaves exactly like user input. So, make sure that after receiving the witness you make any assertions\n   * that you want to associate with it.\n   *\n   * The only constraints enforced on the witnessed value come from its type. This means\n   * the witnessed value may be anything which satisfies the constraints defined in `Type.check()`.\n   * Note that for composite types like ({@link Struct}s, the\n   * default `Type.check()` method calls `check()` on each {@link Struct} field.\n   *\n   * **Warning:** Be *extremely wary* of any custom `check()` methods, which may have forgotten\n   * to call `check()` on sub-components of the {@link Struct}.\n   *\n   * @example\n   * Example for re-implementing `Field.inv` with the help of `witness`:\n   * ```ts\n   * let invX = Provable.witness(Field, () => {\n   *   // compute the inverse of `x` outside the circuit, however you like!\n   *   return Field.inv(x);\n   * }\n   * // prove that `invX` is really the inverse of `x`:\n   * invX.mul(x).assertEquals(1);\n   * ```\n   *\n   * Example for decomposing a 64-bit integer into two 32-bit limbs. {@link Provable.witness} will\n   * prove that the two limbs are actually 32-bits, ensuring the decomposition is unique.\n   * ```ts\n   * function decompose(value: UInt64) {\n   *   // get two arbitrary 32-bit values from the prover\n   *   let lowerLimb = Provable.witness(UInt32, () => {\n   *     return value.and(new UInt64(0xffffffffn)).toUInt32();\n   *   });\n   *   let upperLimb = Provable.witness(UInt32, () => {\n   *     return value\n   *       .and(new UInt64(0xffffffff00000000n))\n   *       .div(2 ** 32)\n   *       .toUInt32();\n   *   });\n   *   // prove the 32-bit lower and upper limbs match the 64-bit value\n   *   value.assertEquals(\n   *     lowerLimb\n   *       .toUInt64()\n   *       .add(upperLimb.toUInt64().mul(UInt64.from(2n ** 32n)))\n   *   );\n   * }\n   * ```\n   *\n   * Modified example for decomposing a 64-bit integer into two 32-bit limbs.\n   * This time we use a {@link Struct} to get both 32-bit values from the prover at once,\n   * while still proving each limb is actually 32 bits.\n   * ```ts\n   * class Decomposition extends Struct({\n   *   lower: UInt32,\n   *   upper: UInt32,\n   * }) {}\n   *\n   * function decompose(value: UInt64) {\n   *   // get two arbitrary 32-bit values from the prover\n   *   let limbs = Provable.witness(Decomposition, () => {\n   *     return new Decomposition({\n   *       lower: value.and(new UInt64(0xffffffffn)).toUInt32(),\n   *       upper: value\n   *         .and(new UInt64(0xffffffff00000000n))\n   *         .div(2 ** 32)\n   *         .toUInt32(),\n   *     });\n   *   });\n   *   // prove the 32-bit lower and upper limbs match the 64-bit value\n   *   value.assertEquals(\n   *     limbs.lower\n   *       .toUInt64()\n   *       .add(limbs.upper.toUInt64().mul(UInt64.from(2n ** 32n)))\n   *   );\n   * }\n   * ```\n   */\n  witness,\n  /**\n   * Witness a tuple of field elements. This works just like {@link Provable.witness},\n   * but optimized for witnessing plain field elements, which is especially common\n   * in low-level provable code.\n   */\n  witnessFields,\n  /**\n   * Create a new witness from an async callback.\n   *\n   * See {@link Provable.witness} for more information.\n   */\n  witnessAsync,\n  /**\n   * Proof-compatible if-statement.\n   * This behaves like a ternary conditional statement in JS.\n   *\n   * **Warning**: Since `Provable.if()` is a normal JS function call, both the if and the else branch\n   * are evaluated before calling it. Therefore, you can't use this function\n   * to guard against execution of one of the branches. It only allows you to pick one of two values.\n   *\n   * @example\n   * ```ts\n   * const condition = Bool(true);\n   * const result = Provable.if(condition, Field(1), Field(2)); // returns Field(1)\n   * ```\n   */\n  if: if_,\n  /**\n   * Generalization of {@link Provable.if} for choosing between more than two different cases.\n   * It takes a \"mask\", which is an array of `Bool`s that contains only one `true` element, a type/constructor, and an array of values of that type.\n   * The result is that value which corresponds to the true element of the mask.\n   * @example\n   * ```ts\n   * let x = Provable.switch([Bool(false), Bool(true)], Field, [Field(1), Field(2)]);\n   * x.assertEquals(2);\n   * ```\n   */\n  switch: switch_,\n  /**\n   * Asserts that two values are equal.\n   * @example\n   * ```ts\n   * class MyStruct extends Struct({ a: Field, b: Bool }) {};\n   * const a: MyStruct = { a: Field(0), b: Bool(false) };\n   * const b: MyStruct = { a: Field(1), b: Bool(true) };\n   * Provable.assertEqual(MyStruct, a, b);\n   * ```\n   */\n  assertEqual,\n  /**\n   * Asserts that two values are equal, if an enabling condition is true.\n   *\n   * If the condition is false, the assertion is skipped.\n   */\n  assertEqualIf,\n  /**\n   * Checks if two elements are equal.\n   * @example\n   * ```ts\n   * class MyStruct extends Struct({ a: Field, b: Bool }) {};\n   * const a: MyStruct = { a: Field(0), b: Bool(false) };\n   * const b: MyStruct = { a: Field(1), b: Bool(true) };\n   * const isEqual = Provable.equal(MyStruct, a, b);\n   * ```\n   */\n  equal,\n  /**\n   * Creates a {@link Provable} for a generic array.\n   * @example\n   * ```ts\n   * const ProvableArray = Provable.Array(Field, 5);\n   * ```\n   */\n  Array: provableArray,\n  /**\n   * @internal\n   * Check whether a value is constant.\n   * See {@link FieldVar} for more information about constants and variables.\n   *\n   * @example\n   * ```ts\n   * let x = Field(42);\n   * Provable.isConstant(Field, x); // true\n   * ```\n   */\n  isConstant,\n  /**\n   * Interface to log elements within a circuit. Similar to `console.log()`.\n   * @example\n   * ```ts\n   * const element = Field(42);\n   * Provable.log(element);\n   * ```\n   */\n  log,\n  /**\n   * Runs code as a prover.\n   * @example\n   * ```ts\n   * Provable.asProver(() => {\n   *   // Your prover code here\n   * });\n   * ```\n   */\n  asProver,\n  /**\n   * Runs provable code quickly, without creating a proof, but still checking whether constraints are satisfied.\n   * @example\n   * ```ts\n   * await Provable.runAndCheck(() => {\n   *   // Your code to check here\n   * });\n   * ```\n   */\n  async runAndCheck(f: (() => Promise<void>) | (() => void)) {\n    await generateWitness(f, { checkConstraints: true });\n  },\n  /**\n   * Runs provable code quickly, without creating a proof, and not checking whether constraints are satisfied.\n   * @example\n   * ```ts\n   * await Provable.runUnchecked(() => {\n   *   // Your code to run here\n   * });\n   * ```\n   */\n  async runUnchecked(f: (() => Promise<void>) | (() => void)) {\n    await generateWitness(f, { checkConstraints: false });\n  },\n  /**\n   * Returns information about the constraints created by the callback function.\n   * @example\n   * ```ts\n   * const result = await Provable.constraintSystem(circuit);\n   * console.log(result);\n   * ```\n   */\n  constraintSystem,\n  /**\n   * Checks if the code is run in prover mode.\n   * @example\n   * ```ts\n   * if (Provable.inProver()) {\n   *   // Prover-specific code\n   * }\n   * ```\n   */\n  inProver,\n  /**\n   * Checks if the code is run in checked computation mode.\n   * @example\n   * ```ts\n   * if (Provable.inCheckedComputation()) {\n   *   // Checked computation-specific code\n   * }\n   * ```\n   */\n  inCheckedComputation,\n\n  /**\n   * Returns a constant version of a provable type.\n   */\n  toConstant<T>(type: ProvableType<T>, value: T) {\n    type = ProvableType.get(type);\n    return type.fromFields(\n      type.toFields(value).map((x) => x.toConstant()),\n      type.toAuxiliary(value)\n    );\n  },\n\n  /**\n   * Return a canonical version of a value, where\n   * canonical is defined by the `type`.\n   */\n  toCanonical<T>(type: Provable<T>, value: T) {\n    return type.toCanonical?.(value) ?? value;\n  },\n};\n\ntype ToFieldable = { toFields(): Field[] };\n\n// general provable methods\n\nfunction assertEqual<T>(type: FlexibleProvableType<T>, x: T, y: T): void;\nfunction assertEqual<T extends ToFieldable>(x: T, y: T): void;\nfunction assertEqual(typeOrX: any, xOrY: any, yOrUndefined?: any) {\n  if (yOrUndefined === undefined) {\n    return assertEqualImplicit(typeOrX, xOrY);\n  } else {\n    return assertEqualExplicit(typeOrX, xOrY, yOrUndefined);\n  }\n}\nfunction assertEqualImplicit<T extends ToFieldable>(x: T, y: T) {\n  let xs = x.toFields();\n  let ys = y.toFields();\n  let n = checkLength('Provable.assertEqual', xs, ys);\n  for (let i = 0; i < n; i++) {\n    xs[i].assertEquals(ys[i]);\n  }\n}\nfunction assertEqualExplicit<T>(type: ProvableType<T>, x: T, y: T) {\n  type = ProvableType.get(type);\n  let xs = type.toFields(x);\n  let ys = type.toFields(y);\n  for (let i = 0; i < xs.length; i++) {\n    xs[i].assertEquals(ys[i]);\n  }\n}\n\nfunction equal<T>(type: FlexibleProvableType<T>, x: T, y: T) {\n  let provable = ProvableType.get(type) as Provable<T>;\n  // when comparing two values of the same type, we use the type's canonical form\n  // otherwise, the case where `equal()` returns false is misleading (two values can differ as field elements but be \"equal\")\n  x = provable.toCanonical?.(x) ?? x;\n  y = provable.toCanonical?.(y) ?? y;\n  let xs = provable.toFields(x);\n  let ys = provable.toFields(y);\n  return xs.map((x, i) => x.equals(ys[i])).reduce(Bool.and);\n}\n\nfunction if_<T>(condition: Bool, type: FlexibleProvableType<T>, x: T, y: T): T;\nfunction if_<T extends ToFieldable>(condition: Bool, x: T, y: T): T;\nfunction if_(condition: Bool, typeOrX: any, xOrY: any, yOrUndefined?: any) {\n  if (yOrUndefined === undefined) {\n    return ifImplicit(condition, typeOrX, xOrY);\n  } else {\n    return ifExplicit(condition, typeOrX, xOrY, yOrUndefined);\n  }\n}\n\nfunction ifField(b: Field, x: Field, y: Field) {\n  // TODO: this is suboptimal if one of x, y is constant\n  // it uses 2-3 generic gates in that case, where 1 would be enough\n\n  // b*(x - y) + y\n  // NOTE: the R1CS constraint used by Field.if_ in snarky-ml\n  // leads to a different but equivalent layout (same # constraints)\n  // https://github.com/o1-labs/snarky/blob/14f8e2ff981a9c9ea48c94b2cc1d8c161301537b/src/base/utils.ml#L171\n  // in the case x, y are constant, the layout is the same\n  return b.mul(x.sub(y)).add(y).seal();\n}\n\nfunction ifExplicit<T>(condition: Bool, type: ProvableType<T>, x: T, y: T): T {\n  type = ProvableType.get(type);\n  let xs = type.toFields(x);\n  let ys = type.toFields(y);\n  let b = condition.toField();\n\n  // simple case: b is constant - it's like a normal if statement\n  if (b.isConstant()) {\n    return clone(type, condition.toBoolean() ? x : y);\n  }\n\n  // if b is variable, we compute if as follows:\n  // if(b, x, y)[i] = b*(x[i] - y[i]) + y[i]\n  let fields = xs.map((xi, i) => ifField(b, xi, ys[i]));\n  let aux = auxiliary(type, () => (condition.toBoolean() ? x : y));\n  return type.fromFields(fields, aux);\n}\n\nfunction ifImplicit<T extends ToFieldable>(condition: Bool, x: T, y: T): T {\n  let type = x.constructor;\n  if (type === undefined)\n    throw Error(\n      `You called Provable.if(bool, x, y) with an argument x that has no constructor, which is not supported.\\n` +\n        `If x, y are Structs or other custom types, you can use the following:\\n` +\n        `Provable.if(bool, MyType, x, y)`\n    );\n  if (type !== y.constructor) {\n    throw Error(\n      'Provable.if: Mismatched argument types. Try using an explicit type argument:\\n' +\n        `Provable.if(bool, MyType, x, y)`\n    );\n  }\n  if (!('fromFields' in type && 'toFields' in type)) {\n    throw Error(\n      'Provable.if: Invalid argument type. Try using an explicit type argument:\\n' +\n        `Provable.if(bool, MyType, x, y)`\n    );\n  }\n  return ifExplicit(condition, type as any as Provable<T>, x, y);\n}\n\nfunction switch_<T, A extends FlexibleProvableType<T>>(\n  mask: Bool[],\n  type: A,\n  values: T[],\n  { allowNonExclusive = false } = {}\n): T {\n  let type_ = ProvableType.get(type as ProvableType<T>);\n  // picks the value at the index where mask is true\n  let nValues = values.length;\n  if (mask.length !== nValues)\n    throw Error(\n      `Provable.switch: \\`values\\` and \\`mask\\` have different lengths (${values.length} vs. ${mask.length}), which is not allowed.`\n    );\n  let checkMask = () => {\n    if (allowNonExclusive) return;\n    let nTrue = mask.filter((b) => b.toBoolean()).length;\n    if (nTrue > 1) {\n      throw Error(`Provable.switch: \\`mask\\` must have 0 or 1 true element, found ${nTrue}.`);\n    }\n  };\n  if (mask.every((b) => b.toField().isConstant())) checkMask();\n  else Provable.asProver(checkMask);\n  let size = type_.sizeInFields();\n  let fields = Array(size).fill(new Field(0));\n  for (let i = 0; i < nValues; i++) {\n    let valueFields = type_.toFields(values[i]);\n    let maskField = mask[i].toField();\n    for (let j = 0; j < size; j++) {\n      let maybeField = valueFields[j].mul(maskField);\n      fields[j] = fields[j].add(maybeField);\n    }\n  }\n  let aux = auxiliary(type_, () => {\n    let i = mask.findIndex((b) => b.toBoolean());\n    if (i === -1) return undefined;\n    return values[i];\n  });\n  return type_.fromFields(fields, aux);\n}\n\nfunction assertEqualIf<\n  A extends ProvableType<any>,\n  T extends InferProvableType<A> = InferProvableType<A>,\n>(enabled: Bool, type: A, x: T, y: T) {\n  // if the condition is disabled, we check the trivial identity x === x instead\n  let xOrY = ifExplicit<T>(enabled, type, y, x);\n  assertEqual(type, x, xOrY);\n}\n\nfunction isConstant<T>(type: ProvableType<T>, x: T): boolean {\n  return ProvableType.get(type)\n    .toFields(x)\n    .every((x) => x.isConstant());\n}\n\n// logging in provable code\n\nfunction log(...args: any) {\n  asProver(() => {\n    let prettyArgs = [];\n    for (let arg of args) {\n      if (arg?.toPretty !== undefined) prettyArgs.push(arg.toPretty());\n      else {\n        try {\n          prettyArgs.push(JSON.parse(JSON.stringify(arg)));\n        } catch {\n          prettyArgs.push(arg);\n        }\n      }\n    }\n    console.log(...prettyArgs);\n  });\n}\n\n// helpers\n\nfunction checkLength(name: string, xs: Field[], ys: Field[]) {\n  let n = xs.length;\n  let m = ys.length;\n  if (n !== m) {\n    throw Error(\n      `${name}: inputs must contain the same number of field elements, got ${n} !== ${m}`\n    );\n  }\n  return n;\n}\n\nfunction clone<T, S extends FlexibleProvable<T>>(type: S, value: T): T {\n  let fields = type.toFields(value);\n  let aux = type.toAuxiliary?.(value) ?? [];\n  return (type as Provable<T>).fromFields(fields, aux);\n}\n\nfunction auxiliary<T>(type: Provable<T>, compute: () => T | undefined) {\n  let aux;\n  // TODO: this accepts types without .toAuxiliary(), should be changed when all snarky types are moved to TS\n  Provable.asProver(() => {\n    let value = compute();\n    if (value !== undefined) {\n      aux = type.toAuxiliary?.(value);\n    }\n  });\n  return aux ?? type.toAuxiliary?.() ?? [];\n}\n\ntype MemoizationContext = {\n  memoized: { fields: Field[]; aux: any[] }[];\n  currentIndex: number;\n  blindingValue: Field;\n};\nlet memoizationContext = Context.create<MemoizationContext>();\n\n/**\n * Like Provable.witness, but memoizes the witness during transaction construction\n * for reuse by the prover. This is needed to witness non-deterministic values.\n */\nfunction memoizeWitness<T>(type: FlexibleProvable<T>, compute: () => T) {\n  return Provable.witness(type as Provable<T>, () => {\n    if (!memoizationContext.has()) return compute();\n    let context = memoizationContext.get();\n    let { memoized, currentIndex } = context;\n    let currentValue = memoized[currentIndex];\n    if (currentValue === undefined) {\n      let value = compute();\n      let fields = type.toFields(value).map((x) => x.toConstant());\n      let aux = type.toAuxiliary(value);\n      currentValue = { fields, aux };\n      memoized[currentIndex] = currentValue;\n    }\n    context.currentIndex += 1;\n    return (type as Provable<T>).fromFields(currentValue.fields, currentValue.aux);\n  });\n}\n\nfunction getBlindingValue() {\n  if (!memoizationContext.has()) return Field.random();\n  let context = memoizationContext.get();\n  if (context.blindingValue === undefined) {\n    context.blindingValue = Field.random();\n  }\n  return context.blindingValue;\n}\n\n// TODO this should return a class, like Struct, so you can just use `class Array3 extends Provable.Array(Field, 3) {}`\nfunction provableArray<A extends FlexibleProvableType<any>>(\n  elementType: A,\n  length: number\n): InferredProvable<ToProvable<A>[]> {\n  type T = InferProvableType<A>;\n  type TValue = InferValue<ToProvable<A>>;\n  type TJson = InferJson<ToProvable<A>>;\n  let type = ProvableType.get(elementType as ProvableType<T>) as ProvableExtended<T, TValue, TJson>;\n  return {\n    /**\n     * Returns the size of this structure in {@link Field} elements.\n     * @returns size of this structure\n     */\n    sizeInFields() {\n      let elementLength = type.sizeInFields();\n      return elementLength * length;\n    },\n    /**\n     * Serializes this structure into {@link Field} elements.\n     * @returns an array of {@link Field} elements\n     */\n    toFields(array: T[]) {\n      return array.map((e) => type.toFields(e)).flat();\n    },\n    /**\n     * Serializes this structure's auxiliary data.\n     * @returns auxiliary data\n     */\n    toAuxiliary(array?) {\n      let array_ = array ?? Array<undefined>(length).fill(undefined);\n      return array_?.map((e) => type.toAuxiliary(e));\n    },\n\n    /**\n     * Deserializes an array of {@link Field} elements into this structure.\n     */\n    fromFields(fields: Field[], aux?: any[]) {\n      let array = [];\n      let size = type.sizeInFields();\n      let n = length;\n      for (let i = 0, offset = 0; i < n; i++, offset += size) {\n        array[i] = type.fromFields(fields.slice(offset, offset + size), aux?.[i]);\n      }\n      return array;\n    },\n    check(array: T[]) {\n      for (let i = 0; i < length; i++) {\n        (type as any).check(array[i]);\n      }\n    },\n    toCanonical(x) {\n      return x.map((v) => Provable.toCanonical(type, v));\n    },\n\n    toValue(x) {\n      return x.map((v) => type.toValue(v));\n    },\n\n    fromValue(x) {\n      return x.map((v) => type.fromValue(v));\n    },\n\n    /**\n     * Encodes this structure into a JSON-like object.\n     */\n    toJSON(array) {\n      if (!('toJSON' in type)) {\n        throw Error('circuitArray.toJSON: element type has no toJSON method');\n      }\n      return array.map((v) => type.toJSON(v));\n    },\n\n    /**\n     * Decodes a JSON-like object into this structure.\n     */\n    fromJSON(json) {\n      if (!('fromJSON' in type)) {\n        throw Error('circuitArray.fromJSON: element type has no fromJSON method');\n      }\n      return json.map((a) => type.fromJSON(a));\n    },\n    toInput(array) {\n      if (!('toInput' in type)) {\n        throw Error('circuitArray.toInput: element type has no toInput method');\n      }\n      return array.reduce(\n        (curr, value) => HashInput.append(curr, type.toInput(value)),\n        HashInput.empty\n      );\n    },\n\n    empty() {\n      if (!('empty' in type)) {\n        throw Error('circuitArray.empty: element type has no empty() method');\n      }\n      return Array.from({ length }, () => type.empty());\n    },\n  } satisfies ProvableExtended<T[], TValue[], TJson[]> as any;\n}\n", "/**\n * Basic gadgets that only use generic gates\n */\nimport { Fp } from '../../../bindings/crypto/finite-field.js';\nimport type { Field, VarField } from '../field.js';\nimport { FieldType, FieldVar, FieldConst, VarFieldVar } from '../core/fieldvar.js';\nimport { toVar } from './common.js';\nimport { Gates, fieldVar } from '../gates.js';\nimport { TupleN } from '../../util/types.js';\nimport { exists, existsOne } from '../core/exists.js';\nimport { createField } from '../core/field-constructor.js';\nimport { assert } from '../../util/assert.js';\nimport { ProvableType } from '../types/provable-intf.js';\nimport { Provable } from '../provable.js';\n\nexport { assertMul, assertBilinear, arrayGet, assertOneOf, assertNotVectorEquals, arrayGetGeneric };\n\n// internal\nexport { reduceToScaledVar, toLinearCombination, emptyCell, linear, bilinear, ScaledVar, Constant };\n\n/**\n * Assert multiplication constraint, `x * y === z`\n */\nfunction assertMul(x: Field | FieldVar, y: Field | FieldVar, z: Field | FieldVar) {\n  // simpler version of assertMulCompatible that currently uses the same amount of constraints but is not compatible\n  // also, doesn't handle all-constant case (handled by calling gadgets already)\n\n  // TODO: if we replace `reduceToScaledVar()` with a function that leaves `a*x + b` unreduced, we can save constraints here\n  // for example: (x - 1)*(x - 2) === 0 would become 1 constraint instead of 3\n  let [[sx, vx], cx] = getLinear(reduceToScaledVar(x));\n  let [[sy, vy], cy] = getLinear(reduceToScaledVar(y));\n  let [[sz, vz], cz] = getLinear(reduceToScaledVar(z));\n\n  // (sx * vx + cx) * (sy * vy + cy) = (sz * vz + cz)\n  // sx*cy*vx + sy*cx*vy - sz*vz + sx*sy*x*vy + (cx*cy - cz) = 0\n\n  Gates.generic(\n    {\n      left: sx * cy,\n      right: sy * cx,\n      out: -sz,\n      mul: sx * sy,\n      const: cx * cy - cz,\n    },\n    { left: vx, right: vy, out: vz }\n  );\n}\n\n// TODO: create constant versions of these and expose on Gadgets\n\n/**\n * Get value from array in O(n) rows.\n *\n * Assumes that index is in [0, n), returns an unconstrained result otherwise.\n *\n * Note: This saves 0.5*n constraints compared to equals() + switch() even if equals() were implemented optimally.\n */\nfunction arrayGet(array: Field[], index: Field) {\n  // if index is constant, we can return the value directly\n  if (index.isConstant()) {\n    return array[Number(index.toBigInt())] ?? createField(0n);\n  }\n\n  let i = toVar(index);\n\n  // witness result\n  let a = existsOne(() => array[Number(i.toBigInt())]?.toBigInt() ?? 0n);\n\n  // we prove a === array[j] + z[j]*(i - j) for some z[j], for all j.\n  // setting j = i, this implies a === array[i]\n  // thanks to our assumption that the index i is within bounds, we know that j = i for some j\n  let n = array.length;\n  for (let j = 0; j < n; j++) {\n    let zj = existsOne(() => {\n      let zj = Fp.div(\n        Fp.sub(a.toBigInt(), array[j].toBigInt()),\n        Fp.sub(i.toBigInt(), Fp.fromNumber(j))\n      );\n      return zj ?? 0n;\n    });\n    // prove that z[j]*(i - j) === a - array[j]\n    // TODO abstract this logic into a general-purpose assertMul() gadget,\n    // which is able to use the constant coefficient\n    // (snarky's assert_r1cs somehow leads to much more constraints than this)\n    if (array[j].isConstant()) {\n      // zj*i + (-j)*zj + 0*i + array[j] === a\n      assertBilinear(zj, i, [1n, -BigInt(j), 0n, array[j].toBigInt()], a);\n    } else {\n      let aMinusAj = toVar(a.sub(array[j]));\n      // zj*i + (-j)*zj + 0*i + 0 === (a - array[j])\n      assertBilinear(zj, i, [1n, -BigInt(j), 0n, 0n], aMinusAj);\n    }\n  }\n\n  return a;\n}\n\n/**\n * Assert that a value equals one of a finite list of constants:\n * `(x - c1)*(x - c2)*...*(x - cn) === 0`\n *\n * TODO: what prevents us from getting the same efficiency with snarky DSL code?\n */\nfunction assertOneOf(x: Field, allowed: [bigint, bigint, ...bigint[]]) {\n  let xv = toVar(x);\n  let [c1, c2, ...c] = allowed;\n  let n = c.length;\n  if (n === 0) {\n    // (x - c1)*(x - c2) === 0\n    assertBilinear(xv, xv, [1n, -(c1 + c2), 0n, c1 * c2]);\n    return;\n  }\n  // z = (x - c1)*(x - c2)\n  let z = bilinear(xv, xv, [1n, -(c1 + c2), 0n, c1 * c2]);\n\n  for (let i = 0; i < n; i++) {\n    if (i < n - 1) {\n      // z = z*(x - c)\n      z = bilinear(z, xv, [1n, -c[i], 0n, 0n]);\n    } else {\n      // z*(x - c) === 0\n      assertBilinear(z, xv, [1n, -c[i], 0n, 0n]);\n    }\n  }\n}\n\n/**\n * Assert that x does not equal a constant vector c:\n *\n * `(x[0],...,x[n-1]) !== (c[0],...,c[n-1])`\n *\n * We prove this by witnessing a vector z such that:\n *\n * `sum_i (x[i] - c[i])*z[i] === 1`\n *\n * If we had `x[i] === c[i]` for all i, the left-hand side would be 0 regardless of z.\n */\nfunction assertNotVectorEquals(x: Field[], c: [bigint, bigint, ...bigint[]]) {\n  let xv = x.map(toVar);\n  let n = c.length;\n  assert(n > 1 && x.length === n, 'vector lengths must match');\n\n  // witness vector z\n  let z = exists(n, () => {\n    let z = Array(n).fill(0n);\n\n    // find index where x[i] !== c[i]\n    let i = x.findIndex((xi, i) => xi.toBigInt() !== c[i]);\n    if (i === -1) return z;\n\n    // z[i] = (x[i] - c[i])^-1\n    z[i] = Fp.inverse(Fp.sub(x[i].toBigInt(), c[i])) ?? 0n;\n    return z;\n  });\n\n  let products = xv.map((xi, i) => {\n    // (xi - ci)*zi = xi*zi + 0*xi - ci*zi + 0\n    return bilinear(xi, z[i], [1n, 0n, -c[i], 0n]);\n  });\n\n  // sum_i (xi - ci)*zi = 1\n  let sum = products[0];\n  for (let i = 1; i < n - 1; i++) {\n    // sum = sum + products[i]\n    sum = bilinear(sum, products[i], [0n, 1n, 1n, 0n]);\n  }\n  // sum + products[n - 1] - 1 === 0\n  assertBilinear(sum, products[n - 1], [0n, 1n, 1n, -1n]);\n}\n\n// low-level helpers to create generic gates\n\n/**\n * Compute linear function of x:\n * `z = a*x + b`\n */\nfunction linear(x: VarField | VarFieldVar, [a, b]: TupleN<bigint, 2>) {\n  let z = existsOne(() => {\n    let x0 = createField(x).toBigInt();\n    return a * x0 + b;\n  });\n  // a*x - z + b === 0\n  Gates.generic(\n    { left: a, right: 0n, out: -1n, mul: 0n, const: b },\n    { left: x, right: emptyCell(), out: z }\n  );\n  return z;\n}\n\n/**\n * Compute bilinear function of x and y:\n * `z = a*x*y + b*x + c*y + d`\n */\nfunction bilinear(\n  x: VarField | VarFieldVar,\n  y: VarField | VarFieldVar,\n  [a, b, c, d]: TupleN<bigint, 4>\n) {\n  let z = existsOne(() => {\n    let x0 = createField(x).toBigInt();\n    let y0 = createField(y).toBigInt();\n    return a * x0 * y0 + b * x0 + c * y0 + d;\n  });\n  // b*x + c*y - z + a*x*y + d === 0\n  Gates.generic({ left: b, right: c, out: -1n, mul: a, const: d }, { left: x, right: y, out: z });\n  return z;\n}\n\n/**\n * Assert bilinear equation on x, y and z:\n * `a*x*y + b*x + c*y + d === z`\n *\n * The default for z is 0.\n */\nfunction assertBilinear(\n  x: VarField | VarFieldVar,\n  y: VarField | VarFieldVar,\n  [a, b, c, d]: TupleN<bigint, 4>,\n  z?: VarField | VarFieldVar\n) {\n  // b*x + c*y - z? + a*x*y + d === 0\n  Gates.generic(\n    { left: b, right: c, out: z === undefined ? 0n : -1n, mul: a, const: d },\n    { left: x, right: y, out: z === undefined ? emptyCell() : z }\n  );\n}\n\nfunction emptyCell() {\n  return existsOne(() => 0n);\n}\n\n/**\n * Converts a `FieldVar` into a set of constraints, returns the remainder as a ScaledVar | Constant\n *\n * Collapses duplicated variables, so e.g. x - x just becomes the 0 constant.\n *\n * This is better than fully reducing to a Var, because it allows callers to fold the scaling factor into the next operation,\n * instead of wasting a constraint on `c * x === y` before using `c * x`.\n */\nfunction reduceToScaledVar(x: Field | FieldVar): ScaledVar | Constant {\n  let { constant: c, terms } = toLinearCombination(fieldVar(x));\n\n  // sort terms alphabetically by variable index\n  // (to match snarky implementation)\n  terms.sort(([, [, i]], [, [, j]]) => i - j);\n\n  if (terms.length === 0) {\n    // constant\n    return [FieldType.Constant, FieldConst.fromBigint(c)];\n  }\n\n  if (terms.length === 1) {\n    let [s, x] = terms[0];\n    if (c === 0n) {\n      // s*x\n      return [FieldType.Scale, FieldConst.fromBigint(s), x];\n    } else {\n      // res = s*x + c\n      let res = linear(x, [s, c]);\n      return [FieldType.Scale, FieldConst[1], res.value];\n    }\n  }\n\n  // res = s0*x0 + s1*x1 + ... + sn*xn + c\n  let [[s0, x0], ...rest] = terms;\n\n  let [s1, x1] = rest.pop()!;\n\n  for (let [si, xi] of rest.reverse()) {\n    // x1 = s1*x1 + si*xi\n    x1 = bilinear(xi, x1, [0n, si, s1, 0n]).value;\n    s1 = 1n;\n  }\n\n  // res = s0*x0 + s1*x1 + c\n  let res = bilinear(x0, x1, [0n, s0, s1, c]);\n  return [FieldType.Scale, FieldConst[1], res.value];\n}\n\n/**\n * Flatten the AST of a `FieldVar` to a linear combination of the form\n *\n * `c + s1*x1 + s2*x2 + ... + sn*xn`\n *\n * where none of the vars xi are duplicated.\n */\nfunction toLinearCombination(\n  x: FieldVar,\n  sx = 1n,\n  lincom: { constant: bigint; terms: [bigint, VarFieldVar][] } = {\n    constant: 0n,\n    terms: [],\n  }\n): { constant: bigint; terms: [bigint, VarFieldVar][] } {\n  let { constant, terms } = lincom;\n  // the recursive logic here adds a new term sx*x to an existing linear combination\n  // but x itself is an AST\n\n  if (sx === 0n) return lincom;\n\n  switch (x[0]) {\n    case FieldType.Constant: {\n      // a constant is added to the constant term\n      let [, [, c]] = x;\n      return { constant: Fp.add(constant, Fp.mul(sx, c)), terms };\n    }\n    case FieldType.Var: {\n      // a variable is added to the terms or included in an existing one\n      let [, i] = x;\n\n      // we search for an existing term with the same var\n      let y = terms.find((t) => t[1][1] === i);\n\n      // if there is none, we just add a new term\n      if (y === undefined) return { constant, terms: [[sx, x], ...terms] };\n\n      // if there is one, we add the scales\n      let [sy] = y;\n      y[0] = Fp.add(sy, sx);\n\n      if (y[0] === 0n) {\n        // if the sum is 0, we remove the term\n        terms = terms.filter((t) => t[1][1] !== i);\n      }\n\n      return { constant, terms };\n    }\n    case FieldType.Scale: {\n      // sx * (s * x) + ... = (sx * s) * x + ...\n      let [, [, s], v] = x;\n      return toLinearCombination(v, Fp.mul(sx, s), lincom);\n    }\n    case FieldType.Add: {\n      // sx * (x1 + x2) + ... = sx * x2 + (sx * x1 + ...)\n      let [, x1, x2] = x;\n      lincom = toLinearCombination(x1, sx, lincom);\n      return toLinearCombination(x2, sx, lincom);\n    }\n  }\n}\n\n// helpers for dealing with scaled vars and constants\n\n// type Scaled = [FieldType.Scale, FieldConst, FieldVar];\ntype ScaledVar = [FieldType.Scale, FieldConst, VarFieldVar];\ntype Constant = [FieldType.Constant, FieldConst];\n\nfunction isVar(x: ScaledVar | Constant): x is ScaledVar {\n  return x[0] === FieldType.Scale;\n}\nfunction isConst(x: ScaledVar | Constant): x is Constant {\n  return x[0] === FieldType.Constant;\n}\n\nfunction getVar(x: ScaledVar): [bigint, VarFieldVar] {\n  return [x[1][1], x[2]];\n}\nfunction getConst(x: Constant): bigint {\n  return x[1][1];\n}\n\nfunction getLinear(x: ScaledVar | Constant): [[bigint, VarFieldVar], bigint] {\n  if (isVar(x)) return [getVar(x), 0n];\n  return [[0n, emptyCell().value], getConst(x)];\n}\n\nconst ScaledVar = { isVar, getVar, isConst, getConst };\n\n/**\n * Get value from array in O(n) constraints.\n *\n * Assumes that index is in [0, n), returns an unconstrained result otherwise.\n */\nfunction arrayGetGeneric<T>(type: ProvableType<T>, array: T[], index: Field) {\n  type = ProvableType.get(type);\n  // witness result\n  let a = Provable.witness(type, () => array[Number(index)]);\n  let aFields = type.toFields(a);\n\n  // constrain each field of the result\n  let size = type.sizeInFields();\n  let arrays = array.map(type.toFields);\n\n  for (let j = 0; j < size; j++) {\n    let arrayFieldsJ = arrays.map((x) => x[j]);\n    arrayGet(arrayFieldsJ, index).assertEquals(aFields[j]);\n  }\n  return a;\n}\n", "/**\n * Basic gadgets that only use generic gates, and are compatible with (create the same constraints as)\n * `plonk_constraint_system.ml` / R1CS_constraint_system.\n */\nimport { Fp } from '../../../bindings/crypto/finite-field.js';\nimport { Field } from '../field.js';\nimport { FieldVar } from '../core/fieldvar.js';\nimport { assert } from './common.js';\nimport { Gates } from '../gates.js';\nimport { ScaledVar, emptyCell, reduceToScaledVar } from './basic.js';\nimport { Snarky } from '../../../bindings.js';\n\nexport {\n  assertMulCompatible as assertMul,\n  assertSquareCompatible as assertSquare,\n  assertBooleanCompatible as assertBoolean,\n  assertEqualCompatible as assertEqual,\n};\n\nlet { isVar, getVar, isConst, getConst } = ScaledVar;\n\n/**\n * Assert multiplication constraint, `x * y === z`\n */\nfunction assertMulCompatible(x: Field | FieldVar, y: Field | FieldVar, z: Field | FieldVar) {\n  // this faithfully implements snarky's `assert_r1cs`,\n  // see `R1CS_constraint_system.add_constraint` -> `Snarky_backendless.Constraint.R1CS`\n\n  let xv = reduceToScaledVar(x);\n  let yv = reduceToScaledVar(y);\n  let zv = reduceToScaledVar(z);\n\n  // three variables\n\n  if (isVar(xv) && isVar(yv) && isVar(zv)) {\n    let [[sx, x], [sy, y], [sz, z]] = [getVar(xv), getVar(yv), getVar(zv)];\n\n    // -sx sy * x y + sz z = 0\n    return Gates.generic(\n      { left: 0n, right: 0n, out: sz, mul: -sx * sy, const: 0n },\n      { left: x, right: y, out: z }\n    );\n  }\n\n  // two variables, one constant\n\n  if (isVar(xv) && isVar(yv) && isConst(zv)) {\n    let [[sx, x], [sy, y], sz] = [getVar(xv), getVar(yv), getConst(zv)];\n\n    // sx sy * x y - sz = 0\n    return Gates.generic(\n      { left: 0n, right: 0n, out: 0n, mul: sx * sy, const: -sz },\n      { left: x, right: y, out: emptyCell() }\n    );\n  }\n\n  if (isVar(xv) && isConst(yv) && isVar(zv)) {\n    let [[sx, x], sy, [sz, z]] = [getVar(xv), getConst(yv), getVar(zv)];\n\n    // sx sy * x - sz z = 0\n    return Gates.generic(\n      { left: sx * sy, right: 0n, out: -sz, mul: 0n, const: 0n },\n      { left: x, right: emptyCell(), out: z }\n    );\n  }\n\n  if (isConst(xv) && isVar(yv) && isVar(zv)) {\n    let [sx, [sy, y], [sz, z]] = [getConst(xv), getVar(yv), getVar(zv)];\n\n    // sx sy * y - sz z = 0\n    return Gates.generic(\n      { left: 0n, right: sx * sy, out: -sz, mul: 0n, const: 0n },\n      { left: emptyCell(), right: y, out: z }\n    );\n  }\n\n  // two constants, one variable\n\n  if (isVar(xv) && isConst(yv) && isConst(zv)) {\n    let [[sx, x], sy, sz] = [getVar(xv), getConst(yv), getConst(zv)];\n\n    // sx sy * x - sz = 0\n    return Gates.generic(\n      { left: sx * sy, right: 0n, out: 0n, mul: 0n, const: -sz },\n      { left: x, right: emptyCell(), out: emptyCell() }\n    );\n  }\n\n  if (isConst(xv) && isVar(yv) && isConst(zv)) {\n    let [sx, [sy, y], sz] = [getConst(xv), getVar(yv), getConst(zv)];\n\n    // sx sy * y - sz = 0\n    return Gates.generic(\n      { left: 0n, right: sx * sy, out: 0n, mul: 0n, const: -sz },\n      { left: emptyCell(), right: y, out: emptyCell() }\n    );\n  }\n\n  if (isConst(xv) && isConst(yv) && isVar(zv)) {\n    let [sx, sy, [sz, z]] = [getConst(xv), getConst(yv), getVar(zv)];\n\n    // sz z - sx sy = 0\n    return Gates.generic(\n      { left: 0n, right: 0n, out: sz, mul: 0n, const: -sx * sy },\n      { left: emptyCell(), right: emptyCell(), out: z }\n    );\n  }\n\n  // three constants\n\n  if (isConst(xv) && isConst(yv) && isConst(zv)) {\n    let [sx, sy, sz] = [getConst(xv), getConst(yv), getConst(zv)];\n\n    assert(Fp.equal(Fp.mul(sx, sy), sz), `assertMul(): ${sx} * ${sy} !== ${sz}`);\n    return;\n  }\n\n  // sadly TS doesn't know that this was exhaustive\n  assert(false, `assertMul(): unreachable`);\n}\n\n/**\n * Assert square, `x^2 === z`\n */\nfunction assertSquareCompatible(x: Field, z: Field) {\n  let xv = reduceToScaledVar(x);\n  let zv = reduceToScaledVar(z);\n\n  if (isVar(xv) && isVar(zv)) {\n    let [[sx, x], [sz, z]] = [getVar(xv), getVar(zv)];\n\n    // -sz * z + (sx)^2 * x*x = 0\n    return Gates.generic(\n      { left: 0n, right: 0n, out: -sz, mul: sx ** 2n, const: 0n },\n      { left: x, right: x, out: z }\n    );\n  }\n\n  if (isVar(xv) && isConst(zv)) {\n    let [[sx, x], sz] = [getVar(xv), getConst(zv)];\n\n    // (sx)^2 * x*x - sz = 0\n    return Gates.generic(\n      { left: 0n, right: 0n, out: 0n, mul: sx ** 2n, const: -sz },\n      { left: x, right: x, out: emptyCell() }\n    );\n  }\n\n  if (isConst(xv) && isVar(zv)) {\n    let [sx, [sz, z]] = [getConst(xv), getVar(zv)];\n\n    // sz * z - (sx)^2 = 0\n    return Gates.generic(\n      { left: 0n, right: 0n, out: sz, mul: 0n, const: -(sx ** 2n) },\n      { left: emptyCell(), right: emptyCell(), out: z }\n    );\n  }\n\n  if (isConst(xv) && isConst(zv)) {\n    let [sx, sz] = [getConst(xv), getConst(zv)];\n\n    assert(Fp.equal(Fp.square(sx), sz), `assertSquare(): ${sx}^2 !== ${sz}`);\n    return;\n  }\n\n  // sadly TS doesn't know that this was exhaustive\n  assert(false, `assertSquare(): unreachable`);\n}\n\n/**\n * Assert that x is either 0 or 1, `x^2 === x`\n */\nfunction assertBooleanCompatible(x: Field) {\n  let xv = reduceToScaledVar(x);\n\n  if (isVar(xv)) {\n    let [s, x] = getVar(xv);\n\n    // -s*x + s^2 * x^2 = 0\n    return Gates.generic(\n      { left: -s, right: 0n, out: 0n, mul: s ** 2n, const: 0n },\n      { left: x, right: x, out: emptyCell() }\n    );\n  }\n\n  let x0 = getConst(xv);\n  assert(Fp.equal(Fp.square(x0), x0), `assertBoolean(): ${x} is not 0 or 1`);\n}\n\n/**\n * Assert equality, `x === y`\n */\nfunction assertEqualCompatible(x: Field | FieldVar, y: Field | FieldVar) {\n  // TODO not optimal for a case like `x + y === c*z`,\n  // where this reduces x + y and then is still not able to just use a wire\n  let yv = reduceToScaledVar(y);\n  let xv = reduceToScaledVar(x);\n\n  if (isVar(xv) && isVar(yv)) {\n    let [[sx, x], [sy, y]] = [getVar(xv), getVar(yv)];\n\n    if (sx === sy) {\n      // x === y, so use a wire\n      return Snarky.field.assertEqual(x, y);\n    }\n\n    // sx * x - sy * y = 0\n    return Gates.generic(\n      { left: sx, right: -sy, out: 0n, mul: 0n, const: 0n },\n      { left: x, right: y, out: emptyCell() }\n    );\n  }\n\n  if (isVar(xv) && isConst(yv)) {\n    let [[sx, x], sy] = [getVar(xv), getConst(yv)];\n\n    // x === sy / sx, call into snarky to use its constants table\n    return Snarky.field.assertEqual(FieldVar.scale(sx, x), FieldVar.constant(sy));\n  }\n\n  if (isConst(xv) && isVar(yv)) {\n    let [sx, [sy, y]] = [getConst(xv), getVar(yv)];\n\n    // sx / sy === y, call into snarky to use its constants table\n    return Snarky.field.assertEqual(FieldVar.constant(sx), FieldVar.scale(sy, y));\n  }\n\n  if (isConst(xv) && isConst(yv)) {\n    let [sx, sy] = [getConst(xv), getConst(yv)];\n\n    assert(Fp.equal(sx, sy), `assertEqual(): ${sx} !== ${sy}`);\n    return;\n  }\n\n  // sadly TS doesn't know that this was exhaustive\n  assert(false, `assertEqual(): unreachable`);\n}\n", "import { Snarky } from '../../bindings.js';\nimport { Field, readVarMessage, withMessage } from './field.js';\nimport { FieldVar, FieldConst, FieldType } from './core/fieldvar.js';\nimport { defineBinable } from '../../bindings/lib/binable.js';\nimport { NonNegativeInteger } from '../../bindings/crypto/non-negative.js';\nimport { existsOne } from './core/exists.js';\nimport { assertMul } from './gadgets/compatible.js';\nimport { setBoolConstructor } from './core/field-constructor.js';\n\nexport { BoolVar, Bool };\n\n// same representation, but use a different name to communicate intent / constraints\ntype BoolVar = FieldVar;\n\ntype ConstantBoolVar = [FieldType.Constant, FieldConst];\ntype ConstantBool = Bool & { value: ConstantBoolVar };\n\n/**\n * A boolean value. You can use it like this:\n *\n * ```\n * const x = new Bool(true);\n * ```\n *\n * You can also combine multiple booleans via [[`not`]], [[`and`]], [[`or`]].\n *\n * Use [[assertEquals]] to enforce the value of a Bool.\n */\nclass Bool {\n  value: BoolVar;\n\n  constructor(x: boolean | Bool | BoolVar) {\n    if (x instanceof Bool) {\n      this.value = x.value;\n      return;\n    }\n    if (Array.isArray(x)) {\n      this.value = x;\n      return;\n    }\n    this.value = FieldVar.constant(BigInt(x));\n  }\n\n  isConstant(): this is { value: ConstantBoolVar } {\n    return this.value[0] === FieldType.Constant;\n  }\n\n  /**\n   * Converts a {@link Bool} to a {@link Field}. `false` becomes 0 and `true` becomes 1.\n   */\n  toField(): Field {\n    return Bool.toField(this);\n  }\n\n  /**\n   * @returns a new {@link Bool} that is the negation of this {@link Bool}.\n   */\n  not(): Bool {\n    if (this.isConstant()) {\n      return new Bool(!this.toBoolean());\n    }\n    // 1 - x\n    let not = new Field(1).sub(this.toField());\n    return new Bool(not.value);\n  }\n\n  /**\n   * @param y A {@link Bool} to AND with this {@link Bool}.\n   * @returns a new {@link Bool} that is set to true only if\n   * this {@link Bool} and `y` are also true.\n   */\n  and(y: Bool | boolean): Bool {\n    if (this.isConstant() && isConstant(y)) {\n      return new Bool(this.toBoolean() && toBoolean(y));\n    }\n    // x * y\n    return new Bool(this.toField().mul(Bool.toField(y)).value);\n  }\n\n  /**\n   * @param y a {@link Bool} to OR with this {@link Bool}.\n   * @returns a new {@link Bool} that is set to true if either\n   * this {@link Bool} or `y` is true.\n   */\n  or(y: Bool | boolean): Bool {\n    if (this.isConstant() && isConstant(y)) {\n      return new Bool(this.toBoolean() || toBoolean(y));\n    }\n    // 1 - (1 - x)(1 - y) = x + y - xy\n    return this.not().and(new Bool(y).not()).not();\n  }\n\n  /**\n   * Whether this Bool implies another Bool `y`.\n   *\n   * This is the same as `x.not().or(y)`: if `x` is true, then `y` must be true for the implication to be true.\n   *\n   * @example\n   * ```ts\n   * let isZero = x.equals(0);\n   * let lessThan10 = x.lessThan(10);\n   * assert(isZero.implies(lessThan10), 'x = 0 implies x < 10');\n   * ```\n   */\n  implies(y: Bool | boolean): Bool {\n    return this.not().or(y);\n  }\n\n  /**\n   * Proves that this {@link Bool} is equal to `y`.\n   * @param y a {@link Bool}.\n   */\n  assertEquals(y: Bool | boolean, message?: string): void {\n    try {\n      if (this.isConstant() && isConstant(y)) {\n        if (this.toBoolean() !== toBoolean(y)) {\n          throw Error(`Bool.assertEquals(): ${this} != ${y}`);\n        }\n        return;\n      }\n      this.toField().assertEquals(Bool.toField(y));\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Proves that this {@link Bool} is `true`.\n   */\n  assertTrue(message?: string): void {\n    try {\n      if (this.isConstant() && !this.toBoolean()) {\n        throw Error(`Bool.assertTrue(): ${this} != ${true}`);\n      }\n      this.assertEquals(true);\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Proves that this {@link Bool} is `false`.\n   */\n  assertFalse(message?: string): void {\n    try {\n      if (this.isConstant() && this.toBoolean()) {\n        throw Error(`Bool.assertFalse(): ${this} != ${false}`);\n      }\n      this.assertEquals(false);\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Returns true if this {@link Bool} is equal to `y`.\n   * @param y a {@link Bool}.\n   */\n  equals(y: Bool | boolean): Bool {\n    if (this.isConstant() && isConstant(y)) {\n      return new Bool(this.toBoolean() === toBoolean(y));\n    }\n    if (isConstant(y)) {\n      if (toBoolean(y)) return this;\n      else return this.not();\n    }\n    if (this.isConstant()) {\n      return new Bool(y).equals(this);\n    }\n    // 1 - (x - y)^2 = 2xy - x - y + 1\n    // match snarky logic:\n    // 2x * y === x + y - z\n    // return 1 - z\n    let z = existsOne(() => BigInt(this.toBoolean() !== toBoolean(y)));\n    let x = this.toField();\n    let y_ = Bool.toField(y);\n    assertMul(x.add(x), y_, x.add(y_).sub(z));\n    return new Bool(z.value).not();\n  }\n\n  /**\n   * Returns the size of this type.\n   */\n  sizeInFields(): number {\n    return 1;\n  }\n\n  /**\n   * Serializes this {@link Bool} into {@link Field} elements.\n   */\n  toFields(): Field[] {\n    return Bool.toFields(this);\n  }\n\n  /**\n   * Serialize the {@link Bool} to a string, e.g. for printing.\n   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.\n   */\n  toString(): string {\n    return this.toBoolean().toString();\n  }\n\n  /**\n   * Serialize the {@link Bool} to a JSON string.\n   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.\n   */\n  toJSON(): boolean {\n    return this.toBoolean();\n  }\n\n  /**\n   * This converts the {@link Bool} to a JS `boolean`.\n   * This can only be called on non-witness values.\n   */\n  toBoolean(): boolean {\n    if (this.isConstant()) {\n      return FieldConst.equal(this.value[1], FieldConst[1]);\n    }\n    if (!Snarky.run.inProverBlock()) {\n      throw Error(readVarMessage('toBoolean', 'b', 'Bool'));\n    }\n    let value = Snarky.field.readVar(this.value);\n    return FieldConst.equal(value, FieldConst[1]);\n  }\n\n  static toField(x: Bool | boolean): Field {\n    return new Field(toFieldVar(x));\n  }\n\n  /**\n   * Boolean negation.\n   */\n  static not(x: Bool | boolean): Bool {\n    if (x instanceof Bool) {\n      return x.not();\n    }\n    return new Bool(!x);\n  }\n\n  /**\n   * Boolean AND operation.\n   */\n  static and(x: Bool | boolean, y: Bool | boolean): Bool {\n    if (x instanceof Bool) {\n      return x.and(y);\n    }\n    return new Bool(x).and(y);\n  }\n\n  /**\n   * Boolean OR operation.\n   */\n  static or(x: Bool | boolean, y: Bool | boolean): Bool {\n    if (x instanceof Bool) {\n      return x.or(y);\n    }\n    return new Bool(x).or(y);\n  }\n\n  /**\n   * Boolean AND operation across a list of booleans, returns `Bool(true)` if all elements in the list are true.\n   */\n  static allTrue(list: (Bool | boolean)[]): Bool {\n    if (list.length === 0) {\n      return new Bool(true);\n    } else {\n      let b = toBool(list[0]);\n\n      for (let i = 1; i < list.length; i++) {\n        b = b.and(toBool(list[i]));\n      }\n\n      return b;\n    }\n  }\n\n  /**\n   * Boolean OR operation across a list of booleans, returns `Bool(true)` if any element in the list is true.\n   */\n  static anyTrue(list: (Bool | boolean)[]): Bool {\n    if (list.length === 0) {\n      return new Bool(false);\n    } else {\n      let b = toBool(list[0]);\n\n      for (let i = 1; i < list.length; i++) {\n        b = b.or(toBool(list[i]));\n      }\n\n      return b;\n    }\n  }\n\n  /**\n   * Asserts if both {@link Bool} are equal.\n   */\n  static assertEqual(x: Bool, y: Bool | boolean): void {\n    if (x instanceof Bool) {\n      x.assertEquals(y);\n      return;\n    }\n    new Bool(x).assertEquals(y);\n  }\n\n  /**\n   * Checks two {@link Bool} for equality.\n   */\n  static equal(x: Bool | boolean, y: Bool | boolean): Bool {\n    if (x instanceof Bool) {\n      return x.equals(y);\n    }\n    return new Bool(x).equals(y);\n  }\n\n  /**\n   * Static method to serialize a {@link Bool} into an array of {@link Field} elements.\n   */\n  static toFields(x: Bool): Field[] {\n    return [Bool.toField(x)];\n  }\n\n  /**\n   * Static method to serialize a {@link Bool} into its auxiliary data.\n   */\n  static toAuxiliary(_?: Bool): [] {\n    return [];\n  }\n\n  /**\n   * Creates a data structure from an array of serialized {@link Field} elements.\n   */\n  static fromFields(fields: Field[]): Bool {\n    if (fields.length !== 1) {\n      throw Error(`Bool.fromFields(): expected 1 field, got ${fields.length}`);\n    }\n    return new Bool(fields[0].value);\n  }\n\n  /**\n   * `Provable<Bool>.toValue()`\n   */\n  static toValue(x: Bool): boolean {\n    return x.toBoolean();\n  }\n\n  /**\n   * `Provable<Bool>.fromValue()`\n   */\n  static fromValue(b: boolean | Bool) {\n    if (typeof b === 'boolean') return new Bool(b);\n    return b;\n  }\n\n  /**\n   * Serialize a {@link Bool} to a JSON string.\n   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.\n   */\n  static toJSON(x: Bool): boolean {\n    return x.toBoolean();\n  }\n\n  /**\n   * Deserialize a JSON structure into a {@link Bool}.\n   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Field.\n   */\n  static fromJSON(b: boolean): Bool {\n    return new Bool(b);\n  }\n\n  /**\n   * Returns the size of this type.\n   */\n  static sizeInFields() {\n    return 1;\n  }\n\n  static empty() {\n    return new Bool(false);\n  }\n\n  static toInput(x: Bool): { packed: [Field, number][] } {\n    return { packed: [[x.toField(), 1] as [Field, number]] };\n  }\n\n  static toBytes(b: Bool): number[] {\n    return BoolBinable.toBytes(b);\n  }\n\n  static fromBytes(bytes: number[]): Bool {\n    return BoolBinable.fromBytes(bytes);\n  }\n\n  static readBytes<N extends number>(\n    bytes: number[],\n    offset: NonNegativeInteger<N>\n  ): [value: Bool, offset: number] {\n    return BoolBinable.readBytes(bytes, offset);\n  }\n\n  static sizeInBytes = 1;\n\n  static check(x: Bool): void {\n    x.toField().assertBool();\n  }\n\n  static Unsafe = {\n    /**\n     * Converts a {@link Field} into a {@link Bool}. This is an **unsafe** operation\n     * as it assumes that the field element is either 0 or 1 (which might not be true).\n     *\n     * Only use this if you have already constrained the Field element to be 0 or 1.\n     *\n     * @param x a {@link Field}\n     */\n    fromField(x: Field) {\n      return new Bool(x.value);\n    },\n  };\n}\nsetBoolConstructor(Bool);\n\nconst BoolBinable = defineBinable({\n  toBytes(b: Bool) {\n    return [Number(b.toBoolean())];\n  },\n  readBytes(bytes, offset) {\n    return [new Bool(!!bytes[offset]), offset + 1];\n  },\n});\n\n// internal helper functions\n\nfunction isConstant(x: boolean | Bool): x is boolean | ConstantBool {\n  if (typeof x === 'boolean') {\n    return true;\n  }\n\n  return x.isConstant();\n}\n\nfunction toBoolean(x: boolean | Bool): boolean {\n  if (typeof x === 'boolean') {\n    return x;\n  }\n  return x.toBoolean();\n}\n\nfunction toBool(x: boolean | Bool): Bool {\n  if (x instanceof Bool) return x;\n  return new Bool(x);\n}\n\nfunction toFieldVar(x: boolean | Bool): BoolVar {\n  if (x instanceof Bool) return x.value;\n  return FieldVar.constant(BigInt(x));\n}\n", "import { Snarky } from '../../../bindings.js';\nimport type { Field } from '../field.js';\nimport type { Provable } from '../provable.js';\nimport { assert } from '../../util/errors.js';\nimport { asProver, inCheckedComputation } from '../core/provable-context.js';\nimport { witness } from './witness.js';\n\nexport { Unconstrained };\n\n/**\n * Container which holds an unconstrained value. This can be used to pass values\n * between the out-of-circuit blocks in provable code.\n *\n * Invariants:\n * - An `Unconstrained`'s value can only be accessed in auxiliary contexts.\n * - An `Unconstrained` can be empty when compiling, but never empty when running as the prover.\n *   (there is no way to create an empty `Unconstrained` in the prover)\n *\n * @example\n * ```ts\n * let x = Unconstrained.from(0n);\n *\n * class MyContract extends SmartContract {\n *   `@method` myMethod(x: Unconstrained<bigint>) {\n *\n *     Provable.witness(Field, () => {\n *       // we can access and modify `x` here\n *       let newValue = x.get() + otherField.toBigInt();\n *       x.set(newValue);\n *\n *       // ...\n *     });\n *\n *     // throws an error!\n *     x.get();\n *   }\n * ```\n */\nclass Unconstrained<T> {\n  private option: { isSome: true; value: T } | { isSome: false; value: undefined };\n\n  private constructor(isSome: boolean, value?: T) {\n    this.option = { isSome, value: value as any };\n  }\n\n  /**\n   * Read an unconstrained value.\n   *\n   * Note: Can only be called outside provable code.\n   */\n  get(): T {\n    if (inCheckedComputation() && !Snarky.run.inProverBlock())\n      throw Error(`You cannot use Unconstrained.get() in provable code.\n\nThe only place where you can read unconstrained values is in Provable.witness()\nand Provable.asProver() blocks, which execute outside the proof.\n`);\n    assert(this.option.isSome, 'Empty `Unconstrained`'); // never triggered\n    return this.option.value;\n  }\n\n  /**\n   * Modify the unconstrained value.\n   */\n  set(value: T) {\n    this.option = { isSome: true, value };\n  }\n\n  /**\n   * Set the unconstrained value to the same as another `Unconstrained`.\n   */\n  setTo(value: Unconstrained<T>) {\n    this.option = value.option;\n  }\n\n  /**\n   * Create an `Unconstrained` with the given `value`.\n   *\n   * Note: If `T` contains provable types, `Unconstrained.from` is an anti-pattern,\n   * because it stores witnesses in a space that's intended to be used outside the proof.\n   * Something like the following should be used instead:\n   *\n   * ```ts\n   * let xWrapped = Unconstrained.witness(() => Provable.toConstant(type, x));\n   * ```\n   */\n  static from<T>(value: T | Unconstrained<T>) {\n    if (value instanceof Unconstrained) return value;\n    return new Unconstrained(true, value);\n  }\n\n  /**\n   * Create an `Unconstrained` from a witness computation.\n   */\n  static witness<T>(compute: () => T): Unconstrained<T> {\n    return witness(Unconstrained, compute);\n  }\n\n  /**\n   * Update an `Unconstrained` by a witness computation.\n   */\n  updateAsProver(compute: (value: T) => T) {\n    return asProver(() => {\n      let value = this.get();\n      this.set(compute(value));\n    });\n  }\n\n  static provable: UnconstrainedProvable<any> & {\n    toInput: (x: Unconstrained<any>) => {\n      fields?: Field[];\n      packed?: [Field, number][];\n    };\n    empty: () => Unconstrained<any>;\n  } = {\n    sizeInFields: () => 0,\n    toFields: () => [],\n    toAuxiliary: (t?: any) => [t ?? new Unconstrained(false)],\n    fromFields: (_, [t]) => t,\n    check: () => {},\n    toValue: (t) => t.get(),\n    fromValue: (t) => Unconstrained.from(t),\n    toInput: () => ({}),\n    empty: (): any => {\n      throw Error('There is no default empty value for Unconstrained.');\n    },\n  };\n\n  static withEmpty<T>(empty: T): Provable<Unconstrained<T>, T> & {\n    toInput: (x: Unconstrained<T>) => {\n      fields?: Field[];\n      packed?: [Field, number][];\n    };\n    empty: () => Unconstrained<T>;\n  } {\n    return {\n      ...Unconstrained.provable,\n      empty: () => Unconstrained.from(empty),\n    };\n  }\n}\n\ntype UnconstrainedProvable<T> = Provable<Unconstrained<T>, T>;\n", "import { ProvablePureExtended } from './struct.js';\nimport type { Field } from '../field.js';\nimport { createField, getField } from '../core/field-constructor.js';\n\nexport { modifiedField, fields };\n\n// provable for a single field element\n\nconst ProvableField: ProvablePureExtended<Field, bigint, string> = {\n  sizeInFields: () => 1,\n  toFields: (x) => [x],\n  toAuxiliary: () => [],\n  fromFields: ([x]) => x,\n  check: () => {},\n  toValue: (x) => x.toBigInt(),\n  fromValue: (x) => createField(x),\n  toInput: (x) => ({ fields: [x] }),\n  toJSON: (x) => getField().toJSON(x),\n  fromJSON: (x) => getField().fromJSON(x),\n  empty: () => createField(0),\n};\n\nfunction modifiedField(\n  methods: Partial<ProvablePureExtended<Field, string>>\n): ProvablePureExtended<Field, string> {\n  return Object.assign({}, ProvableField, methods);\n}\n\n// provable for a fixed-size array of field elements\n\nlet id = <T>(t: T) => t;\n\nfunction fields(length: number): ProvablePureExtended<Field[], bigint[], string[]> {\n  return {\n    sizeInFields: () => length,\n    toFields: id,\n    toAuxiliary: () => [],\n    fromFields: id,\n    check: () => {},\n    toValue: (x) => x.map((y) => y.toBigInt()),\n    fromValue: (x) => x.map(createField),\n    toInput: (x) => ({ fields: x }),\n    toJSON: (x) => x.map(getField().toJSON),\n    fromJSON: (x) => x.map(getField().fromJSON),\n    empty: () => {\n      let zero = createField(0);\n      return new Array(length).fill(zero);\n    },\n  };\n}\n", "import { Snarky } from '../../../bindings.js';\nimport { Fp } from '../../../bindings/crypto/finite-field.js';\nimport { BinableFp } from '../../../mina-signer/src/field-bigint.js';\nimport type { Field } from '../field.js';\nimport { Gates } from '../gates.js';\nimport { assert, bitSlice, toVar, toVars } from './common.js';\nimport { exists } from '../core/exists.js';\nimport { createBool, createField } from '../core/field-constructor.js';\nimport { TupleN } from '../../util/types.js';\n\nexport {\n  rangeCheck64,\n  rangeCheck32,\n  multiRangeCheck,\n  compactMultiRangeCheck,\n  rangeCheckN,\n  isDefinitelyInRangeN,\n  rangeCheck8,\n  rangeCheck16,\n  rangeCheckLessThan16,\n  rangeCheckLessThan64,\n};\nexport { l, l2, l3, lMask, l2Mask };\n\n/**\n * Asserts that x is in the range [0, 2^32)\n */\nfunction rangeCheck32(x: Field) {\n  if (x.isConstant()) {\n    if (x.toBigInt() >= 1n << 32n) {\n      throw Error(`rangeCheck32: expected field to fit in 32 bits, got ${x}`);\n    }\n    return;\n  }\n\n  let actual = rangeCheckHelper(32, x);\n  actual.assertEquals(x);\n}\n\n/**\n * Asserts that x is in the range [0, 2^64).\n *\n * Returns the 4 highest 12-bit limbs of x in reverse order: [x52, x40, x28, x16].\n */\nfunction rangeCheck64(x: Field): TupleN<Field, 4> {\n  if (x.isConstant()) {\n    let xx = x.toBigInt();\n    if (xx >= 1n << 64n) {\n      throw Error(`rangeCheck64: expected field to fit in 64 bits, got ${x}`);\n    }\n    // returned for consistency with the provable case\n    return [\n      createField(bitSlice(xx, 52, 12)),\n      createField(bitSlice(xx, 40, 12)),\n      createField(bitSlice(xx, 28, 12)),\n      createField(bitSlice(xx, 16, 12)),\n    ];\n  }\n\n  // crumbs (2-bit limbs)\n  let [x0, x2, x4, x6, x8, x10, x12, x14] = exists(8, () => {\n    let xx = x.toBigInt();\n    return [\n      bitSlice(xx, 0, 2),\n      bitSlice(xx, 2, 2),\n      bitSlice(xx, 4, 2),\n      bitSlice(xx, 6, 2),\n      bitSlice(xx, 8, 2),\n      bitSlice(xx, 10, 2),\n      bitSlice(xx, 12, 2),\n      bitSlice(xx, 14, 2),\n    ];\n  });\n\n  // 12-bit limbs\n  let [x16, x28, x40, x52] = exists(4, () => {\n    let xx = x.toBigInt();\n    return [bitSlice(xx, 16, 12), bitSlice(xx, 28, 12), bitSlice(xx, 40, 12), bitSlice(xx, 52, 12)];\n  });\n\n  Gates.rangeCheck0(\n    x,\n    [createField(0), createField(0), x52, x40, x28, x16],\n    [x14, x12, x10, x8, x6, x4, x2, x0],\n    false // not using compact mode\n  );\n\n  return [x52, x40, x28, x16];\n}\n\n// default bigint limb size\nconst l = 88n;\nconst l2 = 2n * l;\nconst l3 = 3n * l;\nconst lMask = (1n << l) - 1n;\nconst l2Mask = (1n << l2) - 1n;\n\n/**\n * Asserts that x, y, z \\in [0, 2^88)\n */\nfunction multiRangeCheck([x, y, z]: [Field, Field, Field]) {\n  if (x.isConstant() && y.isConstant() && z.isConstant()) {\n    if (x.toBigInt() >> l || y.toBigInt() >> l || z.toBigInt() >> l) {\n      throw Error(`Expected fields to fit in ${l} bits, got ${x}, ${y}, ${z}`);\n    }\n    return;\n  }\n  // ensure we are using pure variables\n  [x, y, z] = toVars([x, y, z]);\n  let zero = toVar(0n);\n\n  let [x64, x76] = rangeCheck0Helper(x);\n  let [y64, y76] = rangeCheck0Helper(y);\n  rangeCheck1Helper({ x64, x76, y64, y76, z, yz: zero });\n}\n\n/**\n * Compact multi-range-check - checks\n * - xy = x + 2^88*y\n * - x, y, z \\in [0, 2^88)\n *\n * Returns the full limbs x, y, z\n */\nfunction compactMultiRangeCheck(xy: Field, z: Field): [Field, Field, Field] {\n  // constant case\n  if (xy.isConstant() && z.isConstant()) {\n    if (xy.toBigInt() >> l2 || z.toBigInt() >> l) {\n      throw Error(`Expected fields to fit in ${l2} and ${l} bits respectively, got ${xy}, ${z}`);\n    }\n    let [x, y] = splitCompactLimb(xy.toBigInt());\n    return [createField(x), createField(y), z];\n  }\n  // ensure we are using pure variables\n  [xy, z] = toVars([xy, z]);\n\n  let [x, y] = exists(2, () => splitCompactLimb(xy.toBigInt()));\n\n  let [z64, z76] = rangeCheck0Helper(z, false);\n  let [x64, x76] = rangeCheck0Helper(x, true);\n  rangeCheck1Helper({ x64: z64, x76: z76, y64: x64, y76: x76, z: y, yz: xy });\n\n  return [x, y, z];\n}\n\nfunction splitCompactLimb(x01: bigint): [bigint, bigint] {\n  return [x01 & lMask, x01 >> l];\n}\n\nfunction rangeCheck0Helper(x: Field, isCompact = false): [Field, Field] {\n  // crumbs (2-bit limbs)\n  let [x0, x2, x4, x6, x8, x10, x12, x14] = exists(8, () => {\n    let xx = x.toBigInt();\n    return [\n      bitSlice(xx, 0, 2),\n      bitSlice(xx, 2, 2),\n      bitSlice(xx, 4, 2),\n      bitSlice(xx, 6, 2),\n      bitSlice(xx, 8, 2),\n      bitSlice(xx, 10, 2),\n      bitSlice(xx, 12, 2),\n      bitSlice(xx, 14, 2),\n    ];\n  });\n\n  // 12-bit limbs\n  let [x16, x28, x40, x52, x64, x76] = exists(6, () => {\n    let xx = x.toBigInt();\n    return [\n      bitSlice(xx, 16, 12),\n      bitSlice(xx, 28, 12),\n      bitSlice(xx, 40, 12),\n      bitSlice(xx, 52, 12),\n      bitSlice(xx, 64, 12),\n      bitSlice(xx, 76, 12),\n    ];\n  });\n\n  Gates.rangeCheck0(\n    x,\n    [x76, x64, x52, x40, x28, x16],\n    [x14, x12, x10, x8, x6, x4, x2, x0],\n    isCompact\n  );\n\n  // the two highest 12-bit limbs are returned because another gate\n  // is needed to add lookups for them\n  return [x64, x76];\n}\n\nfunction rangeCheck1Helper(inputs: {\n  x64: Field;\n  x76: Field;\n  y64: Field;\n  y76: Field;\n  z: Field;\n  yz: Field;\n}) {\n  let { x64, x76, y64, y76, z, yz } = inputs;\n\n  // create limbs for current row\n  let [z22, z24, z26, z28, z30, z32, z34, z36, z38, z50, z62, z74, z86] = exists(13, () => {\n    let zz = z.toBigInt();\n    return [\n      bitSlice(zz, 22, 2),\n      bitSlice(zz, 24, 2),\n      bitSlice(zz, 26, 2),\n      bitSlice(zz, 28, 2),\n      bitSlice(zz, 30, 2),\n      bitSlice(zz, 32, 2),\n      bitSlice(zz, 34, 2),\n      bitSlice(zz, 36, 2),\n      bitSlice(zz, 38, 12),\n      bitSlice(zz, 50, 12),\n      bitSlice(zz, 62, 12),\n      bitSlice(zz, 74, 12),\n      bitSlice(zz, 86, 2),\n    ];\n  });\n\n  // create limbs for next row\n  let [z0, z2, z4, z6, z8, z10, z12, z14, z16, z18, z20] = exists(11, () => {\n    let zz = z.toBigInt();\n    return [\n      bitSlice(zz, 0, 2),\n      bitSlice(zz, 2, 2),\n      bitSlice(zz, 4, 2),\n      bitSlice(zz, 6, 2),\n      bitSlice(zz, 8, 2),\n      bitSlice(zz, 10, 2),\n      bitSlice(zz, 12, 2),\n      bitSlice(zz, 14, 2),\n      bitSlice(zz, 16, 2),\n      bitSlice(zz, 18, 2),\n      bitSlice(zz, 20, 2),\n    ];\n  });\n\n  Gates.rangeCheck1(\n    z,\n    yz,\n    [z86, z74, z62, z50, z38, z36, z34, z32, z30, z28, z26, z24, z22],\n    [z20, z18, z16, x76, x64, y76, y64, z14, z12, z10, z8, z6, z4, z2, z0]\n  );\n}\n\n/**\n * Helper function that creates a new {@link Field} element from the first `length` bits of this {@link Field} element.\n *\n * This returns the `x` truncated to `length` bits. However, it does **not** prove this truncation or any\n * other relation of the output with `x`.\n *\n * This only proves that the output value is in the range [0, 2^length), and so can be combined\n * with the initial value to prove a range check.\n */\nfunction rangeCheckHelper(length: number, x: Field) {\n  assert(length <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${length}`);\n  assert(length > 0, `bit length must be positive, got ${length}`);\n  assert(length % 16 === 0, '`length` has to be a multiple of 16.');\n\n  let lengthDiv16 = length / 16;\n  if (x.isConstant()) {\n    let bits = BinableFp.toBits(x.toBigInt())\n      .slice(0, length)\n      .concat(Array(Fp.sizeInBits - length).fill(false));\n    return createField(BinableFp.fromBits(bits));\n  }\n  let y = Snarky.field.truncateToBits16(lengthDiv16, x.value);\n  return createField(y);\n}\n\n/**\n * Asserts that x is in the range [0, 2^n)\n */\nfunction rangeCheckN(n: number, x: Field, message: string = '') {\n  assert(n <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${n}`);\n  assert(n > 0, `bit length must be positive, got ${n}`);\n  assert(n % 16 === 0, '`length` has to be a multiple of 16.');\n\n  if (x.isConstant()) {\n    if (x.toBigInt() >= 1n << BigInt(n)) {\n      throw Error(`rangeCheckN: expected field to fit in ${n} bits, got ${x}.\\n${message}`);\n    }\n    return;\n  }\n\n  let actual = rangeCheckHelper(n, x);\n  actual.assertEquals(x, message);\n}\n\n/**\n * Returns a boolean which, being true, proves that x is in the range [0, 2^n).\n *\n * **Beware**: The output being false does **not** prove that x is not in the range [0, 2^n).\n * In other words, it can happen that this returns false even if x is in the range [0, 2^n).\n *\n * This should not be viewed as a standalone provable method but as an advanced helper function\n * for gadgets which need a weakened form of range check.\n */\nfunction isDefinitelyInRangeN(n: number, x: Field) {\n  assert(n <= Fp.sizeInBits, `bit length must be ${Fp.sizeInBits} or less, got ${n}`);\n  assert(n > 0, `bit length must be positive, got ${n}`);\n  assert(n % 16 === 0, '`length` has to be a multiple of 16.');\n\n  if (x.isConstant()) {\n    return createBool(x.toBigInt() < 1n << BigInt(n));\n  }\n\n  let actual = rangeCheckHelper(n, x);\n  return actual.equals(x);\n}\n\nfunction rangeCheck16(x: Field) {\n  if (x.isConstant()) {\n    assert(x.toBigInt() < 1n << 16n, `rangeCheck16: expected field to fit in 16 bits, got ${x}`);\n    return;\n  }\n  // check that x fits in 16 bits\n  rangeCheckHelper(16, x).assertEquals(x);\n}\n\nfunction rangeCheck8(x: Field) {\n  if (x.isConstant()) {\n    assert(x.toBigInt() < 1n << 8n, `rangeCheck8: expected field to fit in 8 bits, got ${x}`);\n    return;\n  }\n\n  // check that x fits in 16 bits\n  rangeCheckHelper(16, x).assertEquals(x);\n  // check that 2^8 x fits in 16 bits\n  let x256 = x.mul(1 << 8).seal();\n  rangeCheckHelper(16, x256).assertEquals(x256);\n}\n\nfunction rangeCheckLessThan16(bits: number, x: Field) {\n  assert(bits < 16, `bits must be less than 16, got ${bits}`);\n\n  if (x.isConstant()) {\n    assert(\n      x.toBigInt() < 1n << BigInt(bits),\n      `rangeCheckLessThan16: expected field to fit in ${bits} bits, got ${x}`\n    );\n    return;\n  }\n\n  // check that x fits in 16 bits\n  rangeCheckHelper(16, x).assertEquals(x);\n  // check that 2^(16 - bits)*x < 2^16, i.e. x < 2^bits\n  let xM = x.mul(1 << (16 - bits)).seal();\n  rangeCheckHelper(16, xM).assertEquals(xM);\n}\n\nfunction rangeCheckLessThan64(bits: number, x: Field) {\n  assert(bits < 64, `bits must be less than 64, got ${bits}`);\n\n  if (x.isConstant()) {\n    assert(\n      x.toBigInt() < 1n << BigInt(bits),\n      `rangeCheckLessThan16: expected field to fit in ${bits} bits, got ${x}`\n    );\n    return;\n  }\n\n  // check that x fits in 64 bits\n  rangeCheck64(x);\n  // check that 2^(64 - bits)*x < 2^64, i.e. x < 2^bits\n  let xM = x.mul(1 << (64 - bits)).seal();\n  rangeCheck64(xM);\n}\n", "/**\n * Foreign field arithmetic gadgets.\n */\nimport { inverse as modInverse, mod } from '../../../bindings/crypto/finite-field.js';\nimport { provableTuple } from '../types/provable-derivers.js';\nimport { Unconstrained } from '../types/unconstrained.js';\nimport type { Field } from '../field.js';\nimport { Gates, foreignFieldAdd } from '../gates.js';\nimport { exists } from '../core/exists.js';\nimport { modifiedField } from '../types/fields.js';\nimport { Tuple, TupleN } from '../../util/types.js';\nimport { assertOneOf } from './basic.js';\nimport { assert, bitSlice, toVar, toVars } from './common.js';\nimport {\n  l,\n  lMask,\n  multiRangeCheck,\n  l2,\n  l2Mask,\n  l3,\n  compactMultiRangeCheck,\n} from './range-check.js';\nimport { createBool, createField, getField } from '../core/field-constructor.js';\nimport type { Bool } from '../bool.js';\nimport { ProvablePureExtended } from '../types/struct.js';\n\n// external API\nexport { ForeignField, Field3 };\n\n// internal API\nexport { bigint3, Sign, split, combine, weakBound, Sum, assertMul, field3FromBits };\n\n/**\n * A 3-tuple of Fields, representing a 3-limb bigint.\n */\ntype Field3 = [Field, Field, Field];\ntype bigint3 = [bigint, bigint, bigint];\ntype Sign = -1n | 1n;\n\nconst ForeignField = {\n  add(x: Field3, y: Field3, f: bigint) {\n    return sum([x, y], [1n], f);\n  },\n  sub(x: Field3, y: Field3, f: bigint) {\n    return sum([x, y], [-1n], f);\n  },\n  negate(x: Field3, f: bigint) {\n    return sum([Field3.from(0n), x], [-1n], f);\n  },\n  sum,\n  Sum(x: Field3) {\n    return new Sum(x);\n  },\n\n  mul: multiply,\n  inv: inverse,\n  div: divide,\n  assertMul,\n\n  assertAlmostReduced,\n\n  assertLessThan,\n  assertLessThanOrEqual,\n  assertEquals,\n\n  equals,\n  toCanonical,\n};\n\n/**\n * computes x[0] + sign[0] * x[1] + ... + sign[n-1] * x[n] modulo f\n *\n * assumes that inputs are range checked, does range check on the result.\n */\nfunction sum(x: Field3[], sign: Sign[], f: bigint) {\n  assert(x.length === sign.length + 1, 'inputs and operators match');\n\n  // constant case\n  if (x.every(Field3.isConstant)) {\n    let xBig = x.map(Field3.toBigint);\n    let sum = sign.reduce((sum, s, i) => sum + s * xBig[i + 1], xBig[0]);\n    return Field3.from(mod(sum, f));\n  }\n  // provable case - create chain of ffadd rows\n  x = x.map(toVars);\n  let result = x[0];\n  for (let i = 0; i < sign.length; i++) {\n    ({ result } = singleAdd(result, x[i + 1], sign[i], f));\n  }\n  // final zero row to hold result\n  Gates.zero(...result);\n\n  // range check result\n  indirectMultiRangeChange(result);\n\n  return result;\n}\n\n/**\n * core building block for non-native addition\n *\n * **warning**: this just adds the `foreignFieldAdd` row;\n * it _must_ be chained with a second row that holds the result in its first 3 cells.\n *\n * the second row could, for example, be `zero`, `foreignFieldMul`, or another `foreignFieldAdd`.\n */\nfunction singleAdd(x: Field3, y: Field3, sign: Sign, f: bigint) {\n  let f_ = split(f);\n\n  let [r0, r1, r2, overflow, carry] = exists(5, () => {\n    let x_ = toBigint3(x);\n    let y_ = toBigint3(y);\n\n    // figure out if there's overflow\n    let r = combine(x_) + sign * combine(y_);\n    let overflow = 0n;\n    if (sign === 1n && r >= f) overflow = 1n;\n    if (sign === -1n && r < 0n) overflow = -1n;\n    if (f === 0n) overflow = 0n; // special case where overflow doesn't change anything\n\n    // do the add with carry\n    // note: this \"just works\" with negative r01\n    let r01 = combine2(x_) + sign * combine2(y_) - overflow * combine2(f_);\n    let carry = r01 >> l2;\n    r01 &= l2Mask;\n    let [r0, r1] = split2(r01);\n    let r2 = x_[2] + sign * y_[2] - overflow * f_[2] + carry;\n\n    return [r0, r1, r2, overflow, carry];\n  });\n\n  foreignFieldAdd({ left: x, right: y, overflow, carry, modulus: f_, sign });\n\n  return { result: [r0, r1, r2] satisfies Field3, overflow };\n}\n\nfunction multiply(a: Field3, b: Field3, f: bigint): Field3 {\n  assert(f < 1n << 259n, 'Foreign modulus fits in 259 bits');\n\n  // constant case\n  if (Field3.isConstant(a) && Field3.isConstant(b)) {\n    let ab = Field3.toBigint(a) * Field3.toBigint(b);\n    return Field3.from(mod(ab, f));\n  }\n\n  // provable case\n  let { r01, r2, q } = multiplyNoRangeCheck(a, b, f);\n\n  // limb range checks on quotient and remainder\n  multiRangeCheck(q);\n  let r = compactMultiRangeCheck(r01, r2);\n  return r;\n}\n\nfunction inverse(x: Field3, f: bigint): Field3 {\n  assert(f < 1n << 259n, 'Foreign modulus fits in 259 bits');\n\n  // constant case\n  if (Field3.isConstant(x)) {\n    let xInv = modInverse(Field3.toBigint(x), f);\n    assert(xInv !== undefined, 'inverse exists');\n    return Field3.from(xInv);\n  }\n\n  // provable case\n  let xInv = exists(3, () => {\n    let xInv = modInverse(Field3.toBigint(x), f);\n    return xInv === undefined ? [0n, 0n, 0n] : split(xInv);\n  });\n  multiRangeCheck(xInv);\n  // we need to bound xInv because it's a multiplication input\n  let xInv2Bound = weakBound(xInv[2], f);\n\n  let one: Field2 = [createField(1n), createField(0n)];\n  assertMulInternal(x, xInv, one, f);\n\n  // range check on result bound\n  // TODO: this uses two RCs too many.. need global RC stack\n  multiRangeCheck([xInv2Bound, createField(0n), createField(0n)]);\n\n  return xInv;\n}\n\nfunction divide(x: Field3, y: Field3, f: bigint, { allowZeroOverZero = false } = {}) {\n  assert(f < 1n << 259n, 'Foreign modulus fits in 259 bits');\n\n  // constant case\n  if (Field3.isConstant(x) && Field3.isConstant(y)) {\n    let yInv = modInverse(Field3.toBigint(y), f);\n    assert(yInv !== undefined, 'inverse exists');\n    return Field3.from(mod(Field3.toBigint(x) * yInv, f));\n  }\n\n  // provable case\n  // to show that z = x/y, we prove that z*y = x and y != 0 (the latter avoids the unconstrained 0/0 case)\n  let z = exists(3, () => {\n    let yInv = modInverse(Field3.toBigint(y), f);\n    if (yInv === undefined) return [0n, 0n, 0n];\n    return split(mod(Field3.toBigint(x) * yInv, f));\n  });\n  multiRangeCheck(z);\n  let z2Bound = weakBound(z[2], f);\n  assertMulInternal(z, y, x, f);\n\n  // range check on result bound\n  multiRangeCheck([z2Bound, createField(0n), createField(0n)]);\n\n  if (!allowZeroOverZero) {\n    ForeignField.equals(y, 0n, f).assertFalse();\n  }\n  return z;\n}\n\n/**\n * Common logic for gadgets that expect a certain multiplication result a priori, instead of just using the remainder.\n */\nfunction assertMulInternal(x: Field3, y: Field3, xy: Field3 | Field2, f: bigint, message?: string) {\n  let { r01, r2, q } = multiplyNoRangeCheck(x, y, f);\n\n  // range check on quotient\n  multiRangeCheck(q);\n\n  // bind remainder to input xy\n  if (xy.length === 2) {\n    let [xy01, xy2] = xy;\n    r01.assertEquals(xy01, message);\n    r2.assertEquals(xy2, message);\n  } else {\n    let xy01 = xy[0].add(xy[1].mul(1n << l));\n    r01.assertEquals(xy01, message);\n    r2.assertEquals(xy[2], message);\n  }\n}\n\n/**\n * Core building block for all gadgets using foreign field multiplication.\n */\nfunction multiplyNoRangeCheck(a: Field3, b: Field3, f: bigint) {\n  // notation follows https://github.com/o1-labs/rfcs/blob/main/0006-ffmul-revised.md\n  let f_ = (1n << l3) - f;\n  let [f_0, f_1, f_2] = split(f_);\n  let f2 = f >> l2;\n  let f2Bound = (1n << l) - f2 - 1n;\n\n  let witnesses = exists(21, () => {\n    // convert inputs to bigints\n    let [a0, a1, a2] = toBigint3(a);\n    let [b0, b1, b2] = toBigint3(b);\n\n    // compute q and r such that a*b = q*f + r\n    let ab = combine([a0, a1, a2]) * combine([b0, b1, b2]);\n    let q = ab / f;\n    let r = ab - q * f;\n\n    let [q0, q1, q2] = split(q);\n    let [r0, r1, r2] = split(r);\n    let r01 = combine2([r0, r1]);\n\n    // compute product terms\n    let p0 = a0 * b0 + q0 * f_0;\n    let p1 = a0 * b1 + a1 * b0 + q0 * f_1 + q1 * f_0;\n    let p2 = a0 * b2 + a1 * b1 + a2 * b0 + q0 * f_2 + q1 * f_1 + q2 * f_0;\n\n    let [p10, p110, p111] = split(p1);\n    let p11 = combine2([p110, p111]);\n\n    // carry bottom limbs\n    let c0 = (p0 + (p10 << l) - r01) >> l2;\n\n    // carry top limb\n    let c1 = (p2 - r2 + p11 + c0) >> l;\n\n    // split high carry\n    let c1_00 = bitSlice(c1, 0, 12);\n    let c1_12 = bitSlice(c1, 12, 12);\n    let c1_24 = bitSlice(c1, 24, 12);\n    let c1_36 = bitSlice(c1, 36, 12);\n    let c1_48 = bitSlice(c1, 48, 12);\n    let c1_60 = bitSlice(c1, 60, 12);\n    let c1_72 = bitSlice(c1, 72, 12);\n    let c1_84 = bitSlice(c1, 84, 2);\n    let c1_86 = bitSlice(c1, 86, 2);\n    let c1_88 = bitSlice(c1, 88, 2);\n    let c1_90 = bitSlice(c1, 90, 1);\n\n    // quotient high bound\n    let q2Bound = q2 + f2Bound;\n\n    // prettier-ignore\n    return [\n      r01, r2,\n      q0, q1, q2,\n      q2Bound,\n      p10, p110, p111,\n      c0,\n      c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72,\n      c1_84, c1_86, c1_88, c1_90,\n    ];\n  });\n\n  // prettier-ignore\n  let [\n    r01, r2,\n    q0, q1, q2,\n    q2Bound,\n    p10, p110, p111,\n    c0,\n    c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72,\n    c1_84, c1_86, c1_88, c1_90,\n  ] = witnesses;\n\n  let q: Field3 = [q0, q1, q2];\n\n  // ffmul gate. this already adds the following zero row.\n  Gates.foreignFieldMul({\n    left: a,\n    right: b,\n    remainder: [r01, r2],\n    quotient: q,\n    quotientHiBound: q2Bound,\n    product1: [p10, p110, p111],\n    carry0: c0,\n    carry1p: [c1_00, c1_12, c1_24, c1_36, c1_48, c1_60, c1_72],\n    carry1c: [c1_84, c1_86, c1_88, c1_90],\n    foreignFieldModulus2: f2,\n    negForeignFieldModulus: [f_0, f_1, f_2],\n  });\n\n  // multi-range check on internal values\n  multiRangeCheck([p10, p110, q2Bound]);\n\n  // note: this function is supposed to be the most flexible interface to the ffmul gate.\n  // that's why we don't add range checks on q and r here, because there are valid use cases\n  // for not range-checking either of them -- for example, they could be wired to other\n  // variables that are already range-checked, or to constants / public inputs.\n  return { r01, r2, q };\n}\n\nfunction weakBound(x: Field, f: bigint) {\n  // if f0, f1 === 0, we can use a stronger bound x[2] < f2\n  // because this is true for all field elements x in [0,f)\n  if ((f & l2Mask) === 0n) {\n    return x.add(lMask + 1n - (f >> l2));\n  }\n  // otherwise, we use x[2] < f2 + 1, so we allow x[2] === f2\n  return x.add(lMask - (f >> l2));\n}\n\n/**\n * Apply range checks and weak bounds checks to a list of Field3s.\n * Optimal if the list length is a multiple of 3.\n */\nfunction assertAlmostReduced(xs: Field3[], f: bigint, skipMrc = false) {\n  let bounds: Field[] = [];\n\n  for (let x of xs) {\n    if (!skipMrc) multiRangeCheck(x);\n\n    bounds.push(weakBound(x[2], f));\n    if (TupleN.hasLength(3, bounds)) {\n      multiRangeCheck(bounds);\n      bounds = [];\n    }\n  }\n  if (TupleN.hasLength(1, bounds)) {\n    multiRangeCheck([...bounds, createField(0n), createField(0n)]);\n  }\n  if (TupleN.hasLength(2, bounds)) {\n    multiRangeCheck([...bounds, createField(0n)]);\n  }\n}\n\n/**\n * check whether x = c mod f\n *\n * c is a constant, and we require c in [0, f)\n *\n * assumes that x is almost reduced mod f, so we know that x might be c or c + f, but not c + 2f, c + 3f, ...\n */\nfunction equals(x: Field3, c: bigint, f: bigint) {\n  assert(c >= 0n && c < f, 'equals: c must be in [0, f)');\n\n  // constant case\n  if (Field3.isConstant(x)) {\n    return createBool(mod(Field3.toBigint(x), f) === c);\n  }\n\n  // provable case\n  if (f >= 1n << l2) {\n    // check whether x = 0 or x = f\n    let x01 = toVar(x[0].add(x[1].mul(1n << l)));\n    let [c01, c2] = [c & l2Mask, c >> l2];\n    let [cPlusF01, cPlusF2] = [(c + f) & l2Mask, (c + f) >> l2];\n\n    // (x01, x2) = (c01, c2)\n    let isC = x01.equals(c01).and(x[2].equals(c2));\n    // (x01, x2) = (cPlusF01, cPlusF2)\n    let isCPlusF = x01.equals(cPlusF01).and(x[2].equals(cPlusF2));\n\n    return isC.or(isCPlusF);\n  } else {\n    // if f < 2^2l, the approach above doesn't work (we don't know from x[2] = 0 that x < 2f),\n    // so in that case we assert that x < f and then check whether it's equal to c\n    ForeignField.assertLessThan(x, f);\n    let x012 = toVar(x[0].add(x[1].mul(1n << l)).add(x[2].mul(1n << l2)));\n    return x012.equals(c);\n  }\n}\n\n// Field3 equality checking that each of the 3 limbs are exactly the same (not modular equality).\nfunction assertEquals(x: Field3, y: Field3) {\n  // constant case\n  if (Field3.isConstant(x) && Field3.isConstant(y)) {\n    assert(Field3.toBigint(x) === Field3.toBigint(y), 'assertEqual: got x != y');\n    return;\n  }\n  //provable case\n  x[0].assertEquals(y[0]);\n  x[1].assertEquals(y[1]);\n  x[2].assertEquals(y[2]);\n}\n\n/**\n * Convert x, which may be unreduced, to a canonical representative < f.\n *\n * Note: This method is complete, it works for all unreduced field elements.\n * It can therefore be used to protect against incompleteness of field operations in other places.\n */\nfunction toCanonical(x: Field3, f: bigint) {\n  // multiply by 1 to get reduced representative\n  // note: this is sound because x < 2^3l << 2^3l p\n  let xR = multiply(x, Field3.from(1n), f);\n\n  // assert the result is canonical, and return it\n  assertLessThan(xR, f);\n\n  return xR;\n}\n\nconst provableLimb = modifiedField({});\n\nconst Field3 = {\n  /**\n   * Turn a bigint into a 3-tuple of Fields\n   */\n  from(x: bigint | Field3): Field3 {\n    if (Array.isArray(x)) return x;\n    return Tuple.map(split(x), createField);\n  },\n\n  /**\n   * Turn a 3-tuple of Fields into a bigint\n   */\n  toBigint(x: Field3): bigint {\n    return combine(toBigint3(x));\n  },\n\n  /**\n   * Turn several 3-tuples of Fields into bigints\n   */\n  toBigints<T extends Tuple<Field3>>(...xs: T) {\n    return Tuple.map(xs, Field3.toBigint);\n  },\n\n  /**\n   * Check whether a 3-tuple of Fields is constant\n   */\n  isConstant(x: Field3) {\n    return x.every((x) => x.isConstant());\n  },\n\n  /**\n   * `Provable<T>` interface for `Field3 = [Field, Field, Field]`.\n   *\n   * Note: Witnessing this creates a plain tuple of field elements without any implicit\n   * range checks.\n   */\n  provable: {\n    ...provableTuple([provableLimb, provableLimb, provableLimb]),\n    toValue(x): bigint {\n      return Field3.toBigint(x);\n    },\n    fromValue(x): Field3 {\n      if (typeof x === 'bigint') return Field3.from(x);\n      return x;\n    },\n  } satisfies ProvablePureExtended<Field3, bigint, [string, string, string]>,\n  /**\n   * Splits a bigint into three limbs using bitwise operations.\n   */\n  split,\n};\n\ntype Field2 = [Field, Field];\nconst Field2 = {\n  toBigint(x: Field2): bigint {\n    return combine2(Tuple.map(x, (x) => x.toBigInt()));\n  },\n};\n\nfunction toBigint3(x: Field3): bigint3 {\n  return Tuple.map(x, (x) => x.toBigInt());\n}\n\nfunction combine([x0, x1, x2]: bigint3) {\n  return x0 + (x1 << l) + (x2 << l2);\n}\nfunction split(x: bigint): bigint3 {\n  return [x & lMask, (x >> l) & lMask, (x >> l2) & lMask];\n}\n\nfunction combine2([x0, x1]: bigint3 | [bigint, bigint]) {\n  return x0 + (x1 << l);\n}\nfunction split2(x: bigint): [bigint, bigint] {\n  return [x & lMask, (x >> l) & lMask];\n}\n\n/**\n * Optimized multiplication of sums, like (x + y)*z = a + b + c\n *\n * We use several optimizations over naive summing and then multiplying:\n *\n * - we skip the range check on the remainder sum, because ffmul is sound with r being a sum of range-checked values\n * - we replace the range check on the input sums with an extra low limb sum using generic gates\n * - we chain the first input's sum into the ffmul gate\n *\n * As usual, all values are assumed to be range checked, and the left and right multiplication inputs\n * are assumed to be bounded such that `l * r < 2^264 * (native modulus)`.\n * However, all extra checks that are needed on the _sums_ are handled here.\n */\nfunction assertMul(\n  x: Field3 | Sum,\n  y: Field3 | Sum,\n  xy: Field3 | Sum,\n  f: bigint,\n  message?: string\n) {\n  x = Sum.fromUnfinished(x);\n  y = Sum.fromUnfinished(y);\n  xy = Sum.fromUnfinished(xy);\n\n  // conservative estimate to ensure that multiplication bound is satisfied\n  // we assume that all summands si are bounded with si[2] <= f[2] checks, which implies si < 2^k where k := ceil(log(f))\n  // our assertion below gives us\n  // |x|*|y| + q*f + |r| < (x.length * y.length) 2^2k + 2^2k + 2^2k < 3 * 2^(2*258) < 2^264 * (native modulus)\n  assert(\n    BigInt(Math.ceil(Math.sqrt(x.length * y.length))) * f < 1n << 258n,\n    `Foreign modulus is too large for multiplication of sums of lengths ${x.length} and ${y.length}`\n  );\n\n  // finish the y and xy sums with a zero gate\n  let y0 = y.finishForMulInput(f);\n  let xy0 = xy.finish(f);\n\n  // x is chained into the ffmul gate\n  let x0 = x.finishForMulInput(f, true);\n\n  // constant case\n  if (Field3.isConstant(x0) && Field3.isConstant(y0) && Field3.isConstant(xy0)) {\n    let x_ = Field3.toBigint(x0);\n    let y_ = Field3.toBigint(y0);\n    let xy_ = Field3.toBigint(xy0);\n    assert(mod(x_ * y_, f) === xy_, message ?? 'assertMul(): incorrect multiplication result');\n    return;\n  }\n\n  assertMulInternal(x0, y0, xy0, f, message);\n}\n\n/**\n * @internal\n *\n * Lazy sum of {@link Field3} elements, which can be used as input to `Gadgets.ForeignField.assertMul()`.\n */\nclass Sum {\n  #result?: Field3;\n  #summands: Field3[];\n  #ops: Sign[] = [];\n\n  constructor(x: Field3) {\n    this.#summands = [x];\n  }\n\n  get result() {\n    assert(this.#result !== undefined, 'sum not finished');\n    return this.#result;\n  }\n\n  get length() {\n    return this.#summands.length;\n  }\n\n  add(y: Field3) {\n    assert(this.#result === undefined, 'sum already finished');\n    this.#ops.push(1n);\n    this.#summands.push(y);\n    return this;\n  }\n\n  sub(y: Field3) {\n    assert(this.#result === undefined, 'sum already finished');\n    this.#ops.push(-1n);\n    this.#summands.push(y);\n    return this;\n  }\n\n  #return(x: Field3) {\n    this.#result = x;\n    return x;\n  }\n\n  isConstant() {\n    return this.#summands.every(Field3.isConstant);\n  }\n\n  finish(f: bigint, isChained = false) {\n    assert(this.#result === undefined, 'sum already finished');\n    let signs = this.#ops;\n    let n = signs.length;\n    if (n === 0) return this.#return(this.#summands[0]);\n\n    // constant case\n    if (this.isConstant()) {\n      return this.#return(sum(this.#summands, signs, f));\n    }\n\n    // provable case\n    let x = this.#summands.map(toVars);\n    let result = x[0];\n\n    for (let i = 0; i < n; i++) {\n      ({ result } = singleAdd(result, x[i + 1], signs[i], f));\n    }\n    if (!isChained) Gates.zero(...result);\n\n    this.#result = result;\n    return result;\n  }\n\n  // TODO this is complex and should be removed once we fix the ffadd gate to constrain all limbs individually\n  finishForMulInput(f: bigint, isChained = false) {\n    assert(this.#result === undefined, 'sum already finished');\n    let signs = this.#ops;\n    let n = signs.length;\n    if (n === 0) return this.#return(this.#summands[0]);\n\n    // constant case\n    if (this.isConstant()) {\n      return this.#return(sum(this.#summands, signs, f));\n    }\n\n    // provable case\n    let xs = this.#summands.map(toVars);\n\n    // since the sum becomes a multiplication input, we need to constrain all limbs _individually_.\n    // sadly, ffadd only constrains the low and middle limb together.\n    // we could fix it with a RC just for the lower two limbs\n    // but it's cheaper to add generic gates which handle the lowest limb separately, and avoids the unfilled MRC slot\n    let f0 = f & lMask;\n\n    // generic gates for low limbs\n    let x0 = xs[0][0];\n    let x0s: Field[] = [];\n    let overflows: Field[] = [];\n    let xRef = Unconstrained.witness(() => Field3.toBigint(xs[0]));\n\n    // this loop mirrors the computation that a chain of ffadd gates does,\n    // but everything is done only on the lowest limb and using generic gates.\n    // the output is a sequence of low limbs (x0) and overflows, which will be wired to the ffadd results at each step.\n    for (let i = 0; i < n; i++) {\n      // compute carry and overflow\n      let [carry, overflow] = exists(2, () => {\n        // this duplicates some of the logic in singleAdd\n        let x = xRef.get();\n        let x0 = x & lMask;\n        let xi = toBigint3(xs[i + 1]);\n        let sign = signs[i];\n\n        // figure out if there's overflow\n        x += sign * combine(xi);\n        let overflow = 0n;\n        if (sign === 1n && x >= f) overflow = 1n;\n        if (sign === -1n && x < 0n) overflow = -1n;\n        if (f === 0n) overflow = 0n;\n        xRef.set(x - overflow * f);\n\n        // add with carry, only on the lowest limb\n        x0 = x0 + sign * xi[0] - overflow * f0;\n        let carry = x0 >> l;\n        return [carry, overflow];\n      });\n      overflows.push(overflow);\n\n      // constrain carry\n      assertOneOf(carry, [0n, 1n, -1n]);\n\n      // x0 <- x0 + s*xi0 - o*f0 - c*2^l\n      x0 = toVar(\n        x0\n          .add(xs[i + 1][0].mul(signs[i]))\n          .sub(overflow.mul(f0))\n          .sub(carry.mul(1n << l))\n      );\n      x0s.push(x0);\n    }\n\n    // ffadd chain\n    let x = xs[0];\n    for (let i = 0; i < n; i++) {\n      let { result, overflow } = singleAdd(x, xs[i + 1], signs[i], f);\n      // wire low limb and overflow to previous values\n      result[0].assertEquals(x0s[i]);\n      overflow.assertEquals(overflows[i]);\n      x = result;\n    }\n    if (!isChained) Gates.zero(...x);\n\n    this.#result = x;\n    return x;\n  }\n\n  rangeCheck() {\n    assert(this.#result !== undefined, 'sum not finished');\n    if (this.#ops.length > 0) multiRangeCheck(this.#result);\n  }\n\n  static fromUnfinished(x: Field3 | Sum) {\n    if (x instanceof Sum) {\n      assert(x.#result === undefined, 'sum already finished');\n      return x;\n    }\n    return new Sum(x);\n  }\n}\n\n// Field3 comparison\n\nfunction assertLessThan(x: Field3, y: bigint | Field3) {\n  let y_ = Field3.from(y);\n\n  // constant case, y = constant, x = constant\n\n  if (Field3.isConstant(x) && Field3.isConstant(y_)) {\n    assert(Field3.toBigint(x) < Field3.toBigint(y_), 'assertLessThan: got x >= y');\n    return;\n  }\n\n  // case of y = constant, x = variable\n\n  if (Field3.isConstant(y_)) {\n    y = typeof y === 'bigint' ? y : Field3.toBigint(y);\n    // this case is not included below, because ffadd doesn't support negative moduli\n    assert(y > 0n, 'assertLessThan: y <= 0, so x < y is impossible');\n\n    // we can just use negation `(y - 1) - x`. because the result is range-checked, it proves that x < y:\n    // `y - 1 - x \\in [0, 2^3l) => x <= x + (y - 1 - x) = y - 1 < y`\n    // (note: ffadd can't add higher multiples of (f - 1). it must always use an overflow of -1, except for x = 0)\n\n    ForeignField.negate(x, y - 1n);\n    return;\n  }\n\n  // case of two variables or x = constant and y = variable\n  // we compute z = y - x - 1 and check that z \\in [0, 2^3l), which implies x < y as above\n\n  // we use modulo 0 here, which means we're proving:\n  // z = y - x - 1 - 0*(o1 + o2) for some overflows o1, o2\n  sum([y_, x, Field3.from(1n)], [-1n, -1n], 0n);\n}\n\nfunction assertLessThanOrEqual(x: Field3, y: bigint | Field3) {\n  assert(typeof y !== 'bigint' || y >= 0n, 'assertLessThanOrEqual: upper bound must be positive');\n  let y_ = Field3.from(y);\n\n  // constant case\n  if (Field3.isConstant(x) && Field3.isConstant(y_)) {\n    assert(Field3.toBigint(x) <= Field3.toBigint(y_), 'assertLessThan: got x > y');\n    return;\n  }\n\n  // provable case\n  // we compute z = y - x and check that z \\in [0, 2^3l), which implies x <= y\n  sum([y_, x], [-1n], 0n);\n}\n\n// Field3 from/to bits\n\nfunction field3FromBits(bits: Bool[]): Field3 {\n  const Field = getField();\n  let limbSize = Number(l);\n  let l0 = Field.fromBits(bits.slice(0 * limbSize, 1 * limbSize));\n  let l1 = Field.fromBits(bits.slice(1 * limbSize, 2 * limbSize));\n  let l2 = Field.fromBits(bits.slice(2 * limbSize, 3 * limbSize));\n  return [l0, l1, l2];\n}\n\n// helpers\n\n/**\n * Version of `multiRangeCheck` which does the check on a truncated version of the input,\n * so that it always succeeds, and then checks equality of the truncated and full input.\n *\n * This is a hack to get an error when the constraint fails, around the fact that multiRangeCheck\n * is not checked by snarky.\n */\nfunction indirectMultiRangeChange(x: Field3, message = 'multi-range check failed') {\n  let xTrunc = exists(3, () => {\n    let [x0, x1, x2] = toBigint3(x);\n    return [x0 & lMask, x1 & lMask, x2 & lMask];\n  });\n  multiRangeCheck(xTrunc);\n  x[0].assertEquals(xTrunc[0], message);\n  x[1].assertEquals(xTrunc[1], message);\n  x[2].assertEquals(xTrunc[2], message);\n}\n", "import type { Field } from '../field.js';\nimport type { Bool } from '../bool.js';\nimport { createBool, createBoolUnsafe, createField } from '../core/field-constructor.js';\nimport { Fp } from '../../../bindings/crypto/finite-field.js';\nimport { assert } from '../../../lib/util/assert.js';\nimport { exists, existsOne } from '../core/exists.js';\nimport { assertMul } from './compatible.js';\nimport { Field3, ForeignField } from './foreign-field.js';\nimport { l, l2, multiRangeCheck } from './range-check.js';\nimport { witness } from '../types/witness.js';\n\nexport {\n  // generic comparison gadgets for inputs in a narrower range < p/2\n  assertLessThanGeneric,\n  assertLessThanOrEqualGeneric,\n  lessThanGeneric,\n  lessThanOrEqualGeneric,\n\n  // comparison gadgets for full range inputs\n  assertLessThanFull,\n  assertLessThanOrEqualFull,\n  lessThanFull,\n  lessThanOrEqualFull,\n\n  // gadgets that are based on full comparisons\n  isOddAndHigh,\n\n  // legacy, unused\n  compareCompatible,\n\n  // internal helper\n  fieldToField3,\n};\n\n/**\n * Prove x <= y assuming 0 <= x, y < c.\n * The upper bound c must satisfy 2c <= p, where p is the field order.\n *\n * Expects a function `rangeCheck(v: Field)` which proves that v is in [0, p-c).\n * (Note: the range check on v can be looser than the assumption on x and y, but it doesn't have to be)\n * The efficiency of the gadget largely depends on the efficiency of `rangeCheck()`.\n *\n * **Warning:** The gadget does not prove x <= y if either 2c > p or x or y are not in [0, c).\n * Neither of these conditions are enforced by the gadget.\n */\nfunction assertLessThanOrEqualGeneric(x: Field, y: Field, rangeCheck: (v: Field) => void) {\n  // since 0 <= x, y < c, we have y - x in [0, c) u (p-c, p)\n  // because of c <= p-c, the two ranges are disjoint. therefore,\n  // y - x in [0, p-c) is equivalent to x <= y\n  rangeCheck(y.sub(x).seal());\n}\n\n/**\n * Prove x < y assuming 0 <= x, y < c.\n *\n * Assumptions are the same as in {@link assertLessThanOrEqualGeneric}.\n */\nfunction assertLessThanGeneric(x: Field, y: Field, rangeCheck: (v: Field) => void) {\n  // since 0 <= x, y < c, we have y - 1 - x in [0, c) u [p-c, p)\n  // because of c <= p-c, the two ranges are disjoint. therefore,\n  // y - 1 - x in [0, p-c) is equivalent to x <= y - 1 which is equivalent to x < y\n  rangeCheck(y.sub(1).sub(x).seal());\n}\n\n/**\n * Return a Bool b that is true if and only if x < y.\n *\n * Assumptions are similar as in {@link assertLessThanOrEqualGeneric}, with some important differences:\n * - c is a required input\n * - the `rangeCheck` function must fully prove that its input is in [0, c)\n */\nfunction lessThanGeneric(x: Field, y: Field, c: bigint, rangeCheck: (v: Field) => void) {\n  // we prove that there exists b such that b*c + x - y is in [0, c)\n  // if b = 0, this implies x - y is in [0, c), and so x >= y\n  // if b = 1, this implies x - y is in [p-c, p), and so x < y because p-c >= c\n  let b = existsOne(() => BigInt(x.toBigInt() < y.toBigInt()));\n  let isLessThan = b.assertBool();\n\n  // b*c + x - y in [0, c)\n  rangeCheck(b.mul(c).add(x).sub(y).seal());\n\n  return isLessThan;\n}\n\n/**\n * Return a Bool b that is true if and only if x <= y.\n *\n * Assumptions are similar as in {@link assertLessThanOrEqualGeneric}, with some important differences:\n * - c is a required input\n * - the `rangeCheck` function must fully prove that its input is in [0, c)\n */\nfunction lessThanOrEqualGeneric(x: Field, y: Field, c: bigint, rangeCheck: (v: Field) => void) {\n  // we prove that there exists b such that b*c + x - y - 1 is in [0, c)\n  // if b = 0, this implies x - y - 1 is in [0, c), and so x > y\n  // if b = 1, this implies x - y - 1 is in [p-c, p), and so x <= y because p-c >= c\n  let b = existsOne(() => BigInt(x.toBigInt() <= y.toBigInt()));\n  let isLessThanOrEqual = b.assertBool();\n\n  // b*c + x - y - 1 in [0, c)\n  rangeCheck(b.mul(c).add(x).sub(y).sub(1).seal());\n\n  return isLessThanOrEqual;\n}\n\n/**\n * Assert that x < y.\n *\n * There are no assumptions on the range of x and y, they can occupy the full range [0, p).\n */\nfunction assertLessThanFull(x: Field, y: Field) {\n  let xBig = fieldToField3(x);\n  let yBig = fieldToField3(y);\n\n  // x < y as bigints\n  ForeignField.assertLessThan(xBig, yBig);\n\n  // y < p, so y is canonical. implies x < p as well.\n  // (if we didn't do this check, we would prove nothing.\n  // e.g. yBig could be the bigint representation of y + p, and only _therefore_ larger than xBig)\n  ForeignField.assertLessThan(yBig, Fp.modulus);\n}\n\n/**\n * Assert that x <= y.\n *\n * There are no assumptions on the range of x and y, they can occupy the full range [0, p).\n */\nfunction assertLessThanOrEqualFull(x: Field, y: Field) {\n  let xBig = fieldToField3(x);\n  let yBig = fieldToField3(y);\n  ForeignField.assertLessThanOrEqual(xBig, yBig);\n  ForeignField.assertLessThan(yBig, Fp.modulus);\n}\n\n/**\n * Return a Bool b that is true if and only if x < y.\n *\n * There are no assumptions on the range of x and y, they can occupy the full range [0, p).\n */\nfunction lessThanFull(x: Field, y: Field) {\n  // same logic as in lessThanGeneric:\n  // we witness b such that b*p + x - y is in [0, p), where the sum is done in bigint arithmetic\n  // if b = 0, x - y is in [0, p), and so x >= y\n  // if b = 1, x - y is in [-p, 0), and so x < y\n  // we must also check that both x and y are canonical, or else the connection between the bigint and the Field is lost\n  let b = existsOne(() => BigInt(x.toBigInt() < y.toBigInt()));\n  let isLessThan = b.assertBool();\n\n  let xBig = fieldToField3(x);\n  let yBig = fieldToField3(y);\n  ForeignField.assertLessThan(xBig, Fp.modulus);\n  ForeignField.assertLessThan(yBig, Fp.modulus);\n\n  let [p0, p1, p2] = Field3.from(Fp.modulus);\n  let bTimesP: Field3 = [p0.mul(b), p1.mul(b), p2.mul(b)];\n\n  // b*p + x - y in [0, p)\n  let z = ForeignField.sum([bTimesP, xBig, yBig], [1n, -1n], 0n);\n  ForeignField.assertLessThan(z, Fp.modulus);\n\n  return isLessThan;\n}\n\n/**\n * Return a Bool b that is true if and only if x <= y.\n *\n * There are no assumptions on the range of x and y, they can occupy the full range [0, p).\n */\nfunction lessThanOrEqualFull(x: Field, y: Field) {\n  // keep it simple and just use x <= y <=> !(y < x)\n  return lessThanFull(y, x).not();\n}\n\n/**\n * Splits a field element into a low bit `isOdd` and a 254-bit `high` part.\n *\n * There are no assumptions on the range of x and y, they can occupy the full range [0, p).\n */\nfunction isOddAndHigh(x: Field) {\n  if (x.isConstant()) {\n    let x0 = x.toBigInt();\n    return { isOdd: createBool((x0 & 1n) === 1n), high: createField(x0 >> 1n) };\n  }\n\n  // witness a bit b such that x = b + 2z for some z <= (p-1)/2\n  // this is always possible, and unique _except_ in the edge case where x = 0 = 0 + 2*0 = 1 + 2*(p-1)/2\n  // so we must assert that x = 0 implies b = 0\n  let [b, z] = exists(2, () => {\n    let x0 = x.toBigInt();\n    return [x0 & 1n, x0 >> 1n];\n  });\n  let isOdd = b.assertBool();\n  z.assertLessThan((Fp.modulus + 1n) / 2n);\n\n  // x == b + 2z\n  b.add(z.mul(2n)).assertEquals(x);\n\n  // prevent overflow case when x = 0\n  // we witness x' such that b == x * x', which makes it impossible to have x = 0 and b = 1\n  let x_ = existsOne(() => (b.toBigInt() === 0n ? 0n : (Fp.inverse(x.toBigInt()) ?? 0n)));\n  x.mul(x_).assertEquals(b);\n\n  return { isOdd, high: z };\n}\n\n/**\n * internal helper, split Field into a 3-limb bigint\n *\n * **Warning:** the output is underconstrained up to a multiple of the modulus that could be added to the bigint.\n */\nfunction fieldToField3(x: Field) {\n  if (x.isConstant()) return Field3.from(x.toBigInt());\n\n  let xBig = witness(Field3, () => x.toBigInt());\n  multiRangeCheck(xBig);\n  let [x0, x1, x2] = xBig;\n\n  // prove that x == x0 + x1*2^l + x2*2^2l\n  let x_ = x0.add(x1.mul(1n << l)).add(x2.mul(1n << l2));\n  x_.assertEquals(x);\n  return xBig;\n}\n\n/**\n * Compare x and y assuming both have at most `n` bits.\n *\n * **Important:** If `x` and `y` have more than `n` bits, this doesn't prove the comparison correctly.\n * It is up to the caller to prove that `x` and `y` have at most `n` bits.\n *\n * **Warning:** This was created for 1:1 compatibility with snarky's `compare` gadget.\n * It was designed for R1CS and is extremely inefficient when used with plonkish arithmetization.\n */\nfunction compareCompatible(x: Field, y: Field, n = Fp.sizeInBits - 2) {\n  let maxLength = Fp.sizeInBits - 2;\n  assert(n <= maxLength, `bitLength must be at most ${maxLength}`);\n\n  // z = 2^n + y - x\n  let z = createField(1n << BigInt(n))\n    .add(y)\n    .sub(x);\n\n  let zBits = unpack(z, n + 1);\n\n  // highest (n-th) bit tells us if z >= 2^n\n  // which is equivalent to x <= y\n  let lessOrEqual = zBits[n];\n\n  // other bits tell us if x = y\n  let prefix = zBits.slice(0, n);\n  let notAllZeros = any(prefix);\n  let less = lessOrEqual.and(notAllZeros);\n\n  return { lessOrEqual, less };\n}\n\n// helper functions for `compareCompatible()`\n\n// custom version of toBits to be compatible\nfunction unpack(x: Field, length: number) {\n  let bits = exists(length, () => {\n    let x0 = x.toBigInt();\n    return Array.from({ length }, (_, k) => (x0 >> BigInt(k)) & 1n);\n  });\n  bits.forEach((b) => b.assertBool());\n  let lc = bits.reduce((acc, b, i) => acc.add(b.mul(1n << BigInt(i))), createField(0));\n  assertMul(lc, createField(1), x);\n  return bits.map((b) => createBoolUnsafe(b));\n}\n\nfunction any(xs: Bool[]) {\n  let sum = xs.reduce((a, b) => a.add(b.toField()), createField(0));\n  let allZero = isZero(sum);\n  return allZero.not();\n}\n\n// custom isZero to be compatible\nfunction isZero(x: Field): Bool {\n  // create witnesses z = 1/x (or z=0 if x=0), and b = 1 - zx\n  let [b, z] = exists(2, () => {\n    let xmy = x.toBigInt();\n    let z = Fp.inverse(xmy) ?? 0n;\n    let b = Fp.sub(1n, Fp.mul(z, xmy));\n    return [b, z];\n  });\n  // b * x === 0\n  assertMul(b, x, createField(0));\n  // z * x === 1 - b\n  assertMul(z, x, createField(1).sub(b));\n  return createBoolUnsafe(b);\n}\n", "import { Snarky } from '../../bindings.js';\nimport { Fp } from '../../bindings/crypto/finite-field.js';\nimport { BinableFp, SignableFp } from '../../mina-signer/src/field-bigint.js';\nimport { defineBinable } from '../../bindings/lib/binable.js';\nimport type { NonNegativeInteger } from '../../bindings/crypto/non-negative.js';\nimport { inCheckedComputation } from './core/provable-context.js';\nimport { Bool } from './bool.js';\nimport { assert } from '../util/errors.js';\nimport { Provable } from './provable.js';\nimport { assertEqual, assertMul, assertSquare, assertBoolean } from './gadgets/compatible.js';\nimport { assertBilinear, toLinearCombination } from './gadgets/basic.js';\nimport { FieldType, FieldVar, FieldConst, VarFieldVar, ConstantFieldVar } from './core/fieldvar.js';\nimport { exists, existsOne } from './core/exists.js';\nimport { setFieldConstructor } from './core/field-constructor.js';\nimport {\n  assertLessThanFull,\n  assertLessThanOrEqualFull,\n  isOddAndHigh,\n  lessThanFull,\n  lessThanOrEqualFull,\n} from './gadgets/comparison.js';\nimport { toVar } from './gadgets/common.js';\n\n// external API\nexport { Field };\n\n// internal API\nexport {\n  ConstantField,\n  VarField,\n  withMessage,\n  readVarMessage,\n  toConstantField,\n  toFp,\n  checkBitLength,\n};\n\ntype ConstantField = Field & { value: ConstantFieldVar };\ntype VarField = Field & { value: VarFieldVar };\n\n/**\n * A {@link Field} is an element of a prime order [finite field](https://en.wikipedia.org/wiki/Finite_field).\n * Every other provable type is built using the {@link Field} type.\n *\n * The field is the [pasta base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/) of order 2^254 + 0x224698fc094cf91b992d30ed00000001 ({@link Field.ORDER}).\n *\n * You can create a new Field from everything \"field-like\" (`bigint`, integer `number`, decimal `string`, `Field`).\n * @example\n * ```\n * Field(10n); // Field construction from a big integer\n * Field(100); // Field construction from a number\n * Field(\"1\"); // Field construction from a decimal string\n * ```\n *\n * **Beware**: Fields _cannot_ be constructed from fractional numbers or alphanumeric strings:\n * ```ts\n * Field(3.141); // ERROR: Cannot convert a float to a field element\n * Field(\"abc\"); // ERROR: Invalid argument \"abc\"\n * ```\n *\n * Creating a Field from a negative number can result in unexpected behavior if you are not familiar with [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).\n * @example\n * ```\n * const x = Field(-1); // Valid Field construction from negative number\n * const y = Field(Field.ORDER - 1n); // equivalent to `x`\n * ```\n *\n * **Important**: All the functions defined on a Field (arithmetic, logic, etc.) take their arguments as \"field-like\". A Field itself is also defined as a \"field-like\" element.\n *\n * @param value - the value to convert to a {@link Field}\n *\n * @return A {@link Field} with the value converted from the argument\n */\nclass Field {\n  value: FieldVar;\n\n  /**\n   * The order of the pasta curve that {@link Field} type build on as a `bigint`.\n   * Order of the {@link Field} is 28948022309329048855892746252171976963363056481941560715954676764349967630337.\n   */\n  static ORDER = Fp.modulus;\n\n  /**\n   * Coerce anything \"field-like\" (bigint, number, string, and {@link Field}) to a Field.\n   */\n  constructor(x: bigint | number | string | Field | FieldVar | FieldConst) {\n    if (x instanceof Field) {\n      this.value = x.value;\n      return;\n    }\n    if (Array.isArray(x)) {\n      if (typeof x[1] === 'bigint') {\n        // FieldConst\n        this.value = FieldVar.constant(x as FieldConst);\n        return;\n      } else {\n        // FieldVar\n        this.value = x as FieldVar;\n        return;\n      }\n    }\n    // TODO this should handle common values efficiently by reading from a lookup table\n    this.value = FieldVar.constant(Fp.mod(BigInt(x)));\n  }\n\n  // helpers\n\n  static from(x: bigint | number | string | Field): Field {\n    if (x instanceof Field) return x;\n    return new Field(x);\n  }\n\n  /**\n   * Check whether this {@link Field} element is a hard-coded constant in the constraint system.\n   * If a {@link Field} is constructed outside a zkApp method, it is a constant.\n   *\n   * @example\n   * ```ts\n   * console.log(Field(42).isConstant()); // true\n   * ```\n   *\n   * @example\n   * ```ts\n   * \\@method myMethod(x: Field) {\n   *    console.log(x.isConstant()); // false\n   * }\n   * ```\n   *\n   * @return A `boolean` showing if this {@link Field} is a constant or not.\n   */\n  isConstant(): this is { value: ConstantFieldVar } {\n    return this.value[0] === FieldType.Constant;\n  }\n\n  /**\n   * Create a {@link Field} element equivalent to this {@link Field} element's value,\n   * but is a constant.\n   * See {@link Field.isConstant} for more information about what is a constant {@link Field}.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * someField.toConstant().assertEquals(someField); // Always true\n   * ```\n   *\n   * @return A constant {@link Field} element equivalent to this {@link Field} element.\n   */\n  toConstant(): ConstantField {\n    return toConstant(this, 'toConstant');\n  }\n\n  /**\n   * Serialize the {@link Field} to a bigint, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the bigint representation of the {@link Field}. Use the operation only during debugging.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * console.log(someField.toBigInt());\n   * ```\n   *\n   * @return A bigint equivalent to the bigint representation of the Field.\n   */\n  toBigInt() {\n    let x = toConstant(this, 'toBigInt');\n    return FieldConst.toBigint(x.value[1]);\n  }\n\n  /**\n   * Serialize the {@link Field} to a string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the {@link Field}. Use the operation only during debugging.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * console.log(someField.toString());\n   * ```\n   *\n   * @return A string equivalent to the string representation of the Field.\n   */\n  toString() {\n    return toConstant(this, 'toString').toBigInt().toString();\n  }\n\n  /**\n   * Assert that this {@link Field} is equal another \"field-like\" value.\n   * Calling this function is equivalent to `Field(...).equals(...).assertEquals(Bool(true))`.\n   * See {@link Field.equals} for more details.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the \"field-like\" value to compare & assert with this {@link Field}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertEquals(y: Field | bigint | number | string, message?: string) {\n    try {\n      if (this.isConstant() && isConstant(y)) {\n        if (this.toBigInt() !== toFp(y)) {\n          throw Error(`Field.assertEquals(): ${this} != ${y}`);\n        }\n        return;\n      }\n      assertEqual(this, toFieldVar(y));\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Add a field-like value to this {@link Field} element.\n   *\n   * @example\n   * ```ts\n   * const x = Field(3);\n   * const sum = x.add(5);\n   *\n   * sum.assertEquals(Field(8));\n   * ```\n   *\n   * **Warning**: This is a modular addition in the pasta field.\n   * @example\n   * ```ts\n   * const x = Field(1);\n   * const sum = x.add(Field(-7));\n   *\n   * // If you try to print sum - `console.log(sum.toBigInt())` - you will realize that it prints a very big integer because this is modular arithmetic, and 1 + (-7) circles around the field to become p - 6.\n   * // You can use the reverse operation of addition (subtraction) to prove the sum is calculated correctly.\n   *\n   * sum.sub(x).assertEquals(Field(-7));\n   * sum.sub(Field(-7)).assertEquals(x);\n   * ```\n   *\n   * @param y - a \"field-like\" value to add to the {@link Field}.\n   *\n   * @return A {@link Field} element equivalent to the modular addition of the two value.\n   */\n  add(y: Field | bigint | number | string): Field {\n    if (this.isConstant() && isConstant(y)) {\n      return new Field(Fp.add(this.toBigInt(), toFp(y)));\n    }\n    // return new AST node Add(x, y)\n    let z = FieldVar.add(this.value, toFieldVar(y));\n    return new Field(z);\n  }\n\n  /**\n   * Negate a {@link Field}. This is equivalent to multiplying the {@link Field} by -1.\n   *\n   * @example\n   * ```ts\n   * const negOne = Field(1).neg();\n   * negOne.assertEquals(-1);\n   * ```\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * someField.neg().assertEquals(someField.mul(Field(-1))); // This statement is always true regardless of the value of `someField`\n   * ```\n   *\n   * **Warning**: This is a modular negation. For details, see the {@link sub} method.\n   *\n   * @return A {@link Field} element that is equivalent to the element multiplied by -1.\n   */\n  neg() {\n    if (this.isConstant()) {\n      return new Field(Fp.negate(this.toBigInt()));\n    }\n    // return new AST node Scale(-1, x)\n    let z = FieldVar.scale(FieldConst[-1], this.value);\n    return new Field(z);\n  }\n\n  /**\n   * Subtract another \"field-like\" value from this {@link Field} element.\n   *\n   * @example\n   * ```ts\n   * const x = Field(3);\n   * const difference = x.sub(5);\n   *\n   * difference.assertEquals(Field(-2));\n   * ```\n   *\n   * **Warning**: This is a modular subtraction in the pasta field.\n   *\n   * @example\n   * ```ts\n   * const x = Field(1);\n   * const difference = x.sub(Field(2));\n   *\n   * // If you try to print difference - `console.log(difference.toBigInt())` - you will realize that it prints a very big integer because this is modular arithmetic, and 1 - 2 circles around the field to become p - 1.\n   * // You can use the reverse operation of subtraction (addition) to prove the difference is calculated correctly.\n   * difference.add(Field(2)).assertEquals(x);\n   * ```\n   *\n   * @param y - a \"field-like\" value to subtract from the {@link Field}.\n   *\n   * @return A {@link Field} element equivalent to the modular difference of the two value.\n   */\n  sub(y: Field | bigint | number | string) {\n    return this.add(Field.from(y).neg());\n  }\n\n  /**\n   * Checks if this {@link Field} is odd. Returns `true` for odd elements and `false` for even elements.\n   *\n   * See {@link Field.isEven} for examples.\n   */\n  isOdd() {\n    return isOddAndHigh(this).isOdd;\n  }\n\n  /**\n   * Checks if this {@link Field} is even. Returns `true` for even elements and `false` for odd elements.\n   *\n   * @example\n   * ```ts\n   * let a = Field(5);\n   * a.isEven(); // false\n   *\n   * let b = Field(4);\n   * b.isEven(); // true\n   * ```\n   */\n  isEven() {\n    return this.isOdd().not();\n  }\n\n  /**\n   * Multiply another \"field-like\" value with this {@link Field} element.\n   *\n   * @example\n   * ```ts\n   * const x = Field(3);\n   * const product = x.mul(Field(5));\n   *\n   * product.assertEquals(Field(15));\n   * ```\n   *\n   * @param y - a \"field-like\" value to multiply with the {@link Field}.\n   *\n   * @return A {@link Field} element equivalent to the modular difference of the two value.\n   */\n  mul(y: Field | bigint | number | string): Field {\n    if (this.isConstant() && isConstant(y)) {\n      return new Field(Fp.mul(this.toBigInt(), toFp(y)));\n    }\n    // if one of the factors is constant, return Scale AST node\n    if (isConstant(y)) {\n      let z = FieldVar.scale(toFieldConst(y), this.value);\n      return new Field(z);\n    }\n    if (this.isConstant()) {\n      let z = FieldVar.scale(this.value[1], y.value);\n      return new Field(z);\n    }\n    // create a new witness for z = x*y\n    let z = existsOne(() => Fp.mul(this.toBigInt(), toFp(y)));\n\n    // add a multiplication constraint\n    assertMul(this, y, z);\n    return z;\n  }\n\n  /**\n   * [Modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of this {@link Field} element.\n   * Equivalent to 1 divided by this {@link Field}, in the sense of modular arithmetic.\n   *\n   * Proves that this Field is non-zero, or throws a \"Division by zero\" error.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * const inverse = someField.inv();\n   * inverse.assertEquals(Field(1).div(someField)); // This statement is always true regardless of the value of `someField`\n   * ```\n   *\n   * **Warning**: This is a modular inverse. See {@link div} method for more details.\n   *\n   * @return A {@link Field} element that is equivalent to one divided by this element.\n   */\n  inv() {\n    if (this.isConstant()) {\n      let z = Fp.inverse(this.toBigInt());\n      if (z === undefined) throw Error('Field.inv(): Division by zero');\n      return new Field(z);\n    }\n    // create a witness for z = x^(-1)\n    let z = existsOne(() => Fp.inverse(this.toBigInt()) ?? 0n);\n\n    // constrain x * z === 1\n    assertMul(this, z, FieldVar[1]);\n    return z;\n  }\n\n  /**\n   * Divide another \"field-like\" value through this {@link Field}.\n   *\n   * Proves that the denominator is non-zero, or throws a \"Division by zero\" error.\n   *\n   * @example\n   * ```ts\n   * const x = Field(6);\n   * const quotient = x.div(Field(3));\n   *\n   * quotient.assertEquals(Field(2));\n   * ```\n   *\n   * **Warning**: This is a modular division in the pasta field. You can think this as the reverse operation of modular multiplication.\n   *\n   * @example\n   * ```ts\n   * const x = Field(2);\n   * const y = Field(5);\n   *\n   * const quotient = x.div(y);\n   *\n   * // If you try to print quotient - `console.log(quotient.toBigInt())` - you will realize that it prints a very big integer because this is a modular inverse.\n   * // You can use the reverse operation of division (multiplication) to prove the quotient is calculated correctly.\n   *\n   * quotient.mul(y).assertEquals(x);\n   * ```\n   *\n   * @param y - a \"field-like\" value to divide with the {@link Field}.\n   *\n   * @return A {@link Field} element equivalent to the modular division of the two value.\n   */\n  div(y: Field | bigint | number | string) {\n    // this intentionally uses 2 constraints instead of 1 to avoid an unconstrained output when dividing 0/0\n    // (in this version, division by 0 is strictly not allowed)\n    return this.mul(Field.from(y).inv());\n  }\n\n  /**\n   * Square this {@link Field} element.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(7);\n   * const square = someField.square();\n   *\n   * square.assertEquals(someField.mul(someField)); // This statement is always true regardless of the value of `someField`\n   * ```\n   *\n   * ** Warning: This is a modular multiplication. See `mul()` method for more details.\n   *\n   * @return A {@link Field} element equivalent to the multiplication of the {@link Field} element with itself.\n   */\n  square() {\n    if (this.isConstant()) {\n      return new Field(Fp.square(this.toBigInt()));\n    }\n    // create a new witness for z = x^2\n    let z = existsOne(() => Fp.square(this.toBigInt()));\n\n    // add a squaring constraint\n    assertSquare(this, z);\n    return z;\n  }\n\n  /**\n   * Take the square root of this {@link Field} element.\n   *\n   * Proves that the Field element has a square root in the finite field, or throws if it doesn't.\n   *\n   * @example\n   * ```ts\n   * let z = x.sqrt();\n   * z.mul(z).assertEquals(x); // true for every `x`\n   * ```\n   *\n   * **Warning**: This is a modular square root, which is any number z that satisfies z*z = x (mod p).\n   * Note that, if a square root z exists, there also exists a second one, -z (which is different if z != 0).\n   * Therefore, this method leaves an adversarial prover the choice between two different values to return.\n   *\n   * @return A {@link Field} element equivalent to the square root of the {@link Field} element.\n   */\n  sqrt() {\n    if (this.isConstant()) {\n      let z = Fp.sqrt(this.toBigInt());\n      if (z === undefined)\n        throw Error(`Field.sqrt(): input ${this} has no square root in the field.`);\n      return new Field(z);\n    }\n    // create a witness for sqrt(x)\n    let z = existsOne(() => Fp.sqrt(this.toBigInt()) ?? 0n);\n\n    // constrain z * z === x\n    assertSquare(z, this);\n    return z;\n  }\n\n  /**\n   * Check if this {@link Field} is equal another \"field-like\" value.\n   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.\n   *\n   * @example\n   * ```ts\n   * Field(5).equals(5).assertEquals(Bool(true));\n   * ```\n   *\n   * @param y - the \"field-like\" value to compare with this {@link Field}.\n   *\n   * @return A {@link Bool} representing if this {@link Field} is equal another \"field-like\" value.\n   */\n  equals(y: Field | bigint | number | string): Bool {\n    if (this.isConstant() && isConstant(y)) {\n      return new Bool(this.toBigInt() === toFp(y));\n    }\n    // TODO: this wastes a constraint on `xMinusY` if one of them is constant\n    // to fix, make assertMul() smart about constant terms and only `seal()` if the two inputs are both variables\n\n    // x == y is equivalent to x - y == 0\n    let xMinusY = this.sub(y).seal();\n\n    // create witnesses z = 1/(x-y), or z=0 if x=y,\n    // and b = 1 - z(x-y)\n    let [b, z] = exists(2, () => {\n      let xmy = xMinusY.toBigInt();\n      let z = Fp.inverse(xmy) ?? 0n;\n      let b = Fp.sub(1n, Fp.mul(z, xmy));\n      return [b, z];\n    });\n    // add constraints\n    // b * (x-y) === 0\n    assertMul(b, xMinusY, FieldVar[0]);\n    // z * (x-y) === 1 - b\n    assertMul(z, xMinusY, new Field(1).sub(b));\n    // ^^^ these prove that b = Bool(x === y):\n    // if x = y, the 2nd equation implies b = 1\n    // if x != y, the 1st implies b = 0\n    return Bool.Unsafe.fromField(b);\n  }\n\n  /**\n   * Check if this {@link Field} is less than another \"field-like\" value.\n   * Returns a {@link Bool}, which is a provable type and can be used prove to the validity of this statement.\n   *\n   * @example\n   * ```ts\n   * let isTrue = Field(2).lessThan(3);\n   * ```\n   *\n   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behavior when used with negative inputs or modular division.\n   *\n   * @example\n   * ```ts\n   * let isFalse = Field(1).div(3).lessThan(Field(1).div(2)); // in fact, 1/3 > 1/2\n   * ```\n   *\n   * @param y - the \"field-like\" value to compare with this {@link Field}.\n   *\n   * @return A {@link Bool} representing if this {@link Field} is less than another \"field-like\" value.\n   */\n  lessThan(y: Field | bigint | number | string): Bool {\n    if (this.isConstant() && isConstant(y)) {\n      return new Bool(this.toBigInt() < toFp(y));\n    }\n    return lessThanFull(this, Field.from(y));\n  }\n\n  /**\n   * Check if this {@link Field} is less than or equal to another \"field-like\" value.\n   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.\n   *\n   * @example\n   * ```ts\n   * let isTrue = Field(3).lessThanOrEqual(3);\n   * ```\n   *\n   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.\n   *\n   * @example\n   * ```ts\n   * let isFalse = Field(1).div(3).lessThanOrEqual(Field(1).div(2)); // in fact, 1/3 > 1/2\n   * ```\n   *\n   * @param y - the \"field-like\" value to compare with this {@link Field}.\n   *\n   * @return A {@link Bool} representing if this {@link Field} is less than or equal another \"field-like\" value.\n   */\n  lessThanOrEqual(y: Field | bigint | number | string): Bool {\n    if (this.isConstant() && isConstant(y)) {\n      return new Bool(this.toBigInt() <= toFp(y));\n    }\n    return lessThanOrEqualFull(this, Field.from(y));\n  }\n\n  /**\n   * Check if this {@link Field} is greater than another \"field-like\" value.\n   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.\n   *\n   * @example\n   * ```ts\n   * let isTrue = Field(5).greaterThan(3);\n   * ```\n   *\n   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.\n   *\n   * @example\n   * ```ts\n   * let isFalse = Field(1).div(2).greaterThan(Field(1).div(3); // in fact, 1/3 > 1/2\n   * ```\n   *\n   * @param y - the \"field-like\" value to compare with this {@link Field}.\n   *\n   * @return A {@link Bool} representing if this {@link Field} is greater than another \"field-like\" value.\n   */\n  greaterThan(y: Field | bigint | number | string) {\n    return Field.from(y).lessThan(this);\n  }\n\n  /**\n   * Check if this {@link Field} is greater than or equal another \"field-like\" value.\n   * Returns a {@link Bool}, which is a provable type and can be used to prove the validity of this statement.\n   *\n   * @example\n   * ```ts\n   * let isTrue = Field(3).greaterThanOrEqual(3);\n   * ```\n   *\n   * **Warning**: As this method compares the bigint value of a {@link Field}, it can result in unexpected behaviour when used with negative inputs or modular division.\n   *\n   * @example\n   * ```ts\n   * let isFalse = Field(1).div(2).greaterThanOrEqual(Field(1).div(3); // in fact, 1/3 > 1/2\n   * ```\n   *\n   * @param y - the \"field-like\" value to compare with this {@link Field}.\n   *\n   * @return A {@link Bool} representing if this {@link Field} is greater than or equal another \"field-like\" value.\n   */\n  greaterThanOrEqual(y: Field | bigint | number | string) {\n    return Field.from(y).lessThanOrEqual(this);\n  }\n\n  /**\n   * Assert that this {@link Field} is less than another \"field-like\" value.\n   *\n   * Note: This uses fewer constraints than `x.lessThan(y).assertTrue()`.\n   * See {@link lessThan} for more details.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the \"field-like\" value to compare & assert with this {@link Field}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertLessThan(y: Field | bigint | number | string, message?: string) {\n    try {\n      if (this.isConstant() && isConstant(y)) {\n        if (!(this.toBigInt() < toFp(y))) {\n          throw Error(`Field.assertLessThan(): expected ${this} < ${y}`);\n        }\n        return;\n      }\n      assertLessThanFull(this, Field.from(y));\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Assert that this {@link Field} is less than or equal to another \"field-like\" value.\n   *\n   * Note: This uses fewer constraints than `x.lessThanOrEqual(y).assertTrue()`.\n   * See {@link Field.lessThanOrEqual} for more details.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the \"field-like\" value to compare & assert with this {@link Field}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertLessThanOrEqual(y: Field | bigint | number | string, message?: string) {\n    try {\n      if (this.isConstant() && isConstant(y)) {\n        if (!(this.toBigInt() <= toFp(y))) {\n          throw Error(`Field.assertLessThan(): expected ${this} <= ${y}`);\n        }\n        return;\n      }\n      assertLessThanOrEqualFull(this, Field.from(y));\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Assert that this {@link Field} is greater than another \"field-like\" value.\n   *\n   * Note: This uses fewer constraints than `x.greaterThan(y).assertTrue()`.\n   * See {@link Field.greaterThan} for more details.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the \"field-like\" value to compare & assert with this {@link Field}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertGreaterThan(y: Field | bigint | number | string, message?: string) {\n    Field.from(y).assertLessThan(this, message);\n  }\n\n  /**\n   * Assert that this {@link Field} is greater than or equal to another \"field-like\" value.\n   *\n   * Note: This uses fewer constraints than `x.greaterThanOrEqual(y).assertTrue()`.\n   * See {@link Field.greaterThanOrEqual} for more details.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the \"field-like\" value to compare & assert with this {@link Field}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertGreaterThanOrEqual(y: Field | bigint | number | string, message?: string) {\n    Field.from(y).assertLessThanOrEqual(this, message);\n  }\n\n  /**\n   * Assert that this {@link Field} does not equal another field-like value.\n   *\n   * Note: This uses fewer constraints than `x.equals(y).assertFalse()`.\n   *\n   * @param y - the \"field-like\" value to compare & assert with this {@link Field}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   *\n   * @example\n   * ```ts\n   * x.assertNotEquals(0, \"expect x to be non-zero\");\n   * ```\n   */\n  assertNotEquals(y: Field | bigint | number | string, message?: string) {\n    try {\n      if (this.isConstant() && isConstant(y)) {\n        if (this.toBigInt() === toFp(y)) {\n          throw Error(`Field.assertNotEquals(): ${this} = ${y}`);\n        }\n        return;\n      }\n      // inv() proves that a field element is non-zero, using 1 constraint.\n      // so this takes 1-2 generic gates, while x.equals(y).assertTrue() takes 3-5\n      if (isConstant(y)) {\n        // custom single generic gate for (x - y) * z = 1\n        // TODO remove once assertMul() handles these cases\n        let x = toVar(this);\n        let y0 = toFp(y);\n        let z = existsOne(() => Fp.inverse(this.toBigInt() - y0) ?? 0n);\n        // 1*x*z + 0*x + (-y)*z + (-1) = 0\n        assertBilinear(x, z, [1n, 0n, -y0, -1n]);\n        return;\n      }\n      this.sub(y).inv();\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Prove that this {@link Field} is equal to 0 or 1.\n   * Returns the Field wrapped in a {@link Bool}.\n   *\n   * If the assertion fails, the code throws an error.\n   *\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertBool(message?: string) {\n    try {\n      if (this.isConstant()) {\n        let x = this.toBigInt();\n        assert(x === 0n || x === 1n, `Field.assertBool(): expected ${x} to be 0 or 1`);\n        return new Bool(x === 1n);\n      }\n      assertBoolean(this);\n      return Bool.Unsafe.fromField(this);\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Returns an array of {@link Bool} elements representing [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of this {@link Field} element.\n   *\n   * If you use the optional `length` argument, proves that the field element fits in `length` bits.\n   * The `length` has to be between 0 and 254 and the method throws if it isn't.\n   *\n   * **Warning**: The cost of this operation in a zk proof depends on the `length` you specify,\n   * which by default is 254 bits. Prefer to pass a smaller `length` if possible.\n   *\n   * @param length - the number of bits to fit the element. If the element does not fit in `length` bits, the functions throws an error.\n   *\n   * @return An array of {@link Bool} element representing little endian binary representation of this {@link Field}.\n   */\n  toBits(length: number = 254) {\n    checkBitLength('Field.toBits()', length, 254);\n    if (this.isConstant()) {\n      let bits = BinableFp.toBits(this.toBigInt());\n      if (bits.slice(length).some((bit) => bit))\n        throw Error(`Field.toBits(): ${this} does not fit in ${length} bits`);\n      return bits.slice(0, length).map((b) => new Bool(b));\n    }\n    let bits = Provable.witness(Provable.Array(Bool, length), () => {\n      let f = this.toBigInt();\n      return Array.from({ length }, (_, k) => new Bool(!!((f >> BigInt(k)) & 0x1n)));\n    });\n    Field.fromBits(bits).assertEquals(this, `Field.toBits(): Input does not fit in ${length} bits`);\n    return bits;\n  }\n\n  /**\n   * Convert a bit array into a {@link Field} element using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness)\n   *\n   * The method throws if the given bits do not fit in a single Field element. In this case, no more than 254 bits are allowed because some 255 bit integers do not fit into a single Field element.\n   *\n   * **Important**: If the given `bits` array is an array of `booleans` or {@link Bool} elements that all are `constant`, the resulting {@link Field} element will be a constant as well. Or else, if the given array is a mixture of constants and variables of {@link Bool} type, the resulting {@link Field} will be a variable as well.\n   *\n   * @param bits - An array of {@link Bool} or `boolean` type.\n   *\n   * @return A {@link Field} element matching the [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of the given `bits` array.\n   */\n  static fromBits(bits: (Bool | boolean)[]) {\n    const length = bits.length;\n    checkBitLength('Field.fromBits()', length, 254);\n    if (bits.every((b) => typeof b === 'boolean' || b.toField().isConstant())) {\n      let bits_ = bits\n        .map((b) => (typeof b === 'boolean' ? b : b.toBoolean()))\n        .concat(Array(Fp.sizeInBits - length).fill(false));\n      return new Field(BinableFp.fromBits(bits_));\n    }\n    return bits\n      .map((b) => new Bool(b))\n      .reduce((acc, bit, idx) => {\n        const shift = 1n << BigInt(idx);\n        return acc.add(bit.toField().mul(shift));\n      }, Field.from(0))\n      .seal();\n  }\n\n  /**\n   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.\n   *\n   * In o1js, addition and scaling (multiplication of variables by a constant) of variables is represented as an AST - [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree). For example, the expression `x.add(y).mul(2)` is represented as `Scale(2, Add(x, y))`.\n   *\n   *  A new internal variable is created only when the variable is needed in a multiplicative or any higher level constraint (for example multiplication of two {@link Field} elements) to represent the operation.\n   *\n   * The `seal()` function tells o1js to stop building an AST and create a new variable right away.\n   *\n   * @return A {@link Field} element that is equal to the result of AST that was previously on this {@link Field} element.\n   */\n  seal(): VarField | ConstantField {\n    let { constant, terms } = toLinearCombination(this.value);\n    if (terms.length === 0) return ConstantField(constant);\n    if (terms.length === 1 && constant === 0n) {\n      let [c, x] = terms[0];\n      if (c === 1n) return VarField(x);\n    }\n    let x = existsOne(() => this.toBigInt());\n    this.assertEquals(x);\n    return x;\n  }\n\n  /**\n   * A random {@link Field} element.\n   *\n   * @example\n   * ```ts\n   * console.log(Field.random().toBigInt()); // Run this code twice!\n   * ```\n   *\n   * @return A random {@link Field} element.\n   */\n  static random() {\n    return new Field(Fp.random());\n  }\n\n  // internal stuff\n\n  // Provable<Field>\n\n  /**\n   * This function is the implementation of {@link Provable.toFields} for the {@link Field} type.\n   *\n   * Static function to serializes a {@link Field} into an array of {@link Field} elements.\n   * This will be always an array of length 1, where the first and only element equals the given parameter itself.\n   *\n   * @param value - the {@link Field} element to cast the array from.\n   *\n   * @return A {@link Field} array of length 1 created from this {@link Field}.\n   */\n  static toFields(value: Field) {\n    return [value];\n  }\n\n  /**\n   * This function is the implementation of {@link Provable.toAuxiliary} for the {@link Field} type.\n   *\n   * As the primitive {@link Field} type has no auxiliary data associated with it, this function will always return an empty array.\n   */\n  static toAuxiliary(): [] {\n    return [];\n  }\n\n  /**\n   * This function is the implementation of {@link Provable.sizeInFields} for the {@link Field} type.\n   *\n   * Size of the {@link Field} type is 1, as it is the primitive type.\n   * This function returns a regular number, so you cannot use it to prove something on chain. You can use it during debugging or to understand the memory complexity of some type.\n   *\n   * @example\n   * ```ts\n   * console.log(Field.sizeInFields()); // Prints 1\n   * ```\n   *\n   * @return A number representing the size of the {@link Field} type in terms of {@link Field} type itself.\n   */\n  static sizeInFields() {\n    return 1;\n  }\n\n  /**\n   * Implementation of {@link Provable.fromFields} for the {@link Field} type.\n   *\n   * **Warning**: This function is designed for internal use. It is not intended to be used by a zkApp developer.\n   *\n   * Creates a {@link Field} from an array of Fields of length 1.\n   *\n   * @param fields - an array of length 1 serialized from {@link Field} elements.\n   *\n   * @return The first {@link Field} element of the given array.\n   */\n  static fromFields([x]: Field[]) {\n    return x;\n  }\n\n  /**\n   * This function is the implementation of {@link Provable.check} in {@link Field} type.\n   *\n   * As any field element can be a {@link Field}, this function does not create any assertions, so it does nothing.\n   */\n  static check() {}\n\n  /**\n   * `Provable<Field>.toValue()`\n   */\n  static toValue(x: Field) {\n    return x.toBigInt();\n  }\n\n  /**\n   * Convert a {@link Field} element to a bigint.\n   */\n  static toBigint(x: Field) {\n    return x.toBigInt();\n  }\n\n  /**\n   * `Provable<Field>.fromValue()`\n   */\n  static fromValue(x: Field | bigint | number | string) {\n    return Field.from(x);\n  }\n\n  /**\n   * This function is the implementation of {@link Provable.toFields} for the {@link Field} type.\n   *\n   * The result will be always an array of length 1, where the first and only element equals the {@link Field} itself.\n   *\n   * @return A {@link Field} array of length 1 created from this {@link Field}.\n   */\n  toFields() {\n    return Field.toFields(this);\n  }\n\n  /**\n   * This function is the implementation of {@link Provable.toAuxiliary} for the {@link Field} type.\n   *\n   * As the primitive {@link Field} type has no auxiliary data associated with it, this function will always return an empty array.\n   */\n  toAuxiliary() {\n    return Field.toAuxiliary();\n  }\n\n  // ProvableExtended<Field>\n\n  static empty() {\n    return new Field(0n);\n  }\n\n  /**\n   * Serialize the {@link Field} to a JSON string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the JSON string representation of the {@link Field}. Use the operation only during debugging.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * console.log(someField.toJSON());\n   * ```\n   *\n   * @return A string equivalent to the JSON representation of the {@link Field}.\n   */\n  toJSON() {\n    return toConstant(this, 'toJSON').toString();\n  }\n\n  /**\n   * Serialize the given {@link Field} element to a JSON string, e.g. for printing. Trying to print a {@link Field} without this function will directly stringify the Field object, resulting in unreadable output.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the JSON string representation of the {@link Field}. Use the operation only during debugging.\n   *\n   * @example\n   * ```ts\n   * const someField = Field(42);\n   * console.log(Field.toJSON(someField));\n   * ```\n   *\n   * @param value - The JSON string to coerce the {@link Field} from.\n   *\n   * @return A string equivalent to the JSON representation of the given {@link Field}.\n   */\n  static toJSON(value: Field) {\n    return value.toJSON();\n  }\n\n  /**\n   * Deserialize a JSON string containing a \"field-like\" value into a {@link Field} element.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the {@link Field}.\n   *\n   * @param json - the \"field-like\" value to coerce the {@link Field} from.\n   *\n   * @return A {@link Field} coerced from the given JSON string.\n   */\n  static fromJSON(json: string) {\n    return new Field(SignableFp.fromJSON(json));\n  }\n\n  /**\n   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.\n   *\n   * This function is the implementation of `ProvableExtended.toInput()` for the {@link Field} type.\n   *\n   * @param value - The {@link Field} element to get the `input` array.\n   *\n   * @return An object where the `fields` key is a {@link Field} array of length 1 created from this {@link Field}.\n   *\n   */\n  static toInput(value: Field) {\n    return { fields: [value] };\n  }\n\n  // Binable<Field>\n\n  /**\n   * Create an array of digits equal to the [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order of the given {@link Field} element.\n   * Note that the array has always 32 elements as the {@link Field} is a `finite-field` in the order of {@link Field.ORDER}.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the byte representation of the {@link Field}.\n   *\n   * @param value - The {@link Field} element to generate the array of bytes of.\n   *\n   * @return An array of digits equal to the [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order of the given {@link Field} element.\n   *\n   */\n  static toBytes(value: Field) {\n    return FieldBinable.toBytes(value);\n  }\n\n  /**\n   * Part of the `Binable` interface.\n   *\n   * **Warning**: This function is for internal use. It is not intended to be used by a zkApp developer.\n   */\n  static readBytes<N extends number>(bytes: number[], offset: NonNegativeInteger<N>) {\n    return FieldBinable.readBytes(bytes, offset);\n  }\n\n  /**\n   * Coerce a new {@link Field} element using the [little-endian](https://en.wikipedia.org/wiki/Endianness) representation of the given `bytes` array.\n   * Note that the given `bytes` array may have at most 32 elements as the {@link Field} is a `finite-field` in the order of {@link Field.ORDER}.\n   *\n   * **Warning**: This operation does _not_ affect the circuit and can't be used to prove anything about the byte representation of the {@link Field}.\n   *\n   * @param bytes - The bytes array to coerce the {@link Field} from.\n   *\n   * @return A new {@link Field} element created using the [little-endian](https://en.wikipedia.org/wiki/Endianness) representation of the given `bytes` array.\n   */\n  static fromBytes(bytes: number[]) {\n    return FieldBinable.fromBytes(bytes);\n  }\n\n  /**\n   * The size of a {@link Field} element in bytes - 32.\n   */\n  static sizeInBytes = BinableFp.sizeInBytes;\n\n  /**\n   * The size of a {@link Field} element in bits - 255.\n   */\n  static sizeInBits = Fp.sizeInBits;\n}\nsetFieldConstructor(Field);\n\nconst FieldBinable = defineBinable({\n  toBytes(t: Field) {\n    let t0 = toConstantField(t, 'toBytes').toBigInt();\n    return BinableFp.toBytes(t0);\n  },\n  readBytes(bytes, offset) {\n    let uint8array = new Uint8Array(32);\n    uint8array.set(bytes.slice(offset, offset + 32));\n    let x = BinableFp.fromBytes([...uint8array]);\n    return [new Field(x), offset + 32];\n  },\n});\n\n// internal helper functions\n\nfunction isConstant(\n  x: bigint | number | string | Field\n): x is bigint | number | string | ConstantField {\n  let type = typeof x;\n  if (type === 'bigint' || type === 'number' || type === 'string') {\n    return true;\n  }\n  return (x as Field).isConstant();\n}\n\nfunction toFp(x: bigint | number | string | Field): bigint {\n  let type = typeof x;\n  if (type === 'bigint' || type === 'number' || type === 'string') {\n    return Fp.mod(BigInt(x as bigint | number | string));\n  }\n  return (x as Field).toBigInt();\n}\n\nfunction toFieldConst(x: bigint | number | string | ConstantField): FieldConst {\n  if (x instanceof Field) return x.value[1];\n  return FieldConst.fromBigint(Fp.mod(BigInt(x)));\n}\n\nfunction toFieldVar(x: bigint | number | string | Field): FieldVar {\n  if (x instanceof Field) return x.value;\n  return FieldVar.constant(Fp.mod(BigInt(x)));\n}\n\nfunction withMessage(error: unknown, message?: string) {\n  if (message === undefined || !(error instanceof Error)) return error;\n  error.message = `${message}\\n${error.message}`;\n  return error;\n}\n\nfunction checkBitLength(name: string, length: number, maxLength = Fp.sizeInBits) {\n  if (length > maxLength)\n    throw Error(`${name}: bit length must be ${maxLength} or less, got ${length}`);\n  if (length < 0) throw Error(`${name}: bit length must be non-negative, got ${length}`);\n}\n\nfunction toConstant(x: Field, name: string): ConstantField {\n  return toConstantField(x, name, 'x', 'field element');\n}\n\nfunction toConstantField(\n  x: Field,\n  methodName: string,\n  varName = 'x',\n  varDescription = 'field element'\n): ConstantField {\n  // if this is a constant, return it\n  if (x.isConstant()) return x;\n\n  // a non-constant can only appear inside a checked computation. everything else is a bug.\n  assert(inCheckedComputation(), 'variables only exist inside checked computations');\n\n  // if we are inside an asProver or witness block, read the variable's value and return it as constant\n  if (Snarky.run.inProverBlock()) {\n    let value = Snarky.field.readVar(x.value);\n    return new Field(value) as ConstantField;\n  }\n\n  // otherwise, calling `toConstant()` is likely a mistake. throw a helpful error message.\n  throw Error(readVarMessage(methodName, varName, varDescription));\n}\n\nfunction readVarMessage(methodName: string, varName: string, varDescription: string) {\n  return `${varName}.${methodName}() was called on a variable ${varDescription} \\`${varName}\\` in provable code.\nThis is not supported, because variables represent an abstract computation, \nwhich only carries actual values during proving, but not during compiling.\n\nAlso, reading out JS values means that whatever you're doing with those values will no longer be\nlinked to the original variable in the proof, which makes this pattern prone to security holes.\n\nYou can check whether your ${varDescription} is a variable or a constant by using ${varName}.isConstant().\n\nTo inspect values for debugging, use Provable.log(${varName}). For more advanced use cases,\nthere is \\`Provable.asProver(() => { ... })\\` which allows you to use ${varName}.${methodName}() inside the callback.\nWarning: whatever happens inside asProver() will not be part of the zk proof.\n`;\n}\n\nfunction VarField(x: VarFieldVar): VarField {\n  return new Field(x) as VarField;\n}\n\nfunction ConstantField(x: ConstantFieldVar | bigint): ConstantField {\n  return new Field(x) as ConstantField;\n}\n", "import type { Field } from '../field.js';\nimport type { Bool } from '../bool.js';\nimport { Fp, Fq } from '../../../bindings/crypto/finite-field.js';\nimport { PallasAffine } from '../../../bindings/crypto/elliptic-curve.js';\nimport { isOddAndHigh } from './comparison.js';\nimport { Field3, ForeignField } from './foreign-field.js';\nimport { exists } from '../core/exists.js';\nimport { assert, bit, bitSlice, isConstant } from './common.js';\nimport { l, multiRangeCheck, rangeCheck64, rangeCheckLessThan64 } from './range-check.js';\nimport { createBool, createBoolUnsafe, createField, getField } from '../core/field-constructor.js';\nimport { Snarky } from '../../../bindings.js';\nimport { Provable } from '../provable.js';\nimport { MlPair } from '../../ml/base.js';\nimport { provable } from '../types/provable-derivers.js';\n\nexport {\n  scaleField,\n  scaleShifted,\n  fieldToShiftedScalar,\n  field3ToShiftedScalar,\n  shiftedScalarToField3,\n  add,\n  ShiftedScalar,\n};\n\ntype Point = { x: Field; y: Field };\ntype ShiftedScalar = { lowBit: Bool; high254: Field };\n\n/**\n * Dedicated gadget to scale a point by a scalar, where the scalar is represented as a _native_ Field.\n */\nfunction scaleField(P: Point, s: Field): Point {\n  // constant case\n  let { x, y } = P;\n  if (x.isConstant() && y.isConstant() && s.isConstant()) {\n    let sP = PallasAffine.scale(\n      PallasAffine.fromNonzero({ x: x.toBigInt(), y: y.toBigInt() }),\n      s.toBigInt()\n    );\n    return { x: createField(sP.x), y: createField(sP.y) };\n  }\n  const Field = getField();\n  const Point = provable({ x: Field, y: Field });\n\n  /**\n   * Strategy:\n   * - use a (1, 254) split and compute s - 2^255 with manual add-and-carry\n   * - use all 255 rounds of `scaleFastUnpack` for the high part\n   * - pass in s or a dummy replacement if s = 0, 1 (which are the disallowed values)\n   * - return sP or 0P = 0 or 1P = P\n   */\n\n  // compute t = s + (-2^255 mod q) in (1, 254) arithmetic\n  let { isOdd: sLo, high: sHi } = isOddAndHigh(s);\n\n  let shift = Fq.mod(-(1n << 255n));\n  assert((shift & 1n) === 0n); // shift happens to be even, so we don't need to worry about a carry\n  let shiftHi = shift >> 1n;\n\n  let tLo = sLo;\n  let tHi = sHi.add(shiftHi).seal();\n\n  // tHi does not overflow:\n  // tHi = sHi + shiftHi < p/2 + p/2 = p\n  // sHi < p/2 is guaranteed by isOddAndHigh\n  assert(shiftHi < Fp.modulus / 2n);\n\n  // the 4 values for s not supported by `scaleFastUnpack` are q-2, q-1, 0, 1\n  // since s came from a `Field`, we can exclude q-2, q-1\n  // s = 0 or 1 iff sHi = 0\n  let isEdgeCase = sHi.equals(0n);\n  let tHiSafe = Provable.if(isEdgeCase, createField(0n), tHi);\n\n  // R = (2*(t >> 1) + 1 + 2^255)P\n  // also returns a 255-bit representation of tHi\n  let [, RMl, [, ...tHiBitsMl]] = Snarky.group.scaleFastUnpack(\n    [0, x.value, y.value],\n    [0, tHiSafe.value],\n    255\n  );\n  let R = { x: createField(RMl[1]), y: createField(RMl[2]) };\n\n  // prove that tHi has only 254 bits set\n  createField(tHiBitsMl[254]).assertEquals(0n);\n\n  // R = tLo ? R : R - P = (t + 2^255)P = sP\n  let RminusP = addNonZero(R, negate(P)); // can only be zero if s = 0, which we handle later\n  R = Provable.if(tLo, Point, R, RminusP);\n\n  // now handle the two edge cases s=0 and s=1\n  let zero = createField(0n);\n  let zeroPoint = { x: zero, y: zero };\n  let edgeCaseResult = Provable.if(sLo, Point, P, zeroPoint);\n  return Provable.if(isEdgeCase, Point, edgeCaseResult, R);\n}\n\n/**\n * Internal helper to compute `(t + 2^255)*P`.\n * `t` is expected to be split into 254 high bits (t >> 1) and a low bit (t & 1).\n *\n * The gadget proves that `tHi` is in [0, 2^254) but assumes that `tLo` is a single bit.\n *\n * Optionally, you can specify a different number of high bits by passing in `numHighBits`.\n */\nfunction scaleShifted(\n  { x, y }: Point,\n  { lowBit: tLo, high254: tHi }: ShiftedScalar,\n  numHighBits = 254\n): Point {\n  // constant case\n  if (isConstant(x, y, tHi, tLo)) {\n    let sP = PallasAffine.scale(\n      PallasAffine.fromNonzero({ x: x.toBigInt(), y: y.toBigInt() }),\n      Fq.mod(tLo.toField().toBigInt() + 2n * tHi.toBigInt() + (1n << 255n))\n    );\n    return { x: createField(sP.x), y: createField(sP.y) };\n  }\n  const Field = getField();\n  const Point = provable({ x: Field, y: Field });\n  let zero = createField(0n);\n\n  /**\n   * Strategy:\n   * - use all 255 rounds of `scaleFastUnpack` for the high part\n   * - handle two disallowed tHi values separately: -2^254, -2^254 - 1\n   * - don't handle disallowed tHi = -2^254 - 1/2 because it wouldn't normally be used, as it's > q/2\n   */\n  let equalsMinusShift = tHi.equals(Fq.modulus - (1n << 254n));\n  let equalsMinusShiftMinus1 = tHi.equals(Fq.modulus - (1n << 254n) - 1n);\n  let isEdgeCase = equalsMinusShift.or(equalsMinusShiftMinus1);\n  let tHiSafe = Provable.if(isEdgeCase, zero, tHi);\n\n  // R = (2*(t >> 1) + 1 + 2^255)P\n  // also returns a 255-bit representation of tHi\n  let [, RMl, [, ...tHiBitsMl]] = Snarky.group.scaleFastUnpack(\n    [0, x.value, y.value],\n    [0, tHiSafe.value],\n    255\n  );\n  let P = { x, y };\n  let R = { x: createField(RMl[1]), y: createField(RMl[2]) };\n\n  // prove that tHi has only `numHighBits` bits set\n  for (let i = numHighBits; i < 255; i++) {\n    createField(tHiBitsMl[i]).assertEquals(zero);\n  }\n\n  // handle edge cases\n  // 2*(-2^254) + 1 + 2^255 = 1\n  // 2*(-2^254 - 1) + 1 + 2^255 = -1\n  // so the result is (x,+-y)\n  let edgeCaseY = y.mul(equalsMinusShift.toField().mul(2n).sub(1n)); // y*(2b - 1) = y or -y\n  let edgeCaseResult = { x, y: edgeCaseY };\n  R = Provable.if(isEdgeCase, Point, edgeCaseResult, R);\n\n  // R = tLo ? R : R - P = (t + 2^255)P\n  // we also handle a zero R-P result to make the 0 scalar work\n  let { result: RminusP, isInfinity } = add(R, negate(P));\n  RminusP = Provable.if(isInfinity, Point, { x: zero, y: zero }, RminusP);\n  R = Provable.if(tLo, Point, R, RminusP);\n\n  return R;\n}\n\n/**\n * Converts a field element s to a shifted representation t = s - 2^254 mod q,\n * where t is represented as a low bit and a 254-bit high part.\n *\n * This is the representation we use for scalars, since it can be used as input to `scaleShifted()`.\n */\nfunction fieldToShiftedScalar(s: Field): ShiftedScalar {\n  // constant case\n  if (s.isConstant()) {\n    let t = Fq.mod(s.toBigInt() - (1n << 255n));\n    let lowBit = createBool((t & 1n) === 1n);\n    let high254 = createField(t >> 1n);\n    return { lowBit, high254 };\n  }\n\n  // compute t = s + (-2^255 mod q) in (1, 254) arithmetic\n  let { isOdd: sLo, high: sHi } = isOddAndHigh(s);\n\n  let shift = Fq.mod(-(1n << 255n));\n  assert((shift & 1n) === 0n); // shift happens to be even, so we don't need to worry about a carry\n  let shiftHi = shift >> 1n;\n\n  let tLo = sLo;\n  let tHi = sHi.add(shiftHi).seal();\n\n  // tHi does not overflow:\n  // tHi = sHi + shiftHi < p/2 + p/2 = p\n  // sHi < p/2 is guaranteed by isOddAndHigh\n  assert(shiftHi < Fp.modulus / 2n);\n\n  return { lowBit: tLo, high254: tHi };\n}\n\n/**\n * Converts a 3-limb bigint to a shifted representation t = s - 2^255 mod q,\n * where t is represented as a low bit and a 254-bit high part.\n *\n * Note: The output is proven to be a canonical scalar, t < q.\n */\nfunction field3ToShiftedScalar(s: Field3): ShiftedScalar {\n  // constant case\n  if (Field3.isConstant(s)) {\n    let t = Fq.mod(Field3.toBigint(s) - (1n << 255n));\n    let lowBit = createBool((t & 1n) === 1n);\n    let high254 = createField(t >> 1n);\n    return { lowBit, high254 };\n  }\n\n  // compute t = s - (2^255 mod q) using foreign field subtraction\n  let twoTo255 = Field3.from(Fq.mod(1n << 255n));\n  let t = ForeignField.sub(s, twoTo255, Fq.modulus);\n  let [t0, t1, t2] = t;\n\n  // to fully constrain the output scalar, we need to prove that t is canonical\n  // otherwise, the subtraction above can add +q to the result, which yields an alternative bit representation\n  // this also provides a bound on the high part, to that the computation of tHi can't overflow\n  ForeignField.assertLessThan(t, Fq.modulus);\n\n  // split t into 254 high bits and a low bit\n  // => split t0 into [1, 87] => split t0 into [1, 64, 23] so we can efficiently range-check\n  let [tLo, tHi00, tHi01] = exists(3, () => {\n    let t = t0.toBigInt();\n    return [bit(t, 0), bitSlice(t, 1, 64), bitSlice(t, 65, 23)];\n  });\n  let tLoBool = tLo.assertBool();\n  rangeCheck64(tHi00);\n  rangeCheck64(tHi01);\n\n  // prove (tLo, tHi0) split\n  // since we know that t0 < 2^88 and tHi0 < 2^128, this even proves that tHi0 < 2^87\n  // (the bound on tHi0 is necessary so that 2*tHi0 can't overflow)\n  let tHi0 = tHi00.add(tHi01.mul(1n << 64n));\n  tLo.add(tHi0.mul(2n)).assertEquals(t0);\n\n  // pack tHi\n  // this can't overflow the native field because:\n  // -) we showed t < q\n  // -) the three combined limbs here represent the bigint (t >> 1) < q/2 < p\n  let tHi = tHi0\n    .add(t1.mul(1n << (l - 1n)))\n    .add(t2.mul(1n << (2n * l - 1n)))\n    .seal();\n\n  return { lowBit: tLoBool, high254: tHi };\n}\n\n/**\n * Converts a shifted representation t = s - 2^255 mod q to s as a Field3 bigint.\n *\n * Note: This method is complete for all t such that tLo < 2 and tHi < 2^254.\n * The output is can always be made a canonical scalar element by an honest prover.\n */\nfunction shiftedScalarToField3(t: ShiftedScalar): Field3 {\n  // constant case\n  if (t.high254.isConstant() && t.lowBit.isConstant()) {\n    let s = t.lowBit.toField().toBigInt() + 2n * t.high254.toBigInt();\n    return Field3.from(Fq.mod(s + (1n << 255n)));\n  }\n\n  // split sHi into 64, 23, 88, 79 bit limbs (254 in total)\n  let [t0Hi0, t0Hi1, t1, t2] = exists(4, () => {\n    let tHi = t.high254.toBigInt();\n    return [\n      bitSlice(tHi, 0, 64),\n      bitSlice(tHi, 64, 23),\n      bitSlice(tHi, 87, 88),\n      bitSlice(tHi, 175, 79),\n    ];\n  });\n  // check t0 < 2^88 in pieces and reassemble\n  rangeCheck64(t0Hi0);\n  rangeCheckLessThan64(23, t0Hi1);\n  let t0Hi = t0Hi0.add(t0Hi1.mul(1n << 64n)).seal(); // < 2^87\n  let t0 = t.lowBit.toField().add(t0Hi.mul(2n)).seal(); // < 2^88\n\n  // check t1 < 2^88 and t2 < 2^79 with MRC\n  multiRangeCheck([t1, t2, t2.mul(1n << 9n)]); // 2^9 t2 < 2^88 => t2 < 2^79\n\n  // prove tHi split (unique because <= 254 bits)\n  let tHi = t0Hi\n    .add(t1.mul(1n << 87n))\n    .add(t2.mul(1n << 175n))\n    .seal();\n  tHi.assertEquals(t.high254);\n\n  // we converted t to a bigint, now add 2^255 mod q\n  let tBig: Field3 = [t0, t1, t2];\n  let shift = Fq.mod(1n << 255n);\n  // we add an extra 0 so that the prover has the opportunity to subtract q twice.\n  // for the maximum input t = 2^255 this is enough to get a reduced result:\n  // 2^255 + (2^255 - q) - 2q = 2^254 - 3*(q - 2^254) < q\n  return ForeignField.sum([tBig, Field3.from(shift), Field3.from(0n)], [1n, 1n], Fq.modulus);\n}\n\n/**\n * Wraps the `EC_add` gate to perform complete addition of two non-zero curve points.\n */\nfunction add(g: Point, h: Point): { result: Point; isInfinity: Bool } {\n  // compute witnesses\n  let witnesses = exists(7, () => {\n    let x1 = g.x.toBigInt();\n    let y1 = g.y.toBigInt();\n    let x2 = h.x.toBigInt();\n    let y2 = h.y.toBigInt();\n\n    let sameX = BigInt(x1 === x2);\n    let inf = BigInt(sameX && y1 !== y2);\n    let infZ = sameX ? (Fp.inverse(y2 - y1) ?? 0n) : 0n;\n    let x21Inv = Fp.inverse(x2 - x1) ?? 0n;\n\n    let slopeDouble = Fp.div(3n * x1 ** 2n, 2n * y1) ?? 0n;\n    let slopeAdd = Fp.mul(y2 - y1, x21Inv);\n    let s = sameX ? slopeDouble : slopeAdd;\n\n    let x3 = Fp.mod(s ** 2n - x1 - x2);\n    let y3 = Fp.mod(s * (x1 - x3) - y1);\n\n    return [sameX, inf, infZ, x21Inv, s, x3, y3];\n  });\n\n  let [same_x, inf, inf_z, x21_inv, s, x3, y3] = witnesses;\n\n  Snarky.gates.ecAdd(\n    MlPair(g.x.seal().value, g.y.seal().value),\n    MlPair(h.x.seal().value, h.y.seal().value),\n    MlPair(x3.value, y3.value),\n    inf.value,\n    same_x.value,\n    s.value,\n    inf_z.value,\n    x21_inv.value\n  );\n\n  // the ecAdd gate constrains `inf` to be boolean\n  let isInfinity = createBoolUnsafe(inf);\n\n  return { result: { x: x3, y: y3 }, isInfinity };\n}\n\n/**\n * Addition that asserts the result is non-zero.\n */\nfunction addNonZero(g: Point, h: Point) {\n  let { result, isInfinity } = add(g, h);\n  isInfinity.assertFalse();\n  return result;\n}\n\n/**\n * Negates a point.\n */\nfunction negate(g: Point): Point {\n  return { x: g.x, y: g.y.neg() };\n}\n", "import { versionBytes } from '../../bindings/crypto/constants.js';\nimport { Binable, withVersionNumber } from '../../bindings/lib/binable.js';\nimport { sha256 } from 'js-sha256';\nimport { changeBase } from '../../bindings/crypto/bigint-helpers.js';\n\nexport { toBase58Check, fromBase58Check, base58, withBase58, fieldEncodings, Base58, alphabet };\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\nlet inverseAlphabet: Record<string, number> = {};\nalphabet.forEach((c, i) => {\n  inverseAlphabet[c] = i;\n});\n\nfunction toBase58Check(input: number[] | Uint8Array, versionByte: number) {\n  let withVersion = [versionByte, ...input];\n  let checksum = computeChecksum(withVersion);\n  let withChecksum = withVersion.concat(checksum);\n  return toBase58(withChecksum);\n}\n\nfunction fromBase58Check(base58: string, versionByte: number) {\n  // throws on invalid character\n  let bytes = fromBase58(base58);\n  // check checksum\n  let checksum = bytes.slice(-4);\n  let originalBytes = bytes.slice(0, -4);\n  let actualChecksum = computeChecksum(originalBytes);\n  if (!arrayEqual(checksum, actualChecksum)) throw Error('fromBase58Check: invalid checksum');\n  // check version byte\n  if (originalBytes[0] !== versionByte)\n    throw Error(\n      `fromBase58Check: input version byte ${versionByte} does not match encoded version byte ${originalBytes[0]}`\n    );\n  // return result\n  return originalBytes.slice(1);\n}\n\nfunction toBase58(bytes: number[] | Uint8Array) {\n  // count the leading zeroes. these get turned into leading zeroes in the output\n  let z = 0;\n  while (bytes[z] === 0) z++;\n  // for some reason, this is big-endian, so we need to reverse\n  let digits = [...bytes].map(BigInt).reverse();\n  // change base and reverse\n  let base58Digits = changeBase(digits, 256n, 58n).reverse();\n  // add leading zeroes, map into alphabet\n  base58Digits = Array(z).fill(0n).concat(base58Digits);\n  return base58Digits.map((x) => alphabet[Number(x)]).join('');\n}\n\nfunction fromBase58(base58: string) {\n  let base58Digits = [...base58].map((c) => {\n    let digit = inverseAlphabet[c];\n    if (digit === undefined) throw Error('fromBase58: invalid character');\n    return BigInt(digit);\n  });\n  let z = 0;\n  while (base58Digits[z] === 0n) z++;\n  let digits = changeBase(base58Digits.reverse(), 58n, 256n).reverse();\n  digits = Array(z).fill(0n).concat(digits);\n  return digits.map(Number);\n}\n\nfunction computeChecksum(input: number[] | Uint8Array) {\n  let hash1 = sha256.create();\n  hash1.update(input);\n  let hash2 = sha256.create();\n  hash2.update(hash1.array());\n  return hash2.array().slice(0, 4);\n}\n\ntype Base58<T> = {\n  toBase58(t: T): string;\n  fromBase58(base58: string): T;\n};\n\nfunction base58<T>(binable: Binable<T>, versionByte: number): Base58<T> {\n  return {\n    toBase58(t) {\n      let bytes = binable.toBytes(t);\n      return toBase58Check(bytes, versionByte);\n    },\n    fromBase58(base58) {\n      let bytes = fromBase58Check(base58, versionByte);\n      return binable.fromBytes(bytes);\n    },\n  };\n}\n\nfunction withBase58<T>(binable: Binable<T>, versionByte: number): Binable<T> & Base58<T> {\n  return { ...binable, ...base58(binable, versionByte) };\n}\n\n// encoding of fields as base58, compatible with ocaml encodings (provided the versionByte and versionNumber are the same)\n\nfunction customEncoding<Field>(Field: Binable<Field>, versionByte: number, versionNumber?: number) {\n  let customField = versionNumber !== undefined ? withVersionNumber(Field, versionNumber) : Field;\n  return base58(customField, versionByte);\n}\n\nconst RECEIPT_CHAIN_HASH_VERSION = 1;\nconst LEDGER_HASH_VERSION = 1;\nconst EPOCH_SEED_VERSION = 1;\nconst STATE_HASH_VERSION = 1;\n\nfunction fieldEncodings<Field>(Field: Binable<Field>) {\n  const TokenId = customEncoding(Field, versionBytes.tokenIdKey);\n  const ReceiptChainHash = customEncoding(\n    Field,\n    versionBytes.receiptChainHash,\n    RECEIPT_CHAIN_HASH_VERSION\n  );\n  const LedgerHash = customEncoding(Field, versionBytes.ledgerHash, LEDGER_HASH_VERSION);\n  const EpochSeed = customEncoding(Field, versionBytes.epochSeed, EPOCH_SEED_VERSION);\n  const StateHash = customEncoding(Field, versionBytes.stateHash, STATE_HASH_VERSION);\n  return { TokenId, ReceiptChainHash, LedgerHash, EpochSeed, StateHash };\n}\n\nfunction arrayEqual(a: unknown[], b: unknown[]) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n", "import { Fq, mod } from '../../bindings/crypto/finite-field.js';\nimport { GroupProjective, Pallas } from '../../bindings/crypto/elliptic-curve.js';\nimport { versionBytes } from '../../bindings/crypto/constants.js';\nimport { record, withCheck, withVersionNumber } from '../../bindings/lib/binable.js';\nimport { base58, withBase58 } from '../../lib/util/base58.js';\nimport { Bool, checkRange, Field, pseudoClass } from './field-bigint.js';\nimport { BinableBigint, SignableBigint, signable } from './derivers-bigint.js';\nimport { HashInputLegacy } from './poseidon-bigint.js';\n\nexport { Group, PublicKey, Scalar, PrivateKey, versionNumbers };\n\n// TODO generate\nconst versionNumbers = {\n  field: 1,\n  scalar: 1,\n  publicKey: 1,\n  signature: 1,\n};\n\ntype Group = { x: Field; y: Field };\ntype PublicKey = { x: Field; isOdd: Bool };\ntype Scalar = bigint;\ntype PrivateKey = bigint;\n\n/**\n * A non-zero point on the Pallas curve in affine form { x, y }\n */\nconst Group = {\n  toProjective({ x, y }: Group): GroupProjective {\n    return Pallas.fromAffine({ x, y, infinity: false });\n  },\n  /**\n   * Convert a projective point to a non-zero affine point.\n   * Throws an error if the point is zero / infinity, i.e. if z === 0\n   */\n  fromProjective(point: GroupProjective): Group {\n    let { x, y, infinity } = Pallas.toAffine(point);\n    if (infinity) throw Error('Group.fromProjective: point is infinity');\n    return { x, y };\n  },\n  get generatorMina(): Group {\n    return Group.fromProjective(Pallas.one);\n  },\n  scale(point: Group, scalar: Scalar): Group {\n    return Group.fromProjective(Pallas.scale(Group.toProjective(point), scalar));\n  },\n  b: Pallas.b,\n  toFields({ x, y }: Group) {\n    return [x, y];\n  },\n};\n\nlet FieldWithVersion = withVersionNumber(Field, versionNumbers.field);\nlet BinablePublicKey = withVersionNumber(\n  withCheck(record({ x: FieldWithVersion, isOdd: Bool }, ['x', 'isOdd']), ({ x }) => {\n    let { mul, add } = Field;\n    let ySquared = add(mul(x, mul(x, x)), Pallas.b);\n    if (!Field.isSquare(ySquared)) {\n      throw Error('PublicKey: not a valid group element');\n    }\n  }),\n  versionNumbers.publicKey\n);\n\n/**\n * A public key, represented by a non-zero point on the Pallas curve, in compressed form { x, isOdd }\n */\nconst PublicKey = {\n  ...signable({ x: Field, isOdd: Bool }),\n  ...withBase58(BinablePublicKey, versionBytes.publicKey),\n\n  toJSON(publicKey: PublicKey) {\n    return PublicKey.toBase58(publicKey);\n  },\n  fromJSON(json: string): PublicKey {\n    return PublicKey.fromBase58(json);\n  },\n\n  toGroup({ x, isOdd }: PublicKey): Group {\n    let { mul, add } = Field;\n    let ySquared = add(mul(x, mul(x, x)), Pallas.b);\n    let y = Field.sqrt(ySquared);\n    if (y === undefined) {\n      throw Error('PublicKey.toGroup: not a valid group element');\n    }\n    if (isOdd !== !!(y & 1n)) y = Field.negate(y);\n    return { x, y };\n  },\n  fromGroup({ x, y }: Group): PublicKey {\n    let isOdd = !!(y & 1n);\n    return { x, isOdd };\n  },\n\n  equal(pk1: PublicKey, pk2: PublicKey) {\n    return pk1.x === pk2.x && pk1.isOdd === pk2.isOdd;\n  },\n\n  toInputLegacy({ x, isOdd }: PublicKey): HashInputLegacy {\n    return { fields: [x], bits: [!!isOdd] };\n  },\n};\n\nconst checkScalar = checkRange(0n, Fq.modulus, 'Scalar');\n\n/**\n * The scalar field of the Pallas curve\n */\nconst Scalar = pseudoClass(\n  function Scalar(value: bigint | number | string): Scalar {\n    return mod(BigInt(value), Fq.modulus);\n  },\n  {\n    ...SignableBigint(checkScalar),\n    ...BinableBigint(Fq.sizeInBits, checkScalar),\n    ...Fq,\n  }\n);\n\nlet BinablePrivateKey = withVersionNumber(Scalar, versionNumbers.scalar);\nlet Base58PrivateKey = base58(BinablePrivateKey, versionBytes.privateKey);\n\n/**\n * A private key, represented by a scalar of the Pallas curve\n */\nconst PrivateKey = {\n  ...Scalar,\n  ...signable(Scalar),\n  ...Base58PrivateKey,\n  ...BinablePrivateKey,\n  toPublicKey(key: PrivateKey) {\n    return PublicKey.fromGroup(Group.scale(Group.generatorMina, key));\n  },\n  convertPrivateKeyToBase58WithMod,\n};\n\nconst Bigint256 = BinableBigint(256, () => {\n  // no check supplied, allows any string of 256 bits\n});\nconst OutOfDomainKey = base58(\n  withVersionNumber(Bigint256, versionNumbers.scalar),\n  versionBytes.privateKey\n);\n\nfunction convertPrivateKeyToBase58WithMod(keyBase58: string): string {\n  let key = OutOfDomainKey.fromBase58(keyBase58);\n  key = mod(key, Fq.modulus);\n  return PrivateKey.toBase58(key);\n}\n", "import { Fq } from '../../bindings/crypto/finite-field.js';\nimport { Scalar as SignableFq } from '../../mina-signer/src/curve-bigint.js';\nimport { Field, checkBitLength } from './field.js';\nimport { Bool } from './bool.js';\nimport {\n  ShiftedScalar,\n  field3ToShiftedScalar,\n  fieldToShiftedScalar,\n  shiftedScalarToField3,\n} from './gadgets/native-curve.js';\nimport { isConstant } from './gadgets/common.js';\nimport { Provable } from './provable.js';\nimport { assert } from '../util/assert.js';\nimport type { HashInput } from './types/provable-derivers.js';\nimport { field3FromBits } from './gadgets/foreign-field.js';\n\nexport { Scalar, ScalarConst };\n\ntype ScalarConst = [0, bigint];\n\n/**\n * Represents a {@link Scalar}.\n */\nclass Scalar implements ShiftedScalar {\n  /**\n   * We represent a scalar s in shifted form t = s - 2^255 mod q,\n   * split into its low bit (t & 1) and high 254 bits (t >> 1).\n   * The reason is that we can efficiently compute the scalar multiplication `(t + 2^255) * P = s * P`.\n   */\n  lowBit: Bool;\n  high254: Field;\n\n  static ORDER = Fq.modulus;\n\n  private constructor(lowBit: Bool, high254: Field) {\n    this.lowBit = lowBit;\n    this.high254 = high254;\n  }\n\n  /**\n   * Create a constant {@link Scalar} from a bigint, number, string or Scalar.\n   *\n   * If the input is too large, it is reduced modulo the scalar field size.\n   */\n  static from(s: Scalar | bigint | number | string): Scalar {\n    if (s instanceof Scalar) return s;\n    let t = Fq.mod(BigInt(s) - (1n << 255n));\n    let lowBit = new Bool((t & 1n) === 1n);\n    let high254 = new Field(t >> 1n);\n    return new Scalar(lowBit, high254);\n  }\n\n  /**\n   * @internal\n   * Provable method to convert a {@link ShiftedScalar} to a {@link Scalar}.\n   */\n  static fromShiftedScalar(s: ShiftedScalar) {\n    return new Scalar(s.lowBit, s.high254);\n  }\n\n  /**\n   * Provable method to convert a {@link Field} into a {@link Scalar}.\n   *\n   * This is always possible and unambiguous, since the scalar field is larger than the base field.\n   */\n  static fromField(s: Field): Scalar {\n    let { lowBit, high254 } = fieldToShiftedScalar(s);\n    return new Scalar(lowBit, high254);\n  }\n\n  /**\n   * Check whether this {@link Scalar} is a hard-coded constant in the constraint system.\n   * If a {@link Scalar} is constructed outside provable code, it is a constant.\n   */\n  isConstant() {\n    let { lowBit, high254 } = this;\n    return isConstant(lowBit, high254);\n  }\n\n  /**\n   * @internal\n   * Convert this {@link Scalar} into a constant if it isn't already.\n   *\n   * If the scalar is a variable, this only works inside `asProver` or `witness` blocks.\n   *\n   * See {@link FieldVar} for an explanation of constants vs. variables.\n   */\n  toConstant(): Scalar {\n    if (this.isConstant()) return this;\n    return Provable.toConstant(Scalar, this);\n  }\n\n  /**\n   * Convert this {@link Scalar} into a bigint\n   */\n  toBigInt() {\n    let { lowBit, high254 } = this.toConstant();\n    let t = lowBit.toField().toBigInt() + 2n * high254.toBigInt();\n    return Fq.mod(t + (1n << 255n));\n  }\n\n  /**\n   * Creates a Scalar from an array of {@link Bool}.\n   * This method is provable.\n   */\n  static fromBits(bits: Bool[]): Scalar {\n    let length = bits.length;\n    checkBitLength('Scalar.fromBits()', length, 255);\n\n    // convert bits to a 3-limb bigint\n    let sBig = field3FromBits(bits);\n\n    // convert to shifted representation\n    let { lowBit, high254 } = field3ToShiftedScalar(sBig);\n    return new Scalar(lowBit, high254);\n  }\n\n  /**\n   * Returns a random {@link Scalar}.\n   * Randomness can not be proven inside a circuit!\n   */\n  static random() {\n    return Scalar.from(Fq.random());\n  }\n\n  // operations on constant scalars\n\n  /**\n   * Negate a scalar field element.\n   *\n   * **Warning**: This method is not available for provable code.\n   */\n  neg() {\n    let x = assertConstant(this, 'neg');\n    let z = Fq.negate(x);\n    return Scalar.from(z);\n  }\n\n  /**\n   * Add scalar field elements.\n   *\n   * **Warning**: This method is not available for provable code.\n   */\n  add(y: Scalar) {\n    let x = assertConstant(this, 'add');\n    let y0 = assertConstant(y, 'add');\n    let z = Fq.add(x, y0);\n    return Scalar.from(z);\n  }\n\n  /**\n   * Subtract scalar field elements.\n   *\n   * **Warning**: This method is not available for provable code.\n   */\n  sub(y: Scalar) {\n    let x = assertConstant(this, 'sub');\n    let y0 = assertConstant(y, 'sub');\n    let z = Fq.sub(x, y0);\n    return Scalar.from(z);\n  }\n\n  /**\n   * Multiply scalar field elements.\n   *\n   * **Warning**: This method is not available for provable code.\n   */\n  mul(y: Scalar) {\n    let x = assertConstant(this, 'mul');\n    let y0 = assertConstant(y, 'mul');\n    let z = Fq.mul(x, y0);\n    return Scalar.from(z);\n  }\n\n  /**\n   * Divide scalar field elements.\n   * Throws if the denominator is zero.\n   *\n   * **Warning**: This method is not available for provable code.\n   */\n  div(y: Scalar) {\n    let x = assertConstant(this, 'div');\n    let y0 = assertConstant(y, 'div');\n    let z = Fq.div(x, y0);\n    if (z === undefined) throw Error('Scalar.div(): Division by zero');\n    return Scalar.from(z);\n  }\n\n  /**\n   * Serialize a Scalar into a Field element plus one bit, where the bit is represented as a Bool.\n   *\n   * **Warning**: This method is not available for provable code.\n   *\n   * Note: Since the Scalar field is slightly larger than the base Field, an additional high bit\n   * is needed to represent all Scalars. However, for a random Scalar, the high bit will be `false` with overwhelming probability.\n   */\n  toFieldsCompressed(): { field: Field; highBit: Bool } {\n    let s = assertConstant(this, 'toFieldsCompressed');\n    let lowBitSize = BigInt(Fq.sizeInBits - 1);\n    let lowBitMask = (1n << lowBitSize) - 1n;\n    return {\n      field: new Field(s & lowBitMask),\n      highBit: new Bool(s >> lowBitSize === 1n),\n    };\n  }\n\n  // internal stuff\n\n  // Provable<Scalar>\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Serialize a {@link Scalar} into an array of {@link Field} elements.\n   *\n   * **Warning**: This function is for internal usage. It returns 255 field elements\n   * which represent the Scalar in a shifted, bitwise format.\n   * The fields are not constrained to be boolean.\n   */\n  static toFields(x: Scalar) {\n    return [x.lowBit.toField(), x.high254];\n  }\n\n  /**\n   * Serialize this Scalar to Field elements.\n   *\n   * **Warning**: This function is for internal usage. It returns 255 field elements\n   * which represent the Scalar in a shifted, bitwise format.\n   * The fields are not constrained to be boolean.\n   *\n   * Check out {@link Scalar.toFieldsCompressed} for a user-friendly serialization\n   * that can be used outside proofs.\n   */\n  toFields(): Field[] {\n    return Scalar.toFields(this);\n  }\n\n  /**\n   * **Warning**: This function is mainly for internal use. Normally it is not intended to be used by a zkApp developer.\n   *\n   * This function is the implementation of `ProvableExtended.toInput()` for the {@link Scalar} type.\n   *\n   * @param value - The {@link Scalar} element to get the `input` array.\n   *\n   * @return An object where the `fields` key is a {@link Field} array of length 1 created from this {@link Field}.\n   *\n   */\n  static toInput(value: Scalar): HashInput {\n    return { fields: [value.high254], packed: [[value.lowBit.toField(), 1]] };\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Serialize a {@link Scalar} into its auxiliary data, which are empty.\n   */\n  static toAuxiliary() {\n    return [];\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Creates a data structure from an array of serialized {@link Field} elements.\n   */\n  static fromFields(fields: Field[]): Scalar {\n    assert(fields.length === 2, `Scalar.fromFields(): expected 2 fields, got ${fields.length}`);\n    let lowBit = Bool.Unsafe.fromField(fields[0]);\n    let high254 = fields[1];\n    return new Scalar(lowBit, high254);\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Returns the size of this type in {@link Field} elements.\n   */\n  static sizeInFields(): number {\n    return 2;\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   */\n  static check(s: Scalar) {\n    /**\n     * It is not necessary to constrain the range of high254, because the only provable operation on Scalar\n     * which relies on that range is scalar multiplication -- which constrains the range itself.\n     */\n    return Bool.check(s.lowBit);\n  }\n\n  static toCanonical(s: Scalar): Scalar {\n    // we convert to a field3, which always works\n    // and then back, which proves the result is canonical\n    let sBig = shiftedScalarToField3(s);\n    let sCanonical = field3ToShiftedScalar(sBig);\n    return Scalar.fromShiftedScalar(sCanonical);\n  }\n\n  static toValue(x: Scalar) {\n    return x.toBigInt();\n  }\n\n  static fromValue(x: bigint) {\n    return Scalar.from(x);\n  }\n\n  // ProvableExtended<Scalar>\n\n  /**\n   * Serialize a {@link Scalar} to a JSON string.\n   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Scalar.\n   */\n  static toJSON(x: Scalar) {\n    let s = assertConstant(x, 'toJSON');\n    return s.toString();\n  }\n\n  /**\n   * Serializes this Scalar to a string\n   */\n  toJSON() {\n    return Scalar.toJSON(this);\n  }\n\n  /**\n   * Deserialize a JSON structure into a {@link Scalar}.\n   * This operation does _not_ affect the circuit and can't be used to prove anything about the string representation of the Scalar.\n   */\n  static fromJSON(x: string) {\n    return Scalar.from(SignableFq.fromJSON(x));\n  }\n\n  static empty() {\n    return Scalar.from(0n);\n  }\n}\n\n// internal helpers\n\nfunction assertConstant(x: Scalar, name: string): bigint {\n  assert(\n    x.isConstant(),\n    `${name}() is not available in provable code.\nThat means it can't be called in a @method or similar environment, and there's no alternative implemented to achieve that.`\n  );\n  return x.toBigInt();\n}\n", "import { GroupAffine, Pallas, PallasAffine } from '../../bindings/crypto/elliptic-curve.js';\nimport { Fp } from '../../bindings/crypto/finite-field.js';\nimport { assert } from '../util/assert.js';\nimport { FieldVar } from './core/fieldvar.js';\nimport { Field } from './field.js';\nimport { add, scaleField, scaleShifted } from './gadgets/native-curve.js';\nimport { Provable } from './provable.js';\nimport { Scalar } from './scalar.js';\n\nexport { Group };\n\n/**\n * An element of a Group.\n */\nclass Group {\n  x: Field;\n  y: Field;\n\n  /**\n   * The generator `g` of the Group.\n   */\n  static get generator() {\n    return new Group({ x: Pallas.one.x, y: Pallas.one.y });\n  }\n\n  /**\n   * Unique representation of the `zero` element of the Group (the identity element of addition in this Group).\n   *\n   * **Note**: The `zero` element is represented as `(0, 0)`.\n   *\n   * ```typescript\n   * // g + -g = 0\n   * g.add(g.neg()).assertEquals(zero);\n   * // g + 0 = g\n   * g.add(zero).assertEquals(g);\n   * ```\n   */\n  static get zero() {\n    return new Group({ x: 0, y: 0 });\n  }\n\n  /**\n   * Coerces anything group-like to a {@link Group}.\n   */\n  constructor({\n    x,\n    y,\n  }: {\n    x: FieldVar | Field | number | string | bigint;\n    y: FieldVar | Field | number | string | bigint;\n  }) {\n    this.x = x instanceof Field ? x : new Field(x);\n    this.y = y instanceof Field ? y : new Field(y);\n\n    if (isConstant(this)) {\n      // we also check the zero element (0, 0) here\n      if (this.x.equals(0).and(this.y.equals(0)).toBoolean()) return;\n\n      const { add, mul, square } = Fp;\n\n      let x_bigint = this.x.toBigInt();\n      let y_bigint = this.y.toBigInt();\n\n      let onCurve = add(mul(x_bigint, mul(x_bigint, x_bigint)), Pallas.b) === square(y_bigint);\n\n      if (!onCurve) {\n        throw Error(`(x: ${x_bigint}, y: ${y_bigint}) is not a valid group element`);\n      }\n    }\n  }\n\n  /**\n   * Checks if this element is the `zero` element `{x: 0, y: 0}`.\n   */\n  isZero() {\n    // only the zero element can have x = 0, there are no other (valid) group elements with x = 0\n    return this.x.equals(0);\n  }\n\n  /**\n   * Adds this {@link Group} element to another {@link Group} element.\n   *\n   * ```ts\n   * let g1 = Group({ x: -1, y: 2})\n   * let g2 = g1.add(g1)\n   * ```\n   */\n  add(g: Group) {\n    if (isConstant(this) && isConstant(g)) {\n      // we check if either operand is zero, because adding zero to g just results in g (and vice versa)\n      if (this.isZero().toBoolean()) {\n        return g;\n      } else if (g.isZero().toBoolean()) {\n        return this;\n      } else {\n        let g_proj = Pallas.add(toProjective(this), toProjective(g));\n        return fromProjective(g_proj);\n      }\n    } else {\n      let { result, isInfinity } = add(this, g);\n      // similarly to the constant implementation, we check if either operand is zero\n      // and the implementation above (original OCaml implementation) returns something wild -> g + 0 != g where it should be g + 0 = g\n      let gIsZero = g.isZero();\n      let onlyThisIsZero = this.isZero().and(gIsZero.not());\n      let isNegation = isInfinity;\n      let isNormalAddition = gIsZero.or(onlyThisIsZero).or(isNegation).not();\n\n      // note: gIsZero and isNegation are not mutually exclusive, but if both are true, we add 1*0 + 1*0 = 0 which is correct\n      return Provable.switch(\n        [gIsZero, onlyThisIsZero, isNegation, isNormalAddition],\n        Group,\n        [this, g, Group.zero, new Group(result)],\n        { allowNonExclusive: true }\n      );\n    }\n  }\n\n  /**\n   * Lower-level variant of {@link add} which doesn't handle the case where one of the operands is zero, and\n   * asserts that the output is non-zero.\n   *\n   * Optionally, zero outputs can be allowed by setting `allowZeroOutput` to `true`.\n   *\n   * **Warning**: If one of the inputs is zero, the result will be garbage and the proof useless.\n   * This case has to be prevented or handled separately by the caller of this method.\n   */\n  addNonZero(g2: Group, allowZeroOutput = false): Group {\n    if (isConstant(this) && isConstant(g2)) {\n      let { x, y, infinity } = PallasAffine.add(toAffine(this), toAffine(g2));\n      assert(!infinity || allowZeroOutput, 'Group.addNonzero(): Result is zero');\n      return fromAffine({ x, y, infinity });\n    }\n    let { result, isInfinity } = add(this, g2);\n\n    if (allowZeroOutput) {\n      return Provable.if(isInfinity, Group.zero, new Group(result));\n    } else {\n      isInfinity.assertFalse('Group.addNonzero(): Result is zero');\n      return new Group(result);\n    }\n  }\n\n  /**\n   * Subtracts another {@link Group} element from this one.\n   */\n  sub(g: Group) {\n    return this.add(g.neg());\n  }\n\n  /**\n   * Negates this {@link Group}. Under the hood, it simply negates the `y` coordinate and leaves the `x` coordinate as is.\n   */\n  neg() {\n    let { x, y } = this;\n\n    return new Group({ x, y: y.neg() });\n  }\n\n  /**\n   * Elliptic curve scalar multiplication. Scales the {@link Group} element `n`-times by itself, where `n` is the {@link Scalar}.\n   *\n   * ```typescript\n   * let s = Scalar(5);\n   * let 5g = g.scale(s);\n   * ```\n   */\n  scale(s: Scalar | Field | number | bigint) {\n    if (s instanceof Field) return new Group(scaleField(this, s));\n    let scalar = Scalar.from(s);\n\n    if (isConstant(this) && scalar.isConstant()) {\n      let g_proj = Pallas.scale(toProjective(this), scalar.toBigInt());\n      return fromProjective(g_proj);\n    } else {\n      let result = scaleShifted(this, scalar);\n      return new Group(result);\n    }\n  }\n\n  /**\n   * Assert that this {@link Group} element equals another {@link Group} element.\n   * Throws an error if the assertion fails.\n   *\n   * ```ts\n   * g1.assertEquals(g2);\n   * ```\n   */\n  assertEquals(g: Group, message?: string) {\n    let { x: x1, y: y1 } = this;\n    let { x: x2, y: y2 } = g;\n\n    x1.assertEquals(x2, message);\n    y1.assertEquals(y2, message);\n  }\n\n  /**\n   * Check if this {@link Group} element equals another {@link Group} element.\n   * Returns a {@link Bool}.\n   *\n   * ```ts\n   * g1.equals(g1); // Bool(true)\n   * ```\n   */\n  equals(g: Group) {\n    let { x: x1, y: y1 } = this;\n    let { x: x2, y: y2 } = g;\n\n    return x1.equals(x2).and(y1.equals(y2));\n  }\n\n  static toValue({ x, y }: Group) {\n    return { x: x.toBigInt(), y: y.toBigInt() };\n  }\n\n  static fromValue(g: { x: bigint | number | Field; y: bigint | number | Field } | Group) {\n    return new Group(g);\n  }\n\n  /**\n   * Serializes this {@link Group} element to a JSON object.\n   *\n   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.\n   */\n  toJSON(): {\n    x: string;\n    y: string;\n  } {\n    return {\n      x: this.x.toString(),\n      y: this.y.toString(),\n    };\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Returns an array containing this {@link Group} element as an array of {@link Field} elements.\n   */\n  toFields() {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Coerces two x and y coordinates into a {@link Group} element.\n   */\n  static from(\n    x: FieldVar | Field | number | string | bigint,\n    y: FieldVar | Field | number | string | bigint\n  ) {\n    return new Group({ x, y });\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Returns an array containing a {@link Group} element as an array of {@link Field} elements.\n   */\n  static toFields(g: Group) {\n    return g.toFields();\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Returns an empty array.\n   */\n  static toAuxiliary(_?: Group) {\n    return [];\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Deserializes a {@link Group} element from a list of field elements.\n   */\n  static fromFields([x, y]: Field[]) {\n    return new Group({ x, y });\n  }\n\n  /**\n   * Part of the {@link Provable} interface.\n   *\n   * Returns 2.\n   */\n  static sizeInFields() {\n    return 2;\n  }\n\n  /**\n   * Serializes a {@link Group} element to a JSON object.\n   *\n   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.\n   */\n  static toJSON(g: Group) {\n    return g.toJSON();\n  }\n\n  /**\n   * Deserializes a JSON-like structure to a {@link Group} element.\n   *\n   * This operation does NOT affect the circuit and can't be used to prove anything about the representation of the element.\n   */\n  static fromJSON({\n    x,\n    y,\n  }: {\n    x: string | number | bigint | Field | FieldVar;\n    y: string | number | bigint | Field | FieldVar;\n  }) {\n    return new Group({ x, y });\n  }\n\n  /**\n   * Checks that a {@link Group} element is constraint properly by checking that the element is on the curve.\n   */\n  static check(g: Group) {\n    try {\n      const { x, y } = g;\n\n      let x2 = x.square();\n      let x3 = x2.mul(x);\n      let ax = x.mul(Pallas.a); // this will obviously be 0, but just for the sake of correctness\n\n      // we also check the zero element (0, 0) here\n      let isZero = x.equals(0).and(y.equals(0));\n\n      isZero.or(x3.add(ax).add(Pallas.b).equals(y.square())).assertTrue();\n    } catch (error) {\n      if (!(error instanceof Error)) return error;\n      throw `${`Element (x: ${g.x}, y: ${g.y}) is not an element of the group.`}\\n${error.message}`;\n    }\n  }\n\n  static toInput(x: Group) {\n    return {\n      fields: [x.x, x.y],\n    };\n  }\n\n  static empty() {\n    return Group.zero;\n  }\n}\n\n// internal helpers\n\nfunction isConstant(g: Group) {\n  return g.x.isConstant() && g.y.isConstant();\n}\n\nfunction toProjective(g: Group) {\n  return Pallas.fromAffine({\n    x: g.x.toBigInt(),\n    y: g.y.toBigInt(),\n    infinity: false,\n  });\n}\n\nfunction fromProjective({ x, y, z }: { x: bigint; y: bigint; z: bigint }) {\n  return fromAffine(Pallas.toAffine({ x, y, z }));\n}\n\nfunction fromAffine({ x, y, infinity }: GroupAffine) {\n  return infinity ? Group.zero : new Group({ x, y });\n}\n\nfunction toAffine(g: Group): GroupAffine {\n  return PallasAffine.from({ x: g.x.toBigInt(), y: g.y.toBigInt() });\n}\n", "import { Field as InternalField } from './field.js';\nimport { Bool as InternalBool } from './bool.js';\nimport { Group as InternalGroup } from './group.js';\nimport { Scalar } from './scalar.js';\n\nexport { Field, Bool, Scalar, Group };\n\n/**\n * A {@link Field} is an element of a prime order [finite field](https://en.wikipedia.org/wiki/Finite_field).\n * Every other provable type is built using the {@link Field} type.\n *\n * The field is the [pasta base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/) of order 2^254 + 0x224698fc094cf91b992d30ed00000001 ({@link Field.ORDER}).\n *\n * You can create a new Field from everything \"field-like\" (`bigint`, integer `number`, decimal `string`, `Field`).\n * @example\n * ```\n * Field(10n); // Field construction from a bigint\n * Field(100); // Field construction from a number\n * Field(\"1\"); // Field construction from a decimal string\n * ```\n *\n * **Beware**: Fields _cannot_ be constructed from fractional numbers or alphanumeric strings:\n * ```ts\n * Field(3.141); // ERROR: Cannot convert a float to a field element\n * Field(\"abc\"); // ERROR: Invalid argument \"abc\"\n * ```\n *\n * Creating a Field from a negative number can result in unexpected behavior if you are not familiar with [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).\n * @example\n * ```\n * const x = Field(-1); // valid Field construction from negative number\n * const y = Field(Field.ORDER - 1n); // same as `x`\n * ```\n *\n * **Important**: All the functions defined on a Field (arithmetic, logic, etc.) take their arguments as \"field-like\".\n * A Field itself is also defined as a \"field-like\" element.\n *\n * @param value - the value to convert to a {@link Field}\n *\n * @return A {@link Field} with the value converted from the argument\n */\nconst Field = toFunctionConstructor(InternalField);\ntype Field = InternalField;\n\n/**\n * A boolean value. You can create it like this:\n *\n * @example\n * ```\n * const b = Bool(true);\n * ```\n *\n * You can also combine multiple Bools with boolean operations:\n *\n * @example\n * ```ts\n * const c = Bool(false);\n *\n * const d = b.or(c).and(false).not();\n *\n * d.assertTrue();\n * ```\n *\n * Bools are often created by methods on other types such as `Field.equals()`:\n *\n * ```ts\n * const b: Bool = Field(5).equals(6);\n * ```\n */\nconst Bool = toFunctionConstructor(InternalBool);\ntype Bool = InternalBool;\n\n/**\n * An element of a Group.\n */\nconst Group = toFunctionConstructor(InternalGroup);\ntype Group = InternalGroup;\n\nfunction toFunctionConstructor<Class extends new (...args: any) => any>(\n  Class: Class\n): Class & ((...args: InferArgs<Class>) => InferReturn<Class>) {\n  function Constructor(...args: any) {\n    return new Class(...args);\n  }\n  Object.defineProperties(Constructor, Object.getOwnPropertyDescriptors(Class));\n  return Constructor as any;\n}\n\ntype InferArgs<T> = T extends new (...args: infer Args) => any ? Args : never;\ntype InferReturn<T> = T extends new (...args: any) => infer Return ? Return : never;\n", "import { MlFeatureFlags, Gate, GateType } from '../../bindings.js';\nimport { MlBool, MlOption, MlArrayOptionalElements } from '../ml/base.js';\nimport type { analyzeMethod } from './zkprogram.js';\n\n// public API\nexport { FeatureFlags };\n\n// internal API\nexport { featureFlagsToMlOption, featureFlagsFromGates };\n\ntype AnalysableProgram = {\n  analyzeMethods: () => Promise<{\n    [I in keyof any]: Awaited<ReturnType<typeof analyzeMethod>>;\n  }>;\n};\n\ntype FeatureFlags = {\n  rangeCheck0: boolean | undefined;\n  rangeCheck1: boolean | undefined;\n  foreignFieldAdd: boolean | undefined;\n  foreignFieldMul: boolean | undefined;\n  xor: boolean | undefined;\n  rot: boolean | undefined;\n  lookup: boolean | undefined;\n  runtimeTables: boolean | undefined;\n};\n/**\n * Feature flags indicate what custom gates are used in a proof of circuit.\n * Side loading, for example, requires a set of feature flags in advance (at compile time) in order to verify and side load proofs.\n * If the side loaded proofs and verification keys do not match the specified feature flag configurations, the verification will fail.\n * Flags specified as `undefined` are considered as `maybe` by Pickles. This means, proofs can be sided loaded that can, but don't have to, use a specific custom gate.\n * _Note:_ `Maybe` feature flags incur a proving overhead.\n */\nconst FeatureFlags = {\n  /**\n   * Returns a feature flag configuration where all flags are set to false.\n   */\n  allNone: {\n    rangeCheck0: false,\n    rangeCheck1: false,\n    foreignFieldAdd: false,\n    foreignFieldMul: false,\n    xor: false,\n    rot: false,\n    lookup: false,\n    runtimeTables: false,\n  },\n  /**\n   * Returns a feature flag configuration where all flags are optional.\n   */\n  allMaybe: {\n    rangeCheck0: undefined,\n    rangeCheck1: undefined,\n    foreignFieldAdd: undefined,\n    foreignFieldMul: undefined,\n    xor: undefined,\n    rot: undefined,\n    lookup: undefined,\n    runtimeTables: undefined,\n  },\n\n  /**\n   * Given a list of gates, returns the feature flag configuration that the gates use.\n   */\n  fromGates: featureFlagsFromGates,\n\n  /**\n   * Given a ZkProgram, return the feature flag configuration that fits the given program.\n   * This function considers all methods of the specified ZkProgram and finds a configuration that fits all.\n   * Optionally, it accepts a flag indicating whether runtime tables are used in the program (default is false)\n   */\n  fromZkProgram: async (program: AnalysableProgram, withRuntimeTables = false) =>\n    await fromZkProgramList([program], withRuntimeTables),\n\n  /**\n   * Given a list of ZkPrograms, return the feature flag configuration that fits the given set of programs.\n   * This function considers all methods of all specified ZkPrograms and finds a configuration that fits all.\n   */\n  fromZkProgramList,\n};\n\nasync function fromZkProgramList(programs: Array<AnalysableProgram>, withRuntimeTables = false) {\n  let flatMethodIntfs: Array<Awaited<ReturnType<typeof analyzeMethod>>> = [];\n  for (const program of programs) {\n    let methodInterface = await program.analyzeMethods();\n    flatMethodIntfs.push(...Object.values(methodInterface));\n  }\n\n  return featureFlagsfromFlatMethodIntfs(flatMethodIntfs, withRuntimeTables);\n}\n\nasync function featureFlagsfromFlatMethodIntfs(\n  methodIntfs: Array<Awaited<ReturnType<typeof analyzeMethod>>>,\n  runtimeTables = false\n): Promise<FeatureFlags> {\n  // compute feature flags that belong to each method\n  let flags = methodIntfs.map(({ gates }) => {\n    return featureFlagsFromGates(gates, runtimeTables);\n  });\n  if (flags.length === 0)\n    throw Error(\n      'The ZkProgram has no methods, in order to calculate feature flags, please attach a method to your ZkProgram.'\n    );\n\n  // initialize feature flags to all false\n  let globalFlags: Record<string, boolean | undefined> = {\n    rangeCheck0: false,\n    rangeCheck1: false,\n    foreignFieldAdd: false,\n    foreignFieldMul: false,\n    xor: false,\n    rot: false,\n    lookup: false,\n    runtimeTables: false,\n  };\n\n  // if there's only one method that means it defines the feature flags for the entire program\n  if (flags.length === 1) return flags[0];\n\n  // calculating the crossover between all methods, compute the shared feature flag set\n  flags.forEach((featureFlags, i) => {\n    for (const [flagType, currentFlag] of Object.entries(featureFlags)) {\n      if (i === 0) {\n        // initialize first iteration of flags freely\n        globalFlags[flagType] = currentFlag;\n      } else if (globalFlags[flagType] != currentFlag) {\n        // if flags conflict, set them to undefined to account for both cases (true and false) ^= maybe\n        // otherwise side loading couldn't verify some proofs of some method branches!\n        globalFlags[flagType] = undefined;\n      }\n    }\n  });\n  return globalFlags as FeatureFlags;\n}\n\n// what feature flags to set to enable certain gate types\n\nconst gateToFlag: Partial<Record<GateType, keyof FeatureFlags>> = {\n  RangeCheck0: 'rangeCheck0',\n  RangeCheck1: 'rangeCheck1',\n  ForeignFieldAdd: 'foreignFieldAdd',\n  ForeignFieldMul: 'foreignFieldMul',\n  Xor16: 'xor',\n  Rot64: 'rot',\n  Lookup: 'lookup',\n};\n\nfunction featureFlagsFromGates(gates: Gate[], runtimeTables = false): FeatureFlags {\n  let flags: FeatureFlags = {\n    rangeCheck0: false,\n    rangeCheck1: false,\n    foreignFieldAdd: false,\n    foreignFieldMul: false,\n    xor: false,\n    rot: false,\n    lookup: false,\n    runtimeTables,\n  };\n  for (let gate of gates) {\n    let flag = gateToFlag[gate.type];\n    if (flag !== undefined) flags[flag] = true;\n  }\n  return flags;\n}\n\nfunction featureFlagsToMlOption(\n  flags: FeatureFlags,\n  withRuntimeTables?: boolean\n): MlArrayOptionalElements<MlFeatureFlags> {\n  const {\n    rangeCheck0,\n    rangeCheck1,\n    foreignFieldAdd,\n    foreignFieldMul,\n    xor,\n    rot,\n    lookup,\n    runtimeTables,\n  } = flags;\n\n  return [\n    0,\n    MlOption.mapTo(rangeCheck0, MlBool),\n    MlOption.mapTo(rangeCheck1, MlBool),\n    MlOption.mapTo(foreignFieldAdd, MlBool),\n    MlOption.mapTo(foreignFieldMul, MlBool),\n    MlOption.mapTo(xor, MlBool),\n    MlOption.mapTo(rot, MlBool),\n    MlOption.mapTo(lookup, MlBool),\n    MlOption.mapTo(withRuntimeTables === true ? withRuntimeTables : runtimeTables, MlBool),\n  \n  ];\n}\n", "import { Context } from '../util/global-context.js';\nimport type { Subclass } from '../util/types.js';\nimport type { ProofBase } from './proof.js';\n\nexport { ZkProgramContext, DeclaredProof };\n\ntype DeclaredProof = {\n  ProofClass: Subclass<typeof ProofBase<any, any>>;\n  proofInstance: ProofBase<any, any>;\n};\ntype ZkProgramContext = {\n  proofs: DeclaredProof[];\n};\nlet context = Context.create<ZkProgramContext>();\n\nconst ZkProgramContext = {\n  enter() {\n    return context.enter({ proofs: [] });\n  },\n  leave: context.leave,\n  has: context.has,\n\n  declareProof(proof: DeclaredProof) {\n    context.get().proofs.push(proof);\n  },\n  getDeclaredProofs() {\n    return context.get().proofs;\n  },\n};\n", "import { areBindingsInitialized, initializeBindings, withThreadPool } from '../../bindings.js';\nimport { Pickles, Base64ProofString } from '../../bindings.js';\nimport { Field, Bool } from '../provable/wrapped.js';\nimport type { FlexibleProvable, InferProvable } from '../provable/types/struct.js';\nimport { FeatureFlags } from './feature-flags.js';\nimport type { JsonProof } from './zkprogram.js';\nimport { Subclass } from '../util/types.js';\nimport type { Provable } from '../provable/provable.js';\nimport { assert } from '../util/assert.js';\nimport { Unconstrained } from '../provable/types/unconstrained.js';\nimport { ProvableType } from '../provable/types/provable-intf.js';\nimport { ZkProgramContext } from './zkprogram-context.js';\nimport { VerificationKey } from './verification-key.js';\n\n// public API\nexport { ProofBase, Proof, DynamicProof, ProofClass };\n\n// internal API\nexport { dummyProof, extractProofs, extractProofTypes, type ProofValue };\n\ntype MaxProofs = 0 | 1 | 2;\n\ntype ProofClass = Subclass<typeof ProofBase>;\n\nclass ProofBase<Input = any, Output = any> {\n  static publicInputType: FlexibleProvable<any> = undefined as any;\n  static publicOutputType: FlexibleProvable<any> = undefined as any;\n  static tag: () => { name: string } = () => {\n    throw Error(\n      `You cannot use the \\`Proof\\` class directly. Instead, define a subclass:\\n` +\n        `class MyProof extends Proof<PublicInput, PublicOutput> { ... }`\n    );\n  };\n  publicInput: Input;\n  publicOutput: Output;\n  proof: Pickles.Proof;\n  maxProofsVerified: 0 | 1 | 2;\n  shouldVerify = Bool(false);\n\n  /**\n   * To verify a recursive proof inside a ZkProgram method, it has to be \"declared\" as part of\n   * the method. This is done by calling `declare()` on the proof.\n   *\n   * Note: `declare()` is a low-level method that most users will not have to call directly.\n   * For proofs that are inputs to the ZkProgram, it is done automatically.\n   *\n   * You can think of declaring a proof as a similar step as witnessing a variable, which introduces\n   * that variable to the circuit. Declaring a proof will tell Pickles to add the additional constraints\n   * for recursive proof verification.\n   *\n   * Similar to `Provable.witness()`, `declare()` is a no-op when run outside ZkProgram compilation or proving.\n   * It returns `false` in that case, and `true` if the proof was actually declared.\n   */\n  declare() {\n    if (!ZkProgramContext.has()) return false;\n    const ProofClass = this.constructor as Subclass<typeof ProofBase>;\n    ZkProgramContext.declareProof({ ProofClass, proofInstance: this });\n    return true;\n  }\n\n  toJSON(): JsonProof {\n    let fields = this.publicFields();\n    return {\n      publicInput: fields.input.map(String),\n      publicOutput: fields.output.map(String),\n      maxProofsVerified: this.maxProofsVerified,\n      proof: Pickles.proofToBase64([this.maxProofsVerified, this.proof]),\n    };\n  }\n\n  constructor({\n    proof,\n    publicInput,\n    publicOutput,\n    maxProofsVerified,\n  }: {\n    proof: Pickles.Proof;\n    publicInput: Input;\n    publicOutput: Output;\n    maxProofsVerified: 0 | 1 | 2;\n  }) {\n    this.publicInput = publicInput;\n    this.publicOutput = publicOutput;\n    this.proof = proof; // TODO optionally convert from string?\n    this.maxProofsVerified = maxProofsVerified;\n  }\n\n  static get provable(): Provable<any> {\n    if (this.publicInputType === undefined || this.publicOutputType === undefined) {\n      throw Error(\n        `You cannot use the \\`Proof\\` class directly. Instead, define a subclass:\\n` +\n          `class MyProof extends Proof<PublicInput, PublicOutput> { ... }`\n      );\n    }\n    return provableProof(\n      this,\n      this.publicInputType,\n      this.publicOutputType,\n      (this as any).maxProofsVerified\n    );\n  }\n\n  static publicFields(value: ProofBase) {\n    let fields = this.provable.toFields(value);\n    let inputSize = this.publicInputType.sizeInFields();\n    return {\n      input: fields.slice(0, inputSize),\n      output: fields.slice(inputSize),\n    };\n  }\n  publicFields() {\n    return (this.constructor as typeof ProofBase).publicFields(this);\n  }\n\n  static _proofFromBase64(proofString: Base64ProofString, maxProofsVerified: 0 | 1 | 2) {\n    assertBindingsInitialized();\n    return Pickles.proofOfBase64(proofString, maxProofsVerified)[1];\n  }\n  static _proofToBase64(proof: Pickles.Proof, maxProofsVerified: 0 | 1 | 2) {\n    assertBindingsInitialized();\n    return Pickles.proofToBase64([maxProofsVerified, proof]);\n  }\n}\n\nclass Proof<Input, Output> extends ProofBase<Input, Output> {\n  /**\n   * Sets the `shouldVerify` flag to `true`\n   * The downstream effect of this is that the proof will be verified when the circuit is run\n   *\n   * @note This method is meant to be called in a circuit.  Executing it outside of a circuit will have no effect.\n   */\n  verify() {\n    this.shouldVerify = Bool(true);\n  }\n  /**\n   * Sets the `shouldVerify` flag to the given condition param\n   * If set to `Bool(true)`, the proof will be verified when the circuit is run\n   * If set to `Bool(false)`, the proof will not be verified when the circuit is run\n   *\n   * @note This method is meant to be called in a circuit.  Executing it outside of a circuit will have no effect.\n   */\n  verifyIf(condition: Bool) {\n    this.shouldVerify = condition;\n  }\n\n  static async fromJSON<S extends Subclass<typeof Proof>>(\n    this: S,\n    {\n      maxProofsVerified,\n      proof: proofString,\n      publicInput: publicInputJson,\n      publicOutput: publicOutputJson,\n    }: JsonProof\n  ): Promise<Proof<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>> {\n    await initializeBindings();\n    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);\n    let fields = publicInputJson.map(Field).concat(publicOutputJson.map(Field));\n    return this.provable.fromFields(fields, [[], [], [proof, maxProofsVerified]]) as any;\n  }\n\n  /**\n   * Dummy proof. This can be useful for ZkPrograms that handle the base case in the same\n   * method as the inductive case, using a pattern like this:\n   *\n   * ```ts\n   * method(proof: SelfProof<I, O>, isRecursive: Bool) {\n   *   proof.verifyIf(isRecursive);\n   *   // ...\n   * }\n   * ```\n   *\n   * To use such a method in the base case, you need a dummy proof:\n   *\n   * ```ts\n   * let dummy = await MyProof.dummy(publicInput, publicOutput, 1);\n   * await myProgram.myMethod(dummy, Bool(false));\n   * ```\n   *\n   * **Note**: The types of `publicInput` and `publicOutput`, as well as the `maxProofsVerified` parameter,\n   * must match your ZkProgram. `maxProofsVerified` is the maximum number of proofs that any of your methods take as arguments.\n   */\n  static async dummy<Input, OutPut>(\n    publicInput: Input,\n    publicOutput: OutPut,\n    maxProofsVerified: 0 | 1 | 2,\n    domainLog2: number = 14\n  ): Promise<Proof<Input, OutPut>> {\n    let dummyRaw = await dummyProof(maxProofsVerified, domainLog2);\n    return new this({\n      publicInput,\n      publicOutput,\n      proof: dummyRaw,\n      maxProofsVerified,\n    });\n  }\n\n  static get provable(): ProvableProof<Proof<any, any>> {\n    return super.provable as any;\n  }\n}\n\nlet sideloadedKeysCounter = 0;\n\n/**\n * The `DynamicProof` class enables circuits to verify proofs using in-circuit verification keys.\n * This is opposed to the baked-in verification keys of the `Proof` class.\n *\n * In order to use this, a subclass of DynamicProof that specifies the public input and output types along with the maxProofsVerified number has to be created.\n *\n * ```ts\n * export class SideloadedProgramProof extends DynamicProof<MyStruct, Field> {\n *   static publicInputType = MyStruct;\n *   static publicOutputType = Field;\n *   static maxProofsVerified = 0 as const;\n * }\n * ```\n *\n * The `maxProofsVerified` constant is a product of the child circuit and indicates the maximum number that that circuit verifies itself.\n * If you are unsure about what that is for you, you should use `2`.\n *\n * Any `DynamicProof` subclass can be used as private input to ZkPrograms or SmartContracts along with a `VerificationKey` input.\n * ```ts\n * proof.verify(verificationKey)\n * ```\n *\n * NOTE: In the case of `DynamicProof`s, the circuit makes no assertions about the verificationKey used on its own.\n * This is the responsibility of the application developer and should always implement appropriate checks.\n * This pattern differs a lot from the usage of normal `Proof`, where the verification key is baked into the compiled circuit.\n * @see {@link src/examples/zkprogram/dynamic-keys-merkletree.ts} for an example of how this can be done using merkle trees\n *\n * Assertions generally only happen using the vk hash that is part of the `VerificationKey` struct along with the raw vk data as auxiliary data.\n * When using verify() on a `DynamicProof`, Pickles makes sure that the verification key data matches the hash.\n * Therefore all manual assertions have to be made on the vk's hash and it can be assumed that the vk's data is checked to match the hash if it is used with verify().\n */\nclass DynamicProof<Input, Output> extends ProofBase<Input, Output> {\n  public static maxProofsVerified: 0 | 1 | 2;\n\n  private static memoizedCounter: number | undefined;\n\n  /**\n   * As the name indicates, feature flags are features of the proof system.\n   *\n   * If we want to side load proofs and verification keys, we first have to tell Pickles what _shape_ of proofs it should expect.\n   *\n   * For example, if we want to side load proofs that use foreign field arithmetic custom gates, we have to make Pickles aware of that by defining\n   * these custom gates.\n   *\n   * _Note:_ Only proofs that use the exact same composition of custom gates which were expected by Pickles can be verified using side loading.\n   * If you want to verify _any_ proof, no matter what custom gates it uses, you can use {@link FeatureFlags.allMaybe}. Please note that this might incur a significant overhead.\n   *\n   * You can also toggle specific feature flags manually by specifying them here.\n   * Alternatively, you can use {@link FeatureFlags.fromZkProgram} to compute the set of feature flags that are compatible with a given program.\n   */\n  static featureFlags: FeatureFlags = FeatureFlags.allNone;\n\n  static tag() {\n    let counter: number;\n    if (this.memoizedCounter !== undefined) {\n      counter = this.memoizedCounter;\n    } else {\n      counter = sideloadedKeysCounter++;\n      this.memoizedCounter = counter;\n    }\n    return { name: `o1js-sideloaded-${counter}` };\n  }\n\n  usedVerificationKey?: VerificationKey;\n\n  /**\n   * Sets the `shouldVerify` flag to `true`\n   * The downstream effect of this is that the proof will be verified when the circuit is run\n   *\n   * @param vk The verification key this proof will be verified against\n   *\n   * @note This method is meant to be called in a circuit.  Executing it outside of a circuit will have no effect.\n   * @note The vk parameter will have its auxiliary data checked in the circuit, so the hash must match the data, or else the proof will fail\n   */\n  verify(vk: VerificationKey) {\n    this.shouldVerify = Bool(true);\n    this.usedVerificationKey = vk;\n  }\n  /**\n   * Sets the `shouldVerify` flag to the given condition param\n   * If set to `Bool(true)`, the proof will be verified when the circuit is run\n   * If set to `Bool(false)`, the proof will not be verified when the circuit is run\n   *\n   * @param vk The verification key this proof will be verified against\n   * @param condition The condition to set the shouldVerify flag to\n   *\n   * @note This method is meant to be called in a circuit.  Executing it outside of a circuit will have no effect.\n   * @note The vk parameter will have its auxiliary data checked in the circuit, so the hash must match the data, or else the proof will fail\n   */\n  verifyIf(vk: VerificationKey, condition: Bool) {\n    this.shouldVerify = condition;\n    this.usedVerificationKey = vk;\n  }\n\n  static async fromJSON<S extends Subclass<typeof DynamicProof>>(\n    this: S,\n    {\n      maxProofsVerified,\n      proof: proofString,\n      publicInput: publicInputJson,\n      publicOutput: publicOutputJson,\n    }: JsonProof\n  ): Promise<\n    DynamicProof<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>\n  > {\n    await initializeBindings();\n    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);\n    let fields = publicInputJson.map(Field).concat(publicOutputJson.map(Field));\n    return this.provable.fromFields(fields, [[], [], [proof, maxProofsVerified]]) as any;\n  }\n\n  static async dummy<S extends Subclass<typeof DynamicProof>>(\n    this: S,\n    publicInput: InferProvable<S['publicInputType']>,\n    publicOutput: InferProvable<S['publicOutputType']>,\n    maxProofsVerified: 0 | 1 | 2,\n    domainLog2: number = 14\n  ): Promise<InstanceType<S>> {\n    return this.fromProof(\n      await Proof.dummy<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>(\n        publicInput,\n        publicOutput,\n        maxProofsVerified,\n        domainLog2\n      )\n    );\n  }\n\n  /**\n   * Converts a Proof into a DynamicProof carrying over all relevant data.\n   * This method can be used to convert a Proof computed by a ZkProgram\n   * into a DynamicProof that is accepted in a circuit that accepts DynamicProofs\n   */\n  static fromProof<S extends Subclass<typeof DynamicProof>>(\n    this: S,\n    proof: Proof<InferProvable<S['publicInputType']>, InferProvable<S['publicOutputType']>>\n  ): InstanceType<S> {\n    return new this({\n      publicInput: proof.publicInput,\n      publicOutput: proof.publicOutput,\n      maxProofsVerified: proof.maxProofsVerified,\n      proof: proof.proof,\n    }) as InstanceType<S>;\n  }\n\n  static get provable(): ProvableProof<DynamicProof<any, any>> {\n    return super.provable as any;\n  }\n}\n\nasync function dummyProof(maxProofsVerified: 0 | 1 | 2, domainLog2: number) {\n  await initializeBindings();\n  return withThreadPool(async () => Pickles.dummyProof(maxProofsVerified, domainLog2)[1]);\n}\n\ntype ProofValue<Input, Output> = {\n  publicInput: Input;\n  publicOutput: Output;\n  proof: Pickles.Proof;\n  maxProofsVerified: 0 | 1 | 2;\n};\n\ntype ProvableProof<Proof extends ProofBase, InputV = any, OutputV = any> = Provable<\n  Proof,\n  ProofValue<InputV, OutputV>\n>;\n\nfunction provableProof<\n  Class extends Subclass<typeof ProofBase<Input, Output>>,\n  Input = any,\n  Output = any,\n  InputV = any,\n  OutputV = any,\n>(\n  Class: Class,\n  input: Provable<Input>,\n  output: Provable<Output>,\n  defaultMaxProofsVerified?: MaxProofs\n): Provable<ProofBase<Input, Output>, ProofValue<InputV, OutputV>> {\n  return {\n    sizeInFields() {\n      return input.sizeInFields() + output.sizeInFields();\n    },\n    toFields(value) {\n      return input.toFields(value.publicInput).concat(output.toFields(value.publicOutput));\n    },\n    toAuxiliary(value) {\n      let inputAux = input.toAuxiliary(value?.publicInput);\n      let outputAux = output.toAuxiliary(value?.publicOutput);\n      let proofAux = [\n        value?.proof ?? undefined,\n        value?.maxProofsVerified ?? defaultMaxProofsVerified ?? 0,\n      ];\n      return [inputAux, outputAux, proofAux];\n    },\n    fromFields(fields, aux) {\n      let inputFields = fields.slice(0, input.sizeInFields());\n      let outputFields = fields.slice(input.sizeInFields());\n      assert(outputFields.length === output.sizeInFields());\n      let [inputAux, outputAux, [proof, maxProofsVerified]] = aux;\n      let publicInput = input.fromFields(inputFields, inputAux);\n      let publicOutput = output.fromFields(outputFields, outputAux);\n      return new Class({\n        publicInput,\n        publicOutput,\n        proof,\n        maxProofsVerified,\n      });\n    },\n    check(value) {\n      input.check(value.publicInput);\n      output.check(value.publicOutput);\n    },\n    toValue(value) {\n      let inputV = input.toValue(value.publicInput);\n      let outputV = output.toValue(value.publicOutput);\n      return {\n        publicInput: inputV,\n        publicOutput: outputV,\n        proof: value.proof,\n        maxProofsVerified: value.maxProofsVerified,\n      };\n    },\n    fromValue(value) {\n      let inputT = input.fromValue(value.publicInput);\n      let outputT = output.fromValue(value.publicOutput);\n      return new Class({\n        publicInput: inputT,\n        publicOutput: outputT,\n        proof: value.proof,\n        maxProofsVerified: value.maxProofsVerified,\n      });\n    },\n  };\n}\n\nfunction extractProofs(value: unknown): ProofBase[] {\n  if (value instanceof ProofBase) {\n    return [value];\n  }\n  if (value instanceof Unconstrained) return [];\n  if (value instanceof Field) return [];\n  if (value instanceof Bool) return [];\n\n  if (Array.isArray(value)) {\n    return value.flatMap((item) => extractProofs(item));\n  }\n\n  if (value === null) return [];\n  if (typeof value === 'object') {\n    return extractProofs(Object.values(value));\n  }\n\n  // functions, primitives\n  return [];\n}\n\nfunction extractProofTypes(type: ProvableType) {\n  let value = ProvableType.synthesize(type);\n  let proofValues = extractProofs(value);\n  return proofValues.map((proof) => proof.constructor as typeof ProofBase);\n}\n\nfunction assertBindingsInitialized() {\n  assert(\n    areBindingsInitialized,\n    'Bindings are not initialized. Try calling `await initializeBindings()` first.'\n  );\n}\n", "import { Field, Bool, Scalar, Group } from '../wrapped.js';\nimport { provable, provableTuple, HashInput, NonMethods } from './provable-derivers.js';\nimport type { InferJson, InferProvable, InferredProvable, IsPure } from './provable-derivers.js';\nimport { Provable } from '../provable.js';\nimport { ProvablePure, ProvableType } from './provable-intf.js';\nimport { From, InferValue } from '../../../bindings/lib/provable-generic.js';\nimport { DynamicProof, Proof } from '../../proof-system/proof.js';\n\n// external API\nexport {\n  ProvableExtended,\n  ProvablePureExtended,\n  Struct,\n  FlexibleProvable,\n  FlexibleProvablePure,\n  FlexibleProvableType,\n};\n\n// internal API\nexport {\n  provableTuple,\n  AnyConstructor,\n  cloneCircuitValue,\n  circuitValueEquals,\n  InferProvable,\n  HashInput,\n  InferJson,\n  InferredProvable,\n  StructNoJson,\n};\n\ntype ProvableExtension<T, TJson = any> = {\n  toInput: (x: T) => { fields?: Field[]; packed?: [Field, number][] };\n  toJSON: (x: T) => TJson;\n  fromJSON: (x: TJson) => T;\n  empty: () => T;\n};\n\ntype ProvableExtended<T, TValue = any, TJson = any> = Provable<T, TValue> &\n  ProvableExtension<T, TJson>;\ntype ProvablePureExtended<T, TValue = any, TJson = any> = ProvablePure<T, TValue> &\n  ProvableExtension<T, TJson>;\n\ntype Struct<T> = ProvableExtended<NonMethods<T>> & Constructor<T> & { _isStruct: true };\ntype StructPure<T> = ProvablePureExtended<NonMethods<T>> & Constructor<T> & { _isStruct: true };\ntype FlexibleProvable<T> = Provable<T> | Struct<T>;\ntype FlexibleProvablePure<T> = ProvablePure<T> | StructPure<T>;\ntype FlexibleProvableType<T> = ProvableType<T> | Struct<T>;\n\ntype Constructor<T> = new (...args: any) => T;\ntype AnyConstructor = Constructor<any>;\n\n/**\n * `Struct` lets you declare composite types for use in o1js circuits.\n *\n * These composite types can be passed in as arguments to smart contract methods, used for on-chain state variables\n * or as event / action types.\n *\n * @example\n * Here's an example of creating a \"Voter\" struct, which holds a public key and a collection of votes on 3 different proposals:\n * ```ts\n * let Vote = { hasVoted: Bool, inFavor: Bool };\n *\n * class Voter extends Struct({\n *   publicKey: PublicKey,\n *   votes: [Vote, Vote, Vote]\n * }) {}\n *\n * // use Voter as SmartContract input:\n * class VoterContract extends SmartContract {\n *   \\@method register(voter: Voter) {\n *     // ...\n *   }\n * }\n * ```\n * In this example, there are no instance methods on the class. This makes `Voter` type-compatible with an anonymous object of the form\n * `{ publicKey: PublicKey, votes: Vote[] }`.\n * This mean you don't have to create instances by using `new Voter(...)`, you can operate with plain objects:\n * ```ts\n * voterContract.register({ publicKey, votes });\n * ```\n *\n * On the other hand, you can also add your own methods:\n * ```ts\n * class Voter extends Struct({\n *   publicKey: PublicKey,\n *   votes: [Vote, Vote, Vote]\n * }) {\n *   vote(index: number, inFavor: Bool) {\n *     let vote = this.votes[i];\n *     vote.hasVoted = Bool(true);\n *     vote.inFavor = inFavor;\n *   }\n * }\n * ```\n *\n * In this case, you'll need the constructor to create instances of `Voter`. It always takes as input the plain object:\n * ```ts\n * let emptyVote = { hasVoted: Bool(false), inFavor: Bool(false) };\n * let voter = new Voter({ publicKey, votes: Array(3).fill(emptyVote) });\n * voter.vote(1, Bool(true));\n * ```\n *\n * In addition to creating types composed of Field elements, you can also include auxiliary data which does not become part of the proof.\n * This, for example, allows you to reuse the same type outside o1js methods, where you might want to store additional metadata.\n *\n * To declare non-proof values of type `string`, `number`, etc, you can use the built-in objects `String`, `Number`, etc.\n * Here's how we could add the voter's name (a string) as auxiliary data:\n * ```ts\n * class Voter extends Struct({\n *   publicKey: PublicKey,\n *   votes: [Vote, Vote, Vote],\n *   fullName: String\n * }) {}\n * ```\n *\n * Again, it's important to note that this doesn't enable you to prove anything about the `fullName` string.\n * From the circuit point of view, it simply doesn't exist!\n *\n * **Note**: Ensure you do not use or extend `Struct` as a type directly. Instead, always call it as a function to construct a type. `Struct` is not a valid provable type itself, types created with `Struct(...)` are.\n *\n * @param type Object specifying the layout of the `Struct`\n * @returns Class which you can extend\n */\nfunction Struct<\n  A,\n  T extends InferProvable<A> = InferProvable<A>,\n  V extends InferValue<A> = InferValue<A>,\n  J extends InferJson<A> = InferJson<A>,\n  Pure extends boolean = IsPure<A>,\n>(\n  type: A\n): (new (value: T) => T) & { _isStruct: true } & (Pure extends true\n    ? ProvablePure<T, V>\n    : Provable<T, V>) & {\n    fromValue: (value: From<A>) => T;\n    toInput: (x: T) => {\n      fields?: Field[] | undefined;\n      packed?: [Field, number][] | undefined;\n    };\n    toJSON: (x: T) => J;\n    fromJSON: (x: J) => T;\n    empty: () => T;\n  } {\n  class Struct_ {\n    static type = provable<A>(type);\n    static _isStruct: true = true;\n\n    constructor(value: T) {\n      Object.assign(this, value);\n    }\n    /**\n     * This method is for internal use, you will probably not need it.\n     * @returns the size of this struct in field elements\n     */\n    static sizeInFields() {\n      return this.type.sizeInFields();\n    }\n    /**\n     * This method is for internal use, you will probably not need it.\n     * @param value\n     * @returns the raw list of field elements that represent this struct inside the proof\n     */\n    static toFields(value: T): Field[] {\n      return this.type.toFields(value);\n    }\n    /**\n     * This method is for internal use, you will probably not need it.\n     * @param value\n     * @returns the raw non-field element data contained in the struct\n     */\n    static toAuxiliary(value: T): any[] {\n      return this.type.toAuxiliary(value);\n    }\n    /**\n     * This method is for internal use, you will probably not need it.\n     * @param value\n     * @returns a representation of this struct as field elements, which can be hashed efficiently\n     */\n    static toInput(value: T): HashInput {\n      return this.type.toInput(value);\n    }\n    /**\n     * Convert this struct to a JSON object, consisting only of numbers, strings, booleans, arrays and plain objects.\n     * @param value\n     * @returns a JSON representation of this struct\n     */\n    static toJSON(value: T): J {\n      return this.type.toJSON(value) as J;\n    }\n    /**\n     * Convert from a JSON object to an instance of this struct.\n     * @param json\n     * @returns a JSON representation of this struct\n     */\n    static fromJSON(json: J): T {\n      let value = this.type.fromJSON(json);\n      let struct = Object.create(this.prototype);\n      return Object.assign(struct, value);\n    }\n    /**\n     * Create an instance of this struct filled with default values\n     * @returns an empty instance of this struct\n     */\n    static empty(): T {\n      let value = this.type.empty();\n      let struct = Object.create(this.prototype);\n      return Object.assign(struct, value);\n    }\n    /**\n     * This method is for internal use, you will probably not need it.\n     * Method to make assertions which should be always made whenever a struct of this type is created in a proof.\n     * @param value\n     */\n    static check(value: T) {\n      return this.type.check(value);\n    }\n\n    /**\n     * `Provable<T>.toCanonical()`\n     */\n    static toCanonical(value: T): T {\n      let canonical = this.type.toCanonical?.(value) ?? value;\n      let struct = Object.create(this.prototype);\n      return Object.assign(struct, canonical);\n    }\n\n    /**\n     * `Provable<T>.toValue()`\n     */\n    static toValue(x: T): V {\n      return this.type.toValue(x) as V;\n    }\n\n    /**\n     * `Provable<T>.fromValue()`\n     */\n    static fromValue(v: From<A>): T {\n      let value = this.type.fromValue(v as any);\n      let struct = Object.create(this.prototype);\n      return Object.assign(struct, value);\n    }\n\n    /**\n     * This method is for internal use, you will probably not need it.\n     * Recover a struct from its raw field elements and auxiliary data.\n     * @param fields the raw fields elements\n     * @param aux the raw non-field element data\n     */\n    static fromFields(fields: Field[], aux: any[]) {\n      let value = this.type.fromFields(fields, aux) as T;\n      let struct = Object.create(this.prototype);\n      return Object.assign(struct, value);\n    }\n  }\n  return Struct_ as any;\n}\n\nfunction StructNoJson<\n  A,\n  T extends InferProvable<A> = InferProvable<A>,\n  Pure extends boolean = IsPure<A>,\n>(\n  type: A\n): (new (value: T) => T) & { _isStruct: true } & (Pure extends true\n    ? ProvablePure<T>\n    : Provable<T>) & {\n    toInput: (x: T) => {\n      fields?: Field[] | undefined;\n      packed?: [Field, number][] | undefined;\n    };\n    empty: () => T;\n  } {\n  return Struct(type) satisfies Provable<T> as any;\n}\n\nlet primitives = new Set([Field, Bool, Scalar, Group]);\nfunction isPrimitive(obj: any) {\n  for (let P of primitives) {\n    if (obj instanceof P) return true;\n  }\n  return false;\n}\n\nfunction cloneCircuitValue<T>(obj: T): T {\n  // primitive JS types and functions aren't cloned\n  if (typeof obj !== 'object' || obj === null) return obj;\n\n  // classes that define clone() are cloned using that method\n  if (obj.constructor !== undefined && 'clone' in obj.constructor) {\n    return (obj as any).constructor.clone(obj);\n  }\n  if ('clone' in obj && typeof obj.clone === 'function') {\n    return (obj as any).clone(obj);\n  }\n\n  // built-in JS datatypes with custom cloning strategies\n  if (Array.isArray(obj)) return obj.map(cloneCircuitValue) as any as T;\n  if (obj instanceof Set) return new Set([...obj].map(cloneCircuitValue)) as any as T;\n  if (obj instanceof Map)\n    return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)])) as any as T;\n  if (ArrayBuffer.isView(obj)) return new (obj.constructor as any)(obj);\n\n  // o1js primitives and proofs aren't cloned\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj instanceof Proof || obj instanceof DynamicProof) {\n    return obj;\n  }\n\n  // cloning strategy that works for plain objects AND classes whose constructor only assigns properties\n  let propertyDescriptors: Record<string, PropertyDescriptor> = {};\n  for (let [key, value] of Object.entries(obj)) {\n    propertyDescriptors[key] = {\n      value: cloneCircuitValue(value),\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    };\n  }\n  return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);\n}\n\nfunction circuitValueEquals<T>(a: T, b: T): boolean {\n  // primitive JS types and functions are checked for exact equality\n  if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) return a === b;\n\n  // built-in JS datatypes with custom equality checks\n  if (Array.isArray(a)) {\n    return (\n      Array.isArray(b) && a.length === b.length && a.every((a_, i) => circuitValueEquals(a_, b[i]))\n    );\n  }\n  if (a instanceof Set) {\n    return b instanceof Set && a.size === b.size && [...a].every((a_) => b.has(a_));\n  }\n  if (a instanceof Map) {\n    return (\n      b instanceof Map &&\n      a.size === b.size &&\n      [...a].every(([k, v]) => circuitValueEquals(v, b.get(k)))\n    );\n  }\n  if (ArrayBuffer.isView(a) && !(a instanceof DataView)) {\n    // typed array\n    return (\n      ArrayBuffer.isView(b) &&\n      !(b instanceof DataView) &&\n      circuitValueEquals([...(a as any)], [...(b as any)])\n    );\n  }\n\n  // the two checks below cover o1js primitives and CircuitValues\n  // if we have an .equals method, try to use it\n  if ('equals' in a && typeof (a as any).equals === 'function') {\n    let isEqual = (a as any).equals(b).toBoolean();\n    if (typeof isEqual === 'boolean') return isEqual;\n    if (isEqual instanceof Bool) return isEqual.toBoolean();\n  }\n  // if we have a .toFields method, try to use it\n  if (\n    'toFields' in a &&\n    typeof (a as any).toFields === 'function' &&\n    'toFields' in b &&\n    typeof (b as any).toFields === 'function'\n  ) {\n    let aFields = (a as any).toFields() as Field[];\n    let bFields = (b as any).toFields() as Field[];\n    return aFields.every((a, i) => a.equals(bFields[i]).toBoolean());\n  }\n\n  // equality test that works for plain objects AND classes whose constructor only assigns properties\n  let aEntries = Object.entries(a as any).filter(([, v]) => v !== undefined);\n  let bEntries = Object.entries(b as any).filter(([, v]) => v !== undefined);\n  if (aEntries.length !== bEntries.length) return false;\n  return aEntries.every(([key, value]) => key in b && circuitValueEquals((b as any)[key], value));\n}\n", "import { provableTuple } from '../types/struct.js';\nimport { Field } from '../wrapped.js';\nimport { assert } from '../../util/errors.js';\nimport { Provable } from '../provable.js';\nimport { rangeCheck32, rangeCheck64, rangeCheckN } from './range-check.js';\n\nexport { divMod32, addMod32, divMod64, addMod64 };\n\nfunction divMod32(n: Field, nBits = 64) {\n  assert(nBits >= 0 && nBits < 255, `nBits must be in the range [0, 255), got ${nBits}`);\n  const quotientBits = Math.max(0, nBits - 32);\n  if (n.isConstant()) {\n    assert(\n      n.toBigInt() < 1n << BigInt(nBits),\n      `n needs to fit into ${nBits} bits, but got ${n.toBigInt()}`\n    );\n\n    let nBigInt = n.toBigInt();\n    let q = nBigInt >> 32n;\n    let r = nBigInt - (q << 32n);\n    return {\n      remainder: new Field(r),\n      quotient: new Field(q),\n    };\n  }\n\n  let [quotient, remainder] = Provable.witness(provableTuple([Field, Field]), () => {\n    let nBigInt = n.toBigInt();\n    let q = nBigInt >> 32n;\n    let r = nBigInt - (q << 32n);\n    // why do we have to do this?\n    return [q, r] satisfies [bigint, bigint];\n  });\n\n  if (quotientBits === 1) {\n    quotient.assertBool();\n  } else {\n    rangeCheckN(quotientBits, quotient);\n  }\n  rangeCheck32(remainder);\n\n  n.assertEquals(quotient.mul(1n << 32n).add(remainder));\n\n  return {\n    remainder,\n    quotient,\n  };\n}\n\nfunction addMod32(x: Field, y: Field) {\n  return divMod32(x.add(y), 33).remainder;\n}\n\nfunction divMod64(n: Field, nBits = 128) {\n  assert(nBits >= 0 && nBits < 255, `nBits must be in the range [0, 255), got ${nBits}`);\n\n  // calculate the number of bits allowed for the quotient to avoid overflow\n  const quotientBits = Math.max(0, nBits - 64);\n\n  if (n.isConstant()) {\n    assert(\n      n.toBigInt() < 1n << BigInt(nBits),\n      `n needs to fit into ${nBits} bits, but got ${n.toBigInt()}`\n    );\n    let nBigInt = n.toBigInt();\n    let q = nBigInt >> 64n;\n    let r = nBigInt - (q << 64n);\n    return {\n      remainder: new Field(r),\n      quotient: new Field(q),\n    };\n  }\n\n  let [quotient, remainder] = Provable.witness(provableTuple([Field, Field]), () => {\n    let nBigInt = n.toBigInt();\n    let q = nBigInt >> 64n;\n    let r = nBigInt - (q << 64n);\n    return [q, r] satisfies [bigint, bigint];\n  });\n\n  if (quotientBits === 1) {\n    quotient.assertBool();\n  } else if (quotientBits === 64) {\n    rangeCheck64(quotient);\n  } else {\n    rangeCheckN(quotientBits, quotient);\n  }\n  rangeCheck64(remainder);\n\n  n.assertEquals(quotient.mul(1n << 64n).add(remainder));\n\n  return {\n    remainder,\n    quotient,\n  };\n}\n\nfunction addMod64(x: Field, y: Field) {\n  return divMod64(x.add(y), 65).remainder;\n}\n", "import { Provable } from '../provable.js';\nimport { Fp } from '../../../bindings/crypto/finite-field.js';\nimport { Field } from '../field.js';\nimport { Gates } from '../gates.js';\nimport { assert, divideWithRemainder, toVar, bitSlice } from './common.js';\nimport { rangeCheck32, rangeCheck64 } from './range-check.js';\nimport { divMod32 } from './arithmetic.js';\nimport { exists } from '../../provable/core/exists.js';\n\nexport { xor, not, rotate64, rotate32, and, or, rightShift64, leftShift64, leftShift32 };\n\nfunction not(a: Field, length: number, checked: boolean = false) {\n  // Validate at 240 bits to ensure padLength (next multiple of 16) doesn't exceed 254 bits,\n  // preventing potential underconstraint issues in the circuit\n  validateBitLength(length, 240, 'not');\n\n  // obtain pad length until the length is a multiple of 16 for n-bit length lookup table\n  let padLength = Math.ceil(length / 16) * 16;\n\n  // handle constant case\n  if (a.isConstant()) {\n    let max = 1n << BigInt(padLength);\n    assert(a.toBigInt() < max, `${a.toBigInt()} does not fit into ${padLength} bits`);\n    return new Field(Fp.not(a.toBigInt(), length));\n  }\n\n  // create a bitmask with all ones\n  let allOnes = new Field(2n ** BigInt(length) - 1n);\n\n  if (checked) {\n    return xor(a, allOnes, length);\n  } else {\n    return allOnes.sub(a).seal();\n  }\n}\n\nfunction xor(a: Field, b: Field, length: number) {\n  // Validate at 240 bits to ensure padLength (next multiple of 16) doesn't exceed 254 bits,\n  // preventing potential underconstraint issues in the circuit\n  validateBitLength(length, 240, 'xor');\n\n  // obtain pad length until the length is a multiple of 16 for n-bit length lookup table\n  let padLength = Math.ceil(length / 16) * 16;\n\n  // handle constant case\n  if (a.isConstant() && b.isConstant()) {\n    let max = 1n << BigInt(padLength);\n\n    assert(a.toBigInt() < max, `${a} does not fit into ${padLength} bits`);\n    assert(b.toBigInt() < max, `${b} does not fit into ${padLength} bits`);\n\n    return new Field(a.toBigInt() ^ b.toBigInt());\n  }\n\n  // calculate expected xor output\n  let outputXor = Provable.witness(Field, () => a.toBigInt() ^ b.toBigInt());\n\n  // builds the xor gadget chain\n  buildXor(a, b, outputXor, padLength);\n\n  // return the result of the xor operation\n  return outputXor;\n}\n\n// builds a xor chain\nfunction buildXor(a: Field, b: Field, out: Field, padLength: number) {\n  // construct the chain of XORs until padLength is 0\n  while (padLength !== 0) {\n    // slices the inputs into 4x 4bit-sized chunks\n    let slices = exists(15, () => {\n      let a0 = a.toBigInt();\n      let b0 = b.toBigInt();\n      let out0 = out.toBigInt();\n      return [\n        // slices of a\n        bitSlice(a0, 0, 4),\n        bitSlice(a0, 4, 4),\n        bitSlice(a0, 8, 4),\n        bitSlice(a0, 12, 4),\n\n        // slices of b\n        bitSlice(b0, 0, 4),\n        bitSlice(b0, 4, 4),\n        bitSlice(b0, 8, 4),\n        bitSlice(b0, 12, 4),\n\n        // slices of expected output\n        bitSlice(out0, 0, 4),\n        bitSlice(out0, 4, 4),\n        bitSlice(out0, 8, 4),\n        bitSlice(out0, 12, 4),\n\n        // next values\n        a0 >> 16n,\n        b0 >> 16n,\n        out0 >> 16n,\n      ];\n    });\n\n    // prettier-ignore\n    let [\n      in1_0, in1_1, in1_2, in1_3,\n      in2_0, in2_1, in2_2, in2_3,\n      out0, out1, out2, out3,\n      aNext, bNext, outNext\n    ] = slices;\n\n    // assert that the xor of the slices is correct, 16 bit at a time\n    // prettier-ignore\n    Gates.xor(\n      a, b, out,\n      in1_0, in1_1, in1_2, in1_3,\n      in2_0, in2_1, in2_2, in2_3,\n      out0, out1, out2, out3\n    );\n\n    // update the values for the next loop iteration\n    a = aNext;\n    b = bNext;\n    out = outNext;\n    padLength = padLength - 16;\n  }\n\n  // inputs are zero and length is zero, add the zero check - we reached the end of our chain\n  Gates.zero(a, b, out);\n\n  let zero = new Field(0);\n  zero.assertEquals(a);\n  zero.assertEquals(b);\n  zero.assertEquals(out);\n}\n\nfunction and(a: Field, b: Field, length: number) {\n  // Validate at 240 bits to ensure padLength (next multiple of 16) doesn't exceed 254 bits,\n  // preventing potential underconstraint issues in the circuit\n  validateBitLength(length, 240, 'and');\n\n  // obtain pad length until the length is a multiple of 16 for n-bit length lookup table\n  let padLength = Math.ceil(length / 16) * 16;\n\n  // handle constant case\n  if (a.isConstant() && b.isConstant()) {\n    let max = 1n << BigInt(padLength);\n\n    assert(a.toBigInt() < max, `${a} does not fit into ${padLength} bits`);\n    assert(b.toBigInt() < max, `${b} does not fit into ${padLength} bits`);\n\n    return new Field(a.toBigInt() & b.toBigInt());\n  }\n\n  // calculate expect and output\n  let outputAnd = Provable.witness(Field, () => a.toBigInt() & b.toBigInt());\n\n  // compute values for gate\n  // explanation: https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and\n  let sum = a.add(b);\n  let xorOutput = xor(a, b, length);\n  outputAnd.mul(2).add(xorOutput).assertEquals(sum);\n\n  // return the result of the and operation\n  return outputAnd;\n}\n\nfunction or(a: Field, b: Field, length: number) {\n  return not(and(not(a, length), not(b, length), length), length);\n}\n\nfunction rotate64(field: Field, bits: number, direction: 'left' | 'right' = 'left') {\n  // Check that the rotation bits are in range\n  assert(bits >= 0 && bits <= 64, `rotation: expected bits to be between 0 and 64, got ${bits}`);\n\n  if (field.isConstant()) {\n    assert(\n      field.toBigInt() < 1n << 64n,\n      `rotation: expected field to be at most 64 bits, got ${field.toBigInt()}`\n    );\n    return new Field(Fp.rot(field.toBigInt(), BigInt(bits), direction));\n  }\n  const [rotated] = rot64(field, bits, direction);\n  return rotated;\n}\n\nfunction rotate32(field: Field, bits: number, direction: 'left' | 'right' = 'left') {\n  assert(bits <= 32 && bits > 0, 'bits must be between 0 and 32');\n\n  if (field.isConstant()) {\n    assert(\n      field.toBigInt() < 1n << 32n,\n      `rotation: expected field to be at most 32 bits, got ${field.toBigInt()}`\n    );\n    return new Field(Fp.rot(field.toBigInt(), BigInt(bits), direction, 32n));\n  }\n\n  let { quotient: excess, remainder: shifted } = divMod32(\n    field.mul(1n << BigInt(direction === 'left' ? bits : 32 - bits))\n  );\n\n  let rotated = shifted.add(excess);\n\n  rangeCheck32(rotated);\n\n  return rotated;\n}\n\nfunction rot64(\n  field: Field,\n  bits: number,\n  direction: 'left' | 'right' = 'left'\n): [Field, Field, Field] {\n  const rotationBits = direction === 'right' ? 64 - bits : bits;\n  const big2Power64 = 1n << 64n;\n  const big2PowerRot = 1n << BigInt(rotationBits);\n\n  const [rotated, excess, shifted, bound] = Provable.witness(Provable.Array(Field, 4), () => {\n    const f = field.toBigInt();\n\n    // Obtain rotated output, excess, and shifted for the equation:\n    // f * 2^rot = excess * 2^64 + shifted\n    const { quotient: excess, remainder: shifted } = divideWithRemainder(\n      f * big2PowerRot,\n      big2Power64\n    );\n\n    // Compute rotated value as: rotated = excess + shifted\n    const rotated = shifted + excess;\n    // Compute bound to check excess < 2^rot\n    const bound = excess + big2Power64 - big2PowerRot;\n    return [rotated, excess, shifted, bound];\n  });\n\n  // flush zero var to prevent broken gate chain (zero is used in rangeCheck64)\n  // TODO this is an abstraction leak, but not clear to me how to improve\n  toVar(0n);\n\n  // slice the bound into chunks\n  let boundSlices = exists(12, () => {\n    let bound0 = bound.toBigInt();\n    return [\n      bitSlice(bound0, 52, 12), // bits 52-64\n      bitSlice(bound0, 40, 12), // bits 40-52\n      bitSlice(bound0, 28, 12), // bits 28-40\n      bitSlice(bound0, 16, 12), // bits 16-28\n\n      bitSlice(bound0, 14, 2), // bits 14-16\n      bitSlice(bound0, 12, 2), // bits 12-14\n      bitSlice(bound0, 10, 2), // bits 10-12\n      bitSlice(bound0, 8, 2), // bits 8-10\n      bitSlice(bound0, 6, 2), // bits 6-8\n      bitSlice(bound0, 4, 2), // bits 4-6\n      bitSlice(bound0, 2, 2), // bits 2-4\n      bitSlice(bound0, 0, 2), // bits 0-2\n    ];\n  });\n  let [b52, b40, b28, b16, b14, b12, b10, b8, b6, b4, b2, b0] = boundSlices;\n\n  // Compute current row\n  Gates.rotate(\n    field,\n    rotated,\n    excess,\n    [b52, b40, b28, b16],\n    [b14, b12, b10, b8, b6, b4, b2, b0],\n    big2PowerRot\n  );\n  // Compute next row\n  rangeCheck64(shifted);\n  // note: range-checking `shifted` and `field` is enough.\n  // * excess < 2^rot follows from the bound check and the rotation equation in the gate\n  // * rotated < 2^64 follows from rotated = excess + shifted (because shifted has to be a multiple of 2^rot)\n  // for a proof, see https://github.com/o1-labs/o1js/pull/1201\n  return [rotated, excess, shifted];\n}\n\nfunction rightShift64(field: Field, bits: number) {\n  assert(bits >= 0 && bits <= 64, `rightShift: expected bits to be between 0 and 64, got ${bits}`);\n\n  if (field.isConstant()) {\n    assert(\n      field.toBigInt() < 1n << 64n,\n      `rightShift: expected field to be at most 64 bits, got ${field.toBigInt()}`\n    );\n    return new Field(Fp.rightShift(field.toBigInt(), bits));\n  }\n  const [, excess] = rot64(field, bits, 'right');\n  return excess;\n}\n\nfunction leftShift64(field: Field, bits: number) {\n  assert(bits >= 0 && bits <= 64, `rightShift: expected bits to be between 0 and 64, got ${bits}`);\n\n  if (field.isConstant()) {\n    assert(\n      field.toBigInt() < 1n << 64n,\n      `rightShift: expected field to be at most 64 bits, got ${field.toBigInt()}`\n    );\n    return new Field(Fp.leftShift(field.toBigInt(), bits));\n  }\n  const [, , shifted] = rot64(field, bits, 'left');\n  return shifted;\n}\n\nfunction leftShift32(field: Field, bits: number) {\n  let { remainder: shifted } = divMod32(field.mul(1n << BigInt(bits)));\n  return shifted;\n}\n\n/**\n * Validates the bit length for bitwise operations.\n *\n * @param length - The input length to validate.\n * @param maxLength - The maximum allowed length.\n * @param functionName - The name of the calling function for error messages.\n *\n * @throws {Error} If the input length is not positive or exceeds the maximum length.\n */\nfunction validateBitLength(length: number, maxLength: number, functionName: string) {\n  // check that both input lengths are positive\n  assert(length > 0, `${functionName}: Input length must be a positive value.`);\n  // check that length does not exceed maximum `maxLength` size in bits\n  assert(\n    length <= maxLength,\n    `${functionName}: Length ${length} exceeds maximum of ${maxLength} bits.`\n  );\n}\n", "import 'reflect-metadata';\nimport { Field } from '../wrapped.js';\nimport { HashInput, NonMethods } from './provable-derivers.js';\nimport { Provable } from '../provable.js';\nimport { AnyConstructor, FlexibleProvable } from './struct.js';\n\nexport { CircuitValue, prop, arrayProp };\n\n/**\n * @deprecated `CircuitValue` is deprecated in favor of {@link Struct}, which features a simpler API and better typing.\n */\nabstract class CircuitValue {\n  constructor(...props: any[]) {\n    // if this is called with no arguments, do nothing, to support simple super() calls\n    if (props.length === 0) return;\n\n    let fields = this.constructor.prototype._fields;\n    if (fields === undefined) return;\n    if (props.length !== fields.length) {\n      throw Error(\n        `${this.constructor.name} constructor called with ${props.length} arguments, but expected ${fields.length}`\n      );\n    }\n    for (let i = 0; i < fields.length; ++i) {\n      let [key] = fields[i];\n      (this as any)[key] = props[i];\n    }\n  }\n\n  static fromObject<T extends AnyConstructor>(\n    this: T,\n    value: NonMethods<InstanceType<T>>\n  ): InstanceType<T> {\n    return Object.assign(Object.create(this.prototype), value);\n  }\n\n  static sizeInFields(): number {\n    const fields: [string, any][] = (this as any).prototype._fields;\n    return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);\n  }\n\n  static toFields<T extends AnyConstructor>(this: T, v: InstanceType<T>): Field[] {\n    const res: Field[] = [];\n    const fields = this.prototype._fields;\n    if (fields === undefined || fields === null) {\n      return res;\n    }\n    for (let i = 0, n = fields.length; i < n; ++i) {\n      const [key, propType] = fields[i];\n      const subElts: Field[] = propType.toFields((v as any)[key]);\n      subElts.forEach((x) => res.push(x));\n    }\n    return res;\n  }\n\n  static toAuxiliary(): [] {\n    return [];\n  }\n\n  static toInput<T extends AnyConstructor>(this: T, v: InstanceType<T>): HashInput {\n    let input: HashInput = { fields: [], packed: [] };\n    let fields = this.prototype._fields;\n    if (fields === undefined) return input;\n    for (let i = 0, n = fields.length; i < n; ++i) {\n      let [key, type] = fields[i];\n      if ('toInput' in type) {\n        input = HashInput.append(input, type.toInput(v[key]));\n        continue;\n      }\n      // as a fallback, use toFields on the type\n      // TODO: this is problematic -- ignores if there's a toInput on a nested type\n      // so, remove this? should every provable define toInput?\n      let xs: Field[] = type.toFields(v[key]);\n      input.fields!.push(...xs);\n    }\n    return input;\n  }\n\n  toFields(): Field[] {\n    return (this.constructor as any).toFields(this);\n  }\n\n  static toValue<T extends AnyConstructor>(this: T, v: InstanceType<T>) {\n    const res: any = {};\n    let fields: [string, any][] = (this as any).prototype._fields ?? [];\n    fields.forEach(([key, propType]) => {\n      res[key] = propType.toValue((v as any)[key]);\n    });\n    return res;\n  }\n\n  static fromValue<T extends AnyConstructor>(this: T, value: any): InstanceType<T> {\n    let props: any = {};\n    let fields: [string, any][] = (this as any).prototype._fields ?? [];\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw Error(`${this.name}.fromValue(): invalid input ${value}`);\n    }\n    for (let i = 0; i < fields.length; ++i) {\n      let [key, propType] = fields[i];\n      if (value[key] === undefined) {\n        throw Error(`${this.name}.fromValue(): invalid input ${value}`);\n      } else {\n        props[key] = propType.fromValue(value[key]);\n      }\n    }\n    return Object.assign(Object.create(this.prototype), props);\n  }\n\n  toJSON(): any {\n    return (this.constructor as any).toJSON(this);\n  }\n\n  toConstant(): this {\n    return (this.constructor as any).toConstant(this);\n  }\n\n  equals(x: this) {\n    return Provable.equal(this.constructor as any, this, x);\n  }\n\n  assertEquals(x: this) {\n    Provable.assertEqual(this, x);\n  }\n\n  isConstant() {\n    return this.toFields().every((x) => x.isConstant());\n  }\n\n  static fromFields<T extends AnyConstructor>(this: T, xs: Field[]): InstanceType<T> {\n    const fields: [string, any][] = (this as any).prototype._fields;\n    if (xs.length < fields.length) {\n      throw Error(\n        `${this.name}.fromFields: Expected ${fields.length} field elements, got ${xs?.length}`\n      );\n    }\n    let offset = 0;\n    const props: any = {};\n    for (let i = 0; i < fields.length; ++i) {\n      const [key, propType] = fields[i];\n      const propSize = propType.sizeInFields();\n      const propVal = propType.fromFields(xs.slice(offset, offset + propSize), []);\n      props[key] = propVal;\n      offset += propSize;\n    }\n    return Object.assign(Object.create(this.prototype), props);\n  }\n\n  static check<T extends AnyConstructor>(this: T, v: InstanceType<T>) {\n    const fields = (this as any).prototype._fields;\n    if (fields === undefined || fields === null) {\n      return;\n    }\n    for (let i = 0; i < fields.length; ++i) {\n      const [key, propType] = fields[i];\n      const value = (v as any)[key];\n      if (propType.check === undefined) throw Error('bug: CircuitValue without .check()');\n      propType.check(value);\n    }\n  }\n\n  static toCanonical<T extends AnyConstructor>(this: T, value: InstanceType<T>): InstanceType<T> {\n    let canonical: any = {};\n    let fields: [string, any][] = (this as any).prototype._fields ?? [];\n    fields.forEach(([key, type]) => {\n      canonical[key] = Provable.toCanonical(type, value[key]);\n    });\n    return canonical;\n  }\n\n  static toConstant<T extends AnyConstructor>(this: T, t: InstanceType<T>): InstanceType<T> {\n    const xs: Field[] = (this as any).toFields(t);\n    return (this as any).fromFields(xs.map((x) => x.toConstant()));\n  }\n\n  static toJSON<T extends AnyConstructor>(this: T, v: InstanceType<T>) {\n    const res: any = {};\n    if ((this as any).prototype._fields !== undefined) {\n      const fields: [string, any][] = (this as any).prototype._fields;\n      fields.forEach(([key, propType]) => {\n        res[key] = propType.toJSON((v as any)[key]);\n      });\n    }\n    return res;\n  }\n\n  static fromJSON<T extends AnyConstructor>(this: T, value: any): InstanceType<T> {\n    let props: any = {};\n    let fields: [string, any][] = (this as any).prototype._fields;\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw Error(`${this.name}.fromJSON(): invalid input ${value}`);\n    }\n    if (fields !== undefined) {\n      for (let i = 0; i < fields.length; ++i) {\n        let [key, propType] = fields[i];\n        if (value[key] === undefined) {\n          throw Error(`${this.name}.fromJSON(): invalid input ${value}`);\n        } else {\n          props[key] = propType.fromJSON(value[key]);\n        }\n      }\n    }\n    return Object.assign(Object.create(this.prototype), props);\n  }\n\n  static empty<T extends AnyConstructor>(): InstanceType<T> {\n    const fields: [string, any][] = (this as any).prototype._fields ?? [];\n    let props: any = {};\n    fields.forEach(([key, propType]) => {\n      props[key] = propType.empty();\n    });\n    return Object.assign(Object.create(this.prototype), props);\n  }\n}\n\nfunction prop(this: any, target: any, key: string) {\n  const fieldType = Reflect.getMetadata('design:type', target, key);\n  if (!target.hasOwnProperty('_fields')) {\n    target._fields = [];\n  }\n  if (fieldType === undefined) {\n  } else if (fieldType.toFields && fieldType.fromFields) {\n    target._fields.push([key, fieldType]);\n  } else {\n    console.log(`warning: property ${key} missing field element conversion methods`);\n  }\n}\n\nfunction arrayProp<T>(elementType: FlexibleProvable<T>, length: number) {\n  return function (target: any, key: string) {\n    if (!target.hasOwnProperty('_fields')) {\n      target._fields = [];\n    }\n    target._fields.push([key, Provable.Array(elementType, length)]);\n  };\n}\n", "import { assert } from './errors.js';\n\nexport { chunk, chunkString, zip, pad, mapObject, mapToObject };\n\nfunction chunk<T>(array: T[], size: number): T[][] {\n  assert(\n    array.length % size === 0,\n    `chunk(): invalid input length, it must be a multiple of ${size}`\n  );\n  return Array.from({ length: array.length / size }, (_, i) =>\n    array.slice(size * i, size * (i + 1))\n  );\n}\n\nfunction chunkString(str: string, size: number): string[] {\n  return chunk([...str], size).map((c) => c.join(''));\n}\n\nfunction zip<T, S>(a: T[], b: S[]) {\n  assert(a.length <= b.length, 'zip(): second array must be at least as long as the first array');\n  return a.map((a, i): [T, S] => [a, b[i]!]);\n}\n\nfunction pad<T>(array: T[], size: number, value: T): T[] {\n  assert(\n    array.length <= size,\n    `target size ${size} should be greater or equal than the length of the array ${array.length}`\n  );\n  return array.concat(Array.from({ length: size - array.length }, () => value));\n}\n\nfunction mapObject<\n  T extends Record<string, any>,\n  F extends <K extends keyof T>(value: T[K], key: K, i: number) => any,\n>(t: T, fn: F) {\n  let s = {} as { [K in keyof T]: ReturnType<F> };\n  let i = 0;\n  for (let key in t) {\n    s[key] = fn(t[key], key, i);\n    i++;\n  }\n  return s;\n}\nfunction mapToObject<\n  Key extends string | number | symbol,\n  F extends <K extends Key>(key: K, i: number) => any,\n>(keys: Key[], fn: F) {\n  let s = {} as { [K in Key]: ReturnType<F> };\n  keys.forEach((key, i) => {\n    s[key] = fn(key, i);\n  });\n  return s;\n}\n", "/**\n * Gadgets for converting between field elements and bit slices of various lengths\n */\nimport { bigIntToBits } from '../../../bindings/crypto/bigint-helpers.js';\nimport { Field } from '../field.js';\nimport { UInt8 } from '../int.js';\nimport { exists } from '../core/exists.js';\nimport { Provable } from '../provable.js';\nimport { chunk } from '../../util/arrays.js';\nimport { assert } from './common.js';\nimport type { Field3 } from './foreign-field.js';\nimport { l } from './range-check.js';\n\nexport { bytesToWord, wordToBytes, wordsToBytes, bytesToWords, sliceField3 };\n\n// conversion between bytes and multi-byte words\n\n/**\n * Convert an array of UInt8 to a Field element. Expects little endian representation.\n */\nfunction bytesToWord(wordBytes: UInt8[]): Field {\n  return wordBytes.reduce((acc, byte, idx) => {\n    const shift = 1n << BigInt(8 * idx);\n    return acc.add(byte.value.mul(shift));\n  }, Field.from(0));\n}\n\n/**\n * Convert a Field element to an array of UInt8. Expects little endian representation.\n * @param bytesPerWord number of bytes per word\n */\nfunction wordToBytes(word: Field, bytesPerWord = 8): UInt8[] {\n  let bytes = Provable.witness(Provable.Array(UInt8, bytesPerWord), () => {\n    let w = word.toBigInt();\n    return Array.from({ length: bytesPerWord }, (_, k) => UInt8.from((w >> BigInt(8 * k)) & 0xffn));\n  });\n\n  // check decomposition\n  bytesToWord(bytes).assertEquals(word);\n\n  return bytes;\n}\n\n/**\n * Convert an array of Field elements to an array of UInt8. Expects little endian representation.\n * @param bytesPerWord number of bytes per word\n */\nfunction wordsToBytes(words: Field[], bytesPerWord = 8): UInt8[] {\n  return words.flatMap((w) => wordToBytes(w, bytesPerWord));\n}\n/**\n * Convert an array of UInt8 to an array of Field elements. Expects little endian representation.\n * @param bytesPerWord number of bytes per word\n */\nfunction bytesToWords(bytes: UInt8[], bytesPerWord = 8): Field[] {\n  return chunk(bytes, bytesPerWord).map(bytesToWord);\n}\n\n// conversion between 3-limb foreign fields and arbitrary bit slices\n\n/**\n * Provable method for slicing a 3x88-bit bigint into smaller bit chunks of length `chunkSize`\n *\n * This serves as a range check that the input is in [0, 2^maxBits)\n */\nfunction sliceField3(\n  [x0, x1, x2]: Field3,\n  { maxBits, chunkSize }: { maxBits: number; chunkSize: number }\n) {\n  let l_ = Number(l);\n  assert(maxBits <= 3 * l_, `expected max bits <= 3*${l_}, got ${maxBits}`);\n\n  // first limb\n  let result0 = sliceField(x0, Math.min(l_, maxBits), chunkSize);\n  if (maxBits <= l_) return result0.chunks;\n  maxBits -= l_;\n\n  // second limb\n  let result1 = sliceField(x1, Math.min(l_, maxBits), chunkSize, result0);\n  if (maxBits <= l_) return result0.chunks.concat(result1.chunks);\n  maxBits -= l_;\n\n  // third limb\n  let result2 = sliceField(x2, maxBits, chunkSize, result1);\n  return result0.chunks.concat(result1.chunks, result2.chunks);\n}\n\n/**\n * Provable method for slicing a field element into smaller bit chunks of length `chunkSize`.\n *\n * This serves as a range check that the input is in [0, 2^maxBits)\n *\n * If `chunkSize` does not divide `maxBits`, the last chunk will be smaller.\n * We return the number of free bits in the last chunk, and optionally accept such a result from a previous call,\n * so that this function can be used to slice up a bigint of multiple limbs into homogeneous chunks.\n *\n * TODO: atm this uses expensive boolean checks for each bit.\n * For larger chunks, we should use more efficient range checks.\n */\nfunction sliceField(\n  x: Field,\n  maxBits: number,\n  chunkSize: number,\n  leftover?: { chunks: Field[]; leftoverSize: number }\n) {\n  let bits = exists(maxBits, () => {\n    let bits = bigIntToBits(x.toBigInt());\n    // normalize length\n    if (bits.length > maxBits) bits = bits.slice(0, maxBits);\n    if (bits.length < maxBits) bits = bits.concat(Array(maxBits - bits.length).fill(false));\n    return bits.map(BigInt);\n  });\n\n  let chunks = [];\n  let sum = Field.from(0n);\n\n  // if there's a leftover chunk from a previous sliceField() call, we complete it\n  if (leftover !== undefined) {\n    let { chunks: previous, leftoverSize: size } = leftover;\n    let remainingChunk = Field.from(0n);\n    for (let i = 0; i < size; i++) {\n      let bit = bits[i];\n      bit.assertBool();\n      remainingChunk = remainingChunk.add(bit.mul(1n << BigInt(i)));\n    }\n    sum = remainingChunk = remainingChunk.seal();\n    let chunk = previous[previous.length - 1];\n    previous[previous.length - 1] = chunk.add(remainingChunk.mul(1n << BigInt(chunkSize - size)));\n  }\n\n  let i = leftover?.leftoverSize ?? 0;\n  for (; i < maxBits; i += chunkSize) {\n    // prove that chunk has `chunkSize` bits\n    // TODO: this inner sum should be replaced with a more efficient range check when possible\n    let chunk = Field.from(0n);\n    let size = Math.min(maxBits - i, chunkSize); // last chunk might be smaller\n    for (let j = 0; j < size; j++) {\n      let bit = bits[i + j];\n      bit.assertBool();\n      chunk = chunk.add(bit.mul(1n << BigInt(j)));\n    }\n    chunk = chunk.seal();\n    // prove that chunks add up to x\n    sum = sum.add(chunk.mul(1n << BigInt(i)));\n    chunks.push(chunk);\n  }\n  sum.assertEquals(x);\n\n  let leftoverSize = i - maxBits;\n  return { chunks, leftoverSize } as const;\n}\n", "import { Field, Bool } from './wrapped.js';\nimport { AnyConstructor, Struct } from './types/struct.js';\nimport { Types } from '../../bindings/mina-transaction/v1/types.js';\nimport * as TypesBigint from '../../bindings/mina-transaction/v1/transaction-leaves-bigint.js';\nimport { HashInput } from './crypto/poseidon.js';\nimport { Provable } from './provable.js';\nimport * as RangeCheck from './gadgets/range-check.js';\nimport * as Bitwise from './gadgets/bitwise.js';\nimport { addMod32, addMod64 } from './gadgets/arithmetic.js';\nimport { checkBitLength, withMessage } from './field.js';\nimport { FieldVar } from './core/fieldvar.js';\nimport { CircuitValue, prop } from './types/circuit-value.js';\nimport {\n  assertLessThanGeneric,\n  assertLessThanOrEqualGeneric,\n  lessThanGeneric,\n  lessThanOrEqualGeneric,\n} from './gadgets/comparison.js';\nimport { assert } from '../util/assert.js';\nimport { TupleN } from '../util/types.js';\nimport { bytesToWord, wordToBytes } from './gadgets/bit-slices.js';\nimport { BinableFp } from '../../mina-signer/src/field-bigint.js';\n\n// external API\nexport { UInt8, UInt32, UInt64, Int64, Sign };\n\n/**\n * A 64 bit unsigned integer with values ranging from 0 to 18,446,744,073,709,551,615.\n */\nclass UInt64 extends CircuitValue {\n  @prop value: Field;\n  static NUM_BITS = 64;\n\n  /**\n   * Create a {@link UInt64}.\n   * The max value of a {@link UInt64} is `2^64 - 1 = UInt64.MAXINT()`.\n   *\n   * **Warning**: Cannot overflow, an error is thrown if the result is greater than UInt64.MAXINT()\n   */\n  constructor(x: UInt64 | UInt32 | FieldVar | number | string | bigint) {\n    if (x instanceof UInt64 || x instanceof UInt32) x = x.value.value;\n    let value = Field(x);\n    super(value);\n    // check the range if the argument is a constant\n    UInt64.checkConstant(value);\n  }\n\n  static Unsafe = {\n    /**\n     * Create a {@link UInt64} from a {@link Field} without constraining its range.\n     *\n     * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 64 bits.\\\n     * Only use this if you know what you are doing, otherwise use the safe {@link UInt64.from}.\n     */\n    fromField(x: Field) {\n      return new UInt64(x.value);\n    },\n  };\n\n  /**\n   * Static method to create a {@link UInt64} with value `0`.\n   */\n  static get zero() {\n    return new UInt64(0);\n  }\n  /**\n   * Static method to create a {@link UInt64} with value `1`.\n   */\n  static get one() {\n    return new UInt64(1);\n  }\n  /**\n   * Turns the {@link UInt64} into a string.\n   * @returns\n   */\n  toString() {\n    return this.value.toString();\n  }\n  /**\n   * Turns the {@link UInt64} into a BigInt.\n   * @returns\n   */\n  toBigInt() {\n    return this.value.toBigInt();\n  }\n\n  /**\n   * Turns the {@link UInt64} into a {@link UInt32}, asserting that it fits in 32 bits.\n   */\n  toUInt32() {\n    let uint32 = new UInt32(this.value.value);\n    UInt32.check(uint32);\n    return uint32;\n  }\n\n  /**\n   * Turns the {@link UInt64} into a {@link UInt32}, clamping to the 32 bits range if it's too large.\n   * ```ts\n   * UInt64.from(4294967296).toUInt32Clamped().toString(); // \"4294967295\"\n   * ```\n   */\n  toUInt32Clamped() {\n    let max = (1n << 32n) - 1n;\n    let field = Provable.if(this.greaterThan(UInt64.from(max)), Field.from(max), this.value);\n    return UInt32.Unsafe.fromField(field);\n  }\n\n  static check(x: UInt64) {\n    RangeCheck.rangeCheckN(UInt64.NUM_BITS, x.value);\n  }\n\n  static toInput(x: UInt64): HashInput {\n    return { packed: [[x.value, 64]] };\n  }\n\n  /**\n   * Encodes this structure into a JSON-like object.\n   */\n  static toJSON(x: UInt64) {\n    return x.value.toString();\n  }\n\n  /**\n   * Decodes a JSON-like object into this structure.\n   */\n  static fromJSON<T extends AnyConstructor>(x: string): InstanceType<T> {\n    return this.from(x) as any;\n  }\n\n  private static checkConstant(x: Field) {\n    if (!x.isConstant()) return x;\n    let xBig = x.toBigInt();\n    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {\n      throw Error(`UInt64: Expected number between 0 and 2^64 - 1, got ${xBig}`);\n    }\n    return x;\n  }\n\n  /**\n   * Creates a new {@link UInt64}.\n   */\n  static from(x: UInt64 | UInt32 | number | string | bigint) {\n    if (x instanceof UInt64) return x;\n    return new this(x);\n  }\n\n  /**\n   * Creates a {@link UInt64} with a value of 18,446,744,073,709,551,615.\n   */\n  static MAXINT() {\n    return new UInt64((1n << 64n) - 1n);\n  }\n\n  /**\n   * Addition modulo 2^64. Check {@link Gadgets.addMod64} for a detailed description.\n   */\n  addMod64(y: UInt64) {\n    return new UInt64(addMod64(this.value, y.value).value);\n  }\n\n  /**\n   * Integer division with remainder.\n   *\n   * `x.divMod(y)` returns the quotient and the remainder.\n   */\n  divMod(y: UInt64 | number | string) {\n    let x = this.value;\n    let y_ = UInt64.from(y).value;\n\n    if (this.value.isConstant() && y_.isConstant()) {\n      let xn = x.toBigInt();\n      let yn = y_.toBigInt();\n      let q = xn / yn;\n      let r = xn - q * yn;\n      return {\n        quotient: new UInt64(q),\n        rest: new UInt64(r),\n      };\n    }\n\n    y_ = y_.seal();\n\n    let q = Provable.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));\n\n    RangeCheck.rangeCheckN(UInt64.NUM_BITS, q);\n\n    // TODO: Could be a bit more efficient\n    let r = x.sub(q.mul(y_)).seal();\n    RangeCheck.rangeCheckN(UInt64.NUM_BITS, r);\n\n    let r_ = new UInt64(r.value);\n    let q_ = new UInt64(q.value);\n\n    r_.assertLessThan(new UInt64(y_.value));\n\n    return { quotient: q_, rest: r_ };\n  }\n\n  /**\n   * Integer division.\n   *\n   * `x.div(y)` returns the floor of `x / y`, that is, the greatest\n   * `z` such that `z * y <= x`.\n   *\n   */\n  div(y: UInt64 | number) {\n    return this.divMod(y).quotient;\n  }\n\n  /**\n   * Integer remainder.\n   *\n   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and\n   * `x - z` is divisible by `y`.\n   */\n  mod(y: UInt64 | number) {\n    return this.divMod(y).rest;\n  }\n\n  /**\n   * Multiplication with overflow checking.\n   */\n  mul(y: UInt64 | number) {\n    let z = this.value.mul(UInt64.from(y).value);\n    RangeCheck.rangeCheckN(UInt64.NUM_BITS, z);\n    return new UInt64(z.value);\n  }\n\n  /**\n   * Addition with overflow checking.\n   */\n  add(y: UInt64 | number) {\n    let z = this.value.add(UInt64.from(y).value);\n    RangeCheck.rangeCheckN(UInt64.NUM_BITS, z);\n    return new UInt64(z.value);\n  }\n\n  /**\n   * Subtraction with underflow checking.\n   */\n  sub(y: UInt64 | number) {\n    let z = this.value.sub(UInt64.from(y).value);\n    RangeCheck.rangeCheckN(UInt64.NUM_BITS, z);\n    return new UInt64(z.value);\n  }\n\n  /**\n   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).\n   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.\n   *\n   * This gadget builds a chain of XOR gates recursively.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)\n   *\n   * @param x {@link UInt64} element to XOR.\n   *\n   * @example\n   * ```ts\n   * let a = UInt64.from(0b0101);\n   * let b = UInt64.from(0b0011);\n   *\n   * let c = a.xor(b);\n   * c.assertEquals(0b0110);\n   * ```\n   */\n  xor(x: UInt64) {\n    return new UInt64(Bitwise.xor(this.value, x.value, UInt64.NUM_BITS).value);\n  }\n\n  /**\n   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise\n   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/\n   * Web/JavaScript/Reference/Operators/Bitwise_NOT).\n   *\n   * **Note:** The NOT gate operates over 64 bit for UInt64 types.\n   *\n   * A NOT gate works by returning `1` in each bit position if the\n   * corresponding bit of the operand is `0`, and returning `0` if the\n   * corresponding bit of the operand is `1`.\n   *\n   * NOT is implemented as a subtraction of the input from the all one bitmask\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)\n   *\n   * @example\n   * ```ts\n   * // NOTing 4 bits with the unchecked version\n   * let a = UInt64.from(0b0101);\n   * let b = a.not();\n   *\n   * console.log(b.toBigInt().toString(2));\n   * // 1111111111111111111111111111111111111111111111111111111111111010\n   *\n   * ```\n   *\n   */\n  not() {\n    return new UInt64(Bitwise.not(this.value, UInt64.NUM_BITS, false).value);\n  }\n\n  /**\n   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,\n   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.\n   * For a left rotation, this means that bits shifted off the left end reappear at the right end.\n   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.\n   *\n   * To safely use `rotate()`, you need to make sure that the value passed in is range-checked to 64 bits;\n   * for example, using {@link Gadgets.rangeCheck64}.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)\n   *\n   * @param bits amount of bits to rotate this {@link UInt64} element with.\n   * @param direction left or right rotation direction.\n   *\n   *\n   * @example\n   * ```ts\n   * const x = UInt64.from(0b001100);\n   * const y = x.rotate(2, 'left');\n   * const z = x.rotate(2, 'right'); // right rotation by 2 bits\n   * y.assertEquals(0b110000);\n   * z.assertEquals(0b000011);\n   * ```\n   */\n  rotate(bits: number, direction: 'left' | 'right' = 'left') {\n    return new UInt64(Bitwise.rotate64(this.value, bits, direction).value);\n  }\n\n  /**\n   * Performs a left shift operation on the provided {@link UInt64} element.\n   * This operation is similar to the `<<` shift operation in JavaScript,\n   * where bits are shifted to the left, and the overflowing bits are discarded.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * @param bits Amount of bits to shift the {@link UInt64} element to the left. The amount should be between 0 and 64 (or else the shift will fail).\n   *\n   * @example\n   * ```ts\n   * const x = UInt64.from(0b001100); // 12 in binary\n   * const y = x.leftShift(2); // left shift by 2 bits\n   * y.assertEquals(0b110000); // 48 in binary\n   * ```\n   */\n  leftShift(bits: number) {\n    return new UInt64(Bitwise.leftShift64(this.value, bits).value);\n  }\n\n  /**\n   * Performs a right shift operation on the provided {@link UInt64} element.\n   * This operation is similar to the `>>` shift operation in JavaScript,\n   * where bits are shifted to the right, and the overflowing bits are discarded.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * @param bits Amount of bits to shift the {@link UInt64} element to the right. The amount should be between 0 and 64 (or else the shift will fail).\n   *\n   * @example\n   * ```ts\n   * const x = UInt64.from(0b001100); // 12 in binary\n   * const y = x.rightShift(2); // right shift by 2 bits\n   * y.assertEquals(0b000011); // 3 in binary\n   * ```\n   */\n  rightShift(bits: number) {\n    return new UInt64(Bitwise.rightShift64(this.value, bits).value);\n  }\n\n  /**\n   * Bitwise AND gadget on {@link UInt64} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).\n   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.\n   *\n   * It can be checked by a double generic gate that verifies the following relationship between the values below.\n   *\n   * The generic gate verifies:\\\n   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\\\n   * Where:\\\n   * `a + b = sum`\\\n   * `a ^ b = xor`\\\n   * `a & b = and`\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)\n   *\n   *\n   * @example\n   * ```typescript\n   * let a = UInt64.from(3);    // ... 000011\n   * let b = UInt64.from(5);    // ... 000101\n   *\n   * let c = a.and(b);    // ... 000001\n   * c.assertEquals(1);\n   * ```\n   */\n  and(x: UInt64) {\n    return new UInt64(Bitwise.and(this.value, x.value, UInt64.NUM_BITS).value);\n  }\n\n  /**\n   * Bitwise OR gadget on {@link UInt64} elements. Equivalent to the [bitwise OR `|` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR).\n   * The OR gate works by comparing two bits and returning `1` if at least one bit is `1`, and `0` otherwise.\n   *\n   * @example\n   * ```typescript\n   * let a = UInt64.from(3);    // ... 000011\n   * let b = UInt64.from(5);    // ... 000101\n   *\n   * let c = a.or(b);    // ... 000111\n   * c.assertEquals(7);\n   * ```\n   */\n  or(x: UInt64) {\n    return new UInt64(Bitwise.or(this.value, x.value, UInt64.NUM_BITS).value);\n  }\n\n  /**\n   * Checks if a {@link UInt64} is less than or equal to another one.\n   */\n  lessThanOrEqual(y: UInt64) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      return Bool(this.value.toBigInt() <= y.value.toBigInt());\n    }\n    return lessThanOrEqualGeneric(this.value, y.value, 1n << 64n, (v) =>\n      RangeCheck.rangeCheckN(UInt64.NUM_BITS, v)\n    );\n  }\n\n  /**\n   * Asserts that a {@link UInt64} is less than or equal to another one.\n   */\n  assertLessThanOrEqual(y: UInt64, message?: string) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];\n      return assert(x0 <= y0, message ?? `UInt64.assertLessThanOrEqual: expected ${x0} <= ${y0}`);\n    }\n    assertLessThanOrEqualGeneric(this.value, y.value, (v) =>\n      RangeCheck.rangeCheckN(UInt64.NUM_BITS, v, message)\n    );\n  }\n\n  /**\n   *\n   * Checks if a {@link UInt64} is less than another one.\n   */\n  lessThan(y: UInt64) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      return Bool(this.value.toBigInt() < y.value.toBigInt());\n    }\n    return lessThanGeneric(this.value, y.value, 1n << 64n, (v) =>\n      RangeCheck.rangeCheckN(UInt64.NUM_BITS, v)\n    );\n  }\n\n  /**\n   * Asserts that a {@link UInt64} is less than another one.\n   */\n  assertLessThan(y: UInt64, message?: string) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];\n      return assert(x0 < y0, message ?? `UInt64.assertLessThan: expected ${x0} < ${y0}`);\n    }\n    assertLessThanGeneric(this.value, y.value, (v) =>\n      RangeCheck.rangeCheckN(UInt64.NUM_BITS, v, message)\n    );\n  }\n\n  /**\n   * Checks if a {@link UInt64} is greater than another one.\n   */\n  greaterThan(y: UInt64) {\n    return y.lessThan(this);\n  }\n\n  /**\n   * Asserts that a {@link UInt64} is greater than another one.\n   */\n  assertGreaterThan(y: UInt64, message?: string) {\n    y.assertLessThan(this, message);\n  }\n\n  /**\n   * Checks if a {@link UInt64} is greater than or equal to another one.\n   */\n  greaterThanOrEqual(y: UInt64) {\n    return y.lessThanOrEqual(this);\n  }\n\n  /**\n   * Asserts that a {@link UInt64} is greater than or equal to another one.\n   */\n  assertGreaterThanOrEqual(y: UInt64, message?: string) {\n    y.assertLessThanOrEqual(this, message);\n  }\n\n  static toValue(x: UInt64) {\n    return x.value.toBigInt();\n  }\n\n  static fromValue<T extends AnyConstructor>(x: number | bigint | UInt64): InstanceType<T> {\n    return UInt64.from(x) as any;\n  }\n\n  /**\n   * Split a UInt64 into 8 UInt8s, in little-endian order.\n   */\n  toBytes() {\n    return TupleN.fromArray(8, wordToBytes(this.value, 8));\n  }\n\n  /**\n   * Split a UInt64 into 8 UInt8s, in big-endian order.\n   */\n  toBytesBE() {\n    return TupleN.fromArray(8, wordToBytes(this.value, 8).reverse());\n  }\n\n  /**\n   * Combine 8 UInt8s into a UInt64, in little-endian order.\n   */\n  static fromBytes(bytes: UInt8[]): UInt64 {\n    assert(bytes.length === 8, '8 bytes needed to create a uint64');\n    return UInt64.Unsafe.fromField(bytesToWord(bytes));\n  }\n\n  /**\n   * Combine 8 UInt8s into a UInt64, in big-endian order.\n   */\n  static fromBytesBE(bytes: UInt8[]): UInt64 {\n    return UInt64.fromBytes([...bytes].reverse());\n  }\n\n  /**\n   * Returns an array of {@link Bool} elements representing [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of this {@link UInt64} element.\n   *\n   * If you use the optional `length` argument, proves that the UInt64 element fits in `length` bits.\n   * The `length` has to be between 0 and 64 and the method throws if it isn't.\n   *\n   * **Warning**: The cost of this operation in a zk proof depends on the `length` you specify,\n   * which by default is 64 bits. Prefer to pass a smaller `length` if possible.\n   *\n   * @param length - the number of bits to fit the element. If the element does not fit in `length` bits, the functions throws an error.\n   *\n   * @return An array of {@link Bool} element representing little endian binary representation of this {@link UInt64}.\n   */\n  toBits(length: number = 64) {\n    checkBitLength('UInt64.toBits()', length, 64);\n    if (this.isConstant()) {\n      let bits = BinableFp.toBits(this.toBigInt());\n      if (bits.slice(length).some((bit) => bit))\n        throw Error(`UInt64.toBits(): ${this} does not fit in ${length} bits`);\n      return bits.slice(0, length).map((b) => new Bool(b));\n    }\n    return this.value.toBits(length);\n  }\n\n  /**\n   * Convert a bit array into a {@link UInt64} element using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness)\n   *\n   * The method throws if the given bits do not fit in a single UInt64 element. In this case, no more than 64 bits are allowed.\n   *\n   * **Important**: If the given `bits` array is an array of `booleans` or {@link Bool} elements that all are `constant`,\n   *  the resulting {@link UInt64} element will be a constant as well. Or else, if the given array is a mixture of constants and variables of {@link Bool} type,\n   *  the resulting {@link UInt64} will be a variable as well.\n   *\n   * @param bits - An array of {@link Bool} or `boolean` type.\n   *\n   * @return A {@link UInt64} element matching the [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of the given `bits` array.\n   */\n  static fromBits(bits: (Bool | boolean)[]) {\n    const length = bits.length;\n    checkBitLength('UInt64.fromBits()', length, 64);\n    return UInt64.Unsafe.fromField(Field.fromBits(bits));\n  }\n}\n/**\n * A 32 bit unsigned integer with values ranging from 0 to 4,294,967,295.\n */\nclass UInt32 extends CircuitValue {\n  @prop value: Field;\n  static NUM_BITS = 32;\n\n  /**\n   * Create a {@link UInt32}.\n   * The max value of a {@link UInt32} is `2^32 - 1 = UInt32.MAXINT()`.\n   *\n   * **Warning**: Cannot overflow, an error is thrown if the result is greater than UInt32.MAXINT()\n   */\n  constructor(x: UInt32 | FieldVar | number | string | bigint) {\n    if (x instanceof UInt32) x = x.value.value;\n    let value = Field(x);\n    super(value);\n    // check the range if the argument is a constant\n    UInt32.checkConstant(value);\n  }\n\n  static Unsafe = {\n    /**\n     * Create a {@link UInt32} from a {@link Field} without constraining its range.\n     *\n     * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 32 bits.\\\n     * Only use this if you know what you are doing, otherwise use the safe {@link UInt32.from}.\n     */\n    fromField(x: Field) {\n      return new UInt32(x.value);\n    },\n  };\n\n  /**\n   * Static method to create a {@link UInt32} with value `0`.\n   */\n  static get zero(): UInt32 {\n    return new UInt32(0);\n  }\n\n  /**\n   * Static method to create a {@link UInt32} with value `0`.\n   */\n  static get one(): UInt32 {\n    return new UInt32(1);\n  }\n  /**\n   * Turns the {@link UInt32} into a string.\n   */\n  toString(): string {\n    return this.value.toString();\n  }\n  /**\n   * Turns the {@link UInt32} into a BigInt.\n   */\n  toBigint() {\n    return this.value.toBigInt();\n  }\n  /**\n   * Turns the {@link UInt32} into a {@link UInt64}.\n   */\n  toUInt64(): UInt64 {\n    // this is safe, because the UInt32 range is included in the UInt64 range\n    return new UInt64(this.value.value);\n  }\n\n  static check(x: UInt32) {\n    RangeCheck.rangeCheck32(x.value);\n  }\n  static toInput(x: UInt32): HashInput {\n    return { packed: [[x.value, 32]] };\n  }\n  /**\n   * Encodes this structure into a JSON-like object.\n   */\n  static toJSON(x: UInt32) {\n    return x.value.toString();\n  }\n\n  /**\n   * Decodes a JSON-like object into this structure.\n   */\n  static fromJSON<T extends AnyConstructor>(x: string): InstanceType<T> {\n    return this.from(x) as any;\n  }\n\n  private static checkConstant(x: Field) {\n    if (!x.isConstant()) return x;\n    let xBig = x.toBigInt();\n    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {\n      throw Error(`UInt32: Expected number between 0 and 2^32 - 1, got ${xBig}`);\n    }\n    return x;\n  }\n\n  // this checks the range if the argument is a constant\n  /**\n   * Creates a new {@link UInt32}.\n   */\n  static from(x: UInt32 | number | string | bigint) {\n    if (x instanceof UInt32) return x;\n    return new this(x);\n  }\n\n  /**\n   * Creates a {@link UInt32} with a value of 4,294,967,295.\n   */\n  static MAXINT() {\n    return new UInt32((1n << 32n) - 1n);\n  }\n\n  /**\n   * Addition modulo 2^32. Check {@link Gadgets.addMod32} for a detailed description.\n   */\n  addMod32(y: UInt32) {\n    return new UInt32(addMod32(this.value, y.value).value);\n  }\n\n  /**\n   * Integer division with remainder.\n   *\n   * `x.divMod(y)` returns the quotient and the remainder.\n   */\n  divMod(y: UInt32 | number | string) {\n    let x = this.value;\n    let y_ = UInt32.from(y).value;\n\n    if (x.isConstant() && y_.isConstant()) {\n      let xn = x.toBigInt();\n      let yn = y_.toBigInt();\n      let q = xn / yn;\n      let r = xn - q * yn;\n      return {\n        quotient: new UInt32(new Field(q.toString()).value),\n        rest: new UInt32(new Field(r.toString()).value),\n      };\n    }\n\n    y_ = y_.seal();\n\n    let q = Provable.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));\n\n    RangeCheck.rangeCheck32(q);\n\n    // TODO: Could be a bit more efficient\n    let r = x.sub(q.mul(y_)).seal();\n    RangeCheck.rangeCheck32(r);\n\n    let r_ = new UInt32(r.value);\n    let q_ = new UInt32(q.value);\n\n    r_.assertLessThan(new UInt32(y_.value));\n\n    return { quotient: q_, rest: r_ };\n  }\n  /**\n   * Integer division.\n   *\n   * `x.div(y)` returns the floor of `x / y`, that is, the greatest\n   * `z` such that `x * y <= x`.\n   *\n   */\n  div(y: UInt32 | number) {\n    return this.divMod(y).quotient;\n  }\n  /**\n   * Integer remainder.\n   *\n   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and\n   * `x - z` is divisible by `y`.\n   */\n  mod(y: UInt32 | number) {\n    return this.divMod(y).rest;\n  }\n  /**\n   * Multiplication with overflow checking.\n   */\n  mul(y: UInt32 | number) {\n    let z = this.value.mul(UInt32.from(y).value);\n    RangeCheck.rangeCheck32(z);\n    return new UInt32(z.value);\n  }\n  /**\n   * Addition with overflow checking.\n   */\n  add(y: UInt32 | number) {\n    let z = this.value.add(UInt32.from(y).value);\n    RangeCheck.rangeCheck32(z);\n    return new UInt32(z.value);\n  }\n  /**\n   * Subtraction with underflow checking.\n   */\n  sub(y: UInt32 | number) {\n    let z = this.value.sub(UInt32.from(y).value);\n    RangeCheck.rangeCheck32(z);\n    return new UInt32(z.value);\n  }\n\n  /**\n   * Bitwise XOR gadget on {@link UInt32} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).\n   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.\n   *\n   * This gadget builds a chain of XOR gates recursively.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)\n   *\n   * @param x {@link UInt32} element to compare.\n   *\n   * @example\n   * ```ts\n   * let a = UInt32.from(0b0101);\n   * let b = UInt32.from(0b0011);\n   *\n   * let c = a.xor(b);\n   * c.assertEquals(0b0110);\n   * ```\n   */\n  xor(x: UInt32) {\n    return new UInt32(Bitwise.xor(this.value, x.value, UInt32.NUM_BITS).value);\n  }\n\n  /**\n   * Bitwise NOT gate on {@link UInt32} elements. Similar to the [bitwise\n   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/\n   * Web/JavaScript/Reference/Operators/Bitwise_NOT).\n   *\n   * **Note:** The NOT gate operates over 32 bit for UInt32 types.\n   *\n   * A NOT gate works by returning `1` in each bit position if the\n   * corresponding bit of the operand is `0`, and returning `0` if the\n   * corresponding bit of the operand is `1`.\n   *\n   * NOT is implemented as a subtraction of the input from the all one bitmask.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)\n   *\n   * @example\n   * ```ts\n   * // NOTing 4 bits with the unchecked version\n   * let a = UInt32.from(0b0101);\n   * let b = a.not();\n   *\n   * console.log(b.toBigInt().toString(2));\n   * // 11111111111111111111111111111010\n   * ```\n   *\n   */\n  not() {\n    return new UInt32(Bitwise.not(this.value, UInt32.NUM_BITS, false).value);\n  }\n\n  /**\n   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,\n   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.\n   * For a left rotation, this means that bits shifted off the left end reappear at the right end.\n   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.\n   *\n   * To safely use `rotate()`, you need to make sure that the value passed in is range-checked to 64 bits;\n   * for example, using {@link Gadgets.rangeCheck64}.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)\n   *\n   * @param bits amount of bits to rotate this {@link UInt32} element with.\n   * @param direction left or right rotation direction.\n   *\n   *\n   * @example\n   * ```ts\n   * const x = UInt32.from(0b001100);\n   * const y = x.rotate(2, 'left');\n   * const z = x.rotate(2, 'right'); // right rotation by 2 bits\n   * y.assertEquals(0b110000);\n   * z.assertEquals(0b000011);\n   * ```\n   */\n  rotate(bits: number, direction: 'left' | 'right' = 'left') {\n    return new UInt32(Bitwise.rotate32(this.value, bits, direction).value);\n  }\n\n  /**\n   * Performs a left shift operation on the provided {@link UInt32} element.\n   * This operation is similar to the `<<` shift operation in JavaScript,\n   * where bits are shifted to the left, and the overflowing bits are discarded.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 32-bit representation of the number,\n   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * The operation expects the input to be range checked to 32 bit.\n   *\n   * @param bits Amount of bits to shift the {@link UInt32} element to the left. The amount should be between 0 and 32 (or else the shift will fail).\n   *\n   * @example\n   * ```ts\n   * const x = UInt32.from(0b001100); // 12 in binary\n   * const y = x.leftShift(2); // left shift by 2 bits\n   * y.assertEquals(0b110000); // 48 in binary\n   * ```\n   */\n  leftShift(bits: number) {\n    return new UInt32(Bitwise.leftShift32(this.value, bits).value);\n  }\n\n  /**\n   * Performs a left right operation on the provided {@link UInt32} element.\n   * This operation is similar to the `>>` shift operation in JavaScript,\n   * where bits are shifted to the right, and the overflowing bits are discarded.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 32-bit representation of the number,\n   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * @param bits Amount of bits to shift the {@link UInt32} element to the right. The amount should be between 0 and 32 (or else the shift will fail).\n   *\n   * The operation expects the input to be range checked to 32 bit.\n   *\n   * @example\n   * ```ts\n   * const x = UInt32.from(0b001100); // 12 in binary\n   * const y = x.rightShift(2); // left shift by 2 bits\n   * y.assertEquals(0b000011); // 48 in binary\n   * ```\n   */\n  rightShift(bits: number) {\n    return new UInt32(Bitwise.rightShift64(this.value, bits).value);\n  }\n\n  /**\n   * Bitwise AND gadget on {@link UInt32} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).\n   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.\n   *\n   * It can be checked by a double generic gate that verifies the following relationship between the values below.\n   *\n   * The generic gate verifies:\\\n   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\\\n   * Where:\\\n   * `a + b = sum`\\\n   * `a ^ b = xor`\\\n   * `a & b = and`\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)\n   *\n   *\n   * @example\n   * ```typescript\n   * let a = UInt32.from(3);    // ... 000011\n   * let b = UInt32.from(5);    // ... 000101\n   *\n   * let c = a.and(b);    // ... 000001\n   * c.assertEquals(1);\n   * ```\n   */\n  and(x: UInt32) {\n    return new UInt32(Bitwise.and(this.value, x.value, UInt32.NUM_BITS).value);\n  }\n\n  /**\n   * Bitwise OR gadget on {@link UInt32} elements. Equivalent to the [bitwise OR `|` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR).\n   * The OR gate works by comparing two bits and returning `1` if at least one bit is `1`, and `0` otherwise.\n   *\n   * @example\n   * ```typescript\n   * let a = UInt32.from(3);    // ... 000011\n   * let b = UInt32.from(5);    // ... 000101\n   *\n   * let c = a.or(b);    // ... 000111\n   * c.assertEquals(7);\n   * ```\n   */\n  or(x: UInt32) {\n    return new UInt32(Bitwise.or(this.value, x.value, UInt32.NUM_BITS).value);\n  }\n\n  /**\n   * Checks if a {@link UInt32} is less than or equal to another one.\n   */\n  lessThanOrEqual(y: UInt32) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      return Bool(this.value.toBigInt() <= y.value.toBigInt());\n    }\n    return lessThanOrEqualGeneric(this.value, y.value, 1n << 32n, (v) =>\n      RangeCheck.rangeCheckN(UInt32.NUM_BITS, v)\n    );\n  }\n\n  /**\n   * Asserts that a {@link UInt32} is less than or equal to another one.\n   */\n  assertLessThanOrEqual(y: UInt32, message?: string) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];\n      return assert(x0 <= y0, message ?? `UInt32.assertLessThanOrEqual: expected ${x0} <= ${y0}`);\n    }\n    assertLessThanOrEqualGeneric(this.value, y.value, (v) =>\n      RangeCheck.rangeCheckN(UInt32.NUM_BITS, v, message)\n    );\n  }\n\n  /**\n   * Checks if a {@link UInt32} is less than another one.\n   */\n  lessThan(y: UInt32) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      return Bool(this.value.toBigInt() < y.value.toBigInt());\n    }\n    return lessThanGeneric(this.value, y.value, 1n << 32n, (v) =>\n      RangeCheck.rangeCheckN(UInt32.NUM_BITS, v)\n    );\n  }\n\n  /**\n   * Asserts that a {@link UInt32} is less than another one.\n   */\n  assertLessThan(y: UInt32, message?: string) {\n    if (this.value.isConstant() && y.value.isConstant()) {\n      let [x0, y0] = [this.value.toBigInt(), y.value.toBigInt()];\n      return assert(x0 < y0, message ?? `UInt32.assertLessThan: expected ${x0} < ${y0}`);\n    }\n    assertLessThanGeneric(this.value, y.value, (v) =>\n      RangeCheck.rangeCheckN(UInt32.NUM_BITS, v, message)\n    );\n  }\n\n  /**\n   * Checks if a {@link UInt32} is greater than another one.\n   */\n  greaterThan(y: UInt32) {\n    return y.lessThan(this);\n  }\n\n  /**\n   * Asserts that a {@link UInt32} is greater than another one.\n   */\n  assertGreaterThan(y: UInt32, message?: string) {\n    y.assertLessThan(this, message);\n  }\n\n  /**\n   * Checks if a {@link UInt32} is greater than or equal to another one.\n   */\n  greaterThanOrEqual(y: UInt32) {\n    return y.lessThanOrEqual(this);\n  }\n\n  /**\n   * Asserts that a {@link UInt32} is greater than or equal to another one.\n   */\n  assertGreaterThanOrEqual(y: UInt32, message?: string) {\n    y.assertLessThanOrEqual(this, message);\n  }\n\n  static toValue(x: UInt32) {\n    return x.value.toBigInt();\n  }\n\n  static fromValue<T extends AnyConstructor>(x: number | bigint | UInt32): InstanceType<T> {\n    return UInt32.from(x) as any;\n  }\n\n  /**\n   * Split a UInt32 into 4 UInt8s, in little-endian order.\n   */\n  toBytes() {\n    return TupleN.fromArray(4, wordToBytes(this.value, 4));\n  }\n\n  /**\n   * Split a UInt32 into 4 UInt8s, in big-endian order.\n   */\n  toBytesBE() {\n    return TupleN.fromArray(4, wordToBytes(this.value, 4).reverse());\n  }\n\n  /**\n   * Combine 4 UInt8s into a UInt32, in little-endian order.\n   */\n  static fromBytes(bytes: UInt8[]): UInt32 {\n    assert(bytes.length === 4, '4 bytes needed to create a uint32');\n    return UInt32.Unsafe.fromField(bytesToWord(bytes));\n  }\n\n  /**\n   * Combine 4 UInt8s into a UInt32, in big-endian order.\n   */\n  static fromBytesBE(bytes: UInt8[]): UInt32 {\n    return UInt32.fromBytes([...bytes].reverse());\n  }\n\n  /**\n   * Returns an array of {@link Bool} elements representing [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of this {@link UInt32} element.\n   *\n   * If you use the optional `length` argument, proves that the UInt32 element fits in `length` bits.\n   * The `length` has to be between 0 and 32 and the method throws if it isn't.\n   *\n   * **Warning**: The cost of this operation in a zk proof depends on the `length` you specify,\n   * which by default is 32 bits. Prefer to pass a smaller `length` if possible.\n   *\n   * @param length - the number of bits to fit the element. If the element does not fit in `length` bits, the functions throws an error.\n   *\n   * @return An array of {@link Bool} element representing little endian binary representation of this {@link UInt32}.\n   */\n  toBits(length: number = 32) {\n    checkBitLength('UInt32.toBits()', length, 32);\n    if (this.isConstant()) {\n      let bits = BinableFp.toBits(this.toBigint());\n      if (bits.slice(length).some((bit) => bit))\n        throw Error(`UInt32.toBits(): ${this} does not fit in ${length} bits`);\n      return bits.slice(0, length).map((b) => new Bool(b));\n    }\n    return this.value.toBits(length);\n  }\n\n  /**\n   * Convert a bit array into a {@link UInt32} element using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness)\n   *\n   * The method throws if the given bits do not fit in a single UInt32 element. In this case, no more than 32 bits are allowed.\n   *\n   * **Important**: If the given `bits` array is an array of `booleans` or {@link Bool} elements that all are `constant`,\n   *  the resulting {@link UInt32} element will be a constant as well. Or else, if the given array is a mixture of constants and variables of {@link Bool} type,\n   *  the resulting {@link UInt32} will be a variable as well.\n   *\n   * @param bits - An array of {@link Bool} or `boolean` type.\n   *\n   * @return A {@link UInt32} element matching the [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of the given `bits` array.\n   */\n  static fromBits(bits: (Bool | boolean)[]) {\n    const length = bits.length;\n    checkBitLength('UInt32.fromBits()', length, 32);\n    return UInt32.Unsafe.fromField(Field.fromBits(bits));\n  }\n}\n\nclass Sign extends CircuitValue {\n  @prop value: Field; // +/- 1\n\n  static get one() {\n    return new Sign(Field(1));\n  }\n  static get minusOne() {\n    return new Sign(Field(-1));\n  }\n  static check(x: Sign) {\n    // x^2 === 1  <=>  x === 1 or x === -1\n    x.value.square().assertEquals(1);\n  }\n  static empty<T extends AnyConstructor>(): InstanceType<T> {\n    return Sign.one as any;\n  }\n  static toInput(x: Sign): HashInput {\n    return { packed: [[x.isPositive().toField(), 1]] };\n  }\n  static toJSON(x: Sign) {\n    if (x.toString() === '1') return 'Positive';\n    if (x.neg().toString() === '1') return 'Negative';\n    throw Error(`Invalid Sign: ${x}`);\n  }\n  static fromJSON<T extends AnyConstructor>(x: 'Positive' | 'Negative'): InstanceType<T> {\n    return (x === 'Positive' ? new Sign(Field(1)) : new Sign(Field(-1))) as any;\n  }\n  neg() {\n    return new Sign(this.value.neg());\n  }\n  mul(y: Sign) {\n    return new Sign(this.value.mul(y.value));\n  }\n  isPositive() {\n    return this.value.equals(1);\n  }\n  isNegative() {\n    return this.value.equals(-1);\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n\n  static toValue(x: Sign) {\n    return x.value.toBigInt() as TypesBigint.Sign;\n  }\n\n  static fromValue<T extends AnyConstructor>(x: number | bigint | Sign): InstanceType<T> {\n    if (x instanceof Sign) return x as any;\n    return new Sign(Field(x)) as any;\n  }\n}\n\ntype BalanceChange = Types.AccountUpdate['body']['balanceChange'];\n\n/**\n * A 64 bit signed integer with values ranging from -18,446,744,073,709,551,615 to 18,446,744,073,709,551,615.\n */\nclass Int64 extends CircuitValue implements BalanceChange {\n  // * in the range [-2^64+1, 2^64-1], unlike a normal int64\n  // * under- and overflowing is disallowed, similar to UInt64, unlike a normal int64\n\n  @prop magnitude: UInt64; // absolute value\n  @prop sgn: Sign; // +/- 1\n\n  // Some thoughts regarding the representation as field elements:\n  // toFields returns the in-circuit representation, so the main objective is to minimize the number of constraints\n  // that result from this representation. Therefore, I think the only candidate for an efficient 1-field representation\n  // is the one where the Int64 is the field: toFields = Int64 => [Int64.magnitude.mul(Int64.sign)]. Anything else involving\n  // bit packing would just lead to very inefficient circuit operations.\n  //\n  // So, is magnitude * sign (\"1-field\") a more efficient representation than (magnitude, sign) (\"2-field\")?\n  // Several common operations like add, mul, etc, operate on 1-field so in 2-field they result in one additional multiplication\n  // constraint per operand. However, the check operation (constraining to 64 bits + a sign) which is called at the introduction\n  // of every witness, and also at the end of add, mul, etc, operates on 2-field. So here, the 1-field representation needs\n  // to add an additional magnitude * sign = Int64 multiplication constraint, which will typically cancel out most of the gains\n  // achieved by 1-field elsewhere.\n  // There are some notable operations for which 2-field is definitely better:\n  //\n  // * div and mod (which do integer division with rounding on the magnitude)\n  // * converting the Int64 to a Currency.Amount.Signed (for the zkapp balance), which has the exact same (magnitude, sign) representation we use here.\n  //\n  // The second point is one of the main things an Int64 is used for, and was the original motivation to use 2 fields.\n  // Overall, I think the existing implementation is the optimal one.\n\n  /**\n   * @deprecated Use {@link Int64.create} for safe creation.\n   *\n   * WARNING: This constructor allows for ambiguous representation of zero (both +0 and -0).\n   * This can lead to unexpected behavior in operations like {@link isPositive()} and {@link mod()}.\n   *\n   * Security Implications:\n   * 1. A malicious prover could choose either positive or negative zero.\n   * 2. Arithmetic operations that result in 0 may allow an attacker to arbitrarily choose the sign.\n   * 3. This ambiguity could be exploited in protocols using Int64s for calculations like PNL tracking.\n   *\n   * Recommended Fix:\n   * Use Int64.create() which enforces a canonical representation of zero, or\n   * explicitly handle the zero case in operations like mod().\n   *\n   * @param magnitude - The magnitude of the integer as a UInt64.\n   * @param [sgn=Sign.one] - The sign of the integer. Default is positive (Sign.one).\n   */\n  constructor(magnitude: UInt64, sgn = Sign.one) {\n    super(magnitude, sgn);\n  }\n\n  /**\n   * Safely creates a new Int64 instance, enforcing canonical representation of zero.\n   * This is the recommended way to create Int64 instances.\n   *\n   * @param magnitude - The magnitude of the integer as a UInt64\n   * @param sign - The sign of the integer.\n   * @returns A new Int64 instance with a canonical representation.\n   *\n   * @example\n   * ```ts\n   * const x = Int64.create(0); // canonical representation of zero\n   * ```\n   */\n  static create(magnitude: UInt64, sign: Sign = Sign.one): Int64 {\n    const mag = UInt64.from(magnitude);\n    const isZero = mag.equals(UInt64.zero);\n    const canonicalSign = Provable.if(isZero, Sign.one, sign);\n    return new Int64(mag, canonicalSign);\n  }\n\n  /**\n   * Creates a new {@link Int64} from a {@link Field}.\n   *\n   * Does check if the {@link Field} is within range.\n   */\n  private static fromFieldUnchecked(x: Field) {\n    let TWO64 = 1n << 64n;\n    let xBigInt = x.toBigInt();\n    let isValidPositive = xBigInt < TWO64; // covers {0,...,2^64 - 1}\n    let isValidNegative = Field.ORDER - xBigInt < TWO64; // {-2^64 + 1,...,-1}\n    if (!isValidPositive && !isValidNegative)\n      throw Error(`Int64: Expected a value between (-2^64, 2^64), got ${x}`);\n    let magnitude = (isValidPositive ? x : x.neg()).toConstant();\n    let sign = isValidPositive ? Sign.one : Sign.minusOne;\n    return Int64.create(UInt64.Unsafe.fromField(magnitude), sign);\n  }\n\n  // this doesn't check ranges because we assume they're already checked on UInts\n  /**\n   * Creates a new {@link Int64} from a {@link Field}.\n   *\n   * **Does not** check if the {@link Field} is within range.\n   */\n  static fromUnsigned(x: UInt64 | UInt32) {\n    return Int64.create(x instanceof UInt32 ? x.toUInt64() : x);\n  }\n\n  // this checks the range if the argument is a constant\n  /**\n   * Creates a new {@link Int64}.\n   *\n   * Check the range if the argument is a constant.\n   */\n  static from(x: Int64 | UInt32 | UInt64 | Field | number | string | bigint) {\n    if (x instanceof Int64) return x;\n    if (x instanceof UInt64 || x instanceof UInt32) {\n      return Int64.fromUnsigned(x);\n    }\n    return Int64.fromFieldUnchecked(Field(x));\n  }\n\n  static Unsafe = {\n    fromObject(obj: { magnitude: UInt64; sgn: Sign }): Int64 {\n      return CircuitValue.fromObject.call(Int64, obj);\n    },\n  };\n\n  fromObject(obj: { magnitude: UInt64 | number | string | bigint; sgn: Sign | bigint }) {\n    return Int64.create(UInt64.from(obj.magnitude), Sign.fromValue(obj.sgn));\n  }\n\n  /**\n   * Turns the {@link Int64} into a BigInt.\n   */\n  toBigint() {\n    let abs = this.magnitude.toBigInt();\n    let sgn = this.sgn.isPositive().toBoolean() ? 1n : -1n;\n    return sgn * abs;\n  }\n\n  /**\n   * Turns the {@link Int64} into a string.\n   */\n  toString() {\n    return this.toBigint().toString();\n  }\n\n  isConstant() {\n    return this.magnitude.value.isConstant() && this.sgn.isConstant();\n  }\n\n  // --- circuit-compatible operations below ---\n  // the assumption here is that all Int64 values that appear in a circuit are already checked as valid\n  // this is because Provable.witness calls .check, which calls .check on each prop, i.e. UInt64 and Sign\n  // so we only have to do additional checks if an operation on valid inputs can have an invalid outcome (example: overflow)\n  /**\n   * Static method to create a {@link Int64} with value `0`.\n   */\n  static get zero() {\n    return Int64.create(UInt64.zero);\n  }\n  /**\n   * Static method to create a {@link Int64} with value `1`.\n   */\n  static get one() {\n    return Int64.create(UInt64.one);\n  }\n  /**\n   * Static method to create a {@link Int64} with value `-1`.\n   */\n  static get minusOne() {\n    return Int64.create(UInt64.one).neg();\n  }\n\n  /**\n   * Returns the {@link Field} value.\n   */\n  toField() {\n    return this.magnitude.value.mul(this.sgn.value);\n  }\n  /**\n   * Static method to create a {@link Int64} from a {@link Field}.\n   */\n  static fromField(x: Field): Int64 {\n    // constant case - just return unchecked value\n    if (x.isConstant()) return Int64.fromFieldUnchecked(x);\n    // variable case - create a new checked witness and prove consistency with original field\n    let xInt = Provable.witness(Int64, () => Int64.fromFieldUnchecked(x));\n    xInt.toField().assertEquals(x); // sign(x) * |x| === x\n    return xInt;\n  }\n\n  /**\n   * Negates the current Int64 value.\n   *\n   * This method returns a new Int64 instance with the opposite sign of the current value.\n   * If the current value is zero, it returns zero.\n   *\n   * @returns A new Int64 instance with the negated value.\n   *\n   * @example\n   * ```ts\n   * Int64.from(5).neg();\n   * ```\n   *\n   * @see {@link Int64.from} for creating Int64 instances\n   * @see {@link Int64.zero} for the zero constant\n   *\n   * @throws {Error} Implicitly, if the internal Provable.if condition fails\n   */\n  neg() {\n    return Provable.if(\n      this.magnitude.value.equals(0),\n      Int64.zero,\n      new Int64(this.magnitude, this.sgn.neg())\n    );\n  }\n\n  /**\n   * Addition with overflow checking.\n   */\n  add(y: Int64 | number | string | bigint | UInt64 | UInt32) {\n    let y_ = Int64.from(y);\n    return Int64.fromField(this.toField().add(y_.toField()));\n  }\n  /**\n   * Subtraction with underflow checking.\n   */\n  sub(y: Int64 | number | string | bigint | UInt64 | UInt32) {\n    let y_ = Int64.from(y);\n    return Int64.fromField(this.toField().sub(y_.toField()));\n  }\n  /**\n   * Multiplication with overflow checking.\n   */\n  mul(y: Int64 | number | string | bigint | UInt64 | UInt32) {\n    let y_ = Int64.from(y);\n    return Int64.fromField(this.toField().mul(y_.toField()));\n  }\n\n  /**\n   * Integer division with canonical zero representation.\n   *\n   * @param y - The divisor. Can be an Int64, number, string, bigint, UInt64, or UInt32.\n   * @returns A new Int64 representing the quotient, with canonical zero representation.\n   *\n   * `x.div(y)` returns the floor of `x / y`, that is, the greatest\n   * *`z`* such that *`z * y <= x`.\n   * On negative numbers, this rounds towards zero.\n   *\n   * This method guarantees that all results, including zero, have a consistent\n   * representation, eliminating potential ambiguities in zero handling.\n   */\n  div(y: Int64 | number | string | bigint | UInt64 | UInt32) {\n    let y_ = Int64.from(y);\n    let { quotient } = this.magnitude.divMod(y_.magnitude);\n    let sign = this.sgn.mul(y_.sgn);\n    return Int64.create(quotient, sign);\n  }\n\n  /**\n   * Calculates the integer remainder of this Int64 divided by the given value.\n   *\n   * The result `z` satisfies the following conditions:\n   * 1. 0 <= z < |y|\n   * 2. x - z is divisible by y\n   *\n   * Note: This method follows the \"truncate toward zero\" convention for negative numbers.\n   *\n   * @param y - The divisor. Will be converted to UInt64 if not already.\n   * @returns A new Int64 instance representing the remainder.\n   *\n   * @example\n   * ```ts\n   * const x1 = Int64.from(17);\n   * const y1 = UInt64.from(5);\n   * console.log(x1.mod(y1).toString()); // Output: 2\n   * ```\n   *\n   * @throws {Error} Implicitly, if y is zero or negative.\n   */\n  mod(y: UInt64 | number | string | bigint | UInt32) {\n    let y_ = UInt64.from(y);\n    let rest = this.magnitude.divMod(y_).rest.value;\n    let isNonNegative = this.isNonNegative();\n    rest = Provable.if(isNonNegative.or(rest.equals(0)), rest, y_.value.sub(rest));\n    return new Int64(new UInt64(rest.value));\n  }\n\n  /**\n   * Checks if two values are equal.\n   */\n  equals(y: Int64 | number | string | bigint | UInt64 | UInt32) {\n    let y_ = Int64.from(y);\n    return this.toField().equals(y_.toField());\n  }\n  /**\n   * Asserts that two values are equal.\n   */\n  assertEquals(y: Int64 | number | string | bigint | UInt64 | UInt32, message?: string) {\n    let y_ = Int64.from(y);\n    this.toField().assertEquals(y_.toField(), message);\n  }\n\n  /**\n   * Checks if the value is strictly positive (x > 0).\n   *\n   * @returns True if the value is greater than zero, false otherwise.\n   *\n   * @remarks\n   * This method considers zero as non-positive. It ensures consistency\n   * with the mathematical definition of \"positive\" as strictly greater than zero.\n   * This differs from some other methods which may treat zero as non-negative.\n   */\n  isPositive() {\n    return this.magnitude.equals(UInt64.zero).not().and(this.sgn.isPositive());\n  }\n\n  /**\n   * Checks if the value is non-negative (x >= 0).\n   */\n  isNonNegative() {\n    return this.sgn.isPositive();\n  }\n\n  // then it will be the correct logic; right now it would be misleading\n  /**\n   * Checks if the value is negative (x < 0).\n   */\n  isNegative() {\n    return this.sgn.isNegative();\n  }\n\n  static check({ magnitude, sgn }: { magnitude: UInt64; sgn: Sign }) {\n    // check that the magnitude is in range\n    UInt64.check(magnitude);\n    // check that the sign is valid\n    Sign.check(sgn);\n\n    // check unique representation of 0: we can't have magnitude = 0 and sgn = -1\n    // magnitude + sign != -1 (this check works because magnitude >= 0)\n    magnitude.value.add(sgn.value).assertNotEquals(-1, 'Int64: 0 must have positive sign');\n  }\n}\n\n/**\n * A 8 bit unsigned integer with values ranging from 0 to 255.\n */\nclass UInt8 extends Struct({\n  value: Field,\n}) {\n  static NUM_BITS = 8;\n\n  /**\n   * Create a {@link UInt8} from a bigint or number.\n   * The max value of a {@link UInt8} is `2^8 - 1 = 255`.\n   *\n   * **Warning**: Cannot overflow past 255, an error is thrown if the result is greater than 255.\n   */\n  constructor(x: number | bigint | FieldVar | UInt8) {\n    if (x instanceof UInt8) x = x.value.value;\n    super({ value: Field(x) });\n    UInt8.checkConstant(this.value);\n  }\n\n  static Unsafe = {\n    /**\n     * Create a {@link UInt8} from a {@link Field} without constraining its range.\n     *\n     * **Warning**: This is unsafe, because it does not prove that the input {@link Field} actually fits in 8 bits.\\\n     * Only use this if you know what you are doing, otherwise use the safe {@link UInt8.from}.\n     */\n    fromField(x: Field) {\n      return new UInt8(x.value);\n    },\n  };\n\n  /**\n   * Static method to create a {@link UInt8} with value `0`.\n   */\n  static get zero() {\n    return new UInt8(0);\n  }\n  /**\n   * Static method to create a {@link UInt8} with value `1`.\n   */\n  static get one() {\n    return new UInt8(1);\n  }\n\n  /**\n   * Add a {@link UInt8} to another {@link UInt8} without allowing overflow.\n   *\n   * @example\n   * ```ts\n   * const x = UInt8.from(3);\n   * const sum = x.add(5);\n   * sum.assertEquals(8);\n   * ```\n   *\n   * @throws if the result is greater than 255.\n   */\n  add(y: UInt8 | bigint | number) {\n    let z = this.value.add(UInt8.from(y).value);\n    RangeCheck.rangeCheck8(z);\n    return UInt8.Unsafe.fromField(z);\n  }\n\n  /**\n   * Subtract a {@link UInt8} from another {@link UInt8} without allowing underflow.\n   *\n   * @example\n   * ```ts\n   * const x = UInt8.from(8);\n   * const difference = x.sub(5);\n   * difference.assertEquals(3);\n   * ```\n   *\n   * @throws if the result is less than 0.\n   */\n  sub(y: UInt8 | bigint | number) {\n    let z = this.value.sub(UInt8.from(y).value);\n    RangeCheck.rangeCheck8(z);\n    return UInt8.Unsafe.fromField(z);\n  }\n\n  /**\n   * Multiply a {@link UInt8} by another {@link UInt8} without allowing overflow.\n   *\n   * @example\n   * ```ts\n   * const x = UInt8.from(3);\n   * const product = x.mul(5);\n   * product.assertEquals(15);\n   * ```\n   *\n   * @throws if the result is greater than 255.\n   */\n  mul(y: UInt8 | bigint | number) {\n    let z = this.value.mul(UInt8.from(y).value);\n    RangeCheck.rangeCheck8(z);\n    return UInt8.Unsafe.fromField(z);\n  }\n\n  /**\n   * Divide a {@link UInt8} by another {@link UInt8}.\n   * This is integer division that rounds down.\n   *\n   * @example\n   * ```ts\n   * const x = UInt8.from(7);\n   * const quotient = x.div(2);\n   * quotient.assertEquals(3);\n   * ```\n   */\n  div(y: UInt8 | bigint | number) {\n    return this.divMod(y).quotient;\n  }\n\n  /**\n   * Get the remainder a {@link UInt8} of division of another {@link UInt8}.\n   *\n   * @example\n   * ```ts\n   * const x = UInt8.from(50);\n   * const mod = x.mod(30);\n   * mod.assertEquals(20);\n   * ```\n   */\n  mod(y: UInt8 | bigint | number) {\n    return this.divMod(y).remainder;\n  }\n\n  /**\n   * Get the quotient and remainder of a {@link UInt8} divided by another {@link UInt8}:\n   *\n   * `x == y * q + r`, where `0 <= r < y`.\n   *\n   * @param y - a {@link UInt8} to get the quotient and remainder of another {@link UInt8}.\n   *\n   * @return The quotient `q` and remainder `r`.\n   */\n  divMod(y: UInt8 | bigint | number) {\n    let x = this.value;\n    let y_ = UInt8.from(y).value.seal();\n\n    if (this.value.isConstant() && y_.isConstant()) {\n      let xn = x.toBigInt();\n      let yn = y_.toBigInt();\n      let q = xn / yn;\n      let r = xn - q * yn;\n      return { quotient: UInt8.from(q), remainder: UInt8.from(r) };\n    }\n\n    // prove that x === q * y + r, where 0 <= r < y\n    let q = Provable.witness(Field, () => Field(x.toBigInt() / y_.toBigInt()));\n    let r = x.sub(q.mul(y_)).seal();\n\n    // q, r being 16 bits is enough for them to be 8 bits,\n    // thanks to the === x check and the r < y check below\n    RangeCheck.rangeCheck16(q);\n    RangeCheck.rangeCheck16(r);\n\n    let remainder = UInt8.Unsafe.fromField(r);\n    let quotient = UInt8.Unsafe.fromField(q);\n\n    remainder.assertLessThan(y);\n    return { quotient, remainder };\n  }\n\n  /**\n   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).\n   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.\n   *\n   * This gadget builds a chain of XOR gates recursively.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)\n   *\n   * @param x {@link UInt8} element to XOR.\n   *\n   * @example\n   * ```ts\n   * let a = UInt8.from(0b0101);\n   * let b = UInt8.from(0b0011);\n   *\n   * let c = a.xor(b);\n   * c.assertEquals(0b0110);\n   * ```\n   */\n  xor(x: UInt8) {\n    return new UInt8(Bitwise.xor(this.value, x.value, UInt8.NUM_BITS).value);\n  }\n\n  /**\n   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise\n   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/\n   * Web/JavaScript/Reference/Operators/Bitwise_NOT).\n   *\n   * **Note:** The NOT gate operates over 8 bit for UInt8 types.\n   *\n   * A NOT gate works by returning `1` in each bit position if the\n   * corresponding bit of the operand is `0`, and returning `0` if the\n   * corresponding bit of the operand is `1`.\n   *\n   * NOT is implemented as a subtraction of the input from the all one bitmask\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)\n   *\n   * @example\n   * ```ts\n   * // NOTing 4 bits with the unchecked version\n   * let a = UInt8.from(0b0101);\n   * let b = a.not();\n   *\n   * console.log(b.toBigInt().toString(2));\n   * // 11111010\n   *\n   * ```\n   *\n   */\n  not() {\n    return new UInt8(Bitwise.not(this.value, UInt8.NUM_BITS, false).value);\n  }\n\n  /**\n   * Bitwise AND gadget on {@link UInt8} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).\n   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.\n   *\n   * It can be checked by a double generic gate that verifies the following relationship between the values below.\n   *\n   * The generic gate verifies:\\\n   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\\\n   * Where:\\\n   * `a + b = sum`\\\n   * `a ^ b = xor`\\\n   * `a & b = and`\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)\n   *\n   *\n   * @example\n   * ```typescript\n   * let a = UInt8.from(3);    // ... 000011\n   * let b = UInt8.from(5);    // ... 000101\n   *\n   * let c = a.and(b);    // ... 000001\n   * c.assertEquals(1);\n   * ```\n   */\n  and(x: UInt8) {\n    return new UInt8(Bitwise.and(this.value, x.value, UInt8.NUM_BITS).value);\n  }\n\n  /**\n   * Bitwise OR gadget on {@link UInt8} elements. Equivalent to the [bitwise OR `|` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR).\n   * The OR gate works by comparing two bits and returning `1` if at least one bit is `1`, and `0` otherwise.\n   *\n   * @example\n   * ```typescript\n   * let a = UInt8.from(3);    // ... 000011\n   * let b = UInt8.from(5);    // ... 000101\n   *\n   * let c = a.or(b);    // ... 000111\n   * c.assertEquals(7);\n   * ```\n   */\n  or(x: UInt8) {\n    return new UInt8(Bitwise.or(this.value, x.value, UInt8.NUM_BITS).value);\n  }\n\n  /**\n   * Check if this {@link UInt8} is less than or equal to another {@link UInt8} value.\n   * Returns a {@link Bool}.\n   *\n   * @example\n   * ```ts\n   * UInt8.from(3).lessThanOrEqual(UInt8.from(5));\n   * ```\n   */\n  lessThanOrEqual(y: UInt8 | bigint | number): Bool {\n    let y_ = UInt8.from(y);\n    if (this.value.isConstant() && y_.value.isConstant()) {\n      return Bool(this.toBigInt() <= y_.toBigInt());\n    }\n    return lessThanOrEqualGeneric(this.value, y_.value, 1n << 8n, RangeCheck.rangeCheck8);\n  }\n\n  /**\n   * Check if this {@link UInt8} is less than another {@link UInt8} value.\n   * Returns a {@link Bool}.\n   *\n   * @example\n   * ```ts\n   * UInt8.from(2).lessThan(UInt8.from(3));\n   * ```\n   */\n  lessThan(y: UInt8 | bigint | number): Bool {\n    let y_ = UInt8.from(y);\n    if (this.value.isConstant() && y_.value.isConstant()) {\n      return Bool(this.toBigInt() < y_.toBigInt());\n    }\n    return lessThanGeneric(this.value, y_.value, 1n << 8n, RangeCheck.rangeCheck8);\n  }\n\n  /**\n   * Assert that this {@link UInt8} is less than another {@link UInt8} value.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertLessThan(y: UInt8 | bigint | number, message?: string) {\n    let y_ = UInt8.from(y);\n    if (this.value.isConstant() && y_.value.isConstant()) {\n      let [x0, y0] = [this.value.toBigInt(), y_.value.toBigInt()];\n      return assert(x0 < y0, message ?? `UInt8.assertLessThan: expected ${x0} < ${y0}`);\n    }\n    try {\n      // 2^16 < p - 2^8, so we satisfy the assumption of `assertLessThanGeneric`\n      assertLessThanGeneric(this.value, y_.value, RangeCheck.rangeCheck16);\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Assert that this {@link UInt8} is less than or equal to another {@link UInt8} value.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertLessThanOrEqual(y: UInt8 | bigint | number, message?: string) {\n    let y_ = UInt8.from(y);\n    if (this.value.isConstant() && y_.value.isConstant()) {\n      let [x0, y0] = [this.value.toBigInt(), y_.value.toBigInt()];\n      return assert(x0 <= y0, message ?? `UInt8.assertLessThanOrEqual: expected ${x0} <= ${y0}`);\n    }\n    try {\n      // 2^16 < p - 2^8, so we satisfy the assumption of `assertLessThanOrEqualGeneric`\n      assertLessThanOrEqualGeneric(this.value, y_.value, RangeCheck.rangeCheck16);\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Check if this {@link UInt8} is greater than another {@link UInt8}.\n   * Returns a {@link Bool}.\n   *\n   * @example\n   * ```ts\n   * // 5 > 3\n   * UInt8.from(5).greaterThan(3);\n   * ```\n   */\n  greaterThan(y: UInt8 | bigint | number) {\n    return UInt8.from(y).lessThan(this);\n  }\n\n  /**\n   * Check if this {@link UInt8} is greater than or equal another {@link UInt8} value.\n   * Returns a {@link Bool}.\n   *\n   * @example\n   * ```ts\n   * // 3 >= 3\n   * UInt8.from(3).greaterThanOrEqual(3);\n   * ```\n   */\n  greaterThanOrEqual(y: UInt8 | bigint | number) {\n    return UInt8.from(y).lessThanOrEqual(this);\n  }\n\n  /**\n   * Assert that this {@link UInt8} is greater than another {@link UInt8} value.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertGreaterThan(y: UInt8 | bigint | number, message?: string) {\n    UInt8.from(y).assertLessThan(this, message);\n  }\n\n  /**\n   * Assert that this {@link UInt8} is greater than or equal to another {@link UInt8} value.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertGreaterThanOrEqual(y: UInt8, message?: string) {\n    UInt8.from(y).assertLessThanOrEqual(this, message);\n  }\n\n  /**\n   * Assert that this {@link UInt8} is equal another {@link UInt8} value.\n   *\n   * **Important**: If an assertion fails, the code throws an error.\n   *\n   * @param y - the {@link UInt8} value to compare & assert with this {@link UInt8}.\n   * @param message - a string error message to print if the assertion fails, optional.\n   */\n  assertEquals(y: UInt8 | bigint | number, message?: string) {\n    let y_ = UInt8.from(y);\n    this.value.assertEquals(y_.value, message);\n  }\n\n  /**\n   * Serialize the {@link UInt8} to a string, e.g. for printing.\n   *\n   * **Warning**: This operation is not provable.\n   */\n  toString() {\n    return this.value.toString();\n  }\n\n  /**\n   * Serialize the {@link UInt8} to a number.\n   *\n   * **Warning**: This operation is not provable.\n   */\n  toNumber() {\n    return Number(this.value.toBigInt());\n  }\n\n  /**\n   * Serialize the {@link UInt8} to a bigint.\n   *\n   * **Warning**: This operation is not provable.\n   */\n  toBigInt() {\n    return this.value.toBigInt();\n  }\n\n  /**\n   * {@link Provable.check} for {@link UInt8}.\n   * Proves that the input is in the [0, 255] range.\n   */\n  static check(x: { value: Field } | Field) {\n    if (x instanceof Field) x = { value: x };\n    RangeCheck.rangeCheck8(x.value);\n  }\n\n  static toInput(x: { value: Field }): HashInput {\n    return { packed: [[x.value, 8]] };\n  }\n\n  /**\n   * Turns a {@link UInt8} into a {@link UInt32}.\n   */\n  toUInt32(): UInt32 {\n    return new UInt32(this.value.value);\n  }\n\n  /**\n   * Turns a {@link UInt8} into a {@link UInt64}.\n   */\n  toUInt64(): UInt64 {\n    return new UInt64(this.value.value);\n  }\n\n  /**\n   * Creates a {@link UInt8} with a value of 255.\n   */\n  static MAXINT() {\n    return new UInt8((1n << BigInt(UInt8.NUM_BITS)) - 1n);\n  }\n\n  /**\n   * Creates a new {@link UInt8}.\n   */\n  static from(x: UInt8 | UInt64 | UInt32 | Field | number | bigint) {\n    if (x instanceof UInt8) return x;\n    if (x instanceof UInt64 || x instanceof UInt32 || x instanceof Field) {\n      // if the input could be larger than 8 bits, we have to prove that it is not\n      let xx = x instanceof Field ? { value: x } : x;\n      UInt8.check(xx);\n      return new UInt8(xx.value.value);\n    }\n    return new UInt8(x);\n  }\n\n  static fromValue(\n    // we need all the { value } inputs to correctly extend the Struct\n    x: number | UInt8 | { value: string | number | bigint | Field }\n  ) {\n    if (typeof x === 'number') return UInt8.from(x);\n    if (x instanceof UInt8) return x;\n    return UInt8.Unsafe.fromField(Field(x.value));\n  }\n\n  private static checkConstant(x: Field) {\n    if (!x.isConstant()) return;\n    RangeCheck.rangeCheck8(x);\n  }\n\n  isConstant() {\n    return this.value.isConstant();\n  }\n\n  /**\n   * Returns an array of {@link Bool} elements representing [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of this {@link UInt8} element.\n   *\n   * If you use the optional `length` argument, proves that the UInt8 element fits in `length` bits.\n   * The `length` has to be between 0 and 8 and the method throws if it isn't.\n   *\n   * **Warning**: The cost of this operation in a zk proof depends on the `length` you specify,\n   * which by default is 8 bits. Prefer to pass a smaller `length` if possible.\n   *\n   * @param length - the number of bits to fit the element. If the element does not fit in `length` bits, the functions throws an error.\n   *\n   * @return An array of {@link Bool} element representing little endian binary representation of this {@link UInt8}.\n   */\n  toBits(length: number = 8) {\n    checkBitLength('UInt8.toBits()', length, 8);\n    if (this.isConstant()) {\n      let bits = BinableFp.toBits(this.toBigInt());\n      if (bits.slice(length).some((bit) => bit))\n        throw Error(`UInt8.toBits(): ${this} does not fit in ${length} bits`);\n      return bits.slice(0, length).map((b) => new Bool(b));\n    }\n    return this.value.toBits(length);\n  }\n\n  /**\n   * Convert a bit array into a {@link UInt8} element using [little endian binary representation](https://en.wikipedia.org/wiki/Endianness)\n   *\n   * The method throws if the given bits do not fit in a single UInt8 element. In this case, no more than 8 bits are allowed.\n   *\n   * **Important**: If the given `bits` array is an array of `booleans` or {@link Bool} elements that all are `constant`,\n   *  the resulting {@link UInt8} element will be a constant as well. Or else, if the given array is a mixture of constants and variables of {@link Bool} type,\n   *  the resulting {@link UInt8} will be a variable as well.\n   *\n   * @param bits - An array of {@link Bool} or `boolean` type.\n   *\n   * @return A {@link UInt8} element matching the [little endian binary representation](https://en.wikipedia.org/wiki/Endianness) of the given `bits` array.\n   */\n  static fromBits(bits: (Bool | boolean)[]) {\n    const length = bits.length;\n    checkBitLength('UInt8.fromBits()', length, 8);\n    return UInt8.Unsafe.fromField(Field.fromBits(bits));\n  }\n}\n", "import { provableFromClass } from './types/provable-derivers.js';\nimport type { ProvablePureExtended } from './types/struct.js';\nimport { assert } from './gadgets/common.js';\nimport { chunk, chunkString } from '../util/arrays.js';\nimport { Provable } from './provable.js';\nimport { UInt8 } from './int.js';\nimport { randomBytes } from '../../bindings/crypto/random.js';\nimport { Field } from './field.js';\nimport { Bool } from './bool.js';\n\n// external API\nexport { Bytes, FlexibleBytes };\n\n// internal API\nexport { createBytes };\n\ntype FlexibleBytes = Bytes | (UInt8 | bigint | number)[] | Uint8Array;\n\n/**\n * A provable type representing an array of bytes.\n */\nclass Bytes {\n  bytes: UInt8[];\n\n  constructor(bytes: UInt8[]) {\n    let size = (this.constructor as typeof Bytes).size;\n\n    // assert that data is not too long\n    assert(bytes.length <= size, `Expected at most ${size} bytes, got ${bytes.length}`);\n\n    // pad the data with zeros\n    let padding = Array.from({ length: size - bytes.length }, () => new UInt8(0));\n    this.bytes = bytes.concat(padding);\n  }\n\n  /**\n   * Coerce the input to {@link Bytes}.\n   *\n   * Inputs smaller than `this.size` are padded with zero bytes.\n   */\n  static from(data: FlexibleBytes): Bytes {\n    if (data instanceof Bytes) return data;\n    if (this._size === undefined) {\n      let Bytes_ = createBytes(data.length);\n      return Bytes_.from(data);\n    }\n    return new this([...data].map(UInt8.from));\n  }\n\n  toBytes(): Uint8Array {\n    return Uint8Array.from(this.bytes.map((x) => x.toNumber()));\n  }\n\n  toFields() {\n    return this.bytes.map((x) => x.value);\n  }\n\n  /**\n   * Create {@link Bytes} from a string.\n   *\n   * Inputs smaller than `this.size` are padded with zero bytes.\n   */\n  static fromString(s: string) {\n    let bytes = new TextEncoder().encode(s);\n    return this.from(bytes);\n  }\n\n  /**\n   * Create random {@link Bytes} using secure builtin randomness.\n   */\n  static random() {\n    let bytes = randomBytes(this.size);\n    return this.from(bytes);\n  }\n\n  /**\n   * Create {@link Bytes} from a hex string.\n   *\n   * Inputs smaller than `this.size` are padded with zero bytes.\n   */\n  static fromHex(xs: string): Bytes {\n    let bytes = chunkString(xs, 2).map((s) => parseInt(s, 16));\n    return this.from(bytes);\n  }\n\n  /**\n   * Convert {@link Bytes} to a hex string.\n   */\n  toHex(): string {\n    return this.bytes.map((x) => x.toBigInt().toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Base64 encode bytes.\n   */\n  base64Encode(): Bytes {\n    const uint8Bytes = this.bytes;\n\n    // Convert each byte to its 8-bit binary representation and reverse endianness\n    let plainBits: Bool[] = uint8Bytes.map((b) => b.value.toBits(8).reverse()).flat();\n\n    // Calculate the bit padding required to make the total bits length a multiple of 6\n    const bitPadding = plainBits.length % 6 !== 0 ? 6 - (plainBits.length % 6) : 0;\n\n    // Add the required bit padding with 0 bits\n    plainBits.push(...Array(bitPadding).fill(new Bool(false)));\n\n    let encodedBytes: UInt8[] = [];\n\n    // Process the bits 6 at a time and encode to Base64\n    for (let i = 0; i < plainBits.length; i += 6) {\n      // Slice the next 6 bits and reverse endianness\n      let byteBits = plainBits.slice(i, i + 6).reverse();\n\n      // Convert the 6-bit chunk to a UInt8 value for indexing the Base64 table\n      const indexTableByte = UInt8.Unsafe.fromField(Field.fromBits(byteBits));\n\n      // Use the index to get the corresponding Base64 character and add to the result\n      encodedBytes.push(base64EncodeLookup(indexTableByte));\n    }\n\n    // Add '=' padding to the encoded output if required\n    const paddingLength = uint8Bytes.length % 3 !== 0 ? 3 - (uint8Bytes.length % 3) : 0;\n    encodedBytes.push(...Array(paddingLength).fill(UInt8.from(61)));\n\n    return Bytes.from(encodedBytes);\n  }\n\n  /**\n   * Decode Base64-encoded bytes.\n   *\n   * @param byteLength The length of the output decoded bytes.\n   * @returns Decoded bytes as {@link Bytes}.\n   *\n   * @warning\n   * Ensure the input Base64 string does not contain '=' characters in the middle,\n   * as it can cause unexpected decoding results.\n   */\n  base64Decode(byteLength: number): Bytes {\n    const encodedB64Bytes = this.bytes;\n\n    const charLength = encodedB64Bytes.length;\n    assert(charLength % 4 === 0, 'Input base64 byte length should be a multiple of 4!');\n\n    let decodedB64Bytes: UInt8[] = new Array(byteLength).fill(UInt8.from(0));\n\n    let bitsIn: Bool[][][] = Array.from({ length: charLength / 4 }, () => []);\n    let bitsOut: Bool[][][] = Array.from({ length: charLength / 4 }, () =>\n      Array.from({ length: 4 }, () => [])\n    );\n\n    let idx = 0;\n    for (let i = 0; i < charLength / 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        const translated = base64DecodeLookup(encodedB64Bytes[4 * i + j]);\n        bitsIn[i][j] = translated.toBits(6);\n      }\n\n      // Convert from four 6-bit words to three 8-bit words, unpacking the base64 encoding\n      bitsOut[i][0] = [bitsIn[i][1][4], bitsIn[i][1][5], ...bitsIn[i][0]];\n\n      for (let j = 0; j < 4; j++) {\n        bitsOut[i][1][j] = bitsIn[i][2][j + 2];\n        bitsOut[i][1][j + 4] = bitsIn[i][1][j];\n      }\n\n      bitsOut[i][2] = [...bitsIn[i][3], bitsIn[i][2][0], bitsIn[i][2][1]];\n\n      for (let j = 0; j < 3; j++) {\n        if (idx + j < byteLength) {\n          decodedB64Bytes[idx + j] = UInt8.Unsafe.fromField(Field.fromBits(bitsOut[i][j]));\n        }\n      }\n      idx += 3;\n    }\n\n    return Bytes.from(decodedB64Bytes);\n  }\n\n  /**\n   * Returns an array of chunks, each of size `size`.\n   * @param size size of each chunk\n   * @returns an array of {@link UInt8} chunks\n   */\n  chunk(size: number) {\n    return chunk(this.bytes, size);\n  }\n\n  // dynamic subclassing infra\n  static _size?: number;\n  static _provable?: ProvablePureExtended<\n    Bytes,\n    { bytes: { value: bigint }[] },\n    { bytes: { value: string }[] }\n  >;\n\n  /**\n   * The size of the {@link Bytes}.\n   */\n  static get size() {\n    assert(this._size !== undefined, 'Bytes not initialized');\n    return this._size;\n  }\n\n  get length() {\n    return this.bytes.length;\n  }\n\n  /**\n   * `Provable<Bytes>`\n   */\n  static get provable() {\n    assert(this._provable !== undefined, 'Bytes not initialized');\n    return this._provable;\n  }\n}\n\nfunction createBytes(size: number): typeof Bytes {\n  return class Bytes_ extends Bytes {\n    static _size = size;\n    static _provable = provableFromClass(Bytes_, {\n      bytes: Provable.Array(UInt8, size),\n    });\n  };\n}\n\n/**\n * Decodes a Base64 character to its original value.\n * Adapted from the algorithm described in: http://0x80.pl/notesen/2016-01-17-sse-base64-decoding.html#vector-lookup-base\n *\n * @param input - The Base64 encoded byte to be decoded.\n * @returns - The corresponding decoded value as a Field.\n */\nfunction base64DecodeLookup(input: UInt8): Field {\n  // Initialize a Field to validate if the input byte is a valid Base64 character\n  let isValidBase64Chars = new Field(0);\n\n  // ['A' - 'Z'] range\n  const le_Z = input.lessThan(91);\n  const ge_A = input.greaterThan(64);\n  const range_AZ = le_Z.and(ge_A);\n  const sum_AZ = range_AZ.toField().mul(input.value.sub(65));\n  isValidBase64Chars = isValidBase64Chars.add(range_AZ.toField());\n\n  // ['a' - 'z'] range\n  const le_z = input.lessThan(123);\n  const ge_a = input.greaterThan(96);\n  const range_az = le_z.and(ge_a);\n  const sum_az = range_az.toField().mul(input.value.sub(71)).add(sum_AZ);\n  isValidBase64Chars = isValidBase64Chars.add(range_az.toField());\n\n  // ['0' - '9'] range\n  const le_9 = input.lessThan(58);\n  const ge_0 = input.greaterThan(47);\n  const range_09 = le_9.and(ge_0);\n  const sum_09 = range_09.toField().mul(input.value.add(4)).add(sum_az);\n  isValidBase64Chars = isValidBase64Chars.add(range_09.toField());\n\n  // '+' character\n  const equal_plus = input.value.equals(43);\n  const sum_plus = equal_plus.toField().mul(input.value.add(19)).add(sum_09);\n  isValidBase64Chars = isValidBase64Chars.add(equal_plus.toField());\n\n  // '/' character\n  const equal_slash = input.value.equals(47);\n  const sum_slash = equal_slash.toField().mul(input.value.add(16)).add(sum_plus);\n  isValidBase64Chars = isValidBase64Chars.add(equal_slash.toField());\n\n  // '=' character\n  const equal_eqsign = input.value.equals(61);\n  isValidBase64Chars = isValidBase64Chars.add(equal_eqsign.toField());\n\n  // Validate if input contains only valid Base64 characters\n  isValidBase64Chars.assertEquals(\n    1,\n    'Please provide Base64-encoded bytes containing only alphanumeric characters and +/='\n  );\n\n  return sum_slash;\n}\n\n/**\n * Encodes a byte into its Base64 character representation.\n *\n * @param input - The byte to be encoded to Base64.\n * @returns - The corresponding Base64 encoded character as a UInt8.\n */\nfunction base64EncodeLookup(input: UInt8): UInt8 {\n  // Initialize a Field to validate if the input byte is included in the Base64 index table\n  let isValidBase64Chars = new Field(0);\n\n  // ['A', 'Z'] - Note: Remove greater than zero check because a UInt8 byte is always positive\n  const le_Z = input.lessThanOrEqual(25);\n  const range_AZ = le_Z;\n  const sum_AZ = range_AZ.toField().mul(input.value.add(65));\n  isValidBase64Chars = isValidBase64Chars.add(range_AZ.toField());\n\n  // ['a', 'z']\n  const le_z = input.lessThanOrEqual(51);\n  const ge_a = input.greaterThanOrEqual(26);\n  const range_az = le_z.and(ge_a);\n  const sum_az = range_az.toField().mul(input.value.add(71)).add(sum_AZ);\n  isValidBase64Chars = isValidBase64Chars.add(range_az.toField());\n\n  // ['0', '9']\n  const le_9 = input.lessThanOrEqual(61);\n  const ge_0 = input.greaterThanOrEqual(52);\n  const range_09 = le_9.and(ge_0);\n  const sum_09 = range_09.toField().mul(input.value.sub(4)).add(sum_az);\n  isValidBase64Chars = isValidBase64Chars.add(range_09.toField());\n\n  // '+'\n  const equal_plus = input.value.equals(62);\n  const sum_plus = equal_plus.toField().mul(input.value.sub(19)).add(sum_09);\n  isValidBase64Chars = isValidBase64Chars.add(equal_plus.toField());\n\n  // '/'\n  const equal_slash = input.value.equals(63);\n  const sum_slash = equal_slash.toField().mul(input.value.sub(16)).add(sum_plus);\n  isValidBase64Chars = isValidBase64Chars.add(equal_slash.toField());\n\n  // Validate if input contains only valid base64 characters\n  isValidBase64Chars.assertEquals(\n    1,\n    'Invalid character detected: The input contains a byte that is not present in the BASE64 index table!'\n  );\n\n  return UInt8.Unsafe.fromField(sum_slash);\n}\n", "import { Bytes as InternalBytes, createBytes, FlexibleBytes } from './bytes.js';\n\nexport { Bytes, FlexibleBytes };\n\ntype Bytes = InternalBytes;\n\n/**\n * A provable type representing an array of bytes.\n *\n * ```ts\n * class Bytes32 extends Bytes(32) {}\n *\n * let bytes = Bytes32.fromHex('deadbeef');\n * ```\n */\nfunction Bytes(size: number) {\n  return createBytes(size);\n}\nBytes.from = InternalBytes.from;\nBytes.fromHex = InternalBytes.fromHex;\nBytes.fromString = InternalBytes.fromString;\n\n// expose base class so that we can detect Bytes with `instanceof`\nBytes.Base = InternalBytes;\n", "import { mod } from '../../../bindings/crypto/finite-field.js';\nimport { Field } from '../wrapped.js';\nimport { UInt32, UInt64, UInt8 } from '../int.js';\nimport { exists } from '../core/exists.js';\nimport { FlexibleBytes } from '../bytes.js';\nimport { Bytes } from '../wrapped-classes.js';\nimport { chunk } from '../../util/arrays.js';\nimport { TupleN } from '../../util/types.js';\nimport { divMod32, divMod64 } from './arithmetic.js';\nimport { bitSlice } from './common.js';\nimport { rangeCheck16 } from './range-check.js';\n\nexport { SHA2 };\n\n// constants for SHA2-224 and SHA2-256 \u00A74.2.2\nconst K224_256 = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\n\n// constants for SHA2-384 and SHA2-512 \u00A74.2.3\n// prettier-ignore\nconst K384_512 = [\n    0x428a2f98d728ae22n, 0x7137449123ef65cdn, 0xb5c0fbcfec4d3b2fn, 0xe9b5dba58189dbbcn,\n    0x3956c25bf348b538n, 0x59f111f1b605d019n, 0x923f82a4af194f9bn, 0xab1c5ed5da6d8118n,\n    0xd807aa98a3030242n, 0x12835b0145706fben, 0x243185be4ee4b28cn, 0x550c7dc3d5ffb4e2n,\n    0x72be5d74f27b896fn, 0x80deb1fe3b1696b1n, 0x9bdc06a725c71235n, 0xc19bf174cf692694n,\n    0xe49b69c19ef14ad2n, 0xefbe4786384f25e3n, 0x0fc19dc68b8cd5b5n, 0x240ca1cc77ac9c65n,\n    0x2de92c6f592b0275n, 0x4a7484aa6ea6e483n, 0x5cb0a9dcbd41fbd4n, 0x76f988da831153b5n,\n    0x983e5152ee66dfabn, 0xa831c66d2db43210n, 0xb00327c898fb213fn, 0xbf597fc7beef0ee4n,\n    0xc6e00bf33da88fc2n, 0xd5a79147930aa725n, 0x06ca6351e003826fn, 0x142929670a0e6e70n,\n    0x27b70a8546d22ffcn, 0x2e1b21385c26c926n, 0x4d2c6dfc5ac42aedn, 0x53380d139d95b3dfn,\n    0x650a73548baf63den, 0x766a0abb3c77b2a8n, 0x81c2c92e47edaee6n, 0x92722c851482353bn,\n    0xa2bfe8a14cf10364n, 0xa81a664bbc423001n, 0xc24b8b70d0f89791n, 0xc76c51a30654be30n,\n    0xd192e819d6ef5218n, 0xd69906245565a910n, 0xf40e35855771202an, 0x106aa07032bbd1b8n,\n    0x19a4c116b8d2d0c8n, 0x1e376c085141ab53n, 0x2748774cdf8eeb99n, 0x34b0bcb5e19b48a8n,\n    0x391c0cb3c5c95a63n, 0x4ed8aa4ae3418acbn, 0x5b9cca4f7763e373n, 0x682e6ff3d6b2b8a3n,\n    0x748f82ee5defb2fcn, 0x78a5636f43172f60n, 0x84c87814a1f0ab72n, 0x8cc702081a6439ecn,\n    0x90befffa23631e28n, 0xa4506cebde82bde9n, 0xbef9a3f7b2c67915n, 0xc67178f2e372532bn,\n    0xca273eceea26619cn, 0xd186b8c721c0c207n, 0xeada7dd6cde0eb1en, 0xf57d4f7fee6ed178n,\n    0x06f067aa72176fban, 0x0a637dc5a2c898a6n, 0x113f9804bef90daen, 0x1b710b35131c471bn,\n    0x28db77f523047d84n, 0x32caab7b40c72493n, 0x3c9ebe0a15c9bebcn, 0x431d67c49c100d4cn,\n    0x4cc5d4becb3e42b6n, 0x597f299cfc657e2an, 0x5fcb6fab3ad6faecn, 0x6c44198c4a475817n,\n  ];\n\ntype Length = 224 | 256 | 384 | 512;\n\n// SHA2 CONSTANTS\nconst SHA2Constants = {\n  // Bit length of the blocks\n  BLOCK_LENGTH: {\n    // SHA2-224 and SHA2-256\n    224: 512n,\n    256: 512n,\n    // SHA2-384 and SHA2-512\n    384: 1024n,\n    512: 1024n,\n  },\n\n  // Value used in the padding equation\n  PADDING_VALUE: {\n    // SHA2-224 and SHA2-256\n    224: 448n,\n    256: 448n,\n    // SHA2-384 and SHA2-512\n    384: 896n,\n    512: 896n,\n  },\n\n  // Bits used to store the length in the padding\n  // It corresponds to BLOCK_LENGTH - PADDING_VALUE\n  LENGTH_CHUNK: {\n    // SHA2-224 and SHA2-256\n    224: 64,\n    256: 64,\n    // SHA2-384 and SHA2-512\n    384: 128,\n    512: 128,\n  },\n\n  // Number of words in message schedule and compression\n  NUM_WORDS: {\n    // SHA2-224 and SHA2-256\n    224: 64n,\n    256: 64n,\n    // SHA2-384 and SHA2-512\n    384: 80n,\n    512: 80n,\n  },\n\n  // Offsets for the DeltaZero function\n  DELTA_ZERO: {\n    // SHA2-224 and SHA2-256: \u00A74.1.2 eq.4.6\n    224: [3, 7, 18] as TupleN<number, 3>,\n    256: [3, 7, 18] as TupleN<number, 3>,\n    // SHA2-384 and SHA2-512: \u00A74.1.3 eq.4.12\n    384: [7, 8, 1] as TupleN<number, 3>,\n    512: [7, 8, 1] as TupleN<number, 3>,\n  },\n\n  // Offsets for the DeltaOne function\n  DELTA_ONE: {\n    // SHA2-224 and SHA2-256: \u00A74.1.2 eq.4.7\n    224: [10, 17, 19] as TupleN<number, 3>,\n    256: [10, 17, 19] as TupleN<number, 3>,\n    // - SHA2-384 and SHA2-512: \u00A74.1.3 eq.4.13\n    384: [6, 19, 61] as TupleN<number, 3>,\n    512: [6, 19, 61] as TupleN<number, 3>,\n  },\n\n  // Offsets for the SigmaZero function\n  SIGMA_ZERO: {\n    // SHA2-224 and SHA2-256: \u00A74.1.2 eq.4.4\n    224: [2, 13, 22] as TupleN<number, 3>,\n    256: [2, 13, 22] as TupleN<number, 3>,\n    // SHA2-384 and SHA2-512: \u00A74.1.3 eq.4.10\n    384: [28, 34, 39] as TupleN<number, 3>,\n    512: [28, 34, 39] as TupleN<number, 3>,\n  },\n\n  // Offsets for the SigmaOne function for SHA2.\n  SIGMA_ONE: {\n    // SHA2-224 and SHA2-256: \u00A74.1.2 eq.4.5\n    224: [6, 11, 25] as TupleN<number, 3>,\n    256: [6, 11, 25] as TupleN<number, 3>,\n    // SHA2-384 and SHA2-512: \u00A74.1.3 eq.4.11\n    384: [14, 18, 41] as TupleN<number, 3>,\n    512: [14, 18, 41] as TupleN<number, 3>,\n  },\n\n  // Initia hash values\n  H: {\n    // SHA2-224 \u00A75.3.2\n    224: [\n      0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7,\n      0xbefa4fa4,\n    ],\n    // SHA-256 \u00A75.3.3\n    256: [\n      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n      0x5be0cd19,\n    ],\n    // SHA2-384 \u00A75.3.4\n    384: [\n      0xcbbb9d5dc1059ed8n,\n      0x629a292a367cd507n,\n      0x9159015a3070dd17n,\n      0x152fecd8f70e5939n,\n      0x67332667ffc00b31n,\n      0x8eb44a8768581511n,\n      0xdb0c2e0d64f98fa7n,\n      0x47b5481dbefa4fa4n,\n    ],\n    // SHA2-512 \u00A75.3.5\n    512: [\n      0x6a09e667f3bcc908n,\n      0xbb67ae8584caa73bn,\n      0x3c6ef372fe94f82bn,\n      0xa54ff53a5f1d36f1n,\n      0x510e527fade682d1n,\n      0x9b05688c2b3e6c1fn,\n      0x1f83d9abfb41bd6bn,\n      0x5be0cd19137e2179n,\n    ],\n  },\n\n  K: {\n    224: K224_256,\n    256: K224_256,\n    384: K384_512,\n    512: K384_512,\n  },\n};\n\nconst SHA2 = {\n  /**\n   * Implementation of [NIST SHA-2](https://csrc.nist.gov/pubs/fips/180-4/upd1/final)\n   * hash Function. Supports output lengths of 224, 256, 384, or 512 bits.\n   *\n   * Applies the SHA-2 hash function to a list of big-endian byte-sized {@link Field}\n   * elements, flexible to handle varying output lengths (224, 256, 384, 512 bits) as specified.\n   *\n   * The function accepts {@link Bytes} as the input message, which is a type that\n   * represents a static-length list of byte-sized field elements (range-checked\n   * using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash\n   * outside provable code.\n   *\n   * Produces an output of {@link Bytes} that conforms to the chosen bit length.\n   * Both input and output bytes are big-endian.\n   *\n   * @param len - Desired output length in bits. Valid options: 224, 256, 384, 512.\n   * @param message - Big-endian {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest224 = SHA2.hash(224, preimage);\n   * let digest256 = SHA2.hash(256, preimage);\n   * let digest384 = SHA2.hash(384, preimage);\n   * let digest512 = SHA2.hash(512, preimage);\n   * ```\n   *\n   */\n  hash<T extends Length>(length: T, data: FlexibleBytes): Bytes {\n    // Infer the type T based on the value of `length` (conditional type)\n    type Type = T extends 224 | 256 ? UInt32 : UInt64;\n\n    // preprocessing \u00A76.2\n    // padding the message $5.1.1 into blocks that are a multiple of 512\n    let messageBlocks = padding<Type>(length, data);\n\n    let H = SHA2.initialState<Type>(length);\n\n    const N = messageBlocks.length;\n\n    for (let i = 0; i < N; i++) {\n      const W = messageSchedule(length, messageBlocks[i]);\n      H = compression(length, H, W);\n    }\n\n    // the working variables H[i] are 32 | 64 bit, however we want to decompose\n    // them into bytes to be more compatible\n    let digest = Bytes.from(H.map((x) => x.toBytesBE()).flat());\n\n    // Take the first `length` bits of the digest. This has no effect in\n    // SHA256 and SHA512, because 8 words of 32 | 64 bits needs no truncation.\n    // Truncation is required for SHA224 and SHA384 though.\n    digest.bytes = digest.bytes.slice(0, length / 8);\n\n    return digest;\n  },\n  compression,\n  messageSchedule,\n  padding,\n  initialState<T extends UInt32 | UInt64>(length: Length): T[] {\n    return SHA2Constants.H[length].map((x) =>\n      isUInt32(length) ? (UInt32.from(x) as T) : (UInt64.from(x) as T)\n    );\n  },\n};\n\n/**\n * Padding function for SHA2, as specified in \u00A75.1.1, \u00A75.1.2,\n *\n * @param data  The message to hash\n * @param length Whether this is a SHA2-224 or SHA2-256 or SHA2-384 or SHA2-512\n * @returns\n */\n// The only difference between the padding used in SHA2-224/256 and SHA2-384/512\n// is the size of the word (32bit vs 64bit). In the first case, UInt32[][] is\n// returned, in the second case UInt64[][] is returned.\nfunction padding<T extends UInt32 | UInt64>(length: Length, data: FlexibleBytes): T[][] {\n  // create a provable Bytes instance from the input data\n  // the Bytes class will be static sized according to the length of the input data\n  let message = Bytes.from(data);\n\n  const blockLength = SHA2Constants.BLOCK_LENGTH[length];\n  const paddingValue = SHA2Constants.PADDING_VALUE[length];\n  const lengthChunk = SHA2Constants.LENGTH_CHUNK[length];\n\n  // now pad the data to reach the format expected by SHA2\n  // pad 1 bit, followed by k zero bits where k is the smallest non-negative solution to\n  // l + 1 + k = (448 | 896) mod (512 | 1024)\n  // then append a (64 | 128)-bit block containing the length of the original message in bits\n  // it holds that PADDING_VALUE = BLOCK_LENGTH - LENGTH_CHUNK\n  // this way the padded message will be a multiple of the BLOCK_LENGTH\n\n  let l = message.length * 8; // length in bits\n  let k = Number(mod(paddingValue - (BigInt(l) + 1n), blockLength));\n\n  let lBinary = l.toString(2);\n\n  let paddingBits = (\n    '1' + // append 1 bit\n    '0'.repeat(k) + // append k zero bits\n    '0'.repeat(lengthChunk - lBinary.length) + // append 64|128-bit containing the length of the original message\n    lBinary\n  ).match(/.{1,8}/g)!; // this should always be divisible by 8\n\n  // map the padding bit string to UInt8 elements\n  let padding = paddingBits.map((x) => UInt8.from(BigInt('0b' + x)));\n\n  // concatenate the padding with the original padded data\n  let paddedMessage = message.bytes.concat(padding);\n\n  // Create chunks based on whether we are dealing with SHA2-224/256 or SHA2-384/512\n  // split the message into (32 | 64)-bit chunks\n  let chunks = isUInt32(length)\n    ? createChunks(paddedMessage, 4, UInt32.fromBytesBE)\n    : createChunks(paddedMessage, 8, UInt64.fromBytesBE);\n\n  // SHA2-224 and SHA2-256 | SHA2-384 and SHA2-512:\n  // split the message into 16 elements of 32 | 64 bits, what gives a block of 512 | 1024 bits\n  return chunk(chunks as T[], 16);\n}\n\n/**\n * Prepares the message schedule for the SHA2 compression function from the given message block.\n *\n * @param length Whether this is a SHA2-224 or SHA2-256 or SHA2-384 or SHA2-512\n * @param M - The 512-bit message block (16-element array of UInt32)\n *            or the 1024-bit message block (16-element array of UInt64).\n * @returns The message schedule (64-element array of UInt32 or 80-element array of UInt64).\n */\nfunction messageSchedule<T extends UInt32 | UInt64>(length: Length, M: T[]): T[] {\n  // \u00A76.2.2.1 and \u00A76.4.2.1\n\n  // Declare W as an empty array of type T[] (generic array)\n  const W: T[] = [];\n\n  // for each message block of 16 x 32bit | 64bit do:\n\n  let numWords = SHA2Constants.NUM_WORDS[length];\n\n  // prepare message block\n  for (let t = 0; t < 16; t++) W[t] = M[t];\n  for (let t = 16; t < numWords; t++) {\n    // the field element is unreduced and not proven to be 32bit | 64bit,\n    // we will do this later to save constraints\n    let unreduced = DeltaOne(length, W[t - 2])\n      .value.add(W[t - 7].value)\n      .add(DeltaZero(length, W[t - 15]).value.add(W[t - 16].value));\n\n    // mod 32 | 64 bit the unreduced field element\n    W[t] = reduceMod(length, unreduced);\n  }\n\n  return W;\n}\n\n/**\n * Performs the SHA-2 compression function on the given hash values and message schedule.\n *\n * @param length Whether this is a SHA2-224 or SHA2-256 or SHA2-384 or SHA2-512\n * @param H - The initial or intermediate hash values (8-element array of T).\n * @param W - The message schedule (64-element array of T).\n *\n * @returns The updated intermediate hash values after compression.\n */\nfunction compression<T extends UInt32 | UInt64>(length: Length, [...H]: T[], W: T[]) {\n  let numWords = SHA2Constants.NUM_WORDS[length];\n\n  let k = SHA2Constants.K[length];\n\n  // \u00A76.2.2.2 and \u00A76.4.2.2:\n  // initialize working variables\n  let a = H[0];\n  let b = H[1];\n  let c = H[2];\n  let d = H[3];\n  let e = H[4];\n  let f = H[5];\n  let g = H[6];\n  let h = H[7];\n\n  // \u00A76.2.2.3 and \u00A76.4.2.3:\n  // main loop\n  for (let t = 0; t < numWords; t++) {\n    // T1 is unreduced and not proven to be 32 | 64 bit,\n    // we will do this later to save constraints\n    const unreducedT1 = h.value\n      .add(SigmaOne(length, e).value)\n      .add(Ch(length, e, f, g).value)\n      .add(k[t])\n      .add(W[t].value)\n      .seal();\n\n    // T2 is also unreduced\n    const unreducedT2 = SigmaZero(length, a).value.add(Maj(length, a, b, c).value);\n\n    h = g;\n    g = f;\n    f = e;\n    e = reduceMod(length, d.value.add(unreducedT1));\n    // mod 32 | 64 bit the unreduced field element\n    d = c;\n    c = b;\n    b = a;\n    a = reduceMod(length, unreducedT2.add(unreducedT1));\n    // mod 32 | 64 bit\n  }\n\n  // \u00A76.2.2.4 and \u00A76.4.2.4\n  // new intermediate hash value\n  intermediateHash(length, [a, b, c, d, e, f, g, h], H);\n\n  return H;\n}\n\n// Helper functions\n\n// Helper function to check if the hash uses words of 32 or 64 bits\nfunction isUInt32(length: Length): length is 224 | 256 {\n  return length === 224 || length === 256;\n}\n\n// Shorthand to reduce a field element modulo 32 or 64 bits depending on T\nfunction reduceMod<T extends UInt32 | UInt64>(length: Length, x: Field): T {\n  return isUInt32(length)\n    ? (UInt32.Unsafe.fromField(divMod32(x, 32 + 16).remainder) as T)\n    : (UInt64.Unsafe.fromField(divMod64(x, 64 + 16).remainder) as T);\n}\n\n// Helper function to create chunks based on the size and type (UInt32 or UInt64)\nfunction createChunks<T extends UInt32 | UInt64>(\n  paddedMessage: UInt8[],\n  byteSize: number,\n  fromBytes: Function\n): T[] {\n  let chunks: any[] = [];\n  // bytesToWord expects little endian, so we reverse the bytes\n  for (let i = 0; i < paddedMessage.length; i += byteSize) {\n    // Chunk the data based on the specified byte size (4 bytes for UInt32, 8 bytes for UInt64)\n    chunks.push(fromBytes(paddedMessage.slice(i, i + byteSize)));\n  }\n  return chunks;\n}\n\nfunction intermediateHash<T extends UInt32 | UInt64>(length: Length, variables: T[], H: T[]) {\n  const addMod = isUInt32(length)\n    ? (x: UInt32, y: UInt32) => x.addMod32(y)\n    : (x: UInt64, y: UInt64) => x.addMod64(y);\n  for (let i = 0; i < 8; i++) {\n    H[i] = addMod(variables[i] as any, H[i] as any) as T;\n  }\n}\n\n// Subroutines for SHA2\n\nfunction Ch<T extends UInt32 | UInt64>(length: Length, x: T, y: T, z: T): T {\n  // ch(x, y, z) = (x & y) ^ (~x & z)\n  //             = (x & y) + (~x & z) (since x & ~x = 0)\n  if (isUInt32(length)) {\n    let xAndY = (x as UInt32).and(y as UInt32).value;\n    let xNotAndZ = (x as UInt32).not().and(z as UInt32).value;\n    let ch = xAndY.add(xNotAndZ).seal();\n    return UInt32.Unsafe.fromField(ch) as T;\n  } else {\n    let xAndY = (x as UInt64).and(y as UInt64).value;\n    let xNotAndZ = (x as UInt64).not().and(z as UInt64).value;\n    let ch = xAndY.add(xNotAndZ).seal();\n    return UInt64.Unsafe.fromField(ch) as T;\n  }\n}\n\nfunction Maj<T extends UInt32 | UInt64>(length: Length, x: T, y: T, z: T): T {\n  // maj(x, y, z) = (x & y) ^ (x & z) ^ (y & z)\n  //              = (x + y + z - (x ^ y ^ z)) / 2\n  if (isUInt32(length)) {\n    let sum = (x as UInt32).value.add(y.value).add(z.value).seal();\n    let xor = (x as UInt32).xor(y as UInt32).xor(z as UInt32).value;\n    let maj = sum.sub(xor).div(2).seal();\n    return UInt32.Unsafe.fromField(maj) as T;\n  } else {\n    let sum = (x as UInt64).value.add(y.value).add(z.value).seal();\n    let xor = (x as UInt64).xor(y as UInt64).xor(z as UInt64).value;\n    let maj = sum.sub(xor).div(2).seal();\n    return UInt64.Unsafe.fromField(maj) as T;\n  }\n}\n\nfunction SigmaZero<T extends UInt32 | UInt64>(length: Length, x: T): T {\n  return sigma(length, x, SHA2Constants.SIGMA_ZERO[length]);\n}\n\nfunction SigmaOne<T extends UInt32 | UInt64>(length: Length, x: T): T {\n  return sigma(length, x, SHA2Constants.SIGMA_ONE[length]);\n}\n\n// lowercase sigma = delta to avoid confusing function names\n\nfunction DeltaZero<T extends UInt32 | UInt64>(length: Length, x: T): T {\n  return sigma(length, x, SHA2Constants.DELTA_ZERO[length], true) as T;\n}\n\nfunction DeltaOne<T extends UInt32 | UInt64>(length: Length, x: T): T {\n  return sigma(length, x, SHA2Constants.DELTA_ONE[length], true) as T;\n}\n\nfunction ROTR<T extends UInt32 | UInt64>(n: number, x: T): T {\n  return x.rotate(n, 'right') as T;\n}\n\nfunction SHR<T extends UInt32 | UInt64>(n: number, x: T): T {\n  return x.rightShift(n) as T;\n}\n\nfunction sigmaSimple<T extends UInt32 | UInt64>(\n  length: Length,\n  u: T,\n  bits: TupleN<number, 3>,\n  firstShifted = false\n): T {\n  let [r0, r1, r2] = bits;\n  if (isUInt32(length)) {\n    let rot0 = firstShifted ? (SHR(r0, u) as UInt32) : (ROTR(r0, u) as UInt32);\n    let rot1 = ROTR(r1, u) as UInt32;\n    let rot2 = ROTR(r2, u) as UInt32;\n    return rot0.xor(rot1).xor(rot2) as T;\n  } else {\n    let rot0 = firstShifted ? (SHR(r0, u) as UInt64) : (ROTR(r0, u) as UInt64);\n    let rot1 = ROTR(r1, u) as UInt64;\n    let rot2 = ROTR(r2, u) as UInt64;\n    return rot0.xor(rot1).xor(rot2) as T;\n  }\n}\n\nfunction sigma<T extends UInt32 | UInt64>(\n  length: Length,\n  u: T,\n  bits: TupleN<number, 3>,\n  firstShifted = false\n): T {\n  if (u.isConstant() || !isUInt32(length)) return sigmaSimple(length, u, bits, firstShifted);\n\n  // When T is UInt64, 64-bit rotation is natively supported in the gadgets.\n  // However, 32-bit rotation is not natively supported, thus the following:\n\n  let [r0, r1, r2] = bits; // TODO assert bits are sorted\n  let x = u.value;\n\n  let d0 = r0;\n  let d1 = r1 - r0;\n  let d2 = r2 - r1;\n  let d3 = 32 - r2;\n\n  // decompose x into 4 chunks of size d0, d1, d2, d3\n  let [x0, x1, x2, x3] = exists(4, () => {\n    let xx = x.toBigInt();\n    return [bitSlice(xx, 0, d0), bitSlice(xx, r0, d1), bitSlice(xx, r1, d2), bitSlice(xx, r2, d3)];\n  });\n\n  // range check each chunk\n  // we only need to range check to 16 bits relying on the requirement that\n  // the rotated values are range-checked to 32 bits later; see comments below\n  rangeCheck16(x0);\n  rangeCheck16(x1);\n  rangeCheck16(x2);\n  rangeCheck16(x3);\n\n  // prove x decomposition\n\n  // x === x0 + x1*2^d0 + x2*2^(d0+d1) + x3*2^(d0+d1+d2)\n  let x23 = x2.add(x3.mul(1 << d2)).seal();\n  let x123 = x1.add(x23.mul(1 << d1)).seal();\n  x0.add(x123.mul(1 << d0)).assertEquals(x);\n  // ^ proves that 2^(32-d3)*x3 < x < 2^32 => x3 < 2^d3\n\n  // reassemble chunks into rotated values\n\n  let xRotR0: Field;\n\n  if (!firstShifted) {\n    // rotr(x, r0) = x1 + x2*2^d1 + x3*2^(d1+d2) + x0*2^(d1+d2+d3)\n    xRotR0 = x123.add(x0.mul(1 << (d1 + d2 + d3))).seal();\n    // ^ proves that 2^(32-d0)*x0 < xRotR0 => x0 < 2^d0 if we check xRotR0 < 2^32 later\n  } else {\n    // shr(x, r0) = x1 + x2*2^d1 + x3*2^(d1+d2)\n    xRotR0 = x123;\n\n    // finish x0 < 2^d0 proof:\n    rangeCheck16(x0.mul(1 << (16 - d0)).seal());\n  }\n\n  // rotr(x, r1) = x2 + x3*2^d2 + x0*2^(d2+d3) + x1*2^(d2+d3+d0)\n  let x01 = x0.add(x1.mul(1 << d0)).seal();\n  let xRotR1 = x23.add(x01.mul(1 << (d2 + d3))).seal();\n  // ^ proves that 2^(32-d1)*x1 < xRotR1 => x1 < 2^d1 if we check xRotR1 < 2^32 later\n\n  // rotr(x, r2) = x3 + x0*2^d3 + x1*2^(d3+d0) + x2*2^(d3+d0+d1)\n  let x012 = x01.add(x2.mul(1 << (d0 + d1))).seal();\n  let xRotR2 = x3.add(x012.mul(1 << d3)).seal();\n  // ^ proves that 2^(32-d2)*x2 < xRotR2 => x2 < 2^d2 if we check xRotR2 < 2^32 later\n\n  // since xor() is implicitly range-checking both of its inputs, this provides the missing\n  // proof that xRotR0, xRotR1, xRotR2 < 2^32, which implies x0 < 2^d0, x1 < 2^d1, x2 < 2^d2\n  return UInt32.Unsafe.fromField(xRotR0)\n    .xor(UInt32.Unsafe.fromField(xRotR1))\n    .xor(UInt32.Unsafe.fromField(xRotR2)) as T;\n}\n", "/** SHA2\n *\n * This module provides a SHA2 provable gadget, including SHA256.\n *\n * https://csrc.nist.gov/pubs/fips/180-4/upd1/final\n */\nimport { mod } from '../../../bindings/crypto/finite-field.js';\nimport { Field } from '../wrapped.js';\nimport { UInt32, UInt8 } from '../int.js';\nimport { exists } from '../core/exists.js';\nimport { FlexibleBytes } from '../bytes.js';\nimport { Bytes } from '../wrapped-classes.js';\nimport { chunk } from '../../util/arrays.js';\nimport { TupleN } from '../../util/types.js';\nimport { divMod32 } from './arithmetic.js';\nimport { bitSlice } from './common.js';\nimport { rangeCheck16 } from './range-check.js';\n\nexport { SHA256 };\n\nconst SHA256Constants = {\n  // constants \u00A74.2.2\n  K: [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n  ],\n  // initial hash values \u00A75.3.3\n  H: [\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n  ],\n};\n\nfunction padding(data: FlexibleBytes): UInt32[][] {\n  // create a provable Bytes instance from the input data\n  // the Bytes class will be static sized according to the length of the input data\n  let message = Bytes.from(data);\n\n  // now pad the data to reach the format expected by sha256\n  // pad 1 bit, followed by k zero bits where k is the smallest non-negative solution to\n  // l + 1 + k = 448 mod 512\n  // then append a 64bit block containing the length of the original message in bits\n\n  let l = message.length * 8; // length in bits\n  let k = Number(mod(448n - (BigInt(l) + 1n), 512n));\n\n  let lBinary = l.toString(2);\n\n  let paddingBits = (\n    '1' + // append 1 bit\n    '0'.repeat(k) + // append k zero bits\n    '0'.repeat(64 - lBinary.length) + // append 64bit containing the length of the original message\n    lBinary\n  ).match(/.{1,8}/g)!; // this should always be divisible by 8\n\n  // map the padding bit string to UInt8 elements\n  let padding = paddingBits.map((x) => UInt8.from(BigInt('0b' + x)));\n\n  // concatenate the padding with the original padded data\n  let paddedMessage = message.bytes.concat(padding);\n\n  // split the message into 32bit chunks\n  let chunks: UInt32[] = [];\n\n  for (let i = 0; i < paddedMessage.length; i += 4) {\n    // chunk 4 bytes into one UInt32, as expected by SHA256\n    // bytesToWord expects little endian, so we reverse the bytes\n    chunks.push(UInt32.fromBytesBE(paddedMessage.slice(i, i + 4)));\n  }\n\n  // split message into 16 element sized message blocks\n  // SHA256 expects n-blocks of 512bit each, 16*32bit = 512bit\n  return chunk(chunks, 16);\n}\n/**\n * @deprecated {@link SHA256} is deprecated in favor of {@link SHA2}, which supports more variants of the hash function.\n */\nconst SHA256 = {\n  hash(data: FlexibleBytes) {\n    // preprocessing \u00A76.2\n    // padding the message $5.1.1 into blocks that are a multiple of 512\n    let messageBlocks = padding(data);\n\n    let H = SHA256.initialState;\n    const N = messageBlocks.length;\n\n    for (let i = 0; i < N; i++) {\n      const W = createMessageSchedule(messageBlocks[i]);\n      H = sha256Compression(H, W);\n    }\n\n    // the working variables H[i] are 32bit, however we want to decompose them into bytes to be more compatible\n    return Bytes.from(H.map((x) => x.toBytesBE()).flat());\n  },\n  compression: sha256Compression,\n  createMessageSchedule,\n  padding,\n  get initialState() {\n    return SHA256Constants.H.map((x) => UInt32.from(x));\n  },\n};\n\nfunction Ch(x: UInt32, y: UInt32, z: UInt32) {\n  // ch(x, y, z) = (x & y) ^ (~x & z)\n  //             = (x & y) + (~x & z) (since x & ~x = 0)\n  let xAndY = x.and(y).value;\n  let xNotAndZ = x.not().and(z).value;\n  let ch = xAndY.add(xNotAndZ).seal();\n  return UInt32.Unsafe.fromField(ch);\n}\n\nfunction Maj(x: UInt32, y: UInt32, z: UInt32) {\n  // maj(x, y, z) = (x & y) ^ (x & z) ^ (y & z)\n  //              = (x + y + z - (x ^ y ^ z)) / 2\n  let sum = x.value.add(y.value).add(z.value).seal();\n  let xor = x.xor(y).xor(z).value;\n  let maj = sum.sub(xor).div(2).seal();\n  return UInt32.Unsafe.fromField(maj);\n}\n\nfunction SigmaZero(x: UInt32) {\n  return sigma(x, [2, 13, 22]);\n}\n\nfunction SigmaOne(x: UInt32) {\n  return sigma(x, [6, 11, 25]);\n}\n\n// lowercase sigma = delta to avoid confusing function names\n\nfunction DeltaZero(x: UInt32) {\n  return sigma(x, [3, 7, 18], true);\n}\n\nfunction DeltaOne(x: UInt32) {\n  return sigma(x, [10, 17, 19], true);\n}\n\nfunction ROTR(n: number, x: UInt32) {\n  return x.rotate(n, 'right');\n}\n\nfunction SHR(n: number, x: UInt32) {\n  let val = x.rightShift(n);\n  return val;\n}\n\nfunction sigmaSimple(u: UInt32, bits: TupleN<number, 3>, firstShifted = false) {\n  let [r0, r1, r2] = bits;\n  let rot0 = firstShifted ? SHR(r0, u) : ROTR(r0, u);\n  let rot1 = ROTR(r1, u);\n  let rot2 = ROTR(r2, u);\n  return rot0.xor(rot1).xor(rot2);\n}\n\nfunction sigma(u: UInt32, bits: TupleN<number, 3>, firstShifted = false) {\n  if (u.isConstant()) return sigmaSimple(u, bits, firstShifted);\n\n  let [r0, r1, r2] = bits; // TODO assert bits are sorted\n  let x = u.value;\n\n  let d0 = r0;\n  let d1 = r1 - r0;\n  let d2 = r2 - r1;\n  let d3 = 32 - r2;\n\n  // decompose x into 4 chunks of size d0, d1, d2, d3\n  let [x0, x1, x2, x3] = exists(4, () => {\n    let xx = x.toBigInt();\n    return [bitSlice(xx, 0, d0), bitSlice(xx, r0, d1), bitSlice(xx, r1, d2), bitSlice(xx, r2, d3)];\n  });\n\n  // range check each chunk\n  // we only need to range check to 16 bits relying on the requirement that\n  // the rotated values are range-checked to 32 bits later; see comments below\n  rangeCheck16(x0);\n  rangeCheck16(x1);\n  rangeCheck16(x2);\n  rangeCheck16(x3);\n\n  // prove x decomposition\n\n  // x === x0 + x1*2^d0 + x2*2^(d0+d1) + x3*2^(d0+d1+d2)\n  let x23 = x2.add(x3.mul(1 << d2)).seal();\n  let x123 = x1.add(x23.mul(1 << d1)).seal();\n  x0.add(x123.mul(1 << d0)).assertEquals(x);\n  // ^ proves that 2^(32-d3)*x3 < x < 2^32 => x3 < 2^d3\n\n  // reassemble chunks into rotated values\n\n  let xRotR0: Field;\n\n  if (!firstShifted) {\n    // rotr(x, r0) = x1 + x2*2^d1 + x3*2^(d1+d2) + x0*2^(d1+d2+d3)\n    xRotR0 = x123.add(x0.mul(1 << (d1 + d2 + d3))).seal();\n    // ^ proves that 2^(32-d0)*x0 < xRotR0 => x0 < 2^d0 if we check xRotR0 < 2^32 later\n  } else {\n    // shr(x, r0) = x1 + x2*2^d1 + x3*2^(d1+d2)\n    xRotR0 = x123;\n\n    // finish x0 < 2^d0 proof:\n    rangeCheck16(x0.mul(1 << (16 - d0)).seal());\n  }\n\n  // rotr(x, r1) = x2 + x3*2^d2 + x0*2^(d2+d3) + x1*2^(d2+d3+d0)\n  let x01 = x0.add(x1.mul(1 << d0)).seal();\n  let xRotR1 = x23.add(x01.mul(1 << (d2 + d3))).seal();\n  // ^ proves that 2^(32-d1)*x1 < xRotR1 => x1 < 2^d1 if we check xRotR1 < 2^32 later\n\n  // rotr(x, r2) = x3 + x0*2^d3 + x1*2^(d3+d0) + x2*2^(d3+d0+d1)\n  let x012 = x01.add(x2.mul(1 << (d0 + d1))).seal();\n  let xRotR2 = x3.add(x012.mul(1 << d3)).seal();\n  // ^ proves that 2^(32-d2)*x2 < xRotR2 => x2 < 2^d2 if we check xRotR2 < 2^32 later\n\n  // since xor() is implicitly range-checking both of its inputs, this provides the missing\n  // proof that xRotR0, xRotR1, xRotR2 < 2^32, which implies x0 < 2^d0, x1 < 2^d1, x2 < 2^d2\n  return UInt32.Unsafe.fromField(xRotR0)\n    .xor(UInt32.Unsafe.fromField(xRotR1))\n    .xor(UInt32.Unsafe.fromField(xRotR2));\n}\n\n/**\n * Performs the SHA-256 compression function on the given hash values and message schedule.\n *\n * @param H - The initial or intermediate hash values (8-element array of UInt32).\n * @param W - The message schedule (64-element array of UInt32).\n *\n * @returns The updated intermediate hash values after compression.\n */\nfunction sha256Compression([...H]: UInt32[], W: UInt32[]) {\n  // initialize working variables\n  let a = H[0];\n  let b = H[1];\n  let c = H[2];\n  let d = H[3];\n  let e = H[4];\n  let f = H[5];\n  let g = H[6];\n  let h = H[7];\n\n  // main loop\n  for (let t = 0; t <= 63; t++) {\n    // T1 is unreduced and not proven to be 32bit, we will do this later to save constraints\n    const unreducedT1 = h.value\n      .add(SigmaOne(e).value)\n      .add(Ch(e, f, g).value)\n      .add(SHA256Constants.K[t])\n      .add(W[t].value)\n      .seal();\n\n    // T2 is also unreduced\n    const unreducedT2 = SigmaZero(a).value.add(Maj(a, b, c).value);\n\n    h = g;\n    g = f;\n    f = e;\n    e = UInt32.Unsafe.fromField(divMod32(d.value.add(unreducedT1), 48).remainder); // mod 32bit the unreduced field element\n    d = c;\n    c = b;\n    b = a;\n    a = UInt32.Unsafe.fromField(divMod32(unreducedT2.add(unreducedT1), 48).remainder); // mod 32bit\n  }\n\n  // new intermediate hash value\n  H[0] = H[0].addMod32(a);\n  H[1] = H[1].addMod32(b);\n  H[2] = H[2].addMod32(c);\n  H[3] = H[3].addMod32(d);\n  H[4] = H[4].addMod32(e);\n  H[5] = H[5].addMod32(f);\n  H[6] = H[6].addMod32(g);\n  H[7] = H[7].addMod32(h);\n\n  return H;\n}\n\n/**\n * Prepares the message schedule for the SHA-256 compression function from the given message block.\n *\n * @param M - The 512-bit message block (16-element array of UInt32).\n * @returns The message schedule (64-element array of UInt32).\n */\nfunction createMessageSchedule(M: UInt32[]) {\n  // for each message block of 16 x 32bit do:\n  const W: UInt32[] = [];\n\n  // prepare message block\n  for (let t = 0; t <= 15; t++) W[t] = M[t];\n  for (let t = 16; t <= 63; t++) {\n    // the field element is unreduced and not proven to be 32bit, we will do this later to save constraints\n    let unreduced = DeltaOne(W[t - 2])\n      .value.add(W[t - 7].value)\n      .add(DeltaZero(W[t - 15]).value.add(W[t - 16].value));\n\n    // mod 32bit the unreduced field element\n    W[t] = UInt32.Unsafe.fromField(divMod32(unreduced, 48).remainder);\n  }\n\n  return W;\n}\n", "// https://datatracker.ietf.org/doc/html/rfc7693.html\nimport { UInt64, UInt8 } from '../int.js';\nimport { FlexibleBytes } from '../bytes.js';\nimport { Bytes } from '../wrapped-classes.js';\nimport { Gadgets } from './gadgets.js';\nimport { assert } from '../../util/errors.js';\nimport { wordToBytes } from './bit-slices.js';\n\nexport { BLAKE2B };\n\n/**\n * IV[0..7]  Initialization Vector (constant).\n * SIGMA[0..9]  Message word permutations (constant).\n * p[0..7]  Parameter block (defines hash and key sizes).\n * m[0..15]  Sixteen words of a single message block.\n * h[0..7]  Internal state of the hash.\n * d[0..dd-1]  Padded input blocks.  Each has \"bb\" bytes.\n * t  Message byte offset at the end of the current block.\n * f  Flag indicating the last block.\n *\n * All mathematical operations are on 64-bit words in BLAKE2b.\n *\n * Byte (octet) streams are interpreted as words in little-endian order,\n * with the least-significant byte first.\n */\n\ntype State = {\n  h: UInt64[];\n  t: [bigint, bigint];\n  buf: UInt8[];\n  buflen: number;\n  outlen: number;\n};\n\nconst BLAKE2BConstants = {\n  IV: [\n    UInt64.from(0x6a09e667f3bcc908n),\n    UInt64.from(0xbb67ae8584caa73bn),\n    UInt64.from(0x3c6ef372fe94f82bn),\n    UInt64.from(0xa54ff53a5f1d36f1n),\n    UInt64.from(0x510e527fade682d1n),\n    UInt64.from(0x9b05688c2b3e6c1fn),\n    UInt64.from(0x1f83d9abfb41bd6bn),\n    UInt64.from(0x5be0cd19137e2179n),\n  ],\n\n  SIGMA: [\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],\n    [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],\n    [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],\n    [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],\n    [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],\n  ],\n};\n\nconst BLAKE2B = {\n  hash(data: FlexibleBytes, digestLength = 64) {\n    assert(\n      digestLength >= 1 && digestLength <= 64,\n      `digestLength must be in the range [1, 64], got ${digestLength}`\n    );\n    assert(\n      data.length >= 0 && data.length < 2 ** 128,\n      `data byte length must be in the range [0, 2**128), got ${data.length}`\n    );\n    const state = initialize(digestLength);\n    const updatedState = update(state, Bytes.from(data).bytes);\n    const out = final(updatedState);\n    return Bytes.from(out);\n  },\n  get IV() {\n    return BLAKE2BConstants.IV;\n  },\n};\n\nfunction G(v: UInt64[], a: number, b: number, c: number, d: number, x: UInt64, y: UInt64) {\n  v[a] = UInt64.Unsafe.fromField(\n    Gadgets.divMod64(v[a].value.add(v[b].value.add(x.value)), 128).remainder\n  );\n  v[d] = v[d].xor(v[a]).rotate(32, 'right');\n\n  v[c] = UInt64.Unsafe.fromField(Gadgets.divMod64(v[c].value.add(v[d].value), 128).remainder);\n  v[b] = v[b].xor(v[c]).rotate(24, 'right');\n\n  v[a] = UInt64.Unsafe.fromField(\n    Gadgets.divMod64(v[a].value.add(v[b].value.add(y.value)), 128).remainder\n  );\n  v[d] = v[d].xor(v[a]).rotate(16, 'right');\n\n  v[c] = UInt64.Unsafe.fromField(Gadgets.divMod64(v[c].value.add(v[d].value), 128).remainder);\n  v[b] = v[b].xor(v[c]).rotate(63, 'right');\n}\n\n/**\n * Compression function. \"last\" flag indicates last block.\n * @param {State} state\n * @param {boolean} last\n */\nfunction compress(state: State, last: boolean): State {\n  const { h, t, buf } = state;\n  const v = h.concat(BLAKE2B.IV); // initialize local work vector. First half from state and second half from IV.\n\n  v[12] = v[12].xor(UInt64.from(t[0])); // low word of the offset\n  v[13] = v[13].xor(UInt64.from(t[1])); // high word of the offset\n\n  if (last) {\n    // last block flag set ?\n    v[14] = v[14].not();\n  }\n\n  const m: UInt64[] = [];\n  for (let i = 0; i < 16; i++) {\n    // get little-endian words\n    m.push(\n      UInt64.Unsafe.fromField(\n        buf[i * 8].value\n          .add(buf[i * 8 + 1].value.mul(1n << 8n))\n          .add(buf[i * 8 + 2].value.mul(1n << 16n))\n          .add(buf[i * 8 + 3].value.mul(1n << 24n))\n          .add(buf[i * 8 + 4].value.mul(1n << 32n))\n          .add(buf[i * 8 + 5].value.mul(1n << 40n))\n          .add(buf[i * 8 + 6].value.mul(1n << 48n))\n          .add(buf[i * 8 + 7].value.mul(1n << 56n))\n          .seal()\n      )\n    );\n  }\n\n  for (let i = 0; i < 12; i++) {\n    // twelve rounds\n    const s = BLAKE2BConstants.SIGMA[i % 10];\n    G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);\n    G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);\n    G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);\n    G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);\n\n    G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);\n    G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);\n    G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);\n    G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);\n  }\n\n  for (let i = 0; i < 8; i++) {\n    // XOR the two halves\n    h[i] = v[i].xor(v[i + 8]).xor(h[i]);\n  }\n  return state;\n}\n\n/**\n * Initializes the state with the given digest length.\n *\n * @param {number} outlen - Digest length in bits\n * @returns {State}\n */\nfunction initialize(outlen: number): State {\n  const h = BLAKE2B.IV.slice(); // shallow copy IV to h\n  h[0] = UInt64.from(0x01010000).xor(UInt64.from(outlen)).xor(h[0]); // state \"param block\"\n\n  return {\n    h,\n    t: [0n, 0n],\n    buf: [],\n    buflen: 0,\n    outlen,\n  };\n}\n\n/**\n * Updates hash state\n * @param {State} state\n * @param {UInt8[]} input\n * @returns {State} updated state\n */\nfunction update(state: State, input: UInt8[]): State {\n  for (let i = 0; i < input.length; i++) {\n    if (state.buflen === 128) {\n      // buffer full ?\n      state.t[0] = UInt64.from(state.t[0]).addMod64(UInt64.from(state.buflen)).toBigInt(); // add counters\n      if (state.t[0] < state.buflen) {\n        // carry overflow ?\n        state.t[1] = UInt64.from(state.t[1]).addMod64(UInt64.one).toBigInt(); // high word\n      }\n      state = compress(state, false); // compress (not last)\n      state.buflen = 0; // counter to zero\n    }\n    state.buf[state.buflen++] = input[i];\n  }\n  return state;\n}\n\n/**\n * Finalizes the hash state and returns digest\n * @param {State} state\n * @returns {UInt8[]} digest\n */\nfunction final(state: State): UInt8[] {\n  state.t[0] = UInt64.from(state.t[0]).addMod64(UInt64.from(state.buflen)).toBigInt(); // add counters\n  if (state.t[0] < state.buflen) {\n    // carry overflow ?\n    state.t[1] = UInt64.from(state.t[1]).addMod64(UInt64.one).toBigInt(); // high word\n  }\n\n  while (state.buflen < 128) {\n    state.buf[state.buflen++] = UInt8.from(0); // fill up with zeroes\n  }\n  compress(state, true);\n\n  // little endian convert and store\n  const out: UInt8[] = state.h.slice(0, state.outlen / 8).flatMap((x) => wordToBytes(x.value));\n  return out;\n}\n", "import { Field } from '../field.js';\nimport { Gates } from '../gates.js';\n\nexport { rangeCheck3x12, inTable };\n\nfunction rangeCheck3x12(v0: Field, v1: Field, v2: Field) {\n  // Checks that all three input values exist in the RANGE_CHECK_TABLE (tableId: 1)\n  // v0, v1, v2 are used as the table keys\n  // The table \"values\" (inputs no 3, 5, 7) are 0 because the table only has one column\n  Gates.lookup(\n    // table id\n    Field.from(1),\n    v0,\n    Field.from(0),\n    v1,\n    Field.from(0),\n    v2,\n    Field.from(0)\n  );\n}\n\n/**\n * In-circuit check that up to 3 pairs of index and value are in the runtime\n * table given by the identifier. Each given pair is a tuple composed of a\n * bigint and a Field.\n *\n * **Note**: The runtime table must be configured before calling this function.\n *\n * **Note**: Table id 0 and 1 are reserved values, do not use them.\n *\n * @param id\n * @param pair0\n * @param pair1\n * @param pair2\n * \n * @deprecated {@link inTable} is deprecated in favor of {@link RuntimeTable} class, \n * which provides a more ergonomic API.\n */\nfunction inTable(\n  id: number,\n  pair0: [bigint, Field],\n  pair1?: [bigint, Field] | undefined,\n  pair2?: [bigint, Field] | undefined\n) {\n  let [idx0, v0] = pair0;\n  let [idx1, v1] = pair1 === undefined ? pair0 : pair1;\n  let [idx2, v2] = pair2 === undefined ? pair0 : pair2;\n\n  Gates.lookup(Field.from(id), Field.from(idx0), v0, Field.from(idx1), v1, Field.from(idx2), v2);\n}\n", "/**\n * Wrapper file for various gadgets, with a namespace and doccomments.\n */\nimport {\n  compactMultiRangeCheck,\n  multiRangeCheck,\n  rangeCheck8,\n  rangeCheck16,\n  rangeCheck32,\n  rangeCheck64,\n  rangeCheckN,\n  isDefinitelyInRangeN,\n  l2Mask,\n  lMask,\n  l2,\n  l,\n  l3,\n} from './range-check.js';\nimport {\n  not,\n  rotate32,\n  rotate64,\n  xor,\n  and,\n  or,\n  leftShift64,\n  rightShift64,\n  leftShift32,\n} from './bitwise.js';\nimport { Field } from '../wrapped.js';\nimport { ForeignField, Field3, Sum as ForeignFieldSum } from './foreign-field.js';\nimport { divMod32, addMod32, divMod64, addMod64 } from './arithmetic.js';\nimport { SHA2 } from './sha2.js';\nimport { SHA256 } from './sha256.js';\nimport { BLAKE2B } from './blake2b.js';\nimport { rangeCheck3x12, inTable } from './lookup.js';\nimport { arrayGet, arrayGetGeneric } from './basic.js';\nimport { sliceField3 } from './bit-slices.js';\n\nexport { Gadgets, Field3, ForeignFieldSum };\n\nconst Gadgets = {\n  /**\n   * Get value from array at a Field element index, in O(n) constraints, where n is the array length.\n   *\n   * **Warning**: This gadget assumes that the index is within the array bounds `[0, n)`,\n   * and returns an unconstrained result otherwise.\n   * To use it with an index that is not already guaranteed to be within the array bounds, you should add a suitable range check.\n   *\n   * ```ts\n   * let array = Provable.witnessFields(3, () => [1n, 2n, 3n]);\n   * let index = Provable.witness(Field, () => 1n);\n   *\n   * let value = Gadgets.arrayGet(array, index);\n   * ```\n   *\n   * **Note**: This saves n constraints compared to `Provable.switch(array.map((_, i) => index.equals(i)), type, array)`.\n   */\n  arrayGet,\n  /**\n   * Get value from array in O(n) constraints.\n   *\n   * Assumes that index is in [0, n), returns an unconstrained result otherwise.\n   */\n  arrayGetGeneric,\n\n  /**\n   * Asserts that the input value is in the range [0, 2^64).\n   *\n   * This function proves that the provided field element can be represented with 64 bits.\n   * If the field element exceeds 64 bits, an error is thrown.\n   *\n   * @param x - The value to be range-checked.\n   *\n   * @throws Throws an error if the input value exceeds 64 bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(12345678n));\n   * Gadgets.rangeCheck64(x); // successfully proves 64-bit range\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * Gadgets.rangeCheck64(xLarge); // throws an error since input exceeds 64 bits\n   * ```\n   *\n   * **Note**: Small \"negative\" field element inputs are interpreted as large integers close to the field size,\n   * and don't pass the 64-bit check. If you want to prove that a value lies in the int64 range [-2^63, 2^63),\n   * you could use `rangeCheck64(x.add(1n << 63n))`.\n   *\n   * _Advanced usage_: This returns the 4 highest limbs of x, in reverse order, i.e. [x52, x40, x28, x16].\n   * This is useful if you want to do a range check for 52, 40, 28, or 16 bits instead of 64,\n   * by constraining some of the returned limbs to be 0.\n   */\n  rangeCheck64(x: Field) {\n    return rangeCheck64(x);\n  },\n\n  /**\n   * Asserts that the input value is in the range [0, 2^32).\n   *\n   * This function proves that the provided field element can be represented with 32 bits.\n   * If the field element exceeds 32 bits, an error is thrown.\n   *\n   * @param x - The value to be range-checked.\n   *\n   * @throws Throws an error if the input value exceeds 32 bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(12345678n));\n   * Gadgets.rangeCheck32(x); // successfully proves 32-bit range\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * Gadgets.rangeCheck32(xLarge); // throws an error since input exceeds 32 bits\n   * ```\n   *\n   * **Note**: Small \"negative\" field element inputs are interpreted as large integers close to the field size,\n   * and don't pass the 32-bit check. If you want to prove that a value lies in the int32 range [-2^31, 2^31),\n   * you could use `rangeCheck32(x.add(1n << 31n))`.\n   */\n  rangeCheck32(x: Field) {\n    return rangeCheck32(x);\n  },\n\n  /**\n   * Asserts that the input value is in the range [0, 2^n). `n` must be a multiple of 16.\n   *\n   * This function proves that the provided field element can be represented with `n` bits.\n   * If the field element exceeds `n` bits, an error is thrown.\n   *\n   * @param x - The value to be range-checked.\n   * @param n - The number of bits to be considered for the range check.\n   * @param message - Optional message to be displayed when the range check fails.\n   *\n   * @throws Throws an error if the input value exceeds `n` bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(12345678n));\n   * Gadgets.rangeCheckN(32, x); // successfully proves 32-bit range\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * Gadgets.rangeCheckN(32, xLarge); // throws an error since input exceeds 32 bits\n   * ```\n   */\n  rangeCheckN(n: number, x: Field, message?: string) {\n    return rangeCheckN(n, x, message);\n  },\n\n  /**\n   * Returns a boolean which being true proves that x is in the range [0, 2^n).\n   *\n   * **Beware**: The output being false does **not** prove that x is not in the range [0, 2^n).\n   * This should not be viewed as a standalone provable method but as an advanced helper function\n   * for gadgets which need a weakened form of range check.\n   *\n   * @param x - The value to be weakly range-checked.\n   * @param n - The number of bits to be considered for the range check.\n   *\n   * @returns a Bool that is definitely only true if the input is in the range [0, 2^n),\n   * but could also be false _even if_ the input is in the range [0, 2^n).\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(12345678n));\n   * let definitelyInRange = Gadgets.isDefinitelyInRangeN(32, x); // could be true or false\n   * ```\n   */\n  isDefinitelyInRangeN(n: number, x: Field) {\n    return isDefinitelyInRangeN(n, x);\n  },\n  /*\n   * Asserts that the input value is in the range [0, 2^16).\n   *\n   * See {@link Gadgets.rangeCheck64} for analogous details and usage examples.\n   */\n  rangeCheck16(x: Field) {\n    return rangeCheck16(x);\n  },\n\n  /**\n   * Asserts that the input value is in the range [0, 2^8).\n   *\n   * See {@link Gadgets.rangeCheck64} for analogous details and usage examples.\n   */\n  rangeCheck8(x: Field) {\n    return rangeCheck8(x);\n  },\n\n  /**\n   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,\n   * with the distinction that the bits are circulated to the opposite end of a 64-bit representation rather than being discarded.\n   * For a left rotation, this means that bits shifted off the left end reappear at the right end.\n   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.\n   *\n   * **Important:** The gadget assumes that its input is at most 64 bits in size.\n   *\n   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the rotation.\n   * To safely use `rotate64()`, you need to make sure that the value passed in is range-checked to 64 bits;\n   * for example, using {@link Gadgets.rangeCheck64}.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation)\n   *\n   * @param field {@link Field} element to rotate.\n   * @param bits amount of bits to rotate this {@link Field} element with.\n   * @param direction left or right rotation direction.\n   *\n   * @throws Throws an error if the input value exceeds 64 bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(0b001100));\n   * const y = Gadgets.rotate64(x, 2, 'left'); // left rotation by 2 bits\n   * const z = Gadgets.rotate64(x, 2, 'right'); // right rotation by 2 bits\n   * y.assertEquals(0b110000);\n   * z.assertEquals(0b000011);\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * Gadgets.rotate64(xLarge, 32, \"left\"); // throws an error since input exceeds 64 bits\n   * ```\n   */\n  rotate64(field: Field, bits: number, direction: 'left' | 'right' = 'left') {\n    return rotate64(field, bits, direction);\n  },\n  /**\n   * A (left and right) rotation operates similarly to the shift operation (`<<` for left and `>>` for right) in JavaScript,\n   * with the distinction that the bits are circulated to the opposite end of a 32-bit representation rather than being discarded.\n   * For a left rotation, this means that bits shifted off the left end reappear at the right end.\n   * Conversely, for a right rotation, bits shifted off the right end reappear at the left end.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 32-bit representation of the number,\n   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.\n   * The `direction` parameter is a string that accepts either `'left'` or `'right'`, determining the direction of the rotation.\n   *\n   * **Important:** The gadget assumes that its input is at most 32 bits in size.\n   *\n   * If the input exceeds 32 bits, the gadget is invalid and fails to prove correct execution of the rotation.\n   * To safely use `rotate32()`, you need to make sure that the value passed in is range-checked to 32 bits;\n   * for example, using {@link Gadgets.rangeCheck32}.\n   *\n   *\n   * @param field {@link Field} element to rotate.\n   * @param bits amount of bits to rotate this {@link Field} element with.\n   * @param direction left or right rotation direction.\n   *\n   * @throws Throws an error if the input value exceeds 32 bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(0b001100));\n   * const y = Gadgets.rotate32(x, 2, 'left'); // left rotation by 2 bits\n   * const z = Gadgets.rotate32(x, 2, 'right'); // right rotation by 2 bits\n   * y.assertEquals(0b110000);\n   * z.assertEquals(0b000011);\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * Gadgets.rotate32(xLarge, 32, \"left\"); // throws an error since input exceeds 32 bits\n   * ```\n   */\n  rotate32(field: Field, bits: number, direction: 'left' | 'right' = 'left') {\n    return rotate32(field, bits, direction);\n  },\n  /**\n   * Bitwise XOR gadget on {@link Field} elements. Equivalent to the [bitwise XOR `^` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR).\n   * A XOR gate works by comparing two bits and returning `1` if two bits differ, and `0` if two bits are equal.\n   *\n   * This gadget builds a chain of XOR gates recursively. Each XOR gate can verify 16 bit at most. If your input elements exceed 16 bit, another XOR gate will be added to the chain.\n   *\n   * The `length` parameter lets you define how many bits should be compared. `length` is rounded to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.\n   *\n   * **Note:** Specifying a larger `length` parameter adds additional constraints.\n   *\n   * It is also important to mention that specifying a smaller `length` allows the verifier to infer the length of the original input data (e.g. smaller than 16 bit if only one XOR gate has been used).\n   * A zkApp developer should consider these implications when choosing the `length` parameter and carefully weigh the trade-off between increased amount of constraints and security.\n   *\n   * **Important:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.\n   *\n   * For example, with `length = 2` (`paddedLength = 16`), `xor()` will fail for any input that is larger than `2**16`.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1)\n   *\n   * @param a {@link Field} element to compare.\n   * @param b {@link Field} element to compare.\n   * @param length amount of bits to compare.\n   *\n   * @throws Throws an error if the input values exceed `2^paddedLength - 1`.\n   *\n   * @example\n   * ```ts\n   * let a = Field(0b0101);\n   * let b = Field(0b0011);\n   *\n   * let c = Gadgets.xor(a, b, 4); // xor-ing 4 bits\n   * c.assertEquals(0b0110);\n   * ```\n   */\n  xor(a: Field, b: Field, length: number) {\n    return xor(a, b, length);\n  },\n\n  /**\n   * Bitwise NOT gate on {@link Field} elements. Similar to the [bitwise\n   * NOT `~` operator in JavaScript](https://developer.mozilla.org/en-US/docs/\n   * Web/JavaScript/Reference/Operators/Bitwise_NOT).\n   *\n   * **Note:** The NOT gate only operates over the amount\n   * of bits specified by the `length` parameter.\n   *\n   * A NOT gate works by returning `1` in each bit position if the\n   * corresponding bit of the operand is `0`, and returning `0` if the\n   * corresponding bit of the operand is `1`.\n   *\n   * The `length` parameter lets you define how many bits to NOT.\n   *\n   * **Note:** Specifying a larger `length` parameter adds additional constraints. The operation will fail if the length or the input value is larger than 254.\n   *\n   * NOT is implemented in two different ways. If the `checked` parameter is set to `true`\n   * the {@link Gadgets.xor} gadget is reused with a second argument to be an\n   * all one bitmask the same length. This approach needs as many rows as an XOR would need\n   * for a single negation. If the `checked` parameter is set to `false`, NOT is\n   * implemented as a subtraction of the input from the all one bitmask. This\n   * implementation is returned by default if no `checked` parameter is provided.\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not)\n   *\n   * @example\n   * ```ts\n   * // not-ing 4 bits with the unchecked version\n   * let a = Field(0b0101);\n   * let b = Gadgets.not(a,4,false);\n   *\n   * b.assertEquals(0b1010);\n   *\n   * // not-ing 4 bits with the checked version utilizing the xor gadget\n   * let a = Field(0b0101);\n   * let b = Gadgets.not(a,4,true);\n   *\n   * b.assertEquals(0b1010);\n   * ```\n   *\n   * @param a - The value to apply NOT to. The operation will fail if the value is larger than 254.\n   * @param length - The number of bits to be considered for the NOT operation.\n   * @param checked - Optional boolean to determine if the checked or unchecked not implementation is used. If it\n   * is set to `true` the {@link Gadgets.xor} gadget is reused. If it is set to `false`, NOT is implemented\n   *  as a subtraction of the input from the all one bitmask. It is set to `false` by default if no parameter is provided.\n   *\n   * @throws Throws an error if the input value exceeds 254 bits.\n   */\n  not(a: Field, length: number, checked: boolean = false) {\n    return not(a, length, checked);\n  },\n\n  /**\n   * Performs a left shift operation on the provided {@link Field} element.\n   * This operation is similar to the `<<` shift operation in JavaScript,\n   * where bits are shifted to the left, and the overflowing bits are discarded.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * **Important:** The gadgets assumes that its input is at most 64 bits in size.\n   *\n   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the shift.\n   * Therefore, to safely use `leftShift()`, you need to make sure that the values passed in are range checked to 64 bits.\n   * For example, this can be done with {@link Gadgets.rangeCheck64}.\n   *\n   * @param field {@link Field} element to shift.\n   * @param bits Amount of bits to shift the {@link Field} element to the left. The amount should be between 0 and 64 (or else the shift will fail).\n   *\n   * @throws Throws an error if the input value exceeds 64 bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary\n   * const y = Gadgets.leftShift64(x, 2); // left shift by 2 bits\n   * y.assertEquals(0b110000); // 48 in binary\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * leftShift64(xLarge, 32); // throws an error since input exceeds 64 bits\n   * ```\n   */\n  leftShift64(field: Field, bits: number) {\n    return leftShift64(field, bits);\n  },\n\n  /**\n   * Performs a left shift operation on the provided {@link Field} element.\n   * This operation is similar to the `<<` shift operation in JavaScript,\n   * where bits are shifted to the left, and the overflowing bits are discarded.\n   *\n   * It\u2019s important to note that these operations are performed considering the big-endian 32-bit representation of the number,\n   * where the most significant (32th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * **Important:** The gadgets assumes that its input is at most 32 bits in size.\n   *\n   * The output is range checked to 32 bits.\n   *\n   * @param field {@link Field} element to shift.\n   * @param bits Amount of bits to shift the {@link Field} element to the left. The amount should be between 0 and 32 (or else the shift will fail).\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary\n   * const y = Gadgets.leftShift32(x, 2); // left shift by 2 bits\n   * y.assertEquals(0b110000); // 48 in binary\n   * ```\n   */\n  leftShift32(field: Field, bits: number) {\n    return leftShift32(field, bits);\n  },\n  /**\n   * Performs a right shift operation on the provided {@link Field} element.\n   * This is similar to the `>>` shift operation in JavaScript, where bits are moved to the right.\n   * The `rightShift64` function utilizes the rotation method internally to implement this operation.\n   *\n   * * It\u2019s important to note that these operations are performed considering the big-endian 64-bit representation of the number,\n   * where the most significant (64th) bit is on the left end and the least significant bit is on the right end.\n   *\n   * **Important:** The gadgets assumes that its input is at most 64 bits in size.\n   *\n   * If the input exceeds 64 bits, the gadget is invalid and fails to prove correct execution of the shift.\n   * To safely use `rightShift64()`, you need to make sure that the value passed in is range-checked to 64 bits;\n   * for example, using {@link Gadgets.rangeCheck64}.\n   *\n   * @param field {@link Field} element to shift.\n   * @param bits Amount of bits to shift the {@link Field} element to the right. The amount should be between 0 and 64 (or else the shift will fail).\n   *\n   * @throws Throws an error if the input value exceeds 64 bits.\n   *\n   * @example\n   * ```ts\n   * const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary\n   * const y = Gadgets.rightShift64(x, 2); // right shift by 2 bits\n   * y.assertEquals(0b000011); // 3 in binary\n   *\n   * const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));\n   * rightShift64(xLarge, 32); // throws an error since input exceeds 64 bits\n   * ```\n   */\n  rightShift64(field: Field, bits: number) {\n    return rightShift64(field, bits);\n  },\n  /**\n   * Bitwise AND gadget on {@link Field} elements. Equivalent to the [bitwise AND `&` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).\n   * The AND gate works by comparing two bits and returning `1` if both bits are `1`, and `0` otherwise.\n   *\n   * It can be checked by a double generic gate that verifies the following relationship between the values\n   * below (in the process it also invokes the {@link Gadgets.xor} gadget which will create additional constraints depending on `length`).\n   *\n   * The generic gate verifies:\\\n   * `a + b = sum` and the conjunction equation `2 * and = sum - xor`\\\n   * Where:\\\n   * `a + b = sum`\\\n   * `a ^ b = xor`\\\n   * `a & b = and`\n   *\n   * You can find more details about the implementation in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and)\n   *\n   * The `length` parameter lets you define how many bits should be compared. `length` is rounded\n   * to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values\n   * are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.\n   *\n   * **Note:** Specifying a larger `length` parameter adds additional constraints.\n   *\n   * **Note:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.\n   * For example, with `length = 2` (`paddedLength = 16`), `and()` will fail for any input that is larger than `2**16`.\n   *\n   * @example\n   * ```typescript\n   * let a = Field(3);    // ... 000011\n   * let b = Field(5);    // ... 000101\n   *\n   * let c = Gadgets.and(a, b, 2);    // ... 000001\n   * c.assertEquals(1);\n   * ```\n   */\n  and(a: Field, b: Field, length: number) {\n    return and(a, b, length);\n  },\n  /**\n   * Bitwise OR gadget on {@link Field} elements. Equivalent to the [bitwise OR `|` operator in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR).\n   * The OR gate works by comparing two bits and returning `1` if at least one bit is `1`, and `0` otherwise.\n   *\n   * The `length` parameter lets you define how many bits should be compared. `length` is rounded\n   * to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`, and both input values\n   * are constrained to fit into `paddedLength` bits. The output is guaranteed to have at most `paddedLength` bits as well.\n   *\n   * **Note:** Specifying a larger `length` parameter adds additional constraints.\n   *\n   * **Note:** Both {@link Field} elements need to fit into `2^paddedLength - 1`. Otherwise, an error is thrown and no proof can be generated.\n   * For example, with `length = 2` (`paddedLength = 16`), `and()` will fail for any input that is larger than `2**16`.\n   *\n   * @example\n   * ```typescript\n   * let a = Field.from(3);    // ... 000011\n   * let b = Field.from(5);    // ... 000101\n   *\n   * let c = Gadgets.or(a, b, 16);    // ... 000111\n   * c.assertEquals(7);\n   * ```\n   */\n  or(a: Field, b: Field, length: number) {\n    return or(a, b, length);\n  },\n\n  /**\n   * Multi-range check.\n   *\n   * Proves that x, y, z are all in the range [0, 2^88).\n   *\n   * This takes 4 rows, so it checks 88*3/4 = 66 bits per row. This is slightly more efficient\n   * than 64-bit range checks, which can do 64 bits in 1 row.\n   *\n   * In particular, the 3x88-bit range check supports bigints up to 264 bits, which in turn is enough\n   * to support foreign field multiplication with moduli up to 2^259.\n   *\n   * @example\n   * ```ts\n   * Gadgets.multiRangeCheck([x, y, z]);\n   * ```\n   *\n   * @throws Throws an error if one of the input values exceeds 88 bits.\n   */\n  multiRangeCheck(limbs: Field3) {\n    multiRangeCheck(limbs);\n  },\n\n  /**\n   * Compact multi-range check\n   *\n   * This is a variant of {@link multiRangeCheck} where the first two variables are passed in\n   * combined form xy = x + 2^88*y.\n   *\n   * The gadget\n   * - splits up xy into x and y\n   * - proves that xy = x + 2^88*y\n   * - proves that x, y, z are all in the range [0, 2^88).\n   *\n   * The split form [x, y, z] is returned.\n   *\n   * @example\n   * ```ts\n   * let [x, y] = Gadgets.compactMultiRangeCheck([xy, z]);\n   * ```\n   *\n   * @throws Throws an error if `xy` exceeds 2*88 = 176 bits, or if z exceeds 88 bits.\n   */\n  compactMultiRangeCheck(xy: Field, z: Field) {\n    return compactMultiRangeCheck(xy, z);\n  },\n\n  /**\n   * Checks that three {@link Field} elements are in the range [0, 2^12) (using only one row).\n   *\n   * Internally, this gadget relies on the 12-bit [range check table](https://github.com/o1-labs/proof-systems/blob/master/kimchi/src/circuits/lookup/tables/mod.rs).\n   * All three inputs are checked to be included in that table.\n   *\n   * It's possible to use this as a range check for bit lengths n < 12, by passing in _two values_.\n   * - the value to be checked, `x`, to prove that x in [0, 2^12)\n   * - x scaled by 2^(12 - n), to prove that either x in [0, 2^n) or `x * 2^(12 - n)` overflows the field size (which is excluded by the first check)\n   *\n   * Note that both of these checks are necessary to prove x in [0, 2^n).\n   *\n   * You can find more details about lookups in the [Mina book](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=lookup%20gate#lookup)\n   *\n   * @param v0 - The first {@link Field} element to be checked.\n   * @param v1 - The second {@link Field} element to be checked.\n   * @param v2 - The third {@link Field} element to be checked.\n   *\n   * @throws Throws an error if one of the input values exceeds 2^12.\n   *\n   * @example\n   * ```typescript\n   * let a = Field(4000);\n   * rangeCheck3x12(a, Field(0), Field(0)); // works, since `a` is less than 12 bits\n   *\n   * let aScaled = a.mul(1 << 4); // scale `a`, to assert that it's less than 8 bits\n   * rangeCheck3x12(a, aScaled, Field(0)); // throws an error, since  `a` is greater than 8 bits (and so `aScaled` is greater than 12 bits)\n   * ```\n   */\n  rangeCheck3x12(v0: Field, v1: Field, v2: Field) {\n    return rangeCheck3x12(v0, v1, v2);\n  },\n\n  /**\n   * In-circuit check that up to 3 pairs of index and value are in the runtime\n   * table given by the identifier. Each given pair is a tuple composed of a\n   * bigint and a Field.\n   *\n   * Internally, it creates a lookup gate for the three pairs. If fewer pairs are\n   * given, the remaining pairs are duplicates of the first one.\n   *\n   * @param id\n   * @param pair0\n   * @param pair1\n   * @param pair2\n   *\n   * @deprecated {@link inTable} is deprecated in favor of RuntimeTable class, \n   * which provides a more ergonomic API.\n   */\n  inTable(\n    id: number,\n    pair0: [bigint, Field],\n    pair1?: [bigint, Field] | undefined,\n    pair2?: [bigint, Field] | undefined\n  ) {\n    return inTable(id, pair0, pair1, pair2);\n  },\n\n  /**\n   * Gadgets for foreign field operations.\n   *\n   * A _foreign field_ is a finite field different from the native field of the proof system.\n   *\n   * The `ForeignField` namespace exposes operations like modular addition and multiplication,\n   * which work for any finite field of size less than 2^259.\n   *\n   * Foreign field elements are represented as 3 limbs of native field elements.\n   * Each limb holds 88 bits of the total, in little-endian order.\n   *\n   * All `ForeignField` gadgets expect that their input limbs are constrained to the range [0, 2^88).\n   * Range checks on outputs are added by the gadget itself.\n   */\n  ForeignField: {\n    /**\n     * Foreign field addition: `x + y mod f`\n     *\n     * The modulus `f` does not need to be prime.\n     *\n     * Inputs and outputs are 3-tuples of native Fields.\n     * Each input limb is assumed to be in the range [0, 2^88), and the gadget is invalid if this is not the case.\n     * The result limbs are guaranteed to be in the same range.\n     *\n     * @example\n     * ```ts\n     * let x = Provable.witness(Field3, () => 9n);\n     * let y = Provable.witness(Field3, () => 10n);\n     *\n     * // range check x and y\n     * Gadgets.multiRangeCheck(x);\n     * Gadgets.multiRangeCheck(y);\n     *\n     * // compute x + y mod 17\n     * let z = ForeignField.add(x, y, 17n);\n     *\n     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = 9 + 10 mod 17\n     * ```\n     *\n     * **Warning**: The gadget does not assume that inputs are reduced modulo f,\n     * and does not prove that the result is reduced modulo f.\n     * It only guarantees that the result is in the correct residue class.\n     *\n     * @param x left summand\n     * @param y right summand\n     * @param f modulus\n     * @returns x + y mod f\n     */\n    add(x: Field3, y: Field3, f: bigint) {\n      return ForeignField.add(x, y, f);\n    },\n\n    /**\n     * Check whether `x = c mod f`\n     *\n     * `c` is a constant, and we require `c` in `[0, f)`\n     *\n     * Assumes that `x` is almost reduced modulo `f`, so we know that `x` might be `c` or `c + f`, but not `c + 2f`, `c + 3f`, ...\n     */\n    equals(x: Field3, c: bigint, f: bigint) {\n      return ForeignField.equals(x, c, f);\n    },\n\n    /**\n     * Foreign field subtraction: `x - y mod f`\n     *\n     * See {@link Gadgets.ForeignField.add} for assumptions and usage examples.\n     *\n     * @throws fails if `x - y < -f`, where the result cannot be brought back to a positive number by adding `f` once.\n     */\n    sub(x: Field3, y: Field3, f: bigint) {\n      return ForeignField.sub(x, y, f);\n    },\n\n    /**\n     * Foreign field negation: `-x mod f = f - x`\n     *\n     * See {@link ForeignField.add} for assumptions and usage examples.\n     *\n     * @throws fails if `x > f`, where `f - x < 0`.\n     */\n    neg(x: Field3, f: bigint) {\n      return ForeignField.negate(x, f);\n    },\n\n    /**\n     * Foreign field sum: `xs[0] + signs[0] * xs[1] + ... + signs[n-1] * xs[n] mod f`\n     *\n     * This gadget takes a list of inputs and a list of signs (of size one less than the inputs),\n     * and computes a chain of additions or subtractions, depending on the sign.\n     * A sign is of type `1n | -1n`, where `1n` represents addition and `-1n` represents subtraction.\n     *\n     * **Note**: For 3 or more inputs, `sum()` uses fewer constraints than a sequence of `add()` and `sub()` calls,\n     * because we can avoid range checks on intermediate results.\n     *\n     * See {@link Gadgets.ForeignField.add} for assumptions on inputs.\n     *\n     * @example\n     * ```ts\n     * let x = Provable.witness(Field3, () => 4n);\n     * let y = Provable.witness(Field3, () => 5n);\n     * let z = Provable.witness(Field3, () => 10n);\n     *\n     * // range check x, y, z\n     * Gadgets.multiRangeCheck(x);\n     * Gadgets.multiRangeCheck(y);\n     * Gadgets.multiRangeCheck(z);\n     *\n     * // compute x + y - z mod 17\n     * let sum = ForeignField.sum([x, y, z], [1n, -1n], 17n);\n     *\n     * Provable.log(sum); // ['16', '0', '0'] = limb representation of 16 = 4 + 5 - 10 mod 17\n     * ```\n     */\n    sum(xs: Field3[], signs: (1n | -1n)[], f: bigint) {\n      return ForeignField.sum(xs, signs, f);\n    },\n\n    /**\n     * @internal\n     *\n     * Foreign field multiplication: `x * y mod f`\n     *\n     * The modulus `f` does not need to be prime, but has to be smaller than 2^259.\n     *\n     * **Assumptions**: In addition to the assumption that input limbs are in the range [0, 2^88), as in all foreign field gadgets,\n     * this assumes an additional bound on the inputs: `x * y < 2^264 * p`, where p is the native modulus.\n     * We usually assert this bound by proving that `x[2] < f[2] + 1`, where `x[2]` is the most significant limb of x.\n     * To do this, we use an 88-bit range check on `2^88 - x[2] - (f[2] + 1)`, and same for y.\n     * The implication is that x and y are _almost_ reduced modulo f.\n     *\n     * All of the above assumptions are checked by {@link Gadgets.ForeignField.assertAlmostReduced}.\n     *\n     * **Warning**: This gadget does not add the extra bound check on the result.\n     * So, to use the result in another foreign field multiplication, you have to add the bound check on it yourself, again.\n     *\n     * @example\n     * ```ts\n     * // example modulus: secp256k1 prime\n     * let f = (1n << 256n) - (1n << 32n) - 0b1111010001n;\n     *\n     * let x = Provable.witness(Field3, () => f - 1n);\n     * let y = Provable.witness(Field3, () => f - 2n);\n     *\n     * // range check x, y and prove additional bounds x[2] <= f[2]\n     * ForeignField.assertAlmostReduced([x, y], f);\n     *\n     * // compute x * y mod f\n     * let z = ForeignField.mul(x, y, f);\n     *\n     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = (-1)*(-2) mod f\n     * ```\n     */\n    mul(x: Field3, y: Field3, f: bigint) {\n      return ForeignField.mul(x, y, f);\n    },\n\n    /**\n     * @internal\n     *\n     * Foreign field inverse: `x^(-1) mod f`\n     *\n     * See {@link Gadgets.ForeignField.mul} for assumptions on inputs and usage examples.\n     *\n     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.\n     */\n    inv(x: Field3, f: bigint) {\n      return ForeignField.inv(x, f);\n    },\n\n    /**\n     * @internal\n     *\n     * Foreign field division: `x * y^(-1) mod f`\n     *\n     * See {@link Gadgets.ForeignField.mul} for assumptions on inputs and usage examples.\n     *\n     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.\n     *\n     * @throws Different than {@link Gadgets.ForeignField.mul}, this fails on unreduced input `x`, because it checks that `x === (x/y)*y` and the right side will be reduced.\n     */\n    div(x: Field3, y: Field3, f: bigint) {\n      return ForeignField.div(x, y, f);\n    },\n\n    /**\n     * @internal\n     *\n     * Optimized multiplication of sums in a foreign field, for example: `(x - y)*z = a + b + c mod f`\n     *\n     * Note: This is much more efficient than using {@link Gadgets.ForeignField.add} and {@link Gadgets.ForeignField.sub} separately to\n     * compute the multiplication inputs and outputs, and then using {@link Gadgets.ForeignField.mul} to constrain the result.\n     *\n     * The sums passed into this method are \"lazy sums\" created with {@link Gadgets.ForeignField.Sum}.\n     * You can also pass in plain {@link Field3} elements.\n     *\n     * **Assumptions**: The assumptions on the _summands_ are analogous to the assumptions described in {@link Gadgets.ForeignField.mul}:\n     * - each summand's limbs are in the range [0, 2^88)\n     * - summands that are part of a multiplication input satisfy `x[2] <= f[2]`\n     *\n     * @throws if the modulus is so large that the second assumption no longer suffices for validity of the multiplication.\n     * For small sums and moduli < 2^256, this will not fail.\n     *\n     * @throws if the provided multiplication result is not correct modulo f.\n     *\n     * @example\n     * ```ts\n     * // range-check x, y, z, a, b, c\n     * ForeignField.assertAlmostReduced([x, y, z], f);\n     * Gadgets.multiRangeCheck(a);\n     * Gadgets.multiRangeCheck(b);\n     * Gadgets.multiRangeCheck(c);\n     *\n     * // create lazy input sums\n     * let xMinusY = ForeignField.Sum(x).sub(y);\n     * let aPlusBPlusC = ForeignField.Sum(a).add(b).add(c);\n     *\n     * // assert that (x - y)*z = a + b + c mod f\n     * ForeignField.assertMul(xMinusY, z, aPlusBPlusC, f);\n     * ```\n     */\n    assertMul(\n      x: Field3 | ForeignFieldSum,\n      y: Field3 | ForeignFieldSum,\n      z: Field3 | ForeignFieldSum,\n      f: bigint,\n      message?: string\n    ) {\n      return ForeignField.assertMul(x, y, z, f, message);\n    },\n\n    /**\n     * @internal\n     *\n     * Lazy sum of {@link Field3} elements, which can be used as input to {@link Gadgets.ForeignField.assertMul}.\n     */\n    Sum(x: Field3) {\n      return ForeignField.Sum(x);\n    },\n\n    /**\n     * @internal\n     *\n     * Prove that each of the given {@link Field3} elements is \"almost\" reduced modulo f,\n     * i.e., satisfies the assumptions required by {@link Gadgets.ForeignField.mul} and other gadgets:\n     * - each limb is in the range [0, 2^88)\n     * - the most significant limb is less or equal than the modulus, x[2] <= f[2]\n     *\n     * **Note**: This method is most efficient when the number of input elements is a multiple of 3.\n     *\n     * @throws if any of the assumptions is violated.\n     *\n     * @example\n     * ```ts\n     * let x = Provable.witness(Field3, () => 4n);\n     * let y = Provable.witness(Field3, () => 5n);\n     * let z = Provable.witness(Field3, () => 10n);\n     *\n     * ForeignField.assertAlmostReduced([x, y, z], f);\n     *\n     * // now we can use x, y, z as inputs to foreign field multiplication\n     * let xy = ForeignField.mul(x, y, f);\n     * let xyz = ForeignField.mul(xy, z, f);\n     *\n     * // since xy is an input to another multiplication, we need to prove that it is almost reduced again!\n     * ForeignField.assertAlmostReduced([xy], f); // TODO: would be more efficient to batch this with 2 other elements\n     * ```\n     */\n    assertAlmostReduced(xs: Field3[], f: bigint, { skipMrc = false } = {}) {\n      ForeignField.assertAlmostReduced(xs, f, skipMrc);\n    },\n\n    /**\n     * Prove that x < f for any constant f < 2^264, or for another `Field3` f.\n     *\n     * If f is a finite field modulus, this means that the given field element is fully reduced modulo f.\n     * This is a stronger statement than {@link ForeignField.assertAlmostReduced}\n     * and also uses more constraints; it should not be needed in most use cases.\n     *\n     * **Note**: This assumes that the limbs of x are in the range [0, 2^88), in contrast to\n     * {@link ForeignField.assertAlmostReduced} which adds that check itself.\n     *\n     * @throws if x is greater or equal to f.\n     *\n     * @example\n     * ```ts\n     * let x = Provable.witness(Field3, () => 0x1235n);\n     *\n     *  // range check limbs of x\n     * Gadgets.multiRangeCheck(x);\n     *\n     * // prove that x is fully reduced mod f\n     * Gadgets.ForeignField.assertLessThan(x, f);\n     * ```\n     */\n    assertLessThan(x: Field3, f: bigint | Field3) {\n      ForeignField.assertLessThan(x, f);\n    },\n\n    /**\n     * Prove that x <= f for any constant f < 2^264, or for another `Field3` f.\n     *\n     * See {@link ForeignField.assertLessThan} for details and usage examples.\n     */\n    assertLessThanOrEqual(x: Field3, f: bigint | Field3) {\n      ForeignField.assertLessThanOrEqual(x, f);\n    },\n\n    /**\n     * Proves that x is equal to y.\n     */\n    assertEquals(x: Field3, y: Field3) {\n      ForeignField.assertEquals(x, y);\n    },\n    /**\n     * Convert x, which may be unreduced, to a canonical representative xR < f\n     * such that x = xR mod f\n     *\n     * Note: This method is complete, it works for all unreduced field elements.\n     * It can therefore be used to protect against incompleteness of field operations in other places.\n     */\n    toCanonical(x: Field3, f: bigint) {\n      return ForeignField.toCanonical(x, f);\n    },\n    /**\n     * Provable method for slicing a 3x88-bit bigint into smaller bit chunks of length `chunkSize`\n     *\n     * This serves as a range check that the input is in [0, 2^maxBits)\n     */\n    sliceField3,\n  },\n\n  /**\n   * Helper methods to interact with 3-limb vectors of Fields.\n   *\n   * **Note:** This interface does not contain any provable methods.\n   */\n  Field3,\n\n  /**\n   * Division modulo 2^32. The operation decomposes a {@link Field} element in the range [0, 2^64) into two 32-bit limbs, `remainder` and `quotient`, using the following equation: `n = quotient * 2^32 + remainder`.\n   *\n   * **Note:** The gadget acts as a proof that the input is in the range [0, 2^64). If the input exceeds 64 bits, the gadget fails.\n   *\n   * Asserts that both `remainder` and `quotient` are in the range [0, 2^32) using {@link Gadgets.rangeCheck32}.\n   *\n   * @example\n   * ```ts\n   * let n = Field((1n << 32n) + 8n)\n   * let { remainder, quotient } = Gadgets.divMod32(n);\n   * // remainder = 8, quotient = 1\n   *\n   * n.assertEquals(quotient.mul(1n << 32n).add(remainder));\n   * ```\n   */\n  divMod32,\n\n  /**\n   * Addition modulo 2^32. The operation adds two {@link Field} elements in the range [0, 2^32) and returns the result modulo 2^32.\n   *\n   * Asserts that the result is in the range [0, 2^32) using {@link Gadgets.rangeCheck32}.\n   *\n   * It uses {@link Gadgets.divMod32} internally by adding the two {@link Field} elements and then decomposing the result into `remainder` and `quotient` and returning the `remainder`.\n   *\n   * **Note:** The gadget assumes both inputs to be in the range [0, 2^64). When called with non-range-checked inputs, be aware that the sum `a + b` can overflow the native field and the gadget can succeed but return an invalid result.\n   *\n   * @example\n   * ```ts\n   * let a = Field(8n);\n   * let b = Field(1n << 32n);\n   *\n   * Gadgets.addMod32(a, b).assertEquals(Field(8n));\n   * ```\n   *    */\n  addMod32,\n\n  /**\n   * Division modulo 2^64. The operation decomposes a {@link Field} element in the range [0, 2^128) into two 64-bit limbs, `remainder` and `quotient`, using the following equation: `n = quotient * 2^64 + remainder`.\n   *\n   * **Note:** The gadget acts as a proof that the input is in the range [0, 2^128). If the input exceeds 128 bits, the gadget fails.\n   *\n   * Asserts that both `remainder` and `quotient` are in the range [0, 2^64) using {@link Gadgets.rangeCheck64}.\n   *\n   * @example\n   * ```ts\n   * let n = Field((1n << 64n) + 8n)\n   * let { remainder, quotient } = Gadgets.divMod64(n);\n   * // remainder = 8, quotient = 1\n   *\n   * n.assertEquals(quotient.mul(1n << 64n).add(remainder));\n   * ```\n   */\n  divMod64,\n\n  /**\n   * Addition modulo 2^64. The operation adds two {@link Field} elements in the range [0, 2^64) and returns the result modulo 2^64.\n   *\n   * Asserts that the result is in the range [0, 2^64) using {@link Gadgets.rangeCheck64}.\n   *\n   * It uses {@link Gadgets.divMod64} internally by adding the two {@link Field} elements and then decomposing the result into `remainder` and `quotient` and returning the `remainder`.\n   *\n   * **Note:** The gadget assumes both inputs to be in the range [0, 2^64). When called with non-range-checked inputs, be aware that the sum `a + b` can overflow the native field and the gadget can succeed but return an invalid result.\n   *\n   * @example\n   * ```ts\n   * let a = Field(8n);\n   * let b = Field(1n << 64n);\n   *\n   * Gadgets.addMod64(a, b).assertEquals(Field(8n));\n   * ```\n   */\n  addMod64,\n\n  /**\n   *\n   * Implementation of the [SHA256 hash function.](https://en.wikipedia.org/wiki/SHA-2) Hash function with 256bit output.\n   *\n   * Applies the SHA2-256 hash function to a list of byte-sized elements.\n   *\n   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]`, `bigint[]` or `Uint8Array` to perform a hash outside provable code.\n   *\n   * Produces an output of {@link Bytes} that conforms to the chosen bit length.\n   *\n   * @param data - {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest = Gadgets.SHA256.hash(preimage);\n   * ```\n   * @deprecated {@link SHA256} is deprecated in favor of {@link SHA2}, which supports more variants of the hash function.\n   */\n  SHA256: SHA256,\n\n  /**\n   * Implementation of the [SHA2 hash function.](https://en.wikipedia.org/wiki/SHA-2) Hash function\n   * with 224 | 256 | 384 | 512 bit output.\n   *\n   * Applies the SHA2 hash function to a list of byte-sized elements.\n   *\n   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]`, `bigint[]` or `Uint8Array` to perform a hash outside provable code.\n   *\n   * Produces an output of {@link Bytes} that conforms to the chosen bit length.\n   *\n   * @param length - 224 | 256 | 384 | 512 representing the length of the hash.\n   * @param data - {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest = Gadgets.SHA2.hash(512, preimage);\n   * ```\n   *   */\n  SHA2: SHA2,\n\n  /**\n   * Implementation of the [BLAKE2b hash function.](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2) Hash function with arbitrary length output.\n   *\n   * Applies the BLAKE2b hash function to a list of byte-sized elements.\n   *\n   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]`, `bigint[]` or `Uint8Array` to perform a hash outside provable code.\n   *\n   * Produces an output of {@link Bytes} that conforms to the chosen digest length.\n   *\n   * @param data - {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest = Gadgets.BLAKE2b.hash(preimage);\n   * ```\n   *\n   */\n  BLAKE2B: BLAKE2B,\n\n  /**\n   * Default limb size constants mostly used in range checks.\n   */\n  Constants: {\n    l2Mask,\n    l,\n    l2,\n    l3,\n    lMask,\n  },\n};\n", "import { mod, Fp, FiniteField, createField } from '../../bindings/crypto/finite-field.js';\nimport { checkBitLength, Field, withMessage } from './field.js';\nimport { Provable } from './provable.js';\nimport { Bool } from './bool.js';\nimport { Tuple, TupleMap, TupleN } from '../util/types.js';\nimport { Gadgets } from './gadgets/gadgets.js';\nimport { ForeignField as FF, Field3 } from './gadgets/foreign-field.js';\nimport { assert } from './gadgets/common.js';\nimport { fieldToField3 } from './gadgets/comparison.js';\nimport { l3, l } from './gadgets/range-check.js';\nimport { ProvablePureExtended } from './types/struct.js';\n\n// external API\nexport { createForeignField };\nexport type { ForeignField, UnreducedForeignField, AlmostForeignField, CanonicalForeignField };\n\nclass ForeignField {\n  static _Bigint: FiniteField | undefined = undefined;\n  static _modulus: bigint | undefined = undefined;\n\n  // static parameters\n  static get Bigint() {\n    assert(this._Bigint !== undefined, 'ForeignField class not initialized.');\n    return this._Bigint;\n  }\n  static get modulus() {\n    assert(this._modulus !== undefined, 'ForeignField class not initialized.');\n    return this._modulus;\n  }\n  get modulus() {\n    return (this.constructor as typeof ForeignField).modulus;\n  }\n  static get sizeInBits() {\n    return this.modulus.toString(2).length;\n  }\n\n  /**\n   * The internal representation of a foreign field element, as a tuple of 3 limbs.\n   */\n  value: Field3;\n\n  get Constructor() {\n    return this.constructor as typeof ForeignField;\n  }\n\n  /**\n   * Unsafe constructor methods for advanced usage.\n   */\n  static get Unsafe() {\n    const Constructor = this;\n    return {\n      /**\n       * Converts a {@link Field} into a {@link ForeignField}. This is an **unsafe** operation\n       * as the native Field size may be larger than the Foreign Field size, and changes in modulus\n       * can have unintended consequences.\n       *\n       * Only use this if you have already constrained the Field element to be within the foreign field modulus.\n       *\n       * @param x a {@link Field}\n       */\n      fromField(x: Field) {\n        const p = Constructor.modulus;\n        if (x.isConstant()) {\n          let value = x.toBigInt();\n          if (value >= p) {\n            throw new Error(\n              `Field value ${value} exceeds foreign field modulus ${p}. Please ensure the value is reduced to the modulus.`\n            );\n          }\n        }\n        return new Constructor.Canonical(fieldToField3(x));\n      },\n    };\n  }\n\n  /**\n   * Sibling classes that represent different ranges of field elements.\n   */\n  static _variants:\n    | {\n        unreduced: typeof UnreducedForeignField;\n        almostReduced: typeof AlmostForeignField;\n        canonical: typeof CanonicalForeignField;\n      }\n    | undefined = undefined;\n\n  /**\n   * Constructor for unreduced field elements.\n   */\n  static get Unreduced() {\n    assert(this._variants !== undefined, 'ForeignField class not initialized.');\n    return this._variants.unreduced;\n  }\n  /**\n   * Constructor for field elements that are \"almost reduced\", i.e. lie in the range [0, 2^ceil(log2(p))).\n   */\n  static get AlmostReduced() {\n    assert(this._variants !== undefined, 'ForeignField class not initialized.');\n    return this._variants.almostReduced;\n  }\n  /**\n   * Constructor for field elements that are fully reduced, i.e. lie in the range [0, p).\n   */\n  static get Canonical() {\n    assert(this._variants !== undefined, 'ForeignField class not initialized.');\n    return this._variants.canonical;\n  }\n\n  /**\n   * Create a new {@link ForeignField} from a bigint, number, string, or another ForeignField.\n   * @example\n   * ```ts\n   * let x = new ForeignField(5);\n   * let y = ForeignField.from(10n);\n   * ```\n   *\n   * Note: Inputs must be range checked if they originate from a different field with a different modulus or if they are not constants.\n   *\n   * - When constructing from another {@link ForeignField} instance, ensure the modulus matches. If not, check the modulus using `Gadgets.ForeignField.assertLessThan()` and handle appropriately.\n   * - When constructing from a `Field3` array, ensure all elements are valid Field elements and range checked.\n   * - Ensure constants are correctly reduced to the modulus of the field.\n   */\n  constructor(x: ForeignField | Field3 | bigint | number | string) {\n    const p = this.modulus;\n    if (x instanceof ForeignField) {\n      if (x.modulus !== p) {\n        throw new Error(\n          `ForeignField constructor: modulus mismatch. Expected ${p}, got ${x.modulus}. Please provide a value with the correct modulus. You can use 'Gadgets.ForeignField.assertLessThan()' to check it.`\n        );\n      }\n      this.value = x.value;\n      return;\n    }\n    // Field3\n    if (Array.isArray(x)) {\n      this.value = x;\n      return;\n    }\n    // constant\n    this.value = Field3.from(mod(BigInt(x), p));\n  }\n\n  /**\n   * Coerce the input to a {@link ForeignField}.\n   * @param x - The value to convert. Can be a {@link ForeignField}, bigint, number, or string.\n   */\n  static from(x: bigint | number | string): CanonicalForeignField;\n  static from(x: ForeignField | bigint | number | string): ForeignField;\n  static from(x: ForeignField | bigint | number | string): ForeignField {\n    if (x instanceof this) return x;\n    return new this.Canonical(x);\n  }\n\n  /**\n   * @internal\n   * Checks whether this field element is a constant.\n   *\n   * See {@link FieldVar} to understand constants vs variables.\n   */\n  isConstant() {\n    return Field3.isConstant(this.value);\n  }\n\n  /**\n   * @internal\n   * Convert this field element to a constant.\n   *\n   * See {@link FieldVar} to understand constants vs variables.\n   *\n   * **Warning**: This function is only useful in {@link Provable.witness} or {@link Provable.asProver} blocks,\n   * that is, in situations where the prover computes a value outside provable code.\n   */\n  toConstant(): ForeignField {\n    let constantLimbs = Tuple.map(this.value, (l) => l.toConstant());\n    return new this.Constructor(constantLimbs);\n  }\n\n  /**\n   * Convert this field element to a bigint.\n   */\n  toBigInt() {\n    return Field3.toBigint(this.value);\n  }\n\n  /**\n   * Assert that this field element lies in the range [0, 2^k),\n   * where k = ceil(log2(p)) and p is the foreign field modulus.\n   *\n   * Returns the field element as a {@link AlmostForeignField}.\n   *\n   * For a more efficient version of this for multiple field elements, see {@link assertAlmostReduced}.\n   *\n   * Note: this does not ensure that the field elements is in the canonical range [0, p).\n   * To assert that stronger property, there is {@link assertCanonical}.\n   * You should typically use {@link assertAlmostReduced} though, because it is cheaper to prove and sufficient for\n   * ensuring validity of all our non-native field arithmetic methods.\n   */\n  assertAlmostReduced() {\n    // TODO: this is not very efficient, but the only way to abstract away the complicated\n    // range check assumptions and also not introduce a global context of pending range checks.\n    // we plan to get rid of bounds checks anyway, then this is just a multi-range check\n    let [x] = this.Constructor.assertAlmostReduced(this);\n    return x;\n  }\n\n  /**\n   * Assert that one or more field elements lie in the range [0, 2^k),\n   * where k = ceil(log2(p)) and p is the foreign field modulus.\n   *\n   * This is most efficient than when checking a multiple of 3 field elements at once.\n   */\n  static assertAlmostReduced<T extends Tuple<ForeignField>>(\n    ...xs: T\n  ): TupleMap<T, AlmostForeignField> {\n    Gadgets.ForeignField.assertAlmostReduced(\n      xs.map((x) => x.value),\n      this.modulus,\n      { skipMrc: true }\n    );\n    return Tuple.map(xs, this.AlmostReduced.unsafeFrom);\n  }\n\n  /**\n   * Assert that this field element is fully reduced,\n   * i.e. lies in the range [0, p), where p is the foreign field modulus.\n   *\n   * Returns the field element as a {@link CanonicalForeignField}.\n   */\n  assertCanonical() {\n    this.assertLessThan(this.modulus);\n    return this.Constructor.Canonical.unsafeFrom(this);\n  }\n\n  // arithmetic with full constraints, for safe use\n\n  /**\n   * Finite field addition\n   * @example\n   * ```ts\n   * x.add(2); // x + 2 mod p\n   * ```\n   */\n  add(y: ForeignField | bigint | number) {\n    return this.Constructor.sum([this, y], [1]);\n  }\n\n  /**\n   * Finite field negation\n   * @example\n   * ```ts\n   * x.neg(); // -x mod p = p - x\n   * ```\n   */\n  neg() {\n    // this gets a special implementation because negation proves that the return value is almost reduced.\n    // it shows that r = f - x >= 0 or r = 0 (for x=0) over the integers, which implies r < f\n    // see also `Gadgets.ForeignField.assertLessThan()`\n    let xNeg = Gadgets.ForeignField.neg(this.value, this.modulus);\n    return new this.Constructor.AlmostReduced(xNeg);\n  }\n\n  /**\n   * Finite field subtraction\n   * @example\n   * ```ts\n   * x.sub(1); // x - 1 mod p\n   * ```\n   */\n  sub(y: ForeignField | bigint | number) {\n    return this.Constructor.sum([this, y], [-1]);\n  }\n\n  /**\n   * Sum (or difference) of multiple finite field elements.\n   *\n   * @example\n   * ```ts\n   * let z = ForeignField.sum([3, 2, 1], [-1, 1]); // 3 - 2 + 1\n   * z.assertEquals(2);\n   * ```\n   *\n   * This method expects a list of ForeignField-like values, `x0,...,xn`,\n   * and a list of \"operations\" `op1,...,opn` where every op is 1 or -1 (plus or minus),\n   * and returns\n   *\n   * `x0 + op1*x1 + ... + opn*xn`\n   *\n   * where the sum is computed in finite field arithmetic.\n   *\n   * **Important:** For more than two summands, this is significantly more efficient\n   * than chaining calls to {@link ForeignField.add} and {@link ForeignField.sub}.\n   *\n   */\n  static sum(xs: (ForeignField | bigint | number)[], operations: (1 | -1)[]) {\n    const p = this.modulus;\n    let fields = xs.map((x) => toLimbs(x, p));\n    let ops = operations.map((op) => (op === 1 ? 1n : -1n));\n    let z = Gadgets.ForeignField.sum(fields, ops, p);\n    return new this.Unreduced(z);\n  }\n\n  // convenience methods\n\n  /**\n   * Assert equality with a ForeignField-like value\n   *\n   * @example\n   * ```ts\n   * x.assertEquals(0, \"x is zero\");\n   * ```\n   *\n   * Since asserting equality can also serve as a range check,\n   * this method returns `x` with the appropriate type:\n   *\n   * @example\n   * ```ts\n   * let xChecked = x.assertEquals(1, \"x is 1\");\n   * xChecked satisfies CanonicalForeignField;\n   * ```\n   */\n  assertEquals(y: bigint | number | CanonicalForeignField, message?: string): CanonicalForeignField;\n  assertEquals(y: AlmostForeignField, message?: string): AlmostForeignField;\n  assertEquals(y: ForeignField, message?: string): ForeignField;\n  assertEquals(y: ForeignField | bigint | number, message?: string): ForeignField {\n    const p = this.modulus;\n    try {\n      if (this.isConstant() && isConstant(y)) {\n        let x = this.toBigInt();\n        let y0 = mod(toBigInt(y), p);\n        if (x !== y0) {\n          throw Error(`ForeignField.assertEquals(): ${x} != ${y0}`);\n        }\n        return new this.Constructor.Canonical(this.value);\n      }\n      Provable.assertEqual(this.Constructor, this, new this.Constructor(y));\n      if (isConstant(y) || y instanceof this.Constructor.Canonical) {\n        return new this.Constructor.Canonical(this.value);\n      } else if (y instanceof this.Constructor.AlmostReduced) {\n        return new this.Constructor.AlmostReduced(this.value);\n      } else {\n        return this;\n      }\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  /**\n   * Assert that this field element is less than a constant c: `x < c`.\n   *\n   * The constant must satisfy `0 <= c < 2^264`, otherwise an error is thrown.\n   *\n   * @example\n   * ```ts\n   * x.assertLessThan(10);\n   * ```\n   */\n  assertLessThan(c: bigint | number, message?: string) {\n    assert(\n      c >= 0 && c < 1n << l3,\n      `ForeignField.assertLessThan(): expected c <= c < 2^264, got ${c}`\n    );\n    try {\n      Gadgets.ForeignField.assertLessThan(this.value, toBigInt(c));\n    } catch (err) {\n      throw withMessage(err, message);\n    }\n  }\n\n  // bit packing\n\n  /**\n   * Unpack a field element to its bits, as a {@link Bool}[] array.\n   *\n   * This method is provable!\n   */\n  toBits(length?: number) {\n    const sizeInBits = this.Constructor.sizeInBits;\n    if (length === undefined) length = sizeInBits;\n    checkBitLength('ForeignField.toBits()', length, sizeInBits);\n    let [l0, l1, l2] = this.value;\n    let limbSize = Number(l);\n    let xBits = l0.toBits(Math.min(length, limbSize));\n    length -= limbSize;\n    if (length <= 0) {\n      // constrain the remaining two high-limbs to be zero, return the first limb\n      l1.assertEquals(0);\n      l2.assertEquals(0);\n      return xBits;\n    }\n    let yBits = l1.toBits(Math.min(length, limbSize));\n    length -= limbSize;\n    if (length <= 0) {\n      // constrain the highest limb to be zero, return the first two limbs\n      l2.assertEquals(0);\n      return [...xBits, ...yBits];\n    }\n    let zBits = l2.toBits(Math.min(length, limbSize));\n    return [...xBits, ...yBits, ...zBits];\n  }\n\n  /**\n   * Create a field element from its bits, as a `Bool[]` array.\n   *\n   * This method is provable!\n   */\n  static fromBits(bits: Bool[]) {\n    let length = bits.length;\n    checkBitLength('ForeignField.fromBits()', length, this.sizeInBits);\n    let limbSize = Number(l);\n    let l0 = Field.fromBits(bits.slice(0 * limbSize, 1 * limbSize));\n    let l1 = Field.fromBits(bits.slice(1 * limbSize, 2 * limbSize));\n    let l2 = Field.fromBits(bits.slice(2 * limbSize, 3 * limbSize));\n    // note: due to the check on the number of bits, we know we return an \"almost valid\" field element\n    return new this.AlmostReduced([l0, l1, l2]);\n  }\n\n  static random() {\n    return new this.Canonical(this.Bigint.random());\n  }\n\n  /**\n   * Instance version of `Provable<ForeignField>.toFields`, see {@link Provable.toFields}\n   */\n  toFields(): Field[] {\n    return this.value;\n  }\n\n  static check(_: ForeignField) {\n    throw Error('ForeignField.check() not implemented: must use a subclass');\n  }\n\n  static _provable: any = undefined;\n\n  /**\n   * `Provable<ForeignField>`, see {@link Provable}\n   */\n  static get provable() {\n    assert(this._provable !== undefined, 'ForeignField class not initialized.');\n    return this._provable;\n  }\n}\n\nclass ForeignFieldWithMul extends ForeignField {\n  /**\n   * Finite field multiplication\n   * @example\n   * ```ts\n   * x.mul(y); // x*y mod p\n   * ```\n   */\n  mul(y: AlmostForeignField | bigint | number) {\n    const p = this.modulus;\n    let z = Gadgets.ForeignField.mul(this.value, toLimbs(y, p), p);\n    return new this.Constructor.Unreduced(z);\n  }\n\n  /**\n   * Multiplicative inverse in the finite field\n   * @example\n   * ```ts\n   * let z = x.inv(); // 1/x mod p\n   * z.mul(x).assertEquals(1);\n   * ```\n   */\n  inv() {\n    const p = this.modulus;\n    let z = Gadgets.ForeignField.inv(this.value, p);\n    return new this.Constructor.AlmostReduced(z);\n  }\n\n  /**\n   * Division in the finite field, i.e. `x*y^(-1) mod p` where `y^(-1)` is the finite field inverse.\n   * @example\n   * ```ts\n   * let z = x.div(y); // x/y mod p\n   * z.mul(y).assertEquals(x);\n   * ```\n   */\n  div(y: AlmostForeignField | bigint | number) {\n    const p = this.modulus;\n    let z = Gadgets.ForeignField.div(this.value, toLimbs(y, p), p);\n    return new this.Constructor.AlmostReduced(z);\n  }\n}\n\nclass UnreducedForeignField extends ForeignField {\n  type: 'Unreduced' | 'AlmostReduced' | 'FullyReduced' = 'Unreduced';\n\n  static _provable: ProvablePureExtended<UnreducedForeignField, bigint, string> | undefined =\n    undefined;\n  static get provable() {\n    assert(this._provable !== undefined, 'ForeignField class not initialized.');\n    return this._provable;\n  }\n\n  static check(x: ForeignField) {\n    Gadgets.multiRangeCheck(x.value);\n  }\n}\n\nclass AlmostForeignField extends ForeignFieldWithMul {\n  type: 'AlmostReduced' | 'FullyReduced' = 'AlmostReduced';\n\n  constructor(x: AlmostForeignField | Field3 | bigint | number | string) {\n    super(x);\n  }\n\n  static _provable: ProvablePureExtended<AlmostForeignField, bigint, string> | undefined =\n    undefined;\n  static get provable() {\n    assert(this._provable !== undefined, 'ForeignField class not initialized.');\n    return this._provable;\n  }\n\n  static check(x: ForeignField) {\n    Gadgets.multiRangeCheck(x.value);\n    x.assertAlmostReduced();\n  }\n\n  /**\n   * Coerce the input to an {@link AlmostForeignField} without additional assertions.\n   *\n   * **Warning:** Only use if you know what you're doing.\n   */\n  static unsafeFrom(x: ForeignField) {\n    return new this(x.value);\n  }\n\n  /**\n   * Check equality with a constant value.\n   *\n   * @example\n   * ```ts\n   * let isXZero = x.equals(0);\n   * ```\n   */\n  equals(y: bigint | number) {\n    return FF.equals(this.value, BigInt(y), this.modulus);\n  }\n}\n\nclass CanonicalForeignField extends ForeignFieldWithMul {\n  type = 'FullyReduced' as const;\n\n  constructor(x: CanonicalForeignField | Field3 | bigint | number | string) {\n    super(x);\n  }\n\n  static _provable: ProvablePureExtended<CanonicalForeignField, bigint, string> | undefined =\n    undefined;\n  static get provable() {\n    assert(this._provable !== undefined, 'ForeignField class not initialized.');\n    return this._provable;\n  }\n\n  static check(x: ForeignField) {\n    Gadgets.multiRangeCheck(x.value);\n    x.assertCanonical();\n  }\n\n  /**\n   * Coerce the input to a {@link CanonicalForeignField} without additional assertions.\n   *\n   * **Warning:** Only use if you know what you're doing.\n   */\n  static unsafeFrom(x: ForeignField) {\n    return new this(x.value);\n  }\n\n  /**\n   * Check equality with a ForeignField-like value.\n   *\n   * @example\n   * ```ts\n   * let isEqual = x.equals(y);\n   * ```\n   *\n   * Note: This method only exists on canonical fields; on unreduced fields, it would be easy to\n   * misuse, because not being exactly equal does not imply being unequal modulo p.\n   */\n  equals(y: CanonicalForeignField | bigint | number) {\n    let [x0, x1, x2] = this.value;\n    let [y0, y1, y2] = toLimbs(y, this.modulus);\n    let x01 = x0.add(x1.mul(1n << l)).seal();\n    let y01 = y0.add(y1.mul(1n << l)).seal();\n    return x01.equals(y01).and(x2.equals(y2));\n  }\n}\n\nfunction toLimbs(x: bigint | number | string | ForeignField, p: bigint): Field3 {\n  if (x instanceof ForeignField) return x.value;\n  return Field3.from(mod(BigInt(x), p));\n}\n\nfunction toBigInt(x: bigint | string | number | ForeignField) {\n  if (x instanceof ForeignField) return x.toBigInt();\n  return BigInt(x);\n}\n\nfunction isConstant(x: bigint | number | string | ForeignField) {\n  if (x instanceof ForeignField) return x.isConstant();\n  return true;\n}\n\n/**\n * Create a class representing a prime order finite field, which is different from the native {@link Field}.\n *\n * ```ts\n * const SmallField = createForeignField(17n); // the finite field F_17\n * ```\n *\n * `createForeignField(p)` takes the prime modulus `p` of the finite field as input, as a bigint.\n * We support prime moduli up to a size of 259 bits.\n *\n * The returned {@link ForeignField} class supports arithmetic modulo `p` (addition and multiplication),\n * as well as helper methods like `assertEquals()` and `equals()`.\n *\n * _Advanced details:_\n *\n * Internally, a foreign field element is represented as three native field elements, each of which\n * represents a limb of 88 bits. Therefore, being a valid foreign field element means that all 3 limbs\n * fit in 88 bits, and the foreign field element altogether is smaller than the modulus p.\n *\n * Since the full `x < p` check is expensive, by default we only prove a weaker assertion, `x < 2^ceil(log2(p))`,\n * see {@link ForeignField.assertAlmostReduced} for more details.\n *\n * This weaker assumption is what we call \"almost reduced\", and it is represented by the {@link AlmostForeignField} class.\n * Note that only {@link AlmostForeignField} supports multiplication and inversion, while {@link UnreducedForeignField}\n * only supports addition and subtraction.\n *\n * This function returns the `Unreduced` class, which will cause the minimum amount of range checks to be created by default.\n * If you want to do multiplication, you have two options:\n * - create your field elements using the {@link ForeignField.AlmostReduced} constructor.\n * ```ts\n * let x = Provable.witness(ForeignField.AlmostReduced, () => 5n);\n * ```\n * - create your field elements normally and convert them using `x.assertAlmostReduced()`.\n * ```ts\n * let xChecked = x.assertAlmostReduced(); // asserts x < 2^ceil(log2(p)); returns `AlmostForeignField`\n * ```\n *\n * Similarly, there is a separate class {@link CanonicalForeignField} which represents fully reduced, \"canonical\" field elements.\n * To convert to a canonical field element, use `ForeignField.assertCanonical()`:\n *\n * ```ts\n * x.assertCanonical(); // asserts x < p; returns `CanonicalForeignField`\n * ```\n * You will likely not need canonical fields most of the time.\n *\n * Base types for all of these classes are separately exported as {@link UnreducedForeignField}, {@link AlmostForeignField} and {@link CanonicalForeignField}.,\n *\n * @param modulus the modulus of the finite field you are instantiating\n */\nfunction createForeignField(modulus: bigint): typeof UnreducedForeignField {\n  assert(modulus > 0n, `ForeignField: modulus must be positive, got ${modulus}`);\n  assert(\n    modulus < foreignFieldMax,\n    `ForeignField: modulus exceeds the max supported size of 2^${foreignFieldMaxBits}`\n  );\n\n  let Bigint = createField(modulus);\n\n  class UnreducedField extends UnreducedForeignField {\n    static _Bigint = Bigint;\n    static _modulus = modulus;\n    static _provable = provable(UnreducedField);\n\n    // bind public static methods to the class so that they have `this` defined\n    static from = ForeignField.from.bind(UnreducedField);\n    static sum = ForeignField.sum.bind(UnreducedField);\n    static fromBits = ForeignField.fromBits.bind(UnreducedField);\n  }\n\n  class AlmostField extends AlmostForeignField {\n    static _Bigint = Bigint;\n    static _modulus = modulus;\n    static _provable = provable(AlmostField);\n\n    // bind public static methods to the class so that they have `this` defined\n    static from = ForeignField.from.bind(AlmostField);\n    static sum = ForeignField.sum.bind(AlmostField);\n    static fromBits = ForeignField.fromBits.bind(AlmostField);\n    static unsafeFrom = AlmostForeignField.unsafeFrom.bind(AlmostField);\n  }\n\n  class CanonicalField extends CanonicalForeignField {\n    static _Bigint = Bigint;\n    static _modulus = modulus;\n    static _provable = provable(CanonicalField);\n\n    // bind public static methods to the class so that they have `this` defined\n    static from = ForeignField.from.bind(CanonicalField);\n    static sum = ForeignField.sum.bind(CanonicalField);\n    static fromBits = ForeignField.fromBits.bind(CanonicalField);\n    static unsafeFrom = CanonicalForeignField.unsafeFrom.bind(CanonicalField);\n  }\n\n  let variants = {\n    unreduced: UnreducedField,\n    almostReduced: AlmostField,\n    canonical: CanonicalField,\n  };\n  UnreducedField._variants = variants;\n  AlmostField._variants = variants;\n  CanonicalField._variants = variants;\n\n  return UnreducedField;\n}\n\n// the max foreign field modulus is f_max = floor(sqrt(p * 2^t)), where t = 3*limbBits = 264 and p is the native modulus\n// see RFC: https://github.com/o1-labs/proof-systems/blob/1fdb1fd1d112f9d4ee095dbb31f008deeb8150b0/book/src/rfcs/foreign_field_mul.md\n// since p = 2^254 + eps for both Pasta fields with eps small, a fairly tight lower bound is\n// f_max >= sqrt(2^254 * 2^264) = 2^259\nconst foreignFieldMaxBits = (BigInt(Fp.sizeInBits - 1) + 3n * l) / 2n;\nconst foreignFieldMax = 1n << foreignFieldMaxBits;\n\n// provable\n\ntype Constructor<T> = new (...args: any[]) => T;\n\nfunction provable<\n  F extends ForeignField & {\n    type: 'Unreduced' | 'AlmostReduced' | 'FullyReduced';\n  }\n>(\n  Class: Constructor<F> & { check(x: ForeignField): void }\n): ProvablePureExtended<F, bigint, string> {\n  return {\n    toFields(x) {\n      return x.value;\n    },\n    toAuxiliary(): [] {\n      return [];\n    },\n    sizeInFields() {\n      return 3;\n    },\n    fromFields(fields) {\n      let limbs = TupleN.fromArray(3, fields);\n      return new Class(limbs);\n    },\n    check(x: ForeignField) {\n      Class.check(x);\n    },\n    toCanonical(x) {\n      if (x.type === 'FullyReduced') return x;\n      return new Class(FF.toCanonical(x.value, x.modulus));\n    },\n    toValue(x) {\n      return x.toBigInt();\n    },\n    fromValue(x) {\n      return new Class(x);\n    },\n    // ugh\n    toJSON(x: ForeignField) {\n      return x.toBigInt().toString();\n    },\n    fromJSON(x: string) {\n      // TODO be more strict about allowed values\n      return new Class(x);\n    },\n    empty() {\n      return new Class(0n);\n    },\n    toInput(x) {\n      let l_ = Number(l);\n      return {\n        packed: [\n          [x.value[0], l_],\n          [x.value[1], l_],\n          [x.value[2], l_],\n        ],\n      };\n    },\n  };\n}\n", "import { inverse, mod } from '../../../bindings/crypto/finite-field.js';\nimport { Field } from '../field.js';\nimport { Provable } from '../provable.js';\nimport { assert } from './common.js';\nimport { Field3, ForeignField, split, weakBound } from './foreign-field.js';\nimport { l, l2, l2Mask, multiRangeCheck } from './range-check.js';\nimport { sha256 } from 'js-sha256';\nimport { bigIntToBytes, bytesToBigInt } from '../../../bindings/crypto/bigint-helpers.js';\nimport {\n  CurveAffine,\n  GroupAffine,\n  affineAdd,\n  affineDouble,\n} from '../../../bindings/crypto/elliptic-curve.js';\nimport { Bool } from '../bool.js';\nimport { provable } from '../types/provable-derivers.js';\nimport { assertPositiveInteger } from '../../../bindings/crypto/non-negative.js';\nimport { arrayGetGeneric, assertNotVectorEquals } from './basic.js';\nimport { sliceField3 } from './bit-slices.js';\nimport { exists } from '../core/exists.js';\n\n// external API\nexport { EllipticCurve, Point, Ecdsa };\n\n// internal API\nexport { verifyEcdsaConstant, initialAggregator, simpleMapToCurve };\n\nconst EllipticCurve = {\n  add,\n  double,\n  negate,\n  assertOnCurve,\n  scale,\n  assertInSubgroup,\n  multiScalarMul,\n};\n\n/**\n * Non-zero elliptic curve point in affine coordinates.\n */\ntype Point = { x: Field3; y: Field3 };\ntype point = { x: bigint; y: bigint };\n\nnamespace Ecdsa {\n  /**\n   * ECDSA signature consisting of two curve scalars.\n   */\n  export type Signature = { r: Field3; s: Field3 };\n  export type signature = { r: bigint; s: bigint };\n}\n\nfunction add(p1: Point, p2: Point, Curve: { modulus: bigint; a: bigint }) {\n  let { x: x1, y: y1 } = p1;\n  let { x: x2, y: y2 } = p2;\n  let f = Curve.modulus;\n  let [f0, f1, f2] = split(f);\n  let [, , fx22] = split(f * 2n);\n\n  // constant case\n  if (Point.isConstant(p1) && Point.isConstant(p2)) {\n    let p3 = affineAdd(Point.toBigint(p1), Point.toBigint(p2), f, Curve.a);\n    return Point.from(p3);\n  }\n\n  assert(Curve.modulus > l2Mask + 1n, 'Base field moduli smaller than 2^176 are not supported');\n\n  // witness and range-check slope, x3, y3\n  let witnesses = exists(9, () => {\n    let [x1_, x2_, y1_, y2_] = Field3.toBigints(x1, x2, y1, y2);\n    let denom = inverse(mod(x1_ - x2_, f), f) ?? 0n;\n\n    let m = mod((y1_ - y2_) * denom, f);\n    let x3 = mod(m * m - x1_ - x2_, f);\n    let y3 = mod(m * (x1_ - x3) - y1_, f);\n\n    return [...split(m), ...split(x3), ...split(y3)];\n  });\n  let [m0, m1, m2, x30, x31, x32, y30, y31, y32] = witnesses;\n  let m: Field3 = [m0, m1, m2];\n  let x3: Field3 = [x30, x31, x32];\n  let y3: Field3 = [y30, y31, y32];\n  ForeignField.assertAlmostReduced([m, x3, y3], f);\n\n  // check that x1 != x2\n  // we assume x1, x2 are almost reduced, so deltaX <= x1 - x2 + f < 3f\n  // which means we need to check that deltaX != 0, f, 2f\n  let deltaX = ForeignField.sub(x1, x2, f);\n  let deltaX01 = deltaX[0].add(deltaX[1].mul(1n << l)).seal();\n  assertNotVectorEquals([deltaX01, deltaX[2]], [0n, 0n]); // != 0\n  assertNotVectorEquals([deltaX01, deltaX[2]], [f0 + (f1 << l), f2]); // != f\n  deltaX[2].assertNotEquals(fx22); // != 2f (stronger check bc assuming deltaX < f doesn't harm completeness)\n\n  // (x1 - x2)*m = y1 - y2\n  let deltaY = ForeignField.Sum(y1).sub(y2);\n  ForeignField.assertMul(deltaX, m, deltaY, f);\n\n  // m^2 = x1 + x2 + x3\n  let xSum = ForeignField.Sum(x1).add(x2).add(x3);\n  ForeignField.assertMul(m, m, xSum, f);\n\n  // (x1 - x3)*m = y1 + y3\n  let deltaX1X3 = ForeignField.Sum(x1).sub(x3);\n  let ySum = ForeignField.Sum(y1).add(y3);\n  ForeignField.assertMul(deltaX1X3, m, ySum, f);\n\n  return { x: x3, y: y3 };\n}\n\nfunction double(p1: Point, Curve: { modulus: bigint; a: bigint }) {\n  let { x: x1, y: y1 } = p1;\n  let f = Curve.modulus;\n\n  // constant case\n  if (Point.isConstant(p1)) {\n    let p3 = affineDouble(Point.toBigint(p1), f, Curve.a);\n    return Point.from(p3);\n  }\n\n  // witness and range-check slope, x3, y3\n  let witnesses = exists(9, () => {\n    let [x1_, y1_] = Field3.toBigints(x1, y1);\n    let denom = inverse(mod(2n * y1_, f), f) ?? 0n;\n\n    let m = mod((3n * mod(x1_ ** 2n, f) + Curve.a) * denom, f);\n    let x3 = mod(m * m - 2n * x1_, f);\n    let y3 = mod(m * (x1_ - x3) - y1_, f);\n\n    return [...split(m), ...split(x3), ...split(y3)];\n  });\n  let [m0, m1, m2, x30, x31, x32, y30, y31, y32] = witnesses;\n  let m: Field3 = [m0, m1, m2];\n  let x3: Field3 = [x30, x31, x32];\n  let y3: Field3 = [y30, y31, y32];\n  ForeignField.assertAlmostReduced([m, x3, y3], f);\n\n  // x1^2 = x1x1\n  let x1x1 = ForeignField.mul(x1, x1, f);\n\n  // 2*y1*m = 3*x1x1 + a\n  let y1Times2 = ForeignField.Sum(y1).add(y1);\n  let x1x1Times3PlusA = ForeignField.Sum(x1x1).add(x1x1).add(x1x1);\n  if (Curve.a !== 0n) x1x1Times3PlusA = x1x1Times3PlusA.add(Field3.from(Curve.a));\n  ForeignField.assertMul(y1Times2, m, x1x1Times3PlusA, f);\n\n  // m^2 = 2*x1 + x3\n  let xSum = ForeignField.Sum(x1).add(x1).add(x3);\n  ForeignField.assertMul(m, m, xSum, f);\n\n  // (x1 - x3)*m = y1 + y3\n  let deltaX1X3 = ForeignField.Sum(x1).sub(x3);\n  let ySum = ForeignField.Sum(y1).add(y3);\n  ForeignField.assertMul(deltaX1X3, m, ySum, f);\n\n  return { x: x3, y: y3 };\n}\n\nfunction negate({ x, y }: Point, Curve: { modulus: bigint }) {\n  return { x, y: ForeignField.negate(y, Curve.modulus) };\n}\n\nfunction assertOnCurve(p: Point, { modulus: f, a, b }: { modulus: bigint; b: bigint; a: bigint }) {\n  let { x, y } = p;\n  let x2 = ForeignField.mul(x, x, f);\n\n  // Ensure x2, x, and y are almost reduced to prevent potential exploitation\n  // by a malicious prover adding large multiples of f, which could violate\n  // the precondition of ForeignField.assertMul\n  ForeignField.assertAlmostReduced([x2, x, y], f);\n\n  let y2 = ForeignField.mul(y, y, f);\n  let y2MinusB = ForeignField.Sum(y2).sub(Field3.from(b));\n\n  // (x^2 + a) * x = y^2 - b\n  let x2PlusA = ForeignField.Sum(x2);\n  if (a !== 0n) x2PlusA = x2PlusA.add(Field3.from(a));\n  let message: string | undefined;\n  if (Point.isConstant(p)) {\n    message = `assertOnCurve(): (${x}, ${y}) is not on the curve.`;\n  }\n  ForeignField.assertMul(x2PlusA, x, y2MinusB, f, message);\n}\n\n/**\n * EC scalar multiplication, `scalar*point`\n *\n * The result is constrained to be not zero.\n */\nfunction scale(\n  scalar: Field3,\n  point: Point,\n  Curve: CurveAffine,\n  config: {\n    mode?: 'assert-nonzero' | 'assert-zero';\n    windowSize?: number;\n    multiples?: Point[];\n  } = { mode: 'assert-nonzero' }\n) {\n  config.windowSize ??= Point.isConstant(point) ? 4 : 3;\n  return multiScalarMul([scalar], [point], Curve, [config], config.mode);\n}\n\n// checks whether the elliptic curve point g is in the subgroup defined by [order]g = 0\nfunction assertInSubgroup(p: Point, Curve: CurveAffine) {\n  if (!Curve.hasCofactor) return;\n  scale(Field3.from(Curve.order), p, Curve, { mode: 'assert-zero' });\n}\n\n// check whether a point equals a constant point\n// TODO implement the full case of two vars\nfunction equals(p1: Point, p2: point, Curve: { modulus: bigint }) {\n  let xEquals = ForeignField.equals(p1.x, p2.x, Curve.modulus);\n  let yEquals = ForeignField.equals(p1.y, p2.y, Curve.modulus);\n  return xEquals.and(yEquals);\n}\n\nfunction verifyEcdsaGeneric(\n  Curve: CurveAffine,\n  signature: Ecdsa.Signature,\n  msgHash: Field3,\n  publicKey: Point,\n  multiScalarMul: (\n    scalars: Field3[],\n    points: Point[],\n    Curve: CurveAffine,\n    tableConfigs?: (\n      | {\n          windowSize?: number;\n          multiples?: Point[];\n        }\n      | undefined\n    )[],\n    mode?: 'assert-nonzero' | 'assert-zero',\n    ia?: point,\n    hashed?: boolean\n  ) => Point,\n  config: {\n    G?: { windowSize: number; multiples?: Point[] };\n    P?: { windowSize: number; multiples?: Point[] };\n    ia?: point;\n  } = { G: { windowSize: 4 }, P: { windowSize: 4 } }\n): Bool {\n  // constant case\n  if (\n    EcdsaSignature.isConstant(signature) &&\n    Field3.isConstant(msgHash) &&\n    Point.isConstant(publicKey)\n  ) {\n    let isValid = verifyEcdsaConstant(\n      Curve,\n      EcdsaSignature.toBigint(signature),\n      Field3.toBigint(msgHash),\n      Point.toBigint(publicKey)\n    );\n    return new Bool(isValid);\n  }\n\n  // provable case\n  // note: usually we don't check validity of inputs, like that the public key is a valid curve point\n  // we make an exception for the two non-standard conditions r != 0 and s != 0,\n  // which are unusual to capture in types and could be considered part of the verification algorithm\n  let { r, s } = signature;\n  ForeignField.inv(r, Curve.order); // proves r != 0 (important, because r = 0 => u2 = 0 kills the private key contribution)\n  let sInv = ForeignField.inv(s, Curve.order); // proves s != 0\n  let u1 = ForeignField.mul(msgHash, sInv, Curve.order);\n  let u2 = ForeignField.mul(r, sInv, Curve.order);\n\n  let G = Point.from(Curve.one);\n  let R = multiScalarMul(\n    [u1, u2],\n    [G, publicKey],\n    Curve,\n    config && [config.G, config.P],\n    'assert-nonzero',\n    config?.ia\n  );\n  // this ^ already proves that R != 0 (part of ECDSA verification)\n\n  // reduce R.x modulo the curve order\n  let Rx = ForeignField.mul(R.x, Field3.from(1n), Curve.order);\n\n  // we have to prove that Rx is canonical, because we check signature validity based on whether Rx _exactly_ equals the input r.\n  // if we allowed non-canonical Rx, the prover could make verify() return false on a valid signature, by adding a multiple of `Curve.order` to Rx.\n  ForeignField.assertLessThan(Rx, Curve.order);\n\n  // assert s to be canonical\n  ForeignField.assertLessThan(s, Curve.order);\n\n  return Provable.equal(Field3, Rx, r);\n}\n\n/**\n * Verify an ECDSA signature.\n *\n * Details about the `config` parameter:\n * - For both the generator point `G` and public key `P`, `config` allows you to specify:\n *   - the `windowSize` which is used in scalar multiplication for this point.\n *     this flexibility is good because the optimal window size is different for constant and non-constant points.\n *     empirically, `windowSize=4` for constants and 3 for variables leads to the fewest constraints.\n *     our defaults reflect that the generator is always constant and the public key is variable in typical applications.\n *   - a table of multiples of those points, of length `2^windowSize`, which is used in the scalar multiplication gadget to speed up the computation.\n *     if these are not provided, they are computed on the fly.\n *     for the constant G, computing multiples costs no constraints, so passing them in makes no real difference.\n *     for variable public key, there is a possible use case: if the public key is a public input, then its multiples could also be.\n *     in that case, passing them in would avoid computing them in-circuit and save a few constraints.\n * - The initial aggregator `ia`, see {@link initialAggregator}. By default, `ia` is computed deterministically on the fly.\n *\n *\n * _Note_: If `signature.s` is a non-canonical element, an error will be thrown.\n * If `signature.r` is non-canonical, however, `false` will be returned.\n */\nfunction verifyEcdsa(\n  Curve: CurveAffine,\n  signature: Ecdsa.Signature,\n  msgHash: Field3,\n  publicKey: Point,\n  config: {\n    G?: { windowSize: number; multiples?: Point[] };\n    P?: { windowSize: number; multiples?: Point[] };\n    ia?: point;\n  } = { G: { windowSize: 4 }, P: { windowSize: 3 } }\n) {\n  return verifyEcdsaGeneric(\n    Curve,\n    signature,\n    msgHash,\n    publicKey,\n    (scalars, points, Curve, configs, mode, ia) =>\n      multiScalarMul(scalars, points, Curve, configs, mode, ia),\n    config\n  );\n}\n\n/**\n * Bigint implementation of ECDSA verify\n */\nfunction verifyEcdsaConstant(\n  Curve: CurveAffine,\n  { r, s }: Ecdsa.signature,\n  msgHash: bigint,\n  publicKey: point\n) {\n  let pk = Curve.from(publicKey);\n  if (Curve.equal(pk, Curve.zero)) return false;\n  if (Curve.hasCofactor && !Curve.isInSubgroup(pk)) return false;\n  if (r < 1n || r >= Curve.order) return false;\n  if (s < 1n || s >= Curve.order) return false;\n\n  let sInv = Curve.Scalar.inverse(s);\n  assert(sInv !== undefined);\n  let u1 = Curve.Scalar.mul(msgHash, sInv);\n  let u2 = Curve.Scalar.mul(r, sInv);\n\n  let R = Curve.add(Curve.scale(Curve.one, u1), Curve.scale(pk, u2));\n  if (Curve.equal(R, Curve.zero)) return false;\n\n  return Curve.Scalar.equal(R.x, r);\n}\n\nfunction multiScalarMulConstant(\n  scalars: Field3[],\n  points: Point[],\n  Curve: CurveAffine,\n  mode: 'assert-nonzero' | 'assert-zero' = 'assert-nonzero'\n): Point {\n  let n = points.length;\n  assert(scalars.length === n, 'Points and scalars lengths must match');\n  assertPositiveInteger(n, 'Expected at least 1 point and scalar');\n  let useGlv = Curve.hasEndomorphism;\n\n  // TODO dedicated MSM\n  let s = scalars.map(Field3.toBigint);\n  let P = points.map(Point.toBigint);\n  let sum: GroupAffine = Curve.zero;\n  for (let i = 0; i < n; i++) {\n    if (useGlv) {\n      sum = Curve.add(sum, Curve.Endo.scale(P[i], s[i]));\n    } else {\n      sum = Curve.add(sum, Curve.scale(P[i], s[i]));\n    }\n  }\n  if (mode === 'assert-zero') {\n    assert(sum.infinity, 'scalar multiplication: expected zero result');\n    return Point.from(Curve.zero);\n  }\n  assert(!sum.infinity, 'scalar multiplication: expected non-zero result');\n  return Point.from(sum);\n}\n\n/**\n * Multi-scalar multiplication:\n *\n * s_0 * P_0 + ... + s_(n-1) * P_(n-1)\n *\n * where P_i are any points.\n *\n * By default, we prove that the result is not zero.\n *\n * If you set the `mode` parameter to `'assert-zero'`, on the other hand,\n * we assert that the result is zero and just return the constant zero point.\n *\n * Implementation: We double all points together and leverage a precomputed table of size 2^c to avoid all but every cth addition.\n *\n * Note: this algorithm targets a small number of points, like 2 needed for ECDSA verification.\n *\n * TODO: could use lookups for picking precomputed multiples, instead of O(2^c) provable switch\n * TODO: custom bit representation for the scalar that avoids 0, to get rid of the degenerate addition case\n */\nfunction multiScalarMul(\n  scalars: Field3[],\n  points: Point[],\n  Curve: CurveAffine,\n  tableConfigs: ({ windowSize?: number; multiples?: Point[] } | undefined)[] = [],\n  mode: 'assert-nonzero' | 'assert-zero' = 'assert-nonzero',\n  ia?: point\n): Point {\n  let n = points.length;\n  assert(scalars.length === n, 'Points and scalars lengths must match');\n  assertPositiveInteger(n, 'Expected at least 1 point and scalar');\n  let useGlv = Curve.hasEndomorphism;\n\n  // constant case\n  if (scalars.every(Field3.isConstant) && points.every(Point.isConstant)) {\n    return multiScalarMulConstant(scalars, points, Curve, mode);\n  }\n\n  // parse or build point tables\n  let windowSizes = points.map((_, i) => tableConfigs[i]?.windowSize ?? 1);\n  let tables = points.map((P, i) =>\n    getPointTable(Curve, P, windowSizes[i], tableConfigs[i]?.multiples)\n  );\n\n  let maxBits = Curve.Scalar.sizeInBits;\n\n  if (useGlv) {\n    maxBits = Curve.Endo.decomposeMaxBits;\n\n    // decompose scalars and handle signs\n    let n2 = 2 * n;\n    let scalars2: Field3[] = Array(n2);\n    let points2: Point[] = Array(n2);\n    let windowSizes2: number[] = Array(n2);\n    let tables2: Point[][] = Array(n2);\n    let mrcStack: Field[] = [];\n\n    for (let i = 0; i < n; i++) {\n      let [s0, s1] = decomposeNoRangeCheck(Curve, scalars[i]);\n      scalars2[2 * i] = s0.abs;\n      scalars2[2 * i + 1] = s1.abs;\n\n      let table = tables[i];\n      let endoTable = table.map((P, i) => {\n        if (i === 0) return P;\n        let [phiP, betaXBound] = endomorphism(Curve, P);\n        mrcStack.push(betaXBound);\n        return phiP;\n      });\n      tables2[2 * i] = table.map((P) => negateIf(s0.isNegative, P, Curve.modulus));\n      tables2[2 * i + 1] = endoTable.map((P) => negateIf(s1.isNegative, P, Curve.modulus));\n      points2[2 * i] = tables2[2 * i][1];\n      points2[2 * i + 1] = tables2[2 * i + 1][1];\n\n      windowSizes2[2 * i] = windowSizes2[2 * i + 1] = windowSizes[i];\n    }\n    reduceMrcStack(mrcStack);\n    // from now on, everything is the same as if these were the original points and scalars\n    points = points2;\n    tables = tables2;\n    scalars = scalars2;\n    windowSizes = windowSizes2;\n    n = n2;\n  }\n\n  // slice scalars\n  let scalarChunks = scalars.map((s, i) => sliceField3(s, { maxBits, chunkSize: windowSizes[i] }));\n\n  // initialize sum to the initial aggregator, which is expected to be unrelated to any point that this gadget is used with\n  // note: this is a trick to ensure _completeness_ of the gadget\n  // soundness follows because add() and double() are sound, on all inputs that are valid non-zero curve points\n  ia ??= initialAggregator(Curve);\n  let sum = Point.from(ia);\n\n  for (let i = maxBits - 1; i >= 0; i--) {\n    // add in multiple of each point\n    for (let j = 0; j < n; j++) {\n      let windowSize = windowSizes[j];\n      if (i % windowSize === 0) {\n        // pick point to add based on the scalar chunk\n        let sj = scalarChunks[j][i / windowSize];\n        let sjP = windowSize === 1 ? points[j] : arrayGetGeneric(Point.provable, tables[j], sj);\n\n        // ec addition\n        let added = add(sum, sjP, Curve);\n\n        // handle degenerate case (if sj = 0, Gj is all zeros and the add result is garbage)\n        sum = Provable.if(sj.equals(0), Point, sum, added);\n      }\n    }\n\n    if (i === 0) break;\n\n    // jointly double all points\n    // (note: the highest couple of bits will not create any constraints because sum is constant; no need to handle that explicitly)\n    sum = double(sum, Curve);\n  }\n\n  // the sum is now 2^(b-1)*IA + sum_i s_i*P_i\n  // we assert that sum != 2^(b-1)*IA, and add -2^(b-1)*IA to get our result\n  let iaFinal = Curve.scale(Curve.fromNonzero(ia), 1n << BigInt(maxBits - 1));\n  let isZero = equals(sum, iaFinal, Curve);\n\n  if (mode === 'assert-nonzero') {\n    isZero.assertFalse();\n    sum = add(sum, Point.from(Curve.negate(iaFinal)), Curve);\n  } else {\n    isZero.assertTrue();\n    // for type consistency with the 'assert-nonzero' case\n    sum = Point.from(Curve.zero);\n  }\n\n  return sum;\n}\n\nfunction negateIf(condition: Field, P: Point, f: bigint) {\n  let y = Provable.if(Bool.Unsafe.fromField(condition), Field3, ForeignField.negate(P.y, f), P.y);\n  return { x: P.x, y };\n}\n\nfunction endomorphism(Curve: CurveAffine, P: Point) {\n  let beta = Field3.from(Curve.Endo.base);\n  let betaX = ForeignField.mul(beta, P.x, Curve.modulus);\n  return [{ x: betaX, y: P.y }, weakBound(betaX[2], Curve.modulus)] as const;\n}\n\n/**\n * Decompose s = s0 + s1*lambda where s0, s1 are guaranteed to be small\n *\n * Note: This assumes that s0 and s1 are range-checked externally; in scalar multiplication this happens because they are split into chunks.\n */\nfunction decomposeNoRangeCheck(Curve: CurveAffine, s: Field3) {\n  assert(Curve.Endo.decomposeMaxBits < l2, 'decomposed scalars assumed to be < 2*88 bits');\n  // witness s0, s1\n  let witnesses = exists(6, () => {\n    let [s0, s1] = Curve.Endo.decompose(Field3.toBigint(s));\n    let [s00, s01] = split(s0.abs);\n    let [s10, s11] = split(s1.abs);\n    // prettier-ignore\n    return [\n      s0.isNegative ? 1n : 0n, s00, s01,\n      s1.isNegative ? 1n : 0n, s10, s11,\n    ];\n  });\n  let [s0Negative, s00, s01, s1Negative, s10, s11] = witnesses;\n  // we can hard-code highest limb to zero\n  // (in theory this would allow us to hard-code the high quotient limb to zero in the ffmul below, and save 2 RCs.. but not worth it)\n  let s0: Field3 = [s00, s01, Field.from(0n)];\n  let s1: Field3 = [s10, s11, Field.from(0n)];\n  s0Negative.assertBool();\n  s1Negative.assertBool();\n\n  // prove that s1*lambda = s - s0\n  let lambda = Provable.if(\n    Bool.Unsafe.fromField(s1Negative),\n    Field3,\n    Field3.from(Curve.Scalar.negate(Curve.Endo.scalar)),\n    Field3.from(Curve.Endo.scalar)\n  );\n  let rhs = Provable.if(\n    Bool.Unsafe.fromField(s0Negative),\n    Field3,\n    ForeignField.Sum(s).add(s0).finish(Curve.order),\n    ForeignField.Sum(s).sub(s0).finish(Curve.order)\n  );\n  ForeignField.assertMul(s1, lambda, rhs, Curve.order);\n\n  return [\n    { isNegative: s0Negative, abs: s0 },\n    { isNegative: s1Negative, abs: s1 },\n  ] as const;\n}\n\n/**\n * Sign a message hash using ECDSA.\n */\nfunction signEcdsa(Curve: CurveAffine, msgHash: bigint, privateKey: bigint) {\n  let { Scalar } = Curve;\n  let k = Scalar.random();\n  let R = Curve.scale(Curve.one, k);\n  let r = Scalar.mod(R.x);\n  let kInv = Scalar.inverse(k);\n  assert(kInv !== undefined);\n  let s = Scalar.mul(kInv, Scalar.add(msgHash, Scalar.mul(r, privateKey)));\n  return { r, s };\n}\n\n/**\n * Given a point P, create the list of multiples [0, P, 2P, 3P, ..., (2^windowSize-1) * P].\n * This method is provable, but won't create any constraints given a constant point.\n */\nfunction getPointTable(Curve: CurveAffine, P: Point, windowSize: number, table?: Point[]): Point[] {\n  assertPositiveInteger(windowSize, 'invalid window size');\n  let n = 1 << windowSize; // n >= 2\n\n  assert(table === undefined || table.length === n, 'invalid table');\n  if (table !== undefined) return table;\n\n  table = [Point.from(Curve.zero), P];\n  if (n === 2) return table;\n\n  let Pi = double(P, Curve);\n  table.push(Pi);\n  for (let i = 3; i < n; i++) {\n    Pi = add(Pi, P, Curve);\n    table.push(Pi);\n  }\n  return table;\n}\n\n/**\n * For EC scalar multiplication we use an initial point which is subtracted\n * at the end, to avoid encountering the point at infinity.\n *\n * This is a simple hash-to-group algorithm which finds that initial point.\n * It's important that this point has no known discrete logarithm so that nobody\n * can create an invalid proof of EC scaling.\n */\nfunction initialAggregator(Curve: CurveAffine) {\n  // hash that identifies the curve\n  let h = sha256.create();\n  h.update('initial-aggregator');\n  h.update(bigIntToBytes(Curve.modulus));\n  h.update(bigIntToBytes(Curve.order));\n  h.update(bigIntToBytes(Curve.a));\n  h.update(bigIntToBytes(Curve.b));\n  let bytes = h.array();\n\n  // bytes represent a 256-bit number\n  // use that as x coordinate\n  const F = Curve.Field;\n  let x = F.mod(bytesToBigInt(bytes));\n  return simpleMapToCurve(x, Curve);\n}\n\nfunction random(Curve: CurveAffine) {\n  let x = Curve.Field.random();\n  return simpleMapToCurve(x, Curve);\n}\n\n/**\n * Given an x coordinate (base field element), increment it until we find one with\n * a y coordinate that satisfies the curve equation, and return the point.\n *\n * If the curve has a cofactor, multiply by it to get a point in the correct subgroup.\n */\nfunction simpleMapToCurve(x: bigint, Curve: CurveAffine) {\n  const F = Curve.Field;\n  let y: bigint | undefined = undefined;\n\n  // increment x until we find a y coordinate\n  while (y === undefined) {\n    x = F.add(x, 1n);\n    // solve y^2 = x^3 + ax + b\n    let x3 = F.mul(F.square(x), x);\n    let y2 = F.add(x3, F.mul(Curve.a, x) + Curve.b);\n    y = F.sqrt(y2);\n  }\n  let p = { x, y, infinity: false };\n\n  // clear cofactor\n  if (Curve.hasCofactor) {\n    p = Curve.scale(p, Curve.cofactor!);\n  }\n  return p;\n}\n\n// type/conversion helpers\n\nconst Point = {\n  from({ x, y }: point): Point {\n    return { x: Field3.from(x), y: Field3.from(y) };\n  },\n  toBigint({ x, y }: Point) {\n    return { x: Field3.toBigint(x), y: Field3.toBigint(y), infinity: false };\n  },\n  isConstant: (P: Point) => Provable.isConstant(Point, P),\n\n  /**\n   * Random point on the curve.\n   */\n  random(Curve: CurveAffine) {\n    return Point.from(random(Curve));\n  },\n\n  provable: provable({ x: Field3, y: Field3 }),\n};\n\nconst EcdsaSignature = {\n  from({ r, s }: Ecdsa.signature): Ecdsa.Signature {\n    return { r: Field3.from(r), s: Field3.from(s) };\n  },\n  toBigint({ r, s }: Ecdsa.Signature): Ecdsa.signature {\n    return { r: Field3.toBigint(r), s: Field3.toBigint(s) };\n  },\n  isConstant: (S: Ecdsa.Signature) => Provable.isConstant(EcdsaSignature, S),\n\n  /**\n   * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in\n   * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).\n   */\n  fromHex(rawSignature: string): Ecdsa.Signature {\n    let prefix = rawSignature.slice(0, 2);\n    let signature = rawSignature.slice(2, 130);\n    if (prefix !== '0x' || signature.length < 128) {\n      throw Error(\n        `Signature.fromHex(): Invalid signature, expected hex string 0x... of length at least 130.`\n      );\n    }\n    let r = BigInt(`0x${signature.slice(0, 64)}`);\n    let s = BigInt(`0x${signature.slice(64)}`);\n    return EcdsaSignature.from({ r, s });\n  },\n\n  provable: provable({ r: Field3, s: Field3 }),\n};\n\nconst Ecdsa = {\n  sign: signEcdsa,\n  verify: verifyEcdsa,\n  Signature: EcdsaSignature,\n};\n\n// MRC stack\n\nfunction reduceMrcStack(xs: Field[]) {\n  let n = xs.length;\n  let nRemaining = n % 3;\n  let nFull = (n - nRemaining) / 3;\n  for (let i = 0; i < nFull; i++) {\n    multiRangeCheck([xs[3 * i], xs[3 * i + 1], xs[3 * i + 2]]);\n  }\n  let remaining: Field3 = [Field.from(0n), Field.from(0n), Field.from(0n)];\n  for (let i = 0; i < nRemaining; i++) {\n    remaining[i] = xs[3 * nFull + i];\n  }\n  multiRangeCheck(remaining);\n}\n", "import {\n  CurveParams,\n  CurveAffine,\n  createCurveAffine,\n} from '../../../bindings/crypto/elliptic-curve.js';\nimport { ProvablePureExtended } from '../types/struct.js';\nimport { AlmostForeignField, createForeignField } from '../foreign-field.js';\nimport { EllipticCurve, Point } from '../gadgets/elliptic-curve.js';\nimport { Field3 } from '../gadgets/foreign-field.js';\nimport { assert } from '../gadgets/common.js';\nimport { Provable } from '../provable.js';\nimport { provableFromClass } from '../types/provable-derivers.js';\nimport { l2Mask, multiRangeCheck } from '../gadgets/range-check.js';\nimport { Bytes } from '../bytes.js';\n\n// external API\nexport { createForeignCurve, ForeignCurve };\n\n// internal API\nexport { toPoint, FlexiblePoint, ForeignCurveNotNeeded };\n\ntype FlexiblePoint = {\n  x: AlmostForeignField | Field3 | bigint | number;\n  y: AlmostForeignField | Field3 | bigint | number;\n};\nfunction toPoint({ x, y }: ForeignCurve): Point {\n  return { x: x.value, y: y.value };\n}\n\nclass ForeignCurve {\n  x: AlmostForeignField;\n  y: AlmostForeignField;\n\n  /**\n   * Create a new {@link ForeignCurve} from an object representing the (affine) x and y coordinates.\n   *\n   * Note: Inputs must be range checked if they originate from a different field with a different modulus or if they are not constants. Please refer to the {@link ForeignField} constructor comments for more details.\n   *\n   * @example\n   * ```ts\n   * let x = new ForeignCurve({ x: 1n, y: 1n });\n   * ```\n   *\n   * **Important**: By design, there is no way for a `ForeignCurve` to represent the zero point.\n   *\n   * **Warning**: This fails for a constant input which does not represent an actual point on the curve.\n   */\n  constructor(g: {\n    x: AlmostForeignField | Field3 | bigint | number;\n    y: AlmostForeignField | Field3 | bigint | number;\n  }) {\n    this.x = new this.Constructor.Field(g.x);\n    this.y = new this.Constructor.Field(g.y);\n    // don't allow constants that aren't on the curve\n    if (this.isConstant()) {\n      this.assertOnCurve();\n      this.assertInSubgroup();\n    }\n  }\n\n  /**\n   * Coerce the input to a {@link ForeignCurve}.\n   */\n  static from(g: ForeignCurve | FlexiblePoint) {\n    if (g instanceof this) return g;\n    return new this(g);\n  }\n\n  /**\n   * Parses a hexadecimal string representing an uncompressed elliptic curve point and coerces it into a {@link ForeignCurve} point.\n   *\n   * The method extracts the x and y coordinates from the provided hex string and verifies that the resulting point lies on the curve.\n   *\n   * **Note:** This method only supports uncompressed elliptic curve points, which are 65 bytes in total (1-byte prefix + 32 bytes for x + 32 bytes for y).\n   *\n   * @param hex - The hexadecimal string representing the uncompressed elliptic curve point.\n   * @returns - A point on the foreign curve, parsed from the given hexadecimal string.\n   *\n   * @throws - Throws an error if the input is not a valid public key.\n   *\n   * @example\n   * ```ts\n   * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}\n   *\n   * const publicKeyHex = '04f8b8db25c619d0c66b2dc9e97ecbafafae...'; // Example hex string for uncompressed point\n   * const point = Secp256k1.fromHex(publicKeyHex);\n   * ```\n   *\n   * **Important:** This method is only designed to handle uncompressed elliptic curve points in hex format.\n   */\n  static fromHex(hex: string) {\n    // trim the '0x' prefix if present\n    if (hex.startsWith('0x')) {\n      hex = hex.slice(2);\n    }\n\n    const bytes = Bytes.fromHex(hex).toBytes();\n    const sizeInBytes = Math.ceil(this.Bigint.Field.sizeInBits / 8);\n\n    // extract x and y coordinates from the byte array\n    const tail = bytes.subarray(1); // skip the first byte (prefix)\n    const xBytes = tail.subarray(0, sizeInBytes); // first `sizeInBytes` bytes for x-coordinate\n    const yBytes = tail.subarray(sizeInBytes, 2 * sizeInBytes); // next `sizeInBytes` bytes for y-coordinate\n\n    // convert byte arrays to bigint\n    const x = BigInt('0x' + Bytes.from(xBytes).toHex());\n    const y = BigInt('0x' + Bytes.from(yBytes).toHex());\n\n    // construct the point on the curve using the x and y coordinates\n    let P = this.from({ x, y });\n\n    // ensure that the point is on the curve\n    P.assertOnCurve();\n\n    return P;\n  }\n\n  /**\n   * Create a new {@link ForeignCurve} instance from an Ethereum public key in hex format, which may be either compressed or uncompressed.\n   * This method is designed to handle the parsing of public keys as used by the ethers.js library.\n   *\n   * The input should represent the affine x and y coordinates of the point, in hexadecimal format.\n   * Compressed keys are 33 bytes long and begin with 0x02 or 0x03, while uncompressed keys are 65 bytes long and begin with 0x04.\n   *\n   * **Warning:** This method is specifically designed for use with the Secp256k1 curve. Using it with other curves may result in incorrect behavior or errors.\n   * Ensure that the curve setup matches Secp256k1, as shown in the example, to avoid unintended issues.\n   *\n   * @example\n   * ```ts\n   * import { Wallet, Signature, getBytes } from 'ethers';\n   *\n   * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}\n   *\n   * const wallet = Wallet.createRandom();\n   *\n   * const publicKey = Secp256k1.fromEthers(wallet.publicKey.slice(2));\n   * ```\n   *\n   * @param hex - The public key as a hexadecimal string (without the \"0x\" prefix).\n   * @returns A new instance of the curve representing the given public key.\n   */\n  static fromEthers(hex: string) {\n    // trim the '0x' prefix if present\n    if (hex.startsWith('0x')) {\n      hex = hex.slice(2);\n    }\n\n    const bytes = Bytes.fromHex(hex).toBytes(); // convert hex string to Uint8Array\n    const len = bytes.length;\n    const head = bytes[0]; // first byte is the prefix (compression identifier)\n    const tail = bytes.slice(1); // remaining bytes contain the coordinates\n\n    const xBytes = tail.slice(0, 32); // extract the x-coordinate (first 32 bytes)\n    const x = BigInt('0x' + Bytes.from(xBytes).toHex()); // convert Uint8Array to bigint\n\n    let p: { x: bigint; y: bigint } | undefined = undefined;\n\n    // handle compressed points (33 bytes, prefix 0x02 or 0x03)\n    if (len === 33 && [0x02, 0x03].includes(head)) {\n      // ensure x is within the valid field range\n      assert(0n < x && x < this.Bigint.Field.modulus);\n\n      // compute the right-hand side of the curve equation: x\u00B3 + ax + b\n      const crvX = this.Bigint.Field.mod(this.Bigint.Field.mod(x * x) * x + this.Bigint.b);\n      // compute the square root (y-coordinate)\n      let y = this.Bigint.Field.sqrt(crvX)!;\n      const isYOdd = (y & 1n) === 1n; // determine whether y is odd\n      const headOdd = (head & 1) === 1; // determine whether the prefix indicates an odd y\n      if (headOdd !== isYOdd) y = this.Bigint.Field.mod(-y); // adjust y if necessary\n      p = { x, y };\n    }\n\n    // handle uncompressed points (65 bytes, prefix 0x04)\n    if (len === 65 && head === 0x04) {\n      const yBytes = tail.slice(32, 64); // extract the y-coordinate (next 32 bytes)\n      p = { x, y: BigInt('0x' + Bytes.from(yBytes).toHex()) };\n    }\n\n    const P = this.from(p!); // create the curve point from the parsed coordinates\n    P.assertOnCurve(); // verify the point lies on the curve\n\n    return P;\n  }\n\n  /**\n   * The constant generator point.\n   */\n  static get generator() {\n    return new this(this.Bigint.one);\n  }\n  /**\n   * The size of the curve's base field.\n   */\n  static get modulus() {\n    return this.Bigint.modulus;\n  }\n  /**\n   * The size of the curve's base field.\n   */\n  get modulus() {\n    return this.Constructor.Bigint.modulus;\n  }\n\n  /**\n   * @internal\n   * Checks whether this curve point is constant.\n   *\n   * See {@link FieldVar} to understand constants vs variables.\n   */\n  isConstant() {\n    return Provable.isConstant(this.Constructor, this);\n  }\n\n  /**\n   * Convert this curve point to a point with bigint coordinates.\n   */\n  toBigint() {\n    return this.Constructor.Bigint.fromNonzero({\n      x: this.x.toBigInt(),\n      y: this.y.toBigInt(),\n    });\n  }\n\n  /**\n   * Elliptic curve addition.\n   *\n   * ```ts\n   * let r = p.add(q); // r = p + q\n   * ```\n   *\n   * **Important**: this is _incomplete addition_ and does not handle the degenerate cases:\n   * - Inputs are equal, `g = h` (where you would use {@link double}).\n   *   In this case, the result of this method is garbage and can be manipulated arbitrarily by a malicious prover.\n   * - Inputs are inverses of each other, `g = -h`, so that the result would be the zero point.\n   *   In this case, the proof fails.\n   *\n   * If you want guaranteed soundness regardless of the input, use {@link addSafe} instead.\n   *\n   * @throws if the inputs are inverses of each other.\n   */\n  add(h: ForeignCurve | FlexiblePoint) {\n    let Curve = this.Constructor.Bigint;\n    let h_ = this.Constructor.from(h);\n    let p = EllipticCurve.add(toPoint(this), toPoint(h_), Curve);\n    return new this.Constructor(p);\n  }\n\n  /**\n   * Safe elliptic curve addition.\n   *\n   * This is the same as {@link add}, but additionally proves that the inputs are not equal.\n   * Therefore, the method is guaranteed to either fail or return a valid addition result.\n   *\n   * **Beware**: this is more expensive than {@link add}, and is still incomplete in that\n   * it does not succeed on equal or inverse inputs.\n   *\n   * @throws if the inputs are equal or inverses of each other.\n   */\n  addSafe(h: ForeignCurve | FlexiblePoint) {\n    let h_ = this.Constructor.from(h);\n\n    // prove that we have x1 != x2 => g != +-h\n    let x1 = this.x.assertCanonical();\n    let x2 = h_.x.assertCanonical();\n    x1.equals(x2).assertFalse();\n\n    return this.add(h_);\n  }\n\n  /**\n   * Elliptic curve doubling.\n   *\n   * @example\n   * ```ts\n   * let r = p.double(); // r = 2 * p\n   * ```\n   */\n  double() {\n    let Curve = this.Constructor.Bigint;\n    let p = EllipticCurve.double(toPoint(this), Curve);\n    return new this.Constructor(p);\n  }\n\n  /**\n   * Elliptic curve negation.\n   *\n   * @example\n   * ```ts\n   * let r = p.negate(); // r = -p\n   * ```\n   */\n  negate(): ForeignCurve {\n    return new this.Constructor({ x: this.x, y: this.y.neg() });\n  }\n\n  /**\n   * Elliptic curve scalar multiplication, where the scalar is represented as a {@link ForeignField} element.\n   *\n   * **Important**: this proves that the result of the scalar multiplication is not the zero point.\n   *\n   * @throws if the scalar multiplication results in the zero point; for example, if the scalar is zero.\n   *\n   * @example\n   * ```ts\n   * let r = p.scale(s); // r = s * p\n   * ```\n   */\n  scale(scalar: AlmostForeignField | bigint | number) {\n    let Curve = this.Constructor.Bigint;\n    let scalar_ = this.Constructor.Scalar.from(scalar);\n    let p = EllipticCurve.scale(scalar_.value, toPoint(this), Curve);\n    return new this.Constructor(p);\n  }\n\n  static assertOnCurve(g: ForeignCurve) {\n    EllipticCurve.assertOnCurve(toPoint(g), this.Bigint);\n  }\n\n  /**\n   * Assert that this point lies on the elliptic curve, which means it satisfies the equation\n   * `y^2 = x^3 + ax + b`\n   */\n  assertOnCurve() {\n    this.Constructor.assertOnCurve(this);\n  }\n\n  static assertInSubgroup(g: ForeignCurve) {\n    if (this.Bigint.hasCofactor) {\n      EllipticCurve.assertInSubgroup(toPoint(g), this.Bigint);\n    }\n  }\n\n  /**\n   * Assert that this point lies in the subgroup defined by `order*P = 0`.\n   *\n   * Note: this is a no-op if the curve has cofactor equal to 1. Otherwise\n   * it performs the full scalar multiplication `order*P` and is expensive.\n   */\n  assertInSubgroup() {\n    this.Constructor.assertInSubgroup(this);\n  }\n\n  /**\n   * Check that this is a valid element of the target subgroup of the curve:\n   * - Check that the coordinates are valid field elements\n   * - Use {@link assertOnCurve()} to check that the point lies on the curve\n   * - If the curve has cofactor unequal to 1, use {@link assertInSubgroup()}.\n   */\n  static check(g: ForeignCurveNotNeeded) {\n    multiRangeCheck(g.x.value);\n    multiRangeCheck(g.y.value);\n    this.assertOnCurve(g); // this does almost reduced checks on x and y\n    this.assertInSubgroup(g);\n  }\n\n  // dynamic subclassing infra\n  get Constructor() {\n    return this.constructor as typeof ForeignCurve;\n  }\n  static _Bigint?: CurveAffine;\n  static _Field?: typeof AlmostForeignField;\n  static _Scalar?: typeof AlmostForeignField;\n  static _provable?: ProvablePureExtended<\n    ForeignCurve,\n    { x: bigint; y: bigint },\n    { x: string; y: string }\n  >;\n\n  /**\n   * Curve arithmetic on JS bigints.\n   */\n  static get Bigint() {\n    assert(this._Bigint !== undefined, 'ForeignCurve not initialized');\n    return this._Bigint;\n  }\n  /**\n   * The base field of this curve as a {@link ForeignField}.\n   */\n  static get Field() {\n    assert(this._Field !== undefined, 'ForeignCurve not initialized');\n    return this._Field;\n  }\n  /**\n   * The scalar field of this curve as a {@link ForeignField}.\n   */\n  static get Scalar() {\n    assert(this._Scalar !== undefined, 'ForeignCurve not initialized');\n    return this._Scalar;\n  }\n  /**\n   * `Provable<ForeignCurve>`\n   */\n  static get provable() {\n    assert(this._provable !== undefined, 'ForeignCurve not initialized');\n    return this._provable;\n  }\n}\n\n/**\n * @see: {@link ForeignCurve}\n */\nclass ForeignCurveNotNeeded extends ForeignCurve {\n  constructor(g: {\n    x: AlmostForeignField | Field3 | bigint | number;\n    y: AlmostForeignField | Field3 | bigint | number;\n  }) {\n    super(g);\n  }\n\n  static check(g: ForeignCurveNotNeeded) {\n    multiRangeCheck(g.x.value);\n    multiRangeCheck(g.y.value);\n    this.assertOnCurve(g);\n    this.assertInSubgroup(g);\n  }\n}\n\n/**\n * Create a class representing an elliptic curve group, which is different from the native {@link Group}.\n *\n * ```ts\n * const Curve = createForeignCurve(Crypto.CurveParams.Secp256k1);\n * ```\n *\n * `createForeignCurve(params)` takes curve parameters `CurveParams` as input.\n * We support `modulus` and `order` to be prime numbers up to 259 bits.\n *\n * The returned {@link ForeignCurveNotNeeded} class represents a _non-zero curve point_ and supports standard\n * elliptic curve operations like point addition and scalar multiplication.\n *\n * {@link ForeignCurveNotNeeded} also includes to associated foreign fields: `ForeignCurve.Field` and `ForeignCurve.Scalar`, see {@link createForeignField}.\n */\nfunction createForeignCurve(params: CurveParams): typeof ForeignCurve {\n  assert(params.modulus > l2Mask + 1n, 'Base field moduli smaller than 2^176 are not supported');\n\n  const FieldUnreduced = createForeignField(params.modulus);\n  const ScalarUnreduced = createForeignField(params.order);\n  class Field extends FieldUnreduced.AlmostReduced {}\n  class Scalar extends ScalarUnreduced.AlmostReduced {}\n\n  const BigintCurve = createCurveAffine(params);\n\n  class Curve extends ForeignCurve {\n    static _Bigint = BigintCurve;\n    static _Field = Field;\n    static _Scalar = Scalar;\n    static _provable = provableFromClass(Curve, { x: Field, y: Field });\n  }\n\n  return Curve;\n}\n", "import { Field } from '../field.js';\nimport { Gadgets } from '../gadgets/gadgets.js';\nimport { assert } from '../../util/errors.js';\nimport { FlexibleBytes } from '../bytes.js';\nimport { UInt8 } from '../int.js';\nimport { Bytes } from '../wrapped-classes.js';\nimport { bytesToWords, wordsToBytes } from '../gadgets/bit-slices.js';\n\nexport { Keccak };\n\nconst Keccak = {\n  /**\n   * Implementation of [NIST SHA-3](https://csrc.nist.gov/pubs/fips/202/final) Hash Function.\n   * Supports output lengths of 256, 384, or 512 bits.\n   *\n   * Applies the SHA-3 hash function to a list of big-endian byte-sized {@link Field} elements, flexible to handle varying output lengths (256, 384, 512 bits) as specified.\n   *\n   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.\n   *\n   * Produces an output of {@link Bytes} that conforms to the chosen bit length.\n   * Both input and output bytes are big-endian.\n   *\n   * @param len - Desired output length in bits. Valid options: 256, 384, 512.\n   * @param message - Big-endian {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest256 = Keccak.nistSha3(256, preimage);\n   * let digest384 = Keccak.nistSha3(384, preimage);\n   * let digest512 = Keccak.nistSha3(512, preimage);\n   * ```\n   *\n   */\n  nistSha3(len: 256 | 384 | 512, message: FlexibleBytes) {\n    return nistSha3(len, Bytes.from(message));\n  },\n  /**\n   * Ethereum-Compatible Keccak-256 Hash Function.\n   * This is a specialized variant of {@link Keccak.preNist} configured for a 256-bit output length.\n   *\n   * Primarily used in Ethereum for hashing transactions, messages, and other types of payloads.\n   *\n   * The function accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.\n   *\n   * Produces an output of {@link Bytes} of length 32. Both input and output bytes are big-endian.\n   *\n   * @param message - Big-endian {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest = Keccak.ethereum(preimage);\n   * ```\n   */\n  ethereum(message: FlexibleBytes) {\n    return ethereum(Bytes.from(message));\n  },\n  /**\n   * Implementation of [pre-NIST Keccak](https://keccak.team/keccak.html) hash function.\n   * Supports output lengths of 256, 384, or 512 bits.\n   *\n   * Keccak won the SHA-3 competition and was slightly altered before being standardized as SHA-3 by NIST in 2015.\n   * This variant was used in Ethereum before the NIST standardization, by specifying `len` as 256 bits you can obtain the same hash function as used by Ethereum {@link Keccak.ethereum}.\n   *\n   * The function applies the pre-NIST Keccak hash function to a list of byte-sized {@link Field} elements and is flexible to handle varying output lengths (256, 384, 512 bits) as specified.\n   *\n   * {@link Keccak.preNist} accepts {@link Bytes} as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using {@link Gadgets.rangeCheck8}).\n   * Alternatively, you can pass plain `number[]` of `Uint8Array` to perform a hash outside provable code.\n   *\n   * Produces an output of {@link Bytes} that conforms to the chosen bit length.\n   * Both input and output bytes are big-endian.\n   *\n   * @param len - Desired output length in bits. Valid options: 256, 384, 512.\n   * @param message - Big-endian {@link Bytes} representing the message to hash.\n   *\n   * ```ts\n   * let preimage = Bytes.fromString(\"hello world\");\n   * let digest256 = Keccak.preNist(256, preimage);\n   * let digest384 = Keccak.preNist(384, preimage);\n   * let digest512= Keccak.preNist(512, preimage);\n   * ```\n   *\n   */\n  preNist(len: 256 | 384 | 512, message: FlexibleBytes) {\n    return preNist(len, Bytes.from(message));\n  },\n};\n\n// KECCAK CONSTANTS\n\n// Length of the square matrix side of Keccak states\nconst KECCAK_DIM = 5;\n\n// Value `l` in Keccak, ranges from 0 to 6 and determines the lane width\nconst KECCAK_ELL = 6;\n\n// Width of a lane of the state, meaning the length of each word in bits (64)\nconst KECCAK_WORD = 2 ** KECCAK_ELL;\n\n// Number of bytes that fit in a word (8)\nconst BYTES_PER_WORD = KECCAK_WORD / 8;\n\n// Length of the state in words, 5x5 = 25\nconst KECCAK_STATE_LENGTH_WORDS = KECCAK_DIM ** 2;\n\n// Length of the state in bits, meaning the 5x5 matrix of words in bits (1600)\nconst KECCAK_STATE_LENGTH = KECCAK_STATE_LENGTH_WORDS * KECCAK_WORD;\n\n// Length of the state in bytes, meaning the 5x5 matrix of words in bytes (200)\nconst KECCAK_STATE_LENGTH_BYTES = KECCAK_STATE_LENGTH / 8;\n\n// Creates the 5x5 table of rotation offset for Keccak modulo 64\n//  | i \\ j |  0 |  1 |  2 |  3 |  4 |\n//  | ----- | -- | -- | -- | -- | -- |\n//  | 0     |  0 | 36 |  3 | 41 | 18 |\n//  | 1     |  1 | 44 | 10 | 45 |  2 |\n//  | 2     | 62 |  6 | 43 | 15 | 61 |\n//  | 3     | 28 | 55 | 25 | 21 | 56 |\n//  | 4     | 27 | 20 | 39 |  8 | 14 |\nconst ROT_TABLE = [\n  [0, 36, 3, 41, 18],\n  [1, 44, 10, 45, 2],\n  [62, 6, 43, 15, 61],\n  [28, 55, 25, 21, 56],\n  [27, 20, 39, 8, 14],\n];\n\n// Round constants for Keccak\n// From https://keccak.team/files/Keccak-reference-3.0.pdf\nconst ROUND_CONSTANTS = [\n  0x0000000000000001n,\n  0x0000000000008082n,\n  0x800000000000808an,\n  0x8000000080008000n,\n  0x000000000000808bn,\n  0x0000000080000001n,\n  0x8000000080008081n,\n  0x8000000000008009n,\n  0x000000000000008an,\n  0x0000000000000088n,\n  0x0000000080008009n,\n  0x000000008000000an,\n  0x000000008000808bn,\n  0x800000000000008bn,\n  0x8000000000008089n,\n  0x8000000000008003n,\n  0x8000000000008002n,\n  0x8000000000000080n,\n  0x000000000000800an,\n  0x800000008000000an,\n  0x8000000080008081n,\n  0x8000000000008080n,\n  0x0000000080000001n,\n  0x8000000080008008n,\n];\n\n// KECCAK HASH FUNCTION\n\n// Computes the number of required extra bytes to pad a message of length bytes\nfunction bytesToPad(rate: number, length: number): number {\n  return rate - (length % rate);\n}\n\n// Pads a message M as:\n// M || pad[x](|M|)\n// The padded message will start with the message argument followed by the padding rule (below) to fulfill a length that is a multiple of rate (in bytes).\n// If nist is true, then the padding rule is 0x06 ..0*..1.\n// If nist is false, then the padding rule is 10*1.\nfunction pad(message: UInt8[], rate: number, nist: boolean): UInt8[] {\n  // Find out desired length of the padding in bytes\n  // If message is already rate bits, need to pad full rate again\n  const extraBytes = bytesToPad(rate, message.length);\n\n  // 0x06 0x00 ... 0x00 0x80 or 0x86\n  const first = nist ? 0x06n : 0x01n;\n  const last = 0x80n;\n\n  // Create the padding vector\n  const pad = Array<UInt8>(extraBytes).fill(UInt8.from(0));\n  pad[0] = UInt8.from(first);\n  pad[extraBytes - 1] = pad[extraBytes - 1].add(last);\n\n  // Return the padded message\n  return [...message, ...pad];\n}\n\n// ROUND TRANSFORMATION\n\n// First algorithm in the compression step of Keccak for 64-bit words.\n// C[i] = A[i,0] xor A[i,1] xor A[i,2] xor A[i,3] xor A[i,4]\n// D[i] = C[i-1] xor ROT(C[i+1], 1)\n// E[i,j] = A[i,j] xor D[i]\n// In the Keccak reference, it corresponds to the `theta` algorithm.\n// We use the first index of the state array as the i coordinate and the second index as the j coordinate.\nconst theta = (state: Field[][]): Field[][] => {\n  const stateA = state;\n\n  // XOR the elements of each row together\n  // for all i in {0..4}: C[i] = A[i,0] xor A[i,1] xor A[i,2] xor A[i,3] xor A[i,4]\n  const stateC = stateA.map((row) => row.reduce(xor));\n\n  // for all i in {0..4}: D[i] = C[i-1] xor ROT(C[i+1], 1)\n  const stateD = Array.from({ length: KECCAK_DIM }, (_, i) =>\n    xor(\n      stateC[(i + KECCAK_DIM - 1) % KECCAK_DIM],\n      Gadgets.rotate64(stateC[(i + 1) % KECCAK_DIM], 1, 'left')\n    )\n  );\n\n  // for all i in {0..4} and j in {0..4}: E[i,j] = A[i,j] xor D[i]\n  const stateE = stateA.map((row, index) => row.map((elem) => xor(elem, stateD[index])));\n\n  return stateE;\n};\n\n// Second and third steps in the compression step of Keccak for 64-bit words.\n// pi: A[i,j] = ROT(E[i,j], r[i,j])\n// rho: A[i,j] = A'[j, 2i+3j mod KECCAK_DIM]\n// piRho: B[j,2i+3j] = ROT(E[i,j], r[i,j])\n// which is equivalent to the `rho` algorithm followed by the `pi` algorithm in the Keccak reference as follows:\n// rho:\n// A[0,0] = a[0,0]\n// | i |  =  | 1 |\n// | j |  =  | 0 |\n// for t = 0 to 23 do\n//   A[i,j] = ROT(a[i,j], (t+1)(t+2)/2 mod 64)))\n//   | i |  =  | 0  1 |   | i |\n//   |   |  =  |      | * |   |\n//   | j |  =  | 2  3 |   | j |\n// end for\n// pi:\n// for i = 0 to 4 do\n//   for j = 0 to 4 do\n//     | I |  =  | 0  1 |   | i |\n//     |   |  =  |      | * |   |\n//     | J |  =  | 2  3 |   | j |\n//     A[I,J] = a[i,j]\n//   end for\n// end for\n// We use the first index of the state array as the i coordinate and the second index as the j coordinate.\nfunction piRho(state: Field[][]): Field[][] {\n  const stateE = state;\n  const stateB = State.zeros();\n\n  // for all i in {0..4} and j in {0..4}: B[j,2i+3j] = ROT(E[i,j], r[i,j])\n  for (let i = 0; i < KECCAK_DIM; i++) {\n    for (let j = 0; j < KECCAK_DIM; j++) {\n      stateB[j][(2 * i + 3 * j) % KECCAK_DIM] = Gadgets.rotate64(\n        stateE[i][j],\n        ROT_TABLE[i][j],\n        'left'\n      );\n    }\n  }\n\n  return stateB;\n}\n\n// Fourth step of the compression function of Keccak for 64-bit words.\n// F[i,j] = B[i,j] xor ((not B[i+1,j]) and B[i+2,j])\n// It corresponds to the chi algorithm in the Keccak reference.\n// for j = 0 to 4 do\n//   for i = 0 to 4 do\n//     A[i,j] = a[i,j] xor ((not a[i+1,j]) and a[i+2,j])\n//   end for\n// end for\nfunction chi(state: Field[][]): Field[][] {\n  const stateB = state;\n  const stateF = State.zeros();\n\n  // for all i in {0..4} and j in {0..4}: F[i,j] = B[i,j] xor ((not B[i+1,j]) and B[i+2,j])\n  for (let i = 0; i < KECCAK_DIM; i++) {\n    for (let j = 0; j < KECCAK_DIM; j++) {\n      stateF[i][j] = xor(\n        stateB[i][j],\n        Gadgets.and(\n          // We can use unchecked NOT because the length of the input is constrained to be 64 bits thanks to the fact that it is the output of a previous Xor64\n          Gadgets.not(stateB[(i + 1) % KECCAK_DIM][j], KECCAK_WORD, false),\n          stateB[(i + 2) % KECCAK_DIM][j],\n          KECCAK_WORD\n        )\n      );\n    }\n  }\n\n  return stateF;\n}\n\n// Fifth step of the permutation function of Keccak for 64-bit words.\n// It takes the word located at the position (0,0) of the state and XORs it with the round constant.\nfunction iota(state: Field[][], rc: bigint): Field[][] {\n  const stateG = state;\n\n  stateG[0][0] = xor(stateG[0][0], Field.from(rc));\n\n  return stateG;\n}\n\n// One round of the Keccak permutation function.\n// iota o chi o pi o rho o theta\nfunction round(state: Field[][], rc: bigint): Field[][] {\n  const stateA = state;\n  const stateE = theta(stateA);\n  const stateB = piRho(stateE);\n  const stateF = chi(stateB);\n  const stateD = iota(stateF, rc);\n  return stateD;\n}\n\n// Keccak permutation function with a constant number of rounds\nfunction permutation(state: Field[][], rcs: bigint[]): Field[][] {\n  return rcs.reduce((state, rc) => round(state, rc), state);\n}\n\n// KECCAK SPONGE\n\n// Absorb padded message into a keccak state with given rate and capacity\nfunction absorb(paddedMessage: Field[], capacity: number, rate: number, rc: bigint[]): State {\n  assert(\n    rate + capacity === KECCAK_STATE_LENGTH_WORDS,\n    `invalid rate or capacity (rate + capacity should be ${KECCAK_STATE_LENGTH_WORDS})`\n  );\n  assert(\n    paddedMessage.length % rate === 0,\n    'invalid padded message length (should be multiple of rate)'\n  );\n\n  let state = State.zeros();\n\n  // array of capacity zero words\n  const zeros = Array(capacity).fill(Field.from(0));\n\n  for (let idx = 0; idx < paddedMessage.length; idx += rate) {\n    // split into blocks of rate words\n    const block = paddedMessage.slice(idx, idx + rate);\n    // pad the block with 0s to up to KECCAK_STATE_LENGTH_WORDS words\n    const paddedBlock = block.concat(zeros);\n    // convert the padded block to a Keccak state\n    const blockState = State.fromWords(paddedBlock);\n    // xor the state with the padded block\n    const stateXor = State.xor(state, blockState);\n    // apply the permutation function to the xored state\n    state = permutation(stateXor, rc);\n  }\n  return state;\n}\n\n// Squeeze state until it has a desired length in words\nfunction squeeze(state: State, length: number, rate: number): Field[] {\n  // number of squeezes\n  const squeezes = Math.floor(length / rate) + 1;\n  assert(squeezes === 1, 'squeezes should be 1');\n\n  // Obtain the hash selecting the first `length` words of the output array\n  const words = State.toWords(state);\n  const hashed = words.slice(0, length);\n  return hashed;\n}\n\n// Keccak sponge function for 200 bytes of state width\nfunction sponge(paddedMessage: Field[], length: number, capacity: number, rate: number): Field[] {\n  // check that the padded message is a multiple of rate\n  assert(paddedMessage.length % rate === 0, 'Invalid padded message length');\n\n  // absorb\n  const state = absorb(paddedMessage, capacity, rate, ROUND_CONSTANTS);\n\n  // squeeze\n  const hashed = squeeze(state, length, rate);\n  return hashed;\n}\n\n// Keccak hash function with input message passed as list of Field bytes.\n// The message will be parsed as follows:\n// - the first byte of the message will be the least significant byte of the first word of the state (A[0][0])\n// - the 10*1 pad will take place after the message, until reaching the bit length rate.\n// - then, {0} pad will take place to finish the 200 bytes of the state.\nfunction hash(message: Bytes, length: number, capacity: number, nistVersion: boolean): UInt8[] {\n  // Throw errors if used improperly\n  assert(capacity > 0, 'capacity must be positive');\n  assert(\n    capacity < KECCAK_STATE_LENGTH_BYTES,\n    `capacity must be less than ${KECCAK_STATE_LENGTH_BYTES}`\n  );\n  assert(length > 0, 'length must be positive');\n\n  // convert capacity and length to word units\n  assert(capacity % BYTES_PER_WORD === 0, 'length must be a multiple of 8');\n  capacity /= BYTES_PER_WORD;\n  assert(length % BYTES_PER_WORD === 0, 'length must be a multiple of 8');\n  length /= BYTES_PER_WORD;\n\n  const rate = KECCAK_STATE_LENGTH_WORDS - capacity;\n\n  // apply padding, convert to words, and hash\n  const paddedBytes = pad(message.bytes, rate * BYTES_PER_WORD, nistVersion);\n  const padded = bytesToWords(paddedBytes);\n\n  const hash = sponge(padded, length, capacity, rate);\n  const hashBytes = wordsToBytes(hash);\n\n  return hashBytes;\n}\n\n// Gadget for NIST SHA-3 function for output lengths 256/384/512.\nfunction nistSha3(len: 256 | 384 | 512, message: Bytes): Bytes {\n  let bytes = hash(message, len / 8, len / 4, true);\n  return BytesOfBitlength[len].from(bytes);\n}\n\n// Gadget for pre-NIST SHA-3 function for output lengths 256/384/512.\n// Note that when calling with output length 256 this is equivalent to the ethereum function\nfunction preNist(len: 256 | 384 | 512, message: Bytes): Bytes {\n  let bytes = hash(message, len / 8, len / 4, false);\n  return BytesOfBitlength[len].from(bytes);\n}\n\n// Gadget for Keccak hash function for the parameters used in Ethereum.\nfunction ethereum(message: Bytes): Bytes {\n  return preNist(256, message);\n}\n\n// FUNCTIONS ON KECCAK STATE\n\ntype State = Field[][];\nconst State = {\n  /**\n   * Create a state of all zeros\n   */\n  zeros(): State {\n    return Array.from(Array(KECCAK_DIM), (_) => Array(KECCAK_DIM).fill(Field.from(0)));\n  },\n\n  /**\n   * Flatten state to words\n   */\n  toWords(state: State): Field[] {\n    const words = Array<Field>(KECCAK_STATE_LENGTH_WORDS);\n    for (let j = 0; j < KECCAK_DIM; j++) {\n      for (let i = 0; i < KECCAK_DIM; i++) {\n        words[KECCAK_DIM * j + i] = state[i][j];\n      }\n    }\n    return words;\n  },\n\n  /**\n   * Compose words to state\n   */\n  fromWords(words: Field[]): State {\n    const state = State.zeros();\n    for (let j = 0; j < KECCAK_DIM; j++) {\n      for (let i = 0; i < KECCAK_DIM; i++) {\n        state[i][j] = words[KECCAK_DIM * j + i];\n      }\n    }\n    return state;\n  },\n\n  /**\n   * XOR two states together and return the result\n   */\n  xor(a: State, b: State): State {\n    assert(\n      a.length === KECCAK_DIM && a[0].length === KECCAK_DIM,\n      `invalid \\`a\\` dimensions (should be ${KECCAK_DIM})`\n    );\n    assert(\n      b.length === KECCAK_DIM && b[0].length === KECCAK_DIM,\n      `invalid \\`b\\` dimensions (should be ${KECCAK_DIM})`\n    );\n\n    // Calls xor() on each pair (i,j) of the states input1 and input2 and outputs the output Fields as a new matrix\n    return a.map((row, i) => row.map((x, j) => xor(x, b[i][j])));\n  },\n};\n\n// AUXILIARY TYPES\n\nclass Bytes32 extends Bytes(32) {}\nclass Bytes48 extends Bytes(48) {}\nclass Bytes64 extends Bytes(64) {}\n\nconst BytesOfBitlength = {\n  256: Bytes32,\n  384: Bytes48,\n  512: Bytes64,\n};\n\n// xor which avoids doing anything on 0 inputs\n// (but doesn't range-check the other input in that case)\nfunction xor(x: Field, y: Field): Field {\n  if (x.isConstant() && x.toBigInt() === 0n) return y;\n  if (y.isConstant() && y.toBigInt() === 0n) return x;\n  return Gadgets.xor(x, y, 64);\n}\n", "import { provableFromClass } from '../types/provable-derivers.js';\nimport { CurveParams } from '../../../bindings/crypto/elliptic-curve.js';\nimport { ProvablePureExtended } from '../types/struct.js';\nimport { FlexiblePoint, ForeignCurve, createForeignCurve, toPoint } from './foreign-curve.js';\nimport { AlmostForeignField } from '../foreign-field.js';\nimport { assert } from '../gadgets/common.js';\nimport { Field3 } from '../gadgets/foreign-field.js';\nimport { Ecdsa } from '../gadgets/elliptic-curve.js';\nimport { l, multiRangeCheck } from '../gadgets/range-check.js';\nimport { Keccak } from './keccak.js';\nimport { Bytes } from '../wrapped-classes.js';\nimport { UInt8 } from '../int.js';\nimport type { Bool } from '../bool.js';\n\n// external API\nexport { createEcdsa, EcdsaSignature };\n\ntype FlexibleSignature =\n  | EcdsaSignature\n  | {\n      r: AlmostForeignField | Field3 | bigint | number;\n      s: AlmostForeignField | Field3 | bigint | number;\n    };\n\nclass EcdsaSignature {\n  r: AlmostForeignField;\n  s: AlmostForeignField;\n\n  /**\n   * Create a new {@link EcdsaSignature} from an object containing the scalars r and s.\n   *\n   * Note: Inputs must be range checked if they originate from a different field with a different modulus or if they are not constants. Please refer to the {@link ForeignField} constructor comments for more details.\n   */\n  constructor(signature: {\n    r: AlmostForeignField | Field3 | bigint | number;\n    s: AlmostForeignField | Field3 | bigint | number;\n  }) {\n    this.r = new this.Constructor.Curve.Scalar(signature.r);\n    this.s = new this.Constructor.Curve.Scalar(signature.s);\n  }\n\n  /**\n   * Coerce the input to a {@link EcdsaSignature}.\n   */\n  static from(signature: FlexibleSignature): EcdsaSignature {\n    if (signature instanceof this) return signature;\n    return new this(signature);\n  }\n\n  /**\n   * Create an {@link EcdsaSignature} from a raw 130-char hex string as used in\n   * [Ethereum transactions](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).\n   */\n  static fromHex(rawSignature: string): EcdsaSignature {\n    let s = Ecdsa.Signature.fromHex(rawSignature);\n    return new this(s);\n  }\n\n  /**\n   * Convert this signature to an object with bigint fields.\n   */\n  toBigInt() {\n    return { r: this.r.toBigInt(), s: this.s.toBigInt() };\n  }\n\n  /**\n   * Verify the ECDSA signature given the message (an array of bytes) and public key (a {@link Curve} point).\n   *\n   * **Important:** This method returns a {@link Bool} which indicates whether the signature is valid.\n   * So, to actually prove validity of a signature, you need to assert that the result is true.\n   *\n   * @throws if one of the signature scalars is zero or if the public key is not on the curve.\n   *\n   * @example\n   * ```ts\n   * // create classes for your curve\n   * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}\n   * class Scalar extends Secp256k1.Scalar {}\n   * class Ecdsa extends createEcdsa(Secp256k1) {}\n   *\n   * let message = 'my message';\n   * let messageBytes = new TextEncoder().encode(message);\n   *\n   * // outside provable code: create inputs\n   * let privateKey = Scalar.random();\n   * let publicKey = Secp256k1.generator.scale(privateKey);\n   * let signature = Ecdsa.sign(messageBytes, privateKey.toBigInt());\n   *\n   * // ...\n   * // in provable code: create input witnesses (or use method inputs, or constants)\n   * let pk = Provable.witness(Secp256k1, () => publicKey);\n   * let msg = Provable.witness(Provable.Array(Field, 9), () => messageBytes.map(Field));\n   * let sig = Provable.witness(Ecdsa, () => signature);\n   *\n   * // verify signature\n   * let isValid = sig.verify(msg, pk);\n   * isValid.assertTrue('signature verifies');\n   * ```\n   */\n  verify(message: Bytes, publicKey: FlexiblePoint): Bool {\n    let msgHashBytes = Keccak.ethereum(message);\n    return this.verifySignedHash(msgHashBytes, publicKey);\n  }\n\n  /**\n   * Verify an ECDSA signature generated by the ethers.js library, given the message (as a byte array) and a public key (a {@link Curve} point).\n   * The message digest used for signing follows the format defined in EIP-191, with the Ethereum-specific prefix.\n   *\n   * **Important:** This method returns a {@link Bool} which indicates whether the signature is valid.\n   * So, to actually prove validity of a signature, you need to assert that the result is true.\n   *\n   * **Note:** This method is specifically designed to verify signatures generated by ethers.js.\n   * Ensure that the curve being used is Secp256k1, as demonstrated in the example.\n   *\n   * @throws An error will be thrown if one of the signature scalars is zero or if the public key does not lie on the curve.\n   *\n   * @example\n   * ```ts\n   * import { Wallet } from 'ethers';\n   *\n   * // create the class for Secp256k1 curve\n   * class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}\n   * class Ecdsa extends createEcdsa(Secp256k1) {}\n   *\n   * // outside provable code: create inputs\n   * let message = 'my message';\n   * let signatureRaw = await wallet.signMessage(message);\n   * let compressedPublicKey = wallet.signingKey.compressedPublicKey;\n   *\n   * // this also works for uncompressed public keys (wallet.signingKey.publicKey)\n   * let publicKey = Secp256k1.fromEthers(compressedPublicKey.slice(2));\n   * let signature = Ecdsa.fromHex(signatureRaw);\n   *\n   * // ...\n   * // in provable code: create input witnesses (or use method inputs, or constants)\n   * // and verify the signature\n   * let isValid = signature.verifyEthers(Bytes.fromString(message), publicKey);\n   * isValid.assertTrue('signature verifies');\n   * ```\n   *\n   * @param message - The original message as a byte array.\n   * @param publicKey - The public key as a point on the Secp256k1 elliptic curve.\n   * @returns - A {@link Bool} indicating the validity of the signature.\n   */\n  verifyEthers(message: Bytes, publicKey: FlexiblePoint): Bool {\n    const MessagePrefix = '\\x19Ethereum Signed Message:\\n'; // Ethereum-specific prefix for signing\n    const msgHashBytes = Keccak.ethereum([\n      ...Bytes.fromString(MessagePrefix).bytes, // prefix for Ethereum signed messages\n      ...Bytes.fromString(String(message.length)).bytes, // message length as string\n      ...message.bytes, // actual message bytes\n    ]);\n    return this.verifySignedHash(msgHashBytes, publicKey);\n  }\n\n  /**\n   * Verify the ECDSA signature given the message hash (a {@link Scalar}) and public key (a {@link Curve} point).\n   *\n   * This is a building block of {@link EcdsaSignature.verify}, where the input message is also hashed.\n   * In contrast, this method just takes the message hash (a curve scalar, or the output bytes of a hash function)\n   * as input, giving you flexibility in choosing the hashing algorithm.\n   */\n  verifySignedHash(msgHash: AlmostForeignField | bigint | Bytes, publicKey: FlexiblePoint): Bool {\n    if (msgHash instanceof Bytes.Base)\n      msgHash = keccakOutputToScalar(msgHash, this.Constructor.Curve);\n\n    let msgHash_ = this.Constructor.Curve.Scalar.from(msgHash);\n    let publicKey_ = this.Constructor.Curve.from(publicKey);\n    return Ecdsa.verify(\n      this.Constructor.Curve.Bigint,\n      toObject(this),\n      msgHash_.value,\n      toPoint(publicKey_)\n    );\n  }\n\n  /**\n   * Create an {@link EcdsaSignature} by signing a message with a private key.\n   *\n   * Note: This method is not provable, and only takes JS bigints as input.\n   */\n  static sign(message: (bigint | number)[] | Uint8Array, privateKey: bigint) {\n    let msgHashBytes = Keccak.ethereum(message);\n    let msgHash = keccakOutputToScalar(msgHashBytes, this.Curve);\n    return this.signHash(msgHash.toBigInt(), privateKey);\n  }\n\n  /**\n   * Create an {@link EcdsaSignature} by signing a message hash with a private key.\n   *\n   * This is a building block of {@link EcdsaSignature.sign}, where the input message is also hashed.\n   * In contrast, this method just takes the message hash (a curve scalar, or the output bytes of a hash function)\n   * as input, giving you flexibility in choosing the hashing algorithm.\n   *\n   * Note: This method is not provable, and only takes JS bigints or constant Bytes as input.\n   */\n  static signHash(msgHash: bigint | Bytes, privateKey: bigint) {\n    if (msgHash instanceof Bytes.Base)\n      msgHash = keccakOutputToScalar(msgHash, this.Curve).toBigInt();\n\n    let { r, s } = Ecdsa.sign(this.Curve.Bigint, msgHash, privateKey);\n    return new this({ r, s });\n  }\n\n  static check(signature: EcdsaSignature) {\n    multiRangeCheck(signature.r.value);\n    multiRangeCheck(signature.s.value);\n    // more efficient than the automatic check, which would do this for each scalar separately\n    this.Curve.Scalar.assertAlmostReduced(signature.r, signature.s);\n  }\n\n  // dynamic subclassing infra\n  get Constructor() {\n    return this.constructor as typeof EcdsaSignature;\n  }\n  static _Curve?: typeof ForeignCurve;\n  static _provable?: ProvablePureExtended<\n    EcdsaSignature,\n    { r: bigint; s: bigint },\n    { r: string; s: string }\n  >;\n\n  /**\n   * The {@link ForeignCurve} on which the ECDSA signature is defined.\n   */\n  static get Curve() {\n    assert(this._Curve !== undefined, 'EcdsaSignature not initialized');\n    return this._Curve;\n  }\n  /**\n   * `Provable<EcdsaSignature>`\n   */\n  static get provable() {\n    assert(this._provable !== undefined, 'EcdsaSignature not initialized');\n    return this._provable;\n  }\n}\n\n/**\n * Create a class {@link EcdsaSignature} for verifying ECDSA signatures on the given curve.\n */\nfunction createEcdsa(curve: CurveParams | typeof ForeignCurve): typeof EcdsaSignature {\n  let Curve0: typeof ForeignCurve = 'b' in curve ? createForeignCurve(curve) : curve;\n  class Curve extends Curve0 {}\n\n  class Signature extends EcdsaSignature {\n    static _Curve = Curve;\n    static _provable = provableFromClass(Signature, {\n      r: Curve.Scalar,\n      s: Curve.Scalar,\n    });\n  }\n\n  return Signature;\n}\n\nfunction toObject(signature: EcdsaSignature) {\n  return { r: signature.r.value, s: signature.s.value };\n}\n\n/**\n * Provable method to convert keccak256 hash output to ECDSA scalar = \"message hash\"\n *\n * Spec from [Wikipedia](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm):\n *\n * > Let z be the L_n leftmost bits of e, where L_{n} is the bit length of the group order n.\n * > (Note that z can be greater than n but not longer.)\n *\n * The output z is used as input to a multiplication:\n *\n * > Calculate u_1 = z s^(-1) mod n ...\n *\n * That means we don't need to reduce z mod n: The fact that it has bitlength <= n makes it\n * almost reduced which is enough for the multiplication to be correct.\n * (using a weaker notion of \"almost reduced\" than what we usually prove, but sufficient for all uses of it: `z < 2^ceil(log(n))`)\n *\n * In summary, this method just:\n * - takes a 32 bytes hash\n * - converts them to 3 limbs which collectively have L_n <= 256 bits\n */\nfunction keccakOutputToScalar(hash: Bytes, Curve: typeof ForeignCurve) {\n  const L_n = Curve.Scalar.sizeInBits;\n  // keep it simple for now, avoid dealing with dropping bits\n  // TODO: what does \"leftmost bits\" mean? big-endian or little-endian?\n  // @noble/curves uses a right shift, dropping the least significant bits:\n  // https://github.com/paulmillr/noble-curves/blob/4007ee975bcc6410c2e7b504febc1d5d625ed1a4/src/abstract/weierstrass.ts#L933\n  assert(L_n === 256, `Scalar sizes ${L_n} !== 256 not supported`);\n  assert(hash.length === 32, `hash length ${hash.length} !== 32 not supported`);\n\n  // piece together into limbs\n  // bytes are big-endian, so the first byte is the most significant\n  assert(l === 88n);\n  let x2 = bytesToLimbBE(hash.bytes.slice(0, 10));\n  let x1 = bytesToLimbBE(hash.bytes.slice(10, 21));\n  let x0 = bytesToLimbBE(hash.bytes.slice(21, 32));\n\n  return new Curve.Scalar.AlmostReduced([x0, x1, x2]);\n}\n\nfunction bytesToLimbBE(bytes_: UInt8[]) {\n  let bytes = bytes_.map((x) => x.value);\n  let n = bytes.length;\n  let limb = bytes[0];\n  for (let i = 1; i < n; i++) {\n    limb = limb.mul(1n << 8n).add(bytes[i]);\n  }\n  return limb.seal();\n}\n", "import { GenericSignableField } from '../../../bindings/lib/generic.js';\nimport { prefixToField } from '../../../bindings/lib/binable.js';\n\nexport { createHashHelpers, HashHelpers };\n\ntype Hash<Field> = {\n  initialState(): Field[];\n  update(state: Field[], input: Field[]): Field[];\n};\n\ntype HashHelpers<Field> = ReturnType<typeof createHashHelpers<Field>>;\n\nfunction createHashHelpers<Field>(Field: GenericSignableField<Field>, Hash: Hash<Field>) {\n  function salt(prefix: string) {\n    return Hash.update(Hash.initialState(), [prefixToField(Field, prefix)]);\n  }\n  function emptyHashWithPrefix(prefix: string) {\n    return salt(prefix)[0];\n  }\n  function hashWithPrefix(prefix: string, input: Field[]) {\n    let init = salt(prefix);\n    return Hash.update(init, input)[0];\n  }\n  return { salt, emptyHashWithPrefix, hashWithPrefix };\n}\n", "import { ConstantField, Field } from '../provable/field.js';\nimport { FieldVar, FieldConst } from '../provable/core/fieldvar.js';\nimport { MlArray } from './base.js';\nexport { MlFieldArray, MlFieldConstArray };\n\ntype MlFieldArray = MlArray<FieldVar>;\nconst MlFieldArray = {\n  to(arr: Field[]): MlArray<FieldVar> {\n    return MlArray.to(arr.map((x) => x.value));\n  },\n  from([, ...arr]: MlArray<FieldVar>) {\n    return arr.map((x) => new Field(x));\n  },\n};\n\ntype MlFieldConstArray = MlArray<FieldConst>;\nconst MlFieldConstArray = {\n  to(arr: Field[]): MlArray<FieldConst> {\n    return MlArray.to(arr.map((x) => x.toConstant().value[1]));\n  },\n  from([, ...arr]: MlArray<FieldConst>): ConstantField[] {\n    return arr.map((x) => new Field(x) as ConstantField);\n  },\n};\n", "import { assertPositiveInteger } from './non-negative.js';\nimport { poseidonParamsKimchiFp, poseidonParamsLegacyFp } from './constants.js';\nimport { FiniteField, Fp } from './finite-field.js';\nimport { GroupMapPallas } from './elliptic-curve.js';\n\nexport { Poseidon, PoseidonLegacy };\n\ntype PoseidonParameters = {\n  fullRounds: number;\n  partialRounds: number;\n  hasInitialRoundConstant: boolean;\n  stateSize: number;\n  rate: number;\n  power: number;\n  roundConstants: string[][];\n  mds: string[][];\n};\n\nfunction fieldToGroup(x: bigint) {\n  const { potentialXs, tryDecode } = GroupMapPallas;\n  const xs = potentialXs(x);\n  return xs.map((x) => tryDecode(x)).find((x) => x);\n}\n\nfunction makeHashToGroup(hash: (i: bigint[]) => bigint) {\n  return (input: bigint[]) => {\n    let digest = hash(input);\n    let g = fieldToGroup(digest);\n    if (g === undefined) return undefined;\n\n    // the y coordinate is calculated using a square root, so it has two possible values\n    // to make the output deterministic, we negate y if it is odd\n    // we do the same in-snark, so both APIs match\n    let isOdd = (g.y & 1n) === 1n;\n    let y = isOdd ? Fp.negate(g.y) : g.y;\n    return { x: g.x, y };\n  };\n}\n\nconst PoseidonSpec = createPoseidon(Fp, poseidonParamsKimchiFp);\n\nconst Poseidon = {\n  ...PoseidonSpec,\n  hashToGroup: makeHashToGroup(PoseidonSpec.hash),\n};\nconst PoseidonLegacy = createPoseidon(Fp, poseidonParamsLegacyFp);\n\nfunction createPoseidon(\n  Fp: FiniteField,\n  {\n    fullRounds,\n    partialRounds,\n    hasInitialRoundConstant,\n    stateSize,\n    rate,\n    power: power_,\n    roundConstants: roundConstants_,\n    mds: mds_,\n  }: PoseidonParameters\n) {\n  if (partialRounds !== 0) {\n    throw Error(\"we don't support partial rounds\");\n  }\n  assertPositiveInteger(rate, 'rate must be a positive integer');\n  assertPositiveInteger(fullRounds, 'fullRounds must be a positive integer');\n  assertPositiveInteger(power_, 'power must be a positive integer');\n  let power = BigInt(power_);\n  let roundConstants = roundConstants_.map((arr) => arr.map(BigInt));\n  let mds = mds_.map((arr) => arr.map(BigInt));\n\n  function initialState(): bigint[] {\n    return Array(stateSize).fill(0n);\n  }\n\n  function hash(input: bigint[]) {\n    let state = update(initialState(), input);\n    return state[0];\n  }\n\n  function update([...state]: bigint[], input: bigint[]) {\n    // special case for empty input\n    if (input.length === 0) {\n      permutation(state);\n      return state;\n    }\n    // pad input with zeros so its length is a multiple of the rate\n    let n = Math.ceil(input.length / rate) * rate;\n    input = input.concat(Array(n - input.length).fill(0n));\n    // for every block of length `rate`, add block to the first `rate` elements of the state, and apply the permutation\n    for (let blockIndex = 0; blockIndex < n; blockIndex += rate) {\n      for (let i = 0; i < rate; i++) {\n        state[i] = Fp.add(state[i], input[blockIndex + i]);\n      }\n      permutation(state);\n    }\n    return state;\n  }\n\n  /**\n   * Standard Poseidon (without \"partial rounds\") goes like this:\n   *\n   *    ARK_0 -> SBOX -> MDS\n   * -> ARK_1 -> SBOX -> MDS\n   * -> ...\n   * -> ARK_{rounds - 1} -> SBOX -> MDS\n   *\n   * where all computation operates on a vector of field elements, the \"state\", and\n   * - ARK  ... add vector of round constants to the state, element-wise (different vector in each round)\n   * - SBOX ... raise state to a power, element-wise\n   * - MDS  ... multiply the state by a constant matrix (same matrix every round)\n   * (these operations are done modulo p of course)\n   *\n   * For constraint efficiency reasons, in Mina's implementation the first round constant addition is left out\n   * and is done at the end instead, so that effectively the order of operations in each iteration is rotated:\n   *\n   *    SBOX -> MDS -> ARK_0\n   * -> SBOX -> MDS -> ARK_1\n   * -> ...\n   * -> SBOX -> MDS -> ARK_{rounds - 1}\n   *\n   * If `hasInitialRoundConstant` is true, another ARK step is added at the beginning.\n   *\n   * See also Snarky.Sponge.Poseidon.block_cipher\n   */\n  function permutation(state: bigint[]) {\n    // special case: initial round constant\n    let offset = 0;\n    if (hasInitialRoundConstant) {\n      for (let i = 0; i < stateSize; i++) {\n        state[i] = Fp.add(state[i], roundConstants[0][i]);\n      }\n      offset = 1;\n    }\n    for (let round = 0; round < fullRounds; round++) {\n      // raise to a power\n      for (let i = 0; i < stateSize; i++) {\n        state[i] = Fp.power(state[i], power);\n      }\n      let oldState = [...state];\n      for (let i = 0; i < stateSize; i++) {\n        // multiply by mds matrix\n        state[i] = Fp.dot(mds[i], oldState);\n        // add round constants\n        state[i] = Fp.add(state[i], roundConstants[round + offset][i]);\n      }\n    }\n  }\n\n  return { initialState, update, hash };\n}\n", "import { HashInput, ProvableExtended, Struct } from '../types/struct.js';\nimport { Snarky } from '../../../bindings.js';\nimport { Field } from '../wrapped.js';\nimport { createHashHelpers } from './hash-generic.js';\nimport { Provable } from '../provable.js';\nimport { MlFieldArray } from '../../ml/fields.js';\nimport { Poseidon as PoseidonBigint } from '../../../bindings/crypto/poseidon.js';\nimport { assert } from '../../util/errors.js';\nimport { rangeCheckN } from '../gadgets/range-check.js';\nimport { TupleN } from '../../util/types.js';\nimport { Group } from '../group.js';\nimport { ProvableType, WithProvable } from '../types/provable-intf.js';\nimport { stringLengthInBytes } from '../../../bindings/lib/binable.js';\n\n// external API\nexport { Poseidon, TokenSymbol };\n\n// internal API\nexport {\n  ProvableHashable,\n  HashInput,\n  HashHelpers,\n  emptyHashWithPrefix,\n  hashWithPrefix,\n  salt,\n  packToFields,\n  emptyReceiptChainHash,\n  hashConstant,\n  isHashable,\n};\n\ntype Hashable<T> = { toInput: (x: T) => HashInput; empty: () => T };\ntype ProvableHashable<T, V = any> = Provable<T, V> & Hashable<T>;\n\nclass Sponge {\n  #sponge: unknown;\n\n  // TODO: implement constant version in TS. currently, you need to call `initializeBindings()` before successfully calling this\n  constructor() {\n    let isChecked = Provable.inCheckedComputation();\n    assert(\n      Snarky !== undefined,\n      'Poseidon.Sponge(): bindings are not initialized, try calling `await initializeBindings()` first.'\n    );\n    this.#sponge = Snarky.poseidon.sponge.create(isChecked);\n  }\n\n  absorb(x: Field) {\n    Snarky.poseidon.sponge.absorb(this.#sponge, x.value);\n  }\n\n  squeeze(): Field {\n    return Field(Snarky.poseidon.sponge.squeeze(this.#sponge));\n  }\n}\n\nconst Poseidon = {\n  hash(input: Field[]) {\n    if (isConstant(input)) {\n      return Field(PoseidonBigint.hash(toBigints(input)));\n    }\n    return Poseidon.update(Poseidon.initialState(), input)[0];\n  },\n\n  update(state: [Field, Field, Field], input: Field[]) {\n    if (isConstant(state) && isConstant(input)) {\n      let newState = PoseidonBigint.update(toBigints(state), toBigints(input));\n      return TupleN.fromArray(3, newState.map(Field));\n    }\n\n    let newState = Snarky.poseidon.update(MlFieldArray.to(state), MlFieldArray.to(input));\n    return MlFieldArray.from(newState) as [Field, Field, Field];\n  },\n\n  hashWithPrefix(prefix: string, input: Field[]) {\n    let init = Poseidon.update(Poseidon.initialState(), [prefixToField(prefix)]);\n    return Poseidon.update(init, input)[0];\n  },\n\n  initialState(): [Field, Field, Field] {\n    return [Field(0), Field(0), Field(0)];\n  },\n\n  Unsafe: {\n    /**\n     * Low-level version of `Poseidon.hashToGroup()`.\n     *\n     * **Warning**: This function is marked unsafe because its output is not deterministic.\n     * It returns the square root of a value without constraining which of the two possible\n     * square roots is chosen. This allows the prover to choose between two different hashes,\n     * which can be a vulnerability if consuming code treats the output as unique.\n     */\n    hashToGroup(input: Field[]) {\n      if (isConstant(input)) {\n        let result = PoseidonBigint.hashToGroup(toBigints(input));\n        assert(result !== undefined, 'hashToGroup works on all inputs');\n        return new Group(result);\n      }\n\n      // y = sqrt(y^2)\n      let [, x, y] = Snarky.poseidon.hashToGroup(MlFieldArray.to(input));\n      return new Group({ x, y });\n    },\n  },\n\n  /**\n   * Hashes a list of field elements to a point on the Pallas curve.\n   *\n   * The output point is deterministic and its discrete log is not efficiently computable.\n   */\n  hashToGroup(input: Field[]): Group {\n    if (isConstant(input)) return Poseidon.Unsafe.hashToGroup(input);\n\n    let { x, y } = Poseidon.Unsafe.hashToGroup(input);\n\n    // the y coordinate is calculated using a square root, so it has two possible values\n    // to make the output deterministic, we negate y if it is odd\n    let sign = Field.from(1n).sub(y.isOdd().toField().mul(2n)); // -1 is y is odd, 1 else\n    y = y.mul(sign);\n\n    return new Group({ x, y });\n  },\n\n  /**\n   * Hashes a provable type efficiently.\n   *\n   * ```ts\n   * let skHash = Poseidon.hashPacked(PrivateKey, secretKey);\n   * ```\n   *\n   * Note: Instead of just doing `Poseidon.hash(value.toFields())`, this\n   * uses the `toInput()` method on the provable type to pack the input into as few\n   * field elements as possible. This saves constraints because packing has a much\n   * lower per-field element cost than hashing.\n   */\n  hashPacked<T>(type: WithProvable<Hashable<T>>, value: T) {\n    let input = ProvableType.get(type).toInput(value);\n    let packed = packToFields(input);\n    return Poseidon.hash(packed);\n  },\n\n  Sponge,\n};\n\nfunction hashConstant(input: Field[]) {\n  return Field(PoseidonBigint.hash(toBigints(input)));\n}\n\nconst HashHelpers = createHashHelpers(Field, Poseidon);\nlet { salt, emptyHashWithPrefix, hashWithPrefix } = HashHelpers;\n\n// same as Random_oracle.prefix_to_field in OCaml\nfunction prefixToField(prefix: string) {\n  if (prefix.length * 8 >= 255) throw Error('prefix too long');\n  let bits = [...prefix]\n    .map((char) => {\n      // convert char to 8 bits\n      let bits = [];\n      for (let j = 0, c = char.charCodeAt(0); j < 8; j++, c >>= 1) {\n        if (j === 7)\n          assert(c === 0, `Invalid character ${char}, only ASCII characters are supported.`);\n        bits.push(!!(c & 1));\n      }\n      return bits;\n    })\n    .flat();\n  return Field.fromBits(bits);\n}\n\n/**\n * Convert the {fields, packed} hash input representation to a list of field elements\n * Random_oracle_input.Chunked.pack_to_fields\n */\nfunction packToFields({ fields = [], packed = [] }: HashInput) {\n  if (packed.length === 0) return fields;\n  let packedBits = [];\n  let currentPackedField = Field(0);\n  let currentSize = 0;\n  for (let [field, size] of packed) {\n    currentSize += size;\n    if (currentSize < 255) {\n      currentPackedField = currentPackedField.mul(Field(1n << BigInt(size))).add(field);\n    } else {\n      packedBits.push(currentPackedField);\n      currentSize = size;\n      currentPackedField = field;\n    }\n  }\n  packedBits.push(currentPackedField);\n  return fields.concat(packedBits);\n}\n\nfunction isHashable<T>(obj: any): obj is Hashable<T> {\n  if (!obj) {\n    return false;\n  }\n  const hasToInput = 'toInput' in obj && typeof obj.toInput === 'function';\n  const hasEmpty = 'empty' in obj && typeof obj.empty === 'function';\n  return hasToInput && hasEmpty;\n}\n\nconst TokenSymbolPure: ProvableExtended<{ symbol: string; field: Field }, string, string> = {\n  toFields({ field }) {\n    return [field];\n  },\n  toAuxiliary(value) {\n    return [value?.symbol ?? ''];\n  },\n  fromFields([field], [symbol]) {\n    return { symbol, field };\n  },\n  sizeInFields() {\n    return 1;\n  },\n  check({ field }: TokenSymbol) {\n    rangeCheckN(48, field);\n  },\n  toValue({ symbol }) {\n    return symbol;\n  },\n  fromValue(symbol: string | TokenSymbol) {\n    if (typeof symbol !== 'string') return symbol;\n    let bytesLength = new TextEncoder().encode(symbol).length;\n    if (bytesLength > MAX_TOKEN_SYMBOL_LENGTH)\n      throw Error(\n        `Token symbol ${symbol} should be a maximum of ${MAX_TOKEN_SYMBOL_LENGTH} bytes, but is ${bytesLength}`\n      );\n    let field = prefixToField(symbol);\n    return { symbol, field };\n  },\n  toJSON({ symbol }) {\n    return symbol;\n  },\n  fromJSON(symbol: string) {\n    let field = prefixToField(symbol);\n    return { symbol, field };\n  },\n  toInput({ field }) {\n    return { packed: [[field, 48]] };\n  },\n  empty() {\n    return { symbol: '', field: Field(0n) };\n  },\n};\n\nconst MAX_TOKEN_SYMBOL_LENGTH = 6;\n\nclass TokenSymbol extends Struct(TokenSymbolPure) {\n  constructor(symbol: string | { symbol: string; field: Field }) {\n    if (typeof symbol === 'object') {\n      super({ symbol: symbol.symbol, field: symbol.field });\n    } else {\n      let bytesLength = stringLengthInBytes(symbol);\n      if (bytesLength > MAX_TOKEN_SYMBOL_LENGTH) {\n        throw Error(\n          `Token symbol ${symbol} should be a maximum of ${MAX_TOKEN_SYMBOL_LENGTH} bytes, but is ${bytesLength}`\n        );\n      }\n\n      super({ symbol: symbol, field: prefixToField(symbol) });\n    }\n  }\n\n  static from(value: string | TokenSymbol) {\n    return TokenSymbol.fromValue(value) as TokenSymbol;\n  }\n\n  static empty(): TokenSymbol {\n    return new TokenSymbol('');\n  }\n}\n\nfunction emptyReceiptChainHash() {\n  return emptyHashWithPrefix('CodaReceiptEmpty');\n}\n\nfunction isConstant(fields: Field[]) {\n  return fields.every((x) => x.isConstant());\n}\nfunction toBigints(fields: Field[]) {\n  return fields.map((x) => x.toBigInt());\n}\n", "import { Gadgets } from '../gadgets/gadgets.js';\nimport { Poseidon } from './poseidon.js';\nimport { Keccak } from './keccak.js';\nimport { Bytes } from '../wrapped-classes.js';\n\nexport { Hash };\n\n/**\n * A collection of hash functions which can be used in provable code.\n */\nconst Hash = {\n  /**\n   * Hashes the given field elements using [Poseidon](https://eprint.iacr.org/2019/458.pdf). Alias for `Poseidon.hash()`.\n   *\n   * ```ts\n   * let hash = Hash.hash([a, b, c]);\n   * ```\n   *\n   * **Important:** This is by far the most efficient hash function o1js has available in provable code.\n   * Use it by default, if no compatibility concerns require you to use a different hash function.\n   *\n   * The Poseidon implementation operates over the native [Pallas base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/)\n   * and uses parameters generated specifically for the [Mina](https://minaprotocol.com) blockchain.\n   *\n   * We use a `rate` of 2, which means that 2 field elements are hashed per permutation.\n   * A permutation causes 11 rows in the constraint system.\n   *\n   * You can find the full set of Poseidon parameters [here](https://github.com/o1-labs/o1js-bindings/blob/main/crypto/constants.ts).\n   */\n  hash: Poseidon.hash,\n\n  /**\n   * The [Poseidon](https://eprint.iacr.org/2019/458.pdf) hash function.\n   *\n   * See {@link Hash.hash} for details and usage examples.\n   */\n  Poseidon,\n\n  /**\n   * The SHA2 hash function with an output length of 256 bits.\n   */\n  SHA2_256: {\n    /**\n     * Hashes the given bytes using SHA2-256.\n     *\n     * This is an alias for `Gadgets.SHA256.hash(bytes)`.\\\n     * See {@link Gadgets.SHA256.hash} for details and usage examples.\n     */\n    hash: Gadgets.SHA256.hash,\n  },\n\n  /**\n   * The SHA2 hash function with an output length of 224 | 256 | 384 | 512 bits.\n   */\n  SHA2: {\n    /**\n     * Hashes the given bytes using SHA2.\n     *\n     * This is an alias for `Gadgets.SHA2.hash(length,bytes)`.\\\n     * See {@link Gadgets.SHA2.hash} for details and usage examples.\n     */\n    hash: Gadgets.SHA2.hash,\n  },\n\n  /**\n   * The SHA3 hash function with an output length of 256 bits.\n   */\n  SHA3_256: {\n    /**\n     * Hashes the given bytes using SHA3-256.\n     *\n     * This is an alias for `Keccak.nistSha3(256, bytes)`.\\\n     * See {@link Keccak.nistSha3} for details and usage examples.\n     */\n    hash(bytes: Bytes) {\n      return Keccak.nistSha3(256, bytes);\n    },\n  },\n\n  /**\n   * The SHA3 hash function with an output length of 384 bits.\n   */\n  SHA3_384: {\n    /**\n     * Hashes the given bytes using SHA3-384.\n     *\n     * This is an alias for `Keccak.nistSha3(384, bytes)`.\\\n     * See {@link Keccak.nistSha3} for details and usage examples.\n     */\n    hash(bytes: Bytes) {\n      return Keccak.nistSha3(384, bytes);\n    },\n  },\n\n  /**\n   * The SHA3 hash function with an output length of 512 bits.\n   */\n  SHA3_512: {\n    /**\n     * Hashes the given bytes using SHA3-512.\n     *\n     * This is an alias for `Keccak.nistSha3(512, bytes)`.\\\n     * See {@link Keccak.nistSha3} for details and usage examples.\n     */\n    hash(bytes: Bytes) {\n      return Keccak.nistSha3(512, bytes);\n    },\n  },\n\n  /**\n   * The pre-NIST Keccak hash function with an output length of 256 bits.\n   */\n  Keccak256: {\n    /**\n     * Hashes the given bytes using Keccak-256.\n     *\n     * This is an alias for `Keccak.preNist(256, bytes)`.\\\n     * See {@link Keccak.preNist} for details and usage examples.\n     */\n    hash(bytes: Bytes) {\n      return Keccak.preNist(256, bytes);\n    },\n  },\n\n  /**\n   * The pre-NIST Keccak hash function with an output length of 384 bits.\n   */\n  Keccak384: {\n    /**\n     * Hashes the given bytes using Keccak-384.\n     *\n     * This is an alias for `Keccak.preNist(384, bytes)`.\\\n     * See {@link Keccak.preNist} for details and usage examples.\n     */\n    hash(bytes: Bytes) {\n      return Keccak.preNist(384, bytes);\n    },\n  },\n\n  /**\n   * The pre-NIST Keccak hash function with an output length of 512 bits.\n   */\n  Keccak512: {\n    /**\n     * Hashes the given bytes using Keccak-512.\n     *\n     * This is an alias for `Keccak.preNist(512, bytes)`.\\\n     * See {@link Keccak.preNist} for details and usage examples.\n     */\n    hash(bytes: Bytes) {\n      return Keccak.preNist(512, bytes);\n    },\n  },\n\n  BLAKE2B: {\n    hash(bytes: Bytes) {\n      return Gadgets.BLAKE2B.hash(bytes);\n    },\n  },\n};\n", "import { Fq } from '../../bindings/crypto/finite-field.js';\nimport { ForeignField, createForeignField } from './foreign-field.js';\nimport { field3ToShiftedScalar } from './gadgets/native-curve.js';\nimport { Provable } from './provable.js';\nimport { Scalar } from './scalar.js';\n\nexport { ScalarField };\n\n/**\n * ForeignField representing the scalar field of Pallas and the base field of Vesta\n */\nclass ScalarField extends createForeignField(Fq.modulus) {\n  /**\n   * Provable method to convert a {@link ScalarField} into a {@link Scalar}\n   */\n  public toScalar(): Scalar {\n    return ScalarField.toScalar(this);\n  }\n\n  public static toScalar(field: ForeignField) {\n    if (field.modulus !== Fq.modulus) {\n      throw new Error('Only ForeignFields with Fq modulus are convertible into a scalar');\n    }\n    const field3 = field.value;\n    const shiftedScalar = field3ToShiftedScalar(field3);\n    return Scalar.fromShiftedScalar(shiftedScalar);\n  }\n\n  /**\n   * Converts this {@link Scalar} into a {@link ScalarField}\n   */\n  static fromScalar(s: Scalar): ScalarField {\n    if (s.lowBit.isConstant() && s.high254.isConstant()) {\n      return new ScalarField(s.toBigInt());\n    }\n    const field = Provable.witness(ScalarField, () => s.toBigInt());\n    const foreignField = new ScalarField(field);\n    const scalar = foreignField.toScalar();\n    Provable.assertEqual(Scalar, s, scalar);\n\n    return foreignField;\n  }\n}\n", "import { blake2b } from 'blakejs';\nimport { Field } from './field-bigint.js';\nimport { Group, Scalar, PrivateKey, versionNumbers, PublicKey } from './curve-bigint.js';\nimport {\n  HashInput,\n  hashWithPrefix,\n  packToFields,\n  prefixes,\n  Poseidon,\n  HashInputLegacy,\n  packToFieldsLegacy,\n  inputToBitsLegacy,\n  HashLegacy,\n} from './poseidon-bigint.js';\nimport { bitsToBytes, bytesToBits, record, withVersionNumber } from '../../bindings/lib/binable.js';\nimport { base58 } from '../../lib/util/base58.js';\nimport { versionBytes } from '../../bindings/crypto/constants.js';\nimport { Pallas } from '../../bindings/crypto/elliptic-curve.js';\nimport { NetworkId } from './types.js';\n\nexport {\n  sign,\n  verify,\n  signFieldElement,\n  verifyFieldElement,\n  Signature,\n  SignatureJson,\n  signLegacy,\n  verifyLegacy,\n  deriveNonce,\n  signaturePrefix,\n  zkAppBodyPrefix,\n};\n\nconst networkIdMainnet = 0x01n;\nconst networkIdDevnet = 0x00n;\n\ntype Signature = { r: Field; s: Scalar };\ntype SignatureJson = { field: string; scalar: string };\n\nconst BinableSignature = withVersionNumber(\n  record({ r: Field, s: Scalar }, ['r', 's']),\n  versionNumbers.signature\n);\nconst Signature = {\n  ...BinableSignature,\n  ...base58(BinableSignature, versionBytes.signature),\n  toJSON({ r, s }: Signature): SignatureJson {\n    return {\n      field: Field.toJSON(r),\n      scalar: Scalar.toJSON(s),\n    };\n  },\n  fromJSON({ field, scalar }: SignatureJson) {\n    let r = Field.fromJSON(field);\n    let s = Scalar.fromJSON(scalar);\n    return { r, s };\n  },\n  dummy() {\n    return { r: Field(1), s: Scalar(1) };\n  },\n};\n\n/**\n * Convenience wrapper around {@link sign} where the message is a single {@link Field} element\n */\nfunction signFieldElement(message: Field, privateKey: PrivateKey, networkId: NetworkId) {\n  return sign({ fields: [message] }, privateKey, networkId);\n}\n/**\n * Convenience wrapper around {@link verify} where the message is a single {@link Field} element\n */\nfunction verifyFieldElement(\n  signature: Signature,\n  message: Field,\n  publicKey: PublicKey,\n  networkId: NetworkId\n) {\n  return verify(signature, { fields: [message] }, publicKey, networkId);\n}\n\n/**\n * Schnorr signature algorithm consistent with the OCaml implementation in Schnorr.Chunked.sign, over\n * the Pallas curve with the original \"Mina\" generator.\n *\n * @see {@link https://github.com/MinaProtocol/mina/blob/develop/docs/specs/signatures/description.md detailed spec of the algorithm}\n *\n * In contrast to the spec above, this uses the \"chunked\" style of hash input packing, implemented in {@link packToFields}.\n *\n * @param message The `message` can be an arbitrary {@link HashInput}, that can be created with\n * `ProvableExtended<T>.toInput(t)` for any provable type `T`, and by concatenating multiple hash inputs\n * with {@link HashInput.append}.\n * Currently, we only use the variant {@link signFieldElement} where the message is a single field element,\n * which itself is the result of computing a hash.\n *\n * @param privateKey The `privateKey` represents an element of the Pallas scalar field, and should be given as a native bigint.\n * It can be converted from the base58 string representation using {@link PrivateKey.fromBase58}.\n *\n * @param networkId The `networkId` is either \"devnet\" or \"mainnet\" and ensures that testnet transactions can\n * never be used as valid mainnet transactions.\n *\n * @see {@link deriveNonce} and {@link hashMessage} for details on how the nonce and hash are computed.\n */\nfunction sign(message: HashInput, privateKey: PrivateKey, networkId: NetworkId): Signature {\n  let publicKey = Group.scale(Group.generatorMina, privateKey);\n  let kPrime = deriveNonce(message, publicKey, privateKey, networkId);\n  if (Scalar.equal(kPrime, 0n)) throw Error('sign: derived nonce is 0');\n  let { x: rx, y: ry } = Group.scale(Group.generatorMina, kPrime);\n  let k = Field.isEven(ry) ? kPrime : Scalar.negate(kPrime);\n  let e = hashMessage(message, publicKey, rx, networkId);\n  let s = Scalar.add(k, Scalar.mul(e, privateKey));\n  return { r: rx, s };\n}\n\n/**\n * Deterministically derive the nonce for the Schnorr signature algorithm, by:\n * - packing all inputs into a byte array,\n * - applying the [blake2b](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) hash function, and\n * - interpreting the resulting 32 bytes as an element of the Pallas curve scalar field (by dropping bits 254 and 255).\n *\n * @see {@link https://github.com/MinaProtocol/mina/blob/develop/docs/specs/signatures/description.md detailed spec of the algorithm}\n *\n * In contrast to the spec above, this uses the \"chunked\" style of hash input packing, implemented in {@link packToFields}.\n *\n * Input arguments are the same as for {@link sign}, with an additional `publicKey` (a non-zero, affine point on the Pallas curve),\n * which `sign` re-derives by scaling the Pallas \"Mina\" generator by the `privateKey`.\n */\nfunction deriveNonce(\n  message: HashInput,\n  publicKey: Group,\n  privateKey: Scalar,\n  networkId: NetworkId\n): Scalar {\n  let { x, y } = publicKey;\n  let d = Field(privateKey);\n  let id = getNetworkIdHashInput(networkId);\n  let input = HashInput.append(message, {\n    fields: [x, y, d],\n    packed: [id],\n  });\n  let packedInput = packToFields(input);\n  let inputBits = packedInput.map(Field.toBits).flat();\n  let inputBytes = bitsToBytes(inputBits);\n  let bytes = blake2b(Uint8Array.from(inputBytes), undefined, 32);\n  // drop the top two bits to convert into a scalar field element\n  // (creates negligible bias because q = 2^254 + eps, eps << q)\n  bytes[bytes.length - 1] &= 0x3f;\n  return Scalar.fromBytes([...bytes]);\n}\n\n/**\n * Hash a message for use by the Schnorr signature algorithm, by:\n * - packing the inputs `message`, `publicKey`, `r` into an array of Pallas base field elements,\n * - apply a salted hash with the {@link Poseidon} hash function,\n * - interpreting the resulting base field element as a scalar\n *   (which is always possible, and is a no-op, since the scalar field is larger and both fields are represented with bigints).\n *\n * @see {@link https://github.com/MinaProtocol/mina/blob/develop/docs/specs/signatures/description.md detailed spec of the algorithm}\n *\n * In contrast to the spec above, this uses the \"chunked\" style of hash input packing, implemented in {@link packToFields}.\n *\n * @param message an arbitrary {@link HashInput}\n * @param publicKey an affine, non-zero point on the Pallas curve, derived by {@link sign} from the private key\n * @param r an element of the Pallas base field, computed by {@link sign} as the x-coordinate of the generator, scaled by the nonce.\n * @param networkId either \"testnet\" or \"mainnet\", determines the salt (initial state) in the Poseidon hash.\n */\nfunction hashMessage(message: HashInput, publicKey: Group, r: Field, networkId: NetworkId): Scalar {\n  let { x, y } = publicKey;\n  let input = HashInput.append(message, { fields: [x, y, r] });\n  return hashWithPrefix(signaturePrefix(networkId), packToFields(input));\n}\n\n/**\n * Verifies a signature created by {@link sign}, returns `true` if (and only if) the signature is valid.\n *\n * @see {@link https://github.com/MinaProtocol/mina/blob/develop/docs/specs/signatures/description.md detailed spec of the algorithm}\n *\n * In contrast to the spec above, this uses the \"chunked\" style of hash input packing, implemented in {@link packToFields}.\n *\n * @param publicKey the public key has to be passed in as a compressed {@link PublicKey}.\n * It can be created from a base58 string with {@link PublicKey.fromBase58}.\n */\nfunction verify(\n  signature: Signature,\n  message: HashInput,\n  publicKey: PublicKey,\n  networkId: NetworkId\n) {\n  let { r, s } = signature;\n  let pk = PublicKey.toGroup(publicKey);\n  let e = hashMessage(message, pk, r, networkId);\n  let { scale, one, sub } = Pallas;\n  let R = sub(scale(one, s), scale(Group.toProjective(pk), e));\n  try {\n    // if `R` is infinity, Group.fromProjective throws an error, so `verify` returns false\n    let { x: rx, y: ry } = Group.fromProjective(R);\n    return Field.isEven(ry) && Field.equal(rx, r);\n  } catch {\n    return false;\n  }\n}\n\n// legacy signatures\n\n/**\n * Same as {@link sign}, but using the \"legacy\" style of hash input packing.\n */\nfunction signLegacy(\n  message: HashInputLegacy,\n  privateKey: PrivateKey,\n  networkId: NetworkId\n): Signature {\n  let publicKey = Group.scale(Group.generatorMina, privateKey);\n  let kPrime = deriveNonceLegacy(message, publicKey, privateKey, networkId);\n  if (Scalar.equal(kPrime, 0n)) throw Error('sign: derived nonce is 0');\n  let { x: rx, y: ry } = Group.scale(Group.generatorMina, kPrime);\n  let k = Field.isEven(ry) ? kPrime : Scalar.negate(kPrime);\n  let e = hashMessageLegacy(message, publicKey, rx, networkId);\n  let s = Scalar.add(k, Scalar.mul(e, privateKey));\n  return { r: rx, s };\n}\n\n/**\n * Same as {@link verify}, but using the \"legacy\" style of hash input packing.\n */\nfunction verifyLegacy(\n  signature: Signature,\n  message: HashInputLegacy,\n  publicKey: PublicKey,\n  networkId: NetworkId\n) {\n  try {\n    let { r, s } = signature;\n    let pk = PublicKey.toGroup(publicKey);\n    let e = hashMessageLegacy(message, pk, r, networkId);\n    let { scale, one, sub } = Pallas;\n    let R = sub(scale(one, s), scale(Group.toProjective(pk), e));\n    // if `R` is infinity, Group.fromProjective throws an error, so `verify` returns false\n    let { x: rx, y: ry } = Group.fromProjective(R);\n    return Field.isEven(ry) && Field.equal(rx, r);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Same as {@link deriveNonce}, but using the \"legacy\" style of hash input packing.\n */\nfunction deriveNonceLegacy(\n  message: HashInputLegacy,\n  publicKey: Group,\n  privateKey: Scalar,\n  networkId: NetworkId\n): Scalar {\n  let { x, y } = publicKey;\n  let scalarBits = Scalar.toBits(privateKey);\n  let id = getNetworkIdHashInput(networkId)[0];\n  let idBits = bytesToBits([Number(id)]);\n  let input = HashInputLegacy.append(message, {\n    fields: [x, y],\n    bits: [...scalarBits, ...idBits],\n  });\n  let inputBits = inputToBitsLegacy(input);\n  let inputBytes = bitsToBytes(inputBits);\n  let bytes = blake2b(Uint8Array.from(inputBytes), undefined, 32);\n  // drop the top two bits to convert into a scalar field element\n  // (creates negligible bias because q = 2^254 + eps, eps << q)\n  bytes[bytes.length - 1] &= 0x3f;\n  return Scalar.fromBytes([...bytes]);\n}\n\n/**\n * Same as {@link hashMessage}, except for two differences:\n * - uses the \"legacy\" style of hash input packing.\n * - uses Poseidon with \"legacy\" parameters for hashing\n *\n * The method produces a hash in the Pallas base field ({@link Field}) and reinterprets it as a {@link Scalar}.\n * This is possible, and a no-op, since the scalar field is larger and both fields are represented with bigints.\n */\nfunction hashMessageLegacy(\n  message: HashInputLegacy,\n  publicKey: Group,\n  r: Field,\n  networkId: NetworkId\n): Scalar {\n  let { x, y } = publicKey;\n  let input = HashInputLegacy.append(message, { fields: [x, y, r], bits: [] });\n  let prefix = signaturePrefix(networkId);\n  return HashLegacy.hashWithPrefix(prefix, packToFieldsLegacy(input));\n}\n\nconst numberToBytePadded = (b: number) => b.toString(2).padStart(8, '0');\n\nfunction networkIdOfString(n: string): [bigint, number] {\n  let l = n.length;\n  let acc = '';\n  for (let i = l - 1; i >= 0; i--) {\n    let b = n.charCodeAt(i);\n    let padded = numberToBytePadded(b);\n    acc = acc.concat(padded);\n  }\n  return [BigInt('0b' + acc), acc.length];\n}\n\nfunction getNetworkIdHashInput(network: NetworkId): [bigint, number] {\n  let s = NetworkId.toString(network);\n  switch (s) {\n    case 'mainnet':\n      return [networkIdMainnet, 8];\n    case 'devnet':\n    case 'testnet':\n      return [networkIdDevnet, 8];\n    default:\n      return networkIdOfString(s);\n  }\n}\n\nconst createCustomPrefix = (prefix: string) => {\n  const maxLength = 20;\n  const paddingChar = '*';\n  let length = prefix.length;\n\n  if (length <= maxLength) {\n    let diff = maxLength - length;\n    return prefix + paddingChar.repeat(diff);\n  } else {\n    return prefix.substring(0, maxLength);\n  }\n};\n\nconst signaturePrefix = (network: NetworkId) => {\n  let s = NetworkId.toString(network);\n  switch (s) {\n    case 'mainnet':\n      return prefixes.signatureMainnet;\n    case 'devnet':\n    case 'testnet':\n      return prefixes.signatureTestnet;\n    default:\n      return createCustomPrefix(s + 'Signature');\n  }\n};\n\nconst zkAppBodyPrefix = (network: NetworkId) => {\n  let s = NetworkId.toString(network);\n  switch (s) {\n    case 'mainnet':\n      return prefixes.zkappBodyMainnet;\n    case 'devnet':\n    case 'testnet':\n      return prefixes.zkappBodyTestnet;\n    default:\n      return createCustomPrefix(s + 'ZkappBody');\n  }\n};\n", "import { Field, sizeInBits } from './field-bigint.js';\nimport { Poseidon, PoseidonLegacy } from '../../bindings/crypto/poseidon.js';\nimport { prefixes } from '../../bindings/crypto/constants.js';\nimport { createHashInput } from '../../bindings/lib/provable-generic.js';\nimport { GenericHashInput } from '../../bindings/lib/generic.js';\nimport { createHashHelpers } from '../../lib/provable/crypto/hash-generic.js';\n\nexport {\n  Poseidon,\n  HashHelpers,\n  HashInput,\n  prefixes,\n  packToFields,\n  hashWithPrefix,\n  packToFieldsLegacy,\n  HashInputLegacy,\n  inputToBitsLegacy,\n  HashLegacy,\n};\n\ntype HashInput = GenericHashInput<Field>;\nconst HashInput = createHashInput<Field>();\nconst HashHelpers = createHashHelpers(Field, Poseidon);\nlet { hashWithPrefix } = HashHelpers;\n\nconst HashLegacy = createHashHelpers(Field, PoseidonLegacy);\n\n/**\n * Convert the {fields, packed} hash input representation to a list of field elements\n * Random_oracle_input.Chunked.pack_to_fields\n */\nfunction packToFields({ fields = [], packed = [] }: HashInput) {\n  if (packed.length === 0) return fields;\n  let packedBits = [];\n  let currentPackedField = 0n;\n  let currentSize = 0;\n  for (let [field, size] of packed) {\n    currentSize += size;\n    if (currentSize < 255) {\n      currentPackedField = currentPackedField * (1n << BigInt(size)) + field;\n    } else {\n      packedBits.push(currentPackedField);\n      currentSize = size;\n      currentPackedField = field;\n    }\n  }\n  packedBits.push(currentPackedField);\n  return fields.concat(packedBits);\n}\n\n/**\n * Random_oracle_input.Legacy.pack_to_fields\n */\nfunction packToFieldsLegacy({ fields, bits }: HashInputLegacy) {\n  let packedFields = [];\n  while (bits.length > 0) {\n    let fieldBits = bits.splice(0, sizeInBits - 1);\n    let field = Field.fromBits(fieldBits);\n    packedFields.push(field);\n  }\n  return fields.concat(packedFields);\n}\nfunction inputToBitsLegacy({ fields, bits }: HashInputLegacy) {\n  let fieldBits = fields.map(Field.toBits).flat();\n  return fieldBits.concat(bits);\n}\n\ntype HashInputLegacy = { fields: Field[]; bits: boolean[] };\n\nconst HashInputLegacy = {\n  empty(): HashInputLegacy {\n    return { fields: [], bits: [] };\n  },\n  bits(bits: boolean[]): HashInputLegacy {\n    return { fields: [], bits };\n  },\n  append(input1: HashInputLegacy, input2: HashInputLegacy): HashInputLegacy {\n    return {\n      fields: (input1.fields ?? []).concat(input2.fields ?? []),\n      bits: (input1.bits ?? []).concat(input2.bits ?? []),\n    };\n  },\n};\n", "import type { ZkappCommand as ZkappCommandJson } from '../../bindings/mina-transaction/gen/v1/transaction-json.js';\nimport type { SignatureJson } from './signature.js';\n\nexport type UInt32 = number | bigint | string;\nexport type UInt64 = number | bigint | string;\n\nexport type Field = number | bigint | string;\n\nexport type PublicKey = string;\nexport type PrivateKey = string;\nexport type Signature = SignatureJson;\n\n// testnet is deprecated in favor of devnet\nexport type NetworkId = 'mainnet' | 'devnet' | 'testnet' | { custom: string };\n\nexport const NetworkId = {\n  toString(network: NetworkId) {\n    return typeof network === 'string' ? network : network.custom;\n  },\n};\n\nexport type Keypair = {\n  readonly privateKey: PrivateKey;\n  readonly publicKey: PublicKey;\n};\n\nexport type Common = {\n  readonly to: PublicKey;\n  readonly from: PublicKey;\n  readonly fee: UInt64;\n  readonly nonce: UInt32;\n  readonly memo?: string;\n  readonly validUntil?: UInt32;\n};\nexport type StrictCommon = {\n  readonly to: string;\n  readonly from: string;\n  readonly fee: string;\n  readonly nonce: string;\n  readonly memo: string;\n  readonly validUntil: string;\n};\n\nexport type StakeDelegation = Common;\nexport type Payment = Common & { readonly amount: UInt64 };\n\ntype FeePayer = {\n  readonly feePayer: PublicKey;\n  readonly fee: UInt64;\n  readonly nonce: UInt32;\n  readonly memo?: string;\n  readonly validUntil?: UInt32 | null;\n};\nexport type StrictFeePayer = {\n  readonly feePayer: PublicKey;\n  readonly fee: string;\n  readonly nonce: string;\n  readonly memo: string;\n  readonly validUntil: string | null;\n};\n\nexport type ZkappCommand = {\n  readonly zkappCommand: ZkappCommandJson;\n  readonly feePayer: FeePayer;\n};\n\nexport type SignableData = string | StakeDelegation | Payment;\n\nexport type SignedLegacy<T> = {\n  signature: SignatureJson;\n  publicKey: PublicKey;\n  data: T;\n};\nexport type Signed<T> = {\n  signature: string; // base58\n  publicKey: PublicKey;\n  data: T;\n};\n\n// distinguish from Signed because signature is in hex format\nexport type SignedRosetta<T> = Signed<T>;\n\nexport type SignedAny = SignedLegacy<SignableData> | Signed<ZkappCommand>;\n\nexport type Group = {\n  x: Field;\n  y: Field;\n};\n\nexport type Nullifier = {\n  publicKey: Group;\n  public: {\n    nullifier: Group;\n    s: Field;\n  };\n  private: {\n    c: Field;\n    g_r: Group;\n    h_m_pk_r: Group;\n  };\n};\n", "import { Field, Bool, Group, Scalar } from '../wrapped.js';\nimport { AnyConstructor } from '../types/struct.js';\nimport { hashWithPrefix } from './poseidon.js';\nimport {\n  deriveNonce,\n  Signature as SignatureBigint,\n  signaturePrefix,\n} from '../../../mina-signer/src/signature.js';\nimport {\n  PrivateKey as PrivateKeyBigint,\n  PublicKey as PublicKeyBigint,\n} from '../../../mina-signer/src/curve-bigint.js';\nimport { toConstantField } from '../field.js';\nimport { CircuitValue, prop } from '../types/circuit-value.js';\n\n// external API\nexport { PrivateKey, PublicKey, Signature };\n\n/**\n * A signing key. You can generate one via {@link PrivateKey.random}.\n */\nclass PrivateKey extends CircuitValue {\n  @prop s: Scalar;\n\n  constructor(s: Scalar) {\n    super(s);\n  }\n\n  /**\n   * Generate a random private key.\n   *\n   * You can obtain the associated public key via {@link toPublicKey}.\n   * And generate signatures via {@link Signature.create}.\n   *\n   * Note: This uses node or browser built-in APIs to obtain cryptographically strong randomness,\n   * and can be safely used to generate a real private key.\n   *\n   * @returns a new {@link PrivateKey}.\n   */\n  static random(): PrivateKey {\n    return new PrivateKey(Scalar.random());\n  }\n\n  /**\n   * Create a random keypair `{ privateKey: PrivateKey, publicKey: PublicKey }`.\n   *\n   * Note: This uses node or browser built-in APIs to obtain cryptographically strong randomness,\n   * and can be safely used to generate a real keypair.\n   */\n  static randomKeypair() {\n    let privateKey = PrivateKey.random();\n    return { privateKey, publicKey: privateKey.toPublicKey() };\n  }\n\n  /**\n   * Deserializes a list of bits into a {@link PrivateKey}.\n   *\n   * @param bs a list of {@link Bool}.\n   * @returns a {@link PrivateKey}.\n   */\n  static fromBits(bs: Bool[]): PrivateKey {\n    return new PrivateKey(Scalar.fromBits(bs));\n  }\n\n  /**\n   * Convert this {@link PrivateKey} to a bigint\n   */\n  toBigInt() {\n    return this.s.toBigInt();\n  }\n\n  /**\n   * Create a {@link PrivateKey} from a bigint\n   *\n   * **Warning**: Private keys should be sampled from secure randomness with sufficient entropy.\n   * Be careful that you don't use this method to create private keys that were sampled insecurely.\n   */\n  static fromBigInt(sk: bigint) {\n    return new PrivateKey(Scalar.from(sk));\n  }\n\n  /**\n   * Derives the associated public key.\n   *\n   * @returns a {@link PublicKey}.\n   */\n  toPublicKey(): PublicKey {\n    return PublicKey.fromPrivateKey(this);\n  }\n\n  /**\n   * Decodes a base58 string into a {@link PrivateKey}.\n   *\n   * @returns a {@link PrivateKey}.\n   */\n  static fromBase58(privateKeyBase58: string) {\n    let scalar = PrivateKeyBigint.fromBase58(privateKeyBase58);\n    return new PrivateKey(Scalar.from(scalar));\n  }\n\n  /**\n   * Encodes a {@link PrivateKey} into a base58 string.\n   * @returns a base58 encoded string\n   */\n  toBase58() {\n    return PrivateKey.toBase58(this);\n  }\n\n  // static version, to operate on non-class versions of this type\n  /**\n   * Static method to encode a {@link PrivateKey} into a base58 string.\n   * @returns a base58 encoded string\n   */\n  static toBase58(privateKey: { s: Scalar }) {\n    return PrivateKeyBigint.toBase58(privateKey.s.toBigInt());\n  }\n\n  static toValue(v: PrivateKey) {\n    return v.toBigInt();\n  }\n  static fromValue<T extends AnyConstructor>(this: T, v: bigint | PrivateKey): InstanceType<T> {\n    if (v instanceof PrivateKey) return v as any;\n    return PrivateKey.fromBigInt(v) as any;\n  }\n}\n\n// TODO: this doesn't have a non-default check method yet. does it need one?\n/**\n * A public key, which is also an address on the Mina network.\n * You can derive a {@link PublicKey} directly from a {@link PrivateKey}.\n */\nclass PublicKey extends CircuitValue {\n  // compressed representation of a curve point, where `isOdd` is the least significant bit of `y`\n  @prop x: Field;\n  @prop isOdd: Bool;\n\n  /**\n   * Returns the {@link Group} representation of this {@link PublicKey}.\n   * @returns A {@link Group}\n   */\n  toGroup(): Group {\n    // compute y from elliptic curve equation y^2 = x^3 + 5\n    let { x, isOdd } = this;\n    let y = x.square().mul(x).add(5).sqrt();\n\n    // negate y if its parity is different from the public key's\n    let sameParity = y.isOdd().equals(isOdd).toField();\n    let sign = sameParity.mul(2).sub(1); // (2*sameParity - 1) == 1 if same parity, -1 if different parity\n    y = y.mul(sign);\n\n    return new Group({ x, y });\n  }\n\n  /**\n   * Creates a {@link PublicKey} from a {@link Group} element.\n   * @returns a {@link PublicKey}.\n   */\n  static fromGroup({ x, y }: Group): PublicKey {\n    return PublicKey.fromObject({ x, isOdd: y.isOdd() });\n  }\n\n  /**\n   * Derives a {@link PublicKey} from a {@link PrivateKey}.\n   * @returns a {@link PublicKey}.\n   */\n  static fromPrivateKey({ s }: PrivateKey): PublicKey {\n    return PublicKey.fromGroup(Group.generator.scale(s));\n  }\n\n  /**\n   * Creates a {@link PublicKey} from a JSON structure element.\n   * @returns a {@link PublicKey}.\n   */\n  static from(g: { x: Field | bigint; isOdd: Bool | boolean }) {\n    return PublicKey.fromObject({ x: Field.from(g.x), isOdd: Bool(g.isOdd) });\n  }\n\n  /**\n   * Creates an empty {@link PublicKey}.\n   * @returns an empty {@link PublicKey}\n   */\n  static empty<T extends AnyConstructor>(): InstanceType<T> {\n    return PublicKey.from({ x: 0n, isOdd: false }) as any;\n  }\n\n  /**\n   * Checks if a {@link PublicKey} is empty.\n   * @returns a {@link Bool}\n   */\n  isEmpty() {\n    // there are no curve points with x === 0\n    return this.x.equals(0);\n  }\n\n  /**\n   * Decodes a base58 encoded {@link PublicKey} into a {@link PublicKey}.\n   * @returns a {@link PublicKey}\n   */\n  static fromBase58(publicKeyBase58: string) {\n    let { x, isOdd } = PublicKeyBigint.fromBase58(publicKeyBase58);\n    return PublicKey.from({ x: Field(x), isOdd: Bool(!!isOdd) });\n  }\n\n  /**\n   * Encodes a {@link PublicKey} in base58 format.\n   * @returns a base58 encoded {@link PublicKey}\n   */\n  toBase58() {\n    return PublicKey.toBase58(this);\n  }\n\n  /**\n   * Static method to encode a {@link PublicKey} into base58 format.\n   * @returns a base58 encoded {@link PublicKey}\n   */\n  static toBase58({ x, isOdd }: PublicKey) {\n    x = toConstantField(x, 'toBase58', 'pk', 'public key');\n    return PublicKeyBigint.toBase58({\n      x: x.toBigInt(),\n      isOdd: isOdd.toBoolean(),\n    });\n  }\n\n  /**\n   * Serializes a {@link PublicKey} into its JSON representation.\n   * @returns a JSON string\n   */\n  static toJSON(publicKey: PublicKey) {\n    return publicKey.toBase58();\n  }\n\n  /**\n   * Deserializes a JSON string into a {@link PublicKey}.\n   * @returns a JSON string\n   */\n  static fromJSON<T extends AnyConstructor>(this: T, publicKey: string) {\n    return PublicKey.fromBase58(publicKey) as InstanceType<T>;\n  }\n\n  static toValue({ x, isOdd }: PublicKey) {\n    return { x: x.toBigInt(), isOdd: isOdd.toBoolean() };\n  }\n  static fromValue<T extends AnyConstructor>(\n    this: T,\n    { x, isOdd }: { x: Field | bigint; isOdd: Bool | boolean }\n  ): InstanceType<T> {\n    return PublicKey.from({ x: Field.from(x), isOdd: Bool(isOdd) }) as any;\n  }\n}\n\n/**\n * A Schnorr {@link Signature} over the Pasta Curves.\n */\nclass Signature extends CircuitValue {\n  @prop r: Field;\n  @prop s: Scalar;\n\n  /**\n   * Signs a message using a {@link PrivateKey}.\n   * @returns a {@link Signature}\n   */\n  static create(privKey: PrivateKey, msg: Field[]): Signature {\n    let publicKey = PublicKey.fromPrivateKey(privKey).toGroup();\n    let d = privKey.s;\n\n    // we chose an arbitrary prefix for the signature\n    // there's no consequences in practice and the signatures can be used with any network\n    // if there needs to be a custom nonce, include it in the message itself\n    let kPrime = Scalar.from(\n      deriveNonce(\n        { fields: msg.map((f) => f.toBigInt()) },\n        { x: publicKey.x.toBigInt(), y: publicKey.y.toBigInt() },\n        d.toBigInt(),\n        'devnet'\n      )\n    );\n\n    let { x: r, y: ry } = Group.generator.scale(kPrime);\n    let k = ry.isOdd().toBoolean() ? kPrime.neg() : kPrime;\n    let h = hashWithPrefix(signaturePrefix('devnet'), msg.concat([publicKey.x, publicKey.y, r]));\n    let e = Scalar.fromField(h);\n    let s = e.mul(d).add(k);\n    return new Signature(r, s);\n  }\n\n  /**\n   * Verifies the {@link Signature} using a message and the corresponding {@link PublicKey}.\n   * @returns a {@link Bool}\n   */\n  verify(publicKey: PublicKey, msg: Field[]): Bool {\n    let point = publicKey.toGroup();\n\n    // we chose an arbitrary prefix for the signature\n    // there's no consequences in practice and the signatures can be used with any network\n    // if there needs to be a custom nonce, include it in the message itself\n    let h = hashWithPrefix(signaturePrefix('devnet'), msg.concat([point.x, point.y, this.r]));\n\n    let r = point.scale(h).neg().add(Group.generator.scale(this.s));\n    return r.x.equals(this.r).and(r.y.isEven());\n  }\n\n  /**\n   * Decodes a base58 encoded signature into a {@link Signature}.\n   */\n  static fromBase58(signatureBase58: string) {\n    let { r, s } = SignatureBigint.fromBase58(signatureBase58);\n    return Signature.fromObject({ r: Field(r), s: Scalar.from(s) });\n  }\n  /**\n   * Encodes a {@link Signature} in base58 format.\n   */\n  toBase58() {\n    let r = this.r.toBigInt();\n    let s = this.s.toBigInt();\n    return SignatureBigint.toBase58({ r, s });\n  }\n\n  static fromValue<T extends AnyConstructor>(\n    this: T,\n    { r, s }: { r: Field | bigint; s: Scalar | bigint }\n  ): InstanceType<T> {\n    return Signature.fromObject({ r: Field.from(r), s: Scalar.from(s) }) as any;\n  }\n}\n", "// @generated this file is auto-generated - don't edit it directly\n\nimport { GenericLayout, ProvableFromLayout } from '../../../lib/from-layout.js';\nimport { GenericProvableExtended } from '../../../lib/generic.js';\nimport {\n  ActionState,\n  Actions,\n  AuthRequired,\n  BalanceChange,\n  Bool,\n  Events,\n  Field,\n  MayUseToken,\n  PublicKey,\n  ReceiptChainHash,\n  Sign,\n  StateHash,\n  TokenId,\n  TokenSymbol,\n  TransactionVersion,\n  UInt32,\n  UInt64,\n  VerificationKeyHash,\n  ZkappUri,\n} from '../../v1/transaction-leaves.js';\nimport { jsLayout } from './js-layout.js';\nimport * as Value from './transaction-bigint.js';\nimport * as Json from './transaction-json.js';\n\nexport * from '../../v1/transaction-leaves.js';\nexport {\n  Account,\n  AccountUpdate,\n  Json,\n  Layout,\n  TypeMap,\n  ZkappCommand,\n  customTypes,\n  empty,\n  provableFromLayout,\n  toJSONEssential,\n};\n\ntype TypeMap = {\n  PublicKey: PublicKey;\n  UInt64: UInt64;\n  UInt32: UInt32;\n  TokenId: TokenId;\n  Field: Field;\n  AuthRequired: AuthRequired;\n  BalanceChange: BalanceChange;\n  Sign: Sign;\n  Bool: Bool;\n};\n\nconst TypeMap: {\n  [K in keyof TypeMap]: ProvableExtended<TypeMap[K], Value.TypeMap[K], Json.TypeMap[K]>;\n} = {\n  PublicKey,\n  UInt64,\n  UInt32,\n  TokenId,\n  Field,\n  AuthRequired,\n  BalanceChange,\n  Sign,\n  Bool,\n};\n\ntype ProvableExtended<T, TValue, TJson> = GenericProvableExtended<T, TValue, TJson, Field>;\ntype Layout = GenericLayout<TypeMap>;\n\ntype CustomTypes = {\n  TransactionVersion: ProvableExtended<UInt32, Value.TypeMap['UInt32'], Json.TypeMap['UInt32']>;\n  ZkappUri: ProvableExtended<\n    {\n      data: string;\n      hash: Field;\n    },\n    {\n      data: string;\n      hash: Value.TypeMap['Field'];\n    },\n    string\n  >;\n  TokenSymbol: ProvableExtended<\n    {\n      symbol: string;\n      field: Field;\n    },\n    {\n      symbol: string;\n      field: Value.TypeMap['Field'];\n    },\n    string\n  >;\n  StateHash: ProvableExtended<Field, Value.TypeMap['Field'], Json.TypeMap['Field']>;\n  BalanceChange: ProvableExtended<\n    BalanceChange,\n    Value.TypeMap['BalanceChange'],\n    {\n      magnitude: Json.TypeMap['UInt64'];\n      sgn: Json.TypeMap['Sign'];\n    }\n  >;\n  Events: ProvableExtended<\n    {\n      data: Field[][];\n      hash: Field;\n    },\n    {\n      data: Value.TypeMap['Field'][][];\n      hash: Value.TypeMap['Field'];\n    },\n    Json.TypeMap['Field'][][]\n  >;\n  Actions: ProvableExtended<\n    {\n      data: Field[][];\n      hash: Field;\n    },\n    {\n      data: Value.TypeMap['Field'][][];\n      hash: Value.TypeMap['Field'];\n    },\n    Json.TypeMap['Field'][][]\n  >;\n  ActionState: ProvableExtended<Field, Value.TypeMap['Field'], Json.TypeMap['Field']>;\n  MayUseToken: ProvableExtended<\n    {\n      parentsOwnToken: Bool;\n      inheritFromParent: Bool;\n    },\n    {\n      parentsOwnToken: Value.TypeMap['Bool'];\n      inheritFromParent: Value.TypeMap['Bool'];\n    },\n    {\n      parentsOwnToken: Json.TypeMap['Bool'];\n      inheritFromParent: Json.TypeMap['Bool'];\n    }\n  >;\n  VerificationKeyHash: ProvableExtended<Field, Value.TypeMap['Field'], Json.TypeMap['Field']>;\n  ReceiptChainHash: ProvableExtended<Field, Value.TypeMap['Field'], Json.TypeMap['Field']>;\n};\nlet customTypes: CustomTypes = {\n  TransactionVersion,\n  ZkappUri,\n  TokenSymbol,\n  StateHash,\n  BalanceChange,\n  Events,\n  Actions,\n  ActionState,\n  MayUseToken,\n  VerificationKeyHash,\n  ReceiptChainHash,\n};\nlet { provableFromLayout, toJSONEssential, empty } = ProvableFromLayout<\n  TypeMap,\n  Value.TypeMap,\n  Json.TypeMap\n>(TypeMap, customTypes);\n\ntype ZkappCommand = {\n  feePayer: {\n    body: {\n      publicKey: PublicKey;\n      fee: UInt64;\n      validUntil?: UInt32;\n      nonce: UInt32;\n    };\n    authorization: string;\n  };\n  accountUpdates: {\n    body: {\n      publicKey: PublicKey;\n      tokenId: TokenId;\n      update: {\n        appState: { isSome: Bool; value: Field }[];\n        delegate: { isSome: Bool; value: PublicKey };\n        verificationKey: {\n          isSome: Bool;\n          value: {\n            data: string;\n            hash: Field;\n          };\n        };\n        permissions: {\n          isSome: Bool;\n          value: {\n            editState: AuthRequired;\n            access: AuthRequired;\n            send: AuthRequired;\n            receive: AuthRequired;\n            setDelegate: AuthRequired;\n            setPermissions: AuthRequired;\n            setVerificationKey: {\n              auth: AuthRequired;\n              txnVersion: UInt32;\n            };\n            setZkappUri: AuthRequired;\n            editActionState: AuthRequired;\n            setTokenSymbol: AuthRequired;\n            incrementNonce: AuthRequired;\n            setVotingFor: AuthRequired;\n            setTiming: AuthRequired;\n          };\n        };\n        zkappUri: {\n          isSome: Bool;\n          value: {\n            data: string;\n            hash: Field;\n          };\n        };\n        tokenSymbol: {\n          isSome: Bool;\n          value: {\n            symbol: string;\n            field: Field;\n          };\n        };\n        timing: {\n          isSome: Bool;\n          value: {\n            initialMinimumBalance: UInt64;\n            cliffTime: UInt32;\n            cliffAmount: UInt64;\n            vestingPeriod: UInt32;\n            vestingIncrement: UInt64;\n          };\n        };\n        votingFor: { isSome: Bool; value: Field };\n      };\n      balanceChange: BalanceChange;\n      incrementNonce: Bool;\n      events: {\n        data: Field[][];\n        hash: Field;\n      };\n      actions: {\n        data: Field[][];\n        hash: Field;\n      };\n      callData: Field;\n      callDepth: number;\n      preconditions: {\n        network: {\n          snarkedLedgerHash: { isSome: Bool; value: Field };\n          blockchainLength: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          minWindowDensity: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          totalCurrency: {\n            isSome: Bool;\n            value: {\n              lower: UInt64;\n              upper: UInt64;\n            };\n          };\n          globalSlotSinceGenesis: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          stakingEpochData: {\n            ledger: {\n              hash: { isSome: Bool; value: Field };\n              totalCurrency: {\n                isSome: Bool;\n                value: {\n                  lower: UInt64;\n                  upper: UInt64;\n                };\n              };\n            };\n            seed: { isSome: Bool; value: Field };\n            startCheckpoint: { isSome: Bool; value: Field };\n            lockCheckpoint: { isSome: Bool; value: Field };\n            epochLength: {\n              isSome: Bool;\n              value: {\n                lower: UInt32;\n                upper: UInt32;\n              };\n            };\n          };\n          nextEpochData: {\n            ledger: {\n              hash: { isSome: Bool; value: Field };\n              totalCurrency: {\n                isSome: Bool;\n                value: {\n                  lower: UInt64;\n                  upper: UInt64;\n                };\n              };\n            };\n            seed: { isSome: Bool; value: Field };\n            startCheckpoint: { isSome: Bool; value: Field };\n            lockCheckpoint: { isSome: Bool; value: Field };\n            epochLength: {\n              isSome: Bool;\n              value: {\n                lower: UInt32;\n                upper: UInt32;\n              };\n            };\n          };\n        };\n        account: {\n          balance: {\n            isSome: Bool;\n            value: {\n              lower: UInt64;\n              upper: UInt64;\n            };\n          };\n          nonce: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          receiptChainHash: { isSome: Bool; value: Field };\n          delegate: { isSome: Bool; value: PublicKey };\n          state: { isSome: Bool; value: Field }[];\n          actionState: { isSome: Bool; value: Field };\n          provedState: { isSome: Bool; value: Bool };\n          isNew: { isSome: Bool; value: Bool };\n        };\n        validWhile: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n      };\n      useFullCommitment: Bool;\n      implicitAccountCreationFee: Bool;\n      mayUseToken: {\n        parentsOwnToken: Bool;\n        inheritFromParent: Bool;\n      };\n      authorizationKind: {\n        isSigned: Bool;\n        isProved: Bool;\n        verificationKeyHash: Field;\n      };\n    };\n    authorization: {\n      proof?: string;\n      signature?: string;\n    };\n  }[];\n  memo: string;\n};\n\nlet ZkappCommand = provableFromLayout<ZkappCommand, Value.ZkappCommand, Json.ZkappCommand>(\n  jsLayout.ZkappCommand as any\n);\n\ntype AccountUpdate = {\n  body: {\n    publicKey: PublicKey;\n    tokenId: TokenId;\n    update: {\n      appState: { isSome: Bool; value: Field }[];\n      delegate: { isSome: Bool; value: PublicKey };\n      verificationKey: {\n        isSome: Bool;\n        value: {\n          data: string;\n          hash: Field;\n        };\n      };\n      permissions: {\n        isSome: Bool;\n        value: {\n          editState: AuthRequired;\n          access: AuthRequired;\n          send: AuthRequired;\n          receive: AuthRequired;\n          setDelegate: AuthRequired;\n          setPermissions: AuthRequired;\n          setVerificationKey: {\n            auth: AuthRequired;\n            txnVersion: UInt32;\n          };\n          setZkappUri: AuthRequired;\n          editActionState: AuthRequired;\n          setTokenSymbol: AuthRequired;\n          incrementNonce: AuthRequired;\n          setVotingFor: AuthRequired;\n          setTiming: AuthRequired;\n        };\n      };\n      zkappUri: {\n        isSome: Bool;\n        value: {\n          data: string;\n          hash: Field;\n        };\n      };\n      tokenSymbol: {\n        isSome: Bool;\n        value: {\n          symbol: string;\n          field: Field;\n        };\n      };\n      timing: {\n        isSome: Bool;\n        value: {\n          initialMinimumBalance: UInt64;\n          cliffTime: UInt32;\n          cliffAmount: UInt64;\n          vestingPeriod: UInt32;\n          vestingIncrement: UInt64;\n        };\n      };\n      votingFor: { isSome: Bool; value: Field };\n    };\n    balanceChange: BalanceChange;\n    incrementNonce: Bool;\n    events: {\n      data: Field[][];\n      hash: Field;\n    };\n    actions: {\n      data: Field[][];\n      hash: Field;\n    };\n    callData: Field;\n    callDepth: number;\n    preconditions: {\n      network: {\n        snarkedLedgerHash: { isSome: Bool; value: Field };\n        blockchainLength: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        minWindowDensity: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        totalCurrency: {\n          isSome: Bool;\n          value: {\n            lower: UInt64;\n            upper: UInt64;\n          };\n        };\n        globalSlotSinceGenesis: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        stakingEpochData: {\n          ledger: {\n            hash: { isSome: Bool; value: Field };\n            totalCurrency: {\n              isSome: Bool;\n              value: {\n                lower: UInt64;\n                upper: UInt64;\n              };\n            };\n          };\n          seed: { isSome: Bool; value: Field };\n          startCheckpoint: { isSome: Bool; value: Field };\n          lockCheckpoint: { isSome: Bool; value: Field };\n          epochLength: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n        };\n        nextEpochData: {\n          ledger: {\n            hash: { isSome: Bool; value: Field };\n            totalCurrency: {\n              isSome: Bool;\n              value: {\n                lower: UInt64;\n                upper: UInt64;\n              };\n            };\n          };\n          seed: { isSome: Bool; value: Field };\n          startCheckpoint: { isSome: Bool; value: Field };\n          lockCheckpoint: { isSome: Bool; value: Field };\n          epochLength: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n        };\n      };\n      account: {\n        balance: {\n          isSome: Bool;\n          value: {\n            lower: UInt64;\n            upper: UInt64;\n          };\n        };\n        nonce: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        receiptChainHash: { isSome: Bool; value: Field };\n        delegate: { isSome: Bool; value: PublicKey };\n        state: { isSome: Bool; value: Field }[];\n        actionState: { isSome: Bool; value: Field };\n        provedState: { isSome: Bool; value: Bool };\n        isNew: { isSome: Bool; value: Bool };\n      };\n      validWhile: {\n        isSome: Bool;\n        value: {\n          lower: UInt32;\n          upper: UInt32;\n        };\n      };\n    };\n    useFullCommitment: Bool;\n    implicitAccountCreationFee: Bool;\n    mayUseToken: {\n      parentsOwnToken: Bool;\n      inheritFromParent: Bool;\n    };\n    authorizationKind: {\n      isSigned: Bool;\n      isProved: Bool;\n      verificationKeyHash: Field;\n    };\n  };\n  authorization: {\n    proof?: string;\n    signature?: string;\n  };\n};\n\nlet AccountUpdate = provableFromLayout<AccountUpdate, Value.AccountUpdate, Json.AccountUpdate>(\n  jsLayout.AccountUpdate as any\n);\n\ntype Account = {\n  publicKey: PublicKey;\n  tokenId: TokenId;\n  tokenSymbol: string;\n  balance: UInt64;\n  nonce: UInt32;\n  receiptChainHash: Field;\n  delegate?: PublicKey;\n  votingFor: Field;\n  timing: {\n    isTimed: Bool;\n    initialMinimumBalance: UInt64;\n    cliffTime: UInt32;\n    cliffAmount: UInt64;\n    vestingPeriod: UInt32;\n    vestingIncrement: UInt64;\n  };\n  permissions: {\n    editState: AuthRequired;\n    access: AuthRequired;\n    send: AuthRequired;\n    receive: AuthRequired;\n    setDelegate: AuthRequired;\n    setPermissions: AuthRequired;\n    setVerificationKey: {\n      auth: AuthRequired;\n      txnVersion: UInt32;\n    };\n    setZkappUri: AuthRequired;\n    editActionState: AuthRequired;\n    setTokenSymbol: AuthRequired;\n    incrementNonce: AuthRequired;\n    setVotingFor: AuthRequired;\n    setTiming: AuthRequired;\n  };\n  zkapp?: {\n    appState: Field[];\n    verificationKey?: {\n      data: string;\n      hash: Field;\n    };\n    zkappVersion: UInt32;\n    actionState: Field[];\n    lastActionSlot: UInt32;\n    provedState: Bool;\n    zkappUri: string;\n  };\n};\n\nlet Account = provableFromLayout<Account, Value.Account, Json.Account>(jsLayout.Account as any);\n", "import { Binable } from './binable.js';\n\nexport {\n  GenericProvable,\n  GenericProvablePure,\n  GenericProvableExtended,\n  GenericProvableExtendedPure,\n  GenericField,\n  GenericBool,\n  GenericHashInput,\n  GenericSignable,\n  GenericSignableField,\n  GenericSignableBool,\n  primitiveTypes,\n  PrimitiveTypeMap,\n  primitiveTypeMap,\n  EmptyNull,\n  EmptyUndefined,\n  EmptyVoid,\n};\n\ntype GenericProvable<T, TValue, Field> = {\n  toFields: (x: T) => Field[];\n  toAuxiliary: (x?: T) => any[];\n  fromFields: (x: Field[], aux: any[]) => T;\n  sizeInFields(): number;\n  check: (x: T) => void;\n  toValue: (x: T) => TValue;\n  fromValue: (x: T | TValue) => T;\n  toCanonical?: (x: T) => T;\n};\ntype GenericProvablePure<T, TValue, Field> = Omit<\n  GenericProvable<T, TValue, Field>,\n  'fromFields'\n> & {\n  fromFields: (x: Field[]) => T;\n};\n\ntype GenericSignable<T, TJson, Field> = {\n  toInput: (x: T) => { fields?: Field[]; packed?: [Field, number][] };\n  toJSON: (x: T) => TJson;\n  fromJSON: (x: TJson) => T;\n  empty: () => T;\n};\n\ntype GenericProvableExtended<T, TValue, TJson, Field> = GenericProvable<T, TValue, Field> &\n  GenericSignable<T, TJson, Field>;\n\ntype GenericProvableExtendedPure<T, TValue, TJson, Field> = GenericProvablePure<T, TValue, Field> &\n  GenericSignable<T, TJson, Field>;\n\ntype GenericSignableField<Field> = ((value: number | string | bigint | Field) => Field) &\n  GenericSignable<Field, string, Field> &\n  Binable<Field> & { sizeInBytes: number; toBigint: (x: Field) => bigint };\n\ntype GenericField<Field> = GenericSignableField<Field> & GenericProvable<Field, bigint, Field>;\n\ntype GenericSignableBool<Field, Bool = unknown> = ((value: boolean) => Bool) &\n  GenericSignable<Bool, boolean, Field> &\n  Binable<Bool> & { sizeInBytes: number };\n\ntype GenericBool<Field, Bool = unknown> = GenericSignableBool<Field, Bool> &\n  GenericProvable<Bool, boolean, Field>;\n\ntype GenericHashInput<Field> = { fields?: Field[]; packed?: [Field, number][] };\n\nconst emptyType = {\n  sizeInFields: () => 0,\n  toFields: () => [],\n  toAuxiliary: (): [] => [],\n  fromFields: () => null,\n  check: () => {},\n  toInput: () => ({}),\n  toJSON: () => null,\n  fromJSON: () => null,\n  empty: () => null,\n  toValue: () => null,\n  fromValue: () => null,\n};\n\nconst undefinedType = {\n  ...emptyType,\n  fromFields: () => undefined,\n  toJSON: () => null,\n  fromJSON: () => undefined,\n  empty: () => undefined,\n  toValue: () => undefined,\n  fromValue: () => undefined,\n};\n\nlet primitiveTypes = new Set(['number', 'string', 'null']);\n\nfunction EmptyNull<Field>(): GenericProvableExtendedPure<null, null, null, Field> {\n  return emptyType;\n}\nfunction EmptyUndefined<Field>(): GenericProvableExtendedPure<undefined, undefined, null, Field> {\n  return undefinedType;\n}\nfunction EmptyVoid<Field>(): GenericProvableExtendedPure<void, void, null, Field> {\n  return undefinedType;\n}\n\ntype PrimitiveTypeMap<Field> = {\n  number: GenericProvableExtended<number, number, number, Field>;\n  string: GenericProvableExtended<string, string, string, Field>;\n  null: GenericProvableExtended<null, null, null, Field>;\n};\n\nconst primitiveTypeMap: PrimitiveTypeMap<any> = {\n  number: {\n    ...emptyType,\n    toAuxiliary: (value = 0) => [value],\n    toJSON: (value) => value,\n    fromJSON: (value) => value,\n    fromFields: (_, [value]) => value,\n    empty: () => 0,\n    toValue: (value) => value,\n    fromValue: (value) => value,\n  },\n  string: {\n    ...emptyType,\n    toAuxiliary: (value = '') => [value],\n    toJSON: (value) => value,\n    fromJSON: (value) => value,\n    fromFields: (_, [value]) => value,\n    empty: () => '',\n    toValue: (value) => value,\n    fromValue: (value) => value,\n  },\n  null: emptyType,\n};\n", "import {\n  GenericProvableExtended,\n  GenericSignable,\n  primitiveTypeMap,\n  primitiveTypes,\n} from './generic.js';\n\nexport { ProvableFromLayout, SignableFromLayout, GenericLayout, genericLayoutFold };\n\ntype GenericTypeMap<\n  Field,\n  Bool,\n  UInt32,\n  UInt64,\n  Sign,\n  BalanceChange,\n  PublicKey,\n  AuthRequired,\n  TokenId,\n> = {\n  Field: Field;\n  Bool: Bool;\n  UInt32: UInt32;\n  UInt64: UInt64;\n  Sign: Sign;\n  BalanceChange: BalanceChange;\n  PublicKey: PublicKey;\n  AuthRequired: AuthRequired;\n  TokenId: TokenId;\n};\ntype AnyTypeMap = GenericTypeMap<any, any, any, any, any, any, any, any, any>;\n\ntype TypeMapValues<TypeMap extends AnyTypeMap, JsonMap extends AnyTypeMap, BaseType> = {\n  [K in keyof TypeMap & keyof JsonMap]: BaseType;\n};\n\ntype TypeMapProvable<\n  TypeMap extends AnyTypeMap,\n  ValueMap extends AnyTypeMap,\n  JsonMap extends AnyTypeMap,\n> = {\n  [K in keyof TypeMap & keyof JsonMap]: K extends keyof ValueMap\n    ? GenericProvableExtended<TypeMap[K], ValueMap[K], JsonMap[K], TypeMap['Field']>\n    : never;\n};\ntype TypeMapSignable<TypeMap extends AnyTypeMap, JsonMap extends AnyTypeMap> = {\n  [K in keyof TypeMap & keyof JsonMap]: GenericSignable<TypeMap[K], JsonMap[K], TypeMap['Field']>;\n};\n\nfunction SignableFromLayout<TypeMap extends AnyTypeMap, JsonMap extends AnyTypeMap>(\n  TypeMap: TypeMapSignable<TypeMap, JsonMap>,\n  customTypes: Record<string, GenericSignable<any, any, TypeMap['Field']>>\n) {\n  type Field = TypeMap['Field'];\n  const Field = TypeMap.Field;\n  type BaseType = GenericSignable<any, any, TypeMap['Field']>;\n  type HashInput = { fields?: Field[]; packed?: [Field, number][] };\n  type Layout = GenericLayout<TypeMap>;\n\n  type FoldSpec<T, R> = GenericFoldSpec<T, R, TypeMap, BaseType>;\n\n  function layoutFold<T, R>(spec: FoldSpec<T, R>, typeData: Layout, value?: T) {\n    return genericLayoutFold(TypeMap, customTypes, spec, typeData, value);\n  }\n\n  function signableFromLayout<T, TJson>(typeData: Layout) {\n    return {\n      toJSON(value: T): TJson {\n        return toJSON(typeData, value);\n      },\n      fromJSON(json: TJson): T {\n        return fromJSON(typeData, json);\n      },\n      toInput(value: T): HashInput {\n        return toInput(typeData, value);\n      },\n      empty(): T {\n        return empty(typeData);\n      },\n    };\n  }\n\n  function toJSON(typeData: Layout, value: any) {\n    return layoutFold<any, any>(\n      {\n        map(type, value) {\n          return type.toJSON(value);\n        },\n        reduceArray(array) {\n          return array;\n        },\n        reduceObject(_, object) {\n          return object;\n        },\n        reduceFlaggedOption({ isSome, value }) {\n          return isSome ? value : null;\n        },\n        reduceOrUndefined(value) {\n          return value ?? null;\n        },\n      },\n      typeData,\n      value\n    );\n  }\n\n  function fromJSON(typeData: Layout, json: any): any {\n    let { checkedTypeName } = typeData;\n    if (checkedTypeName) {\n      // there's a custom type!\n      return customTypes[checkedTypeName].fromJSON(json);\n    }\n    if (typeData.type === 'array') {\n      let arrayTypeData = typeData as ArrayLayout<TypeMap>;\n      return json.map((json: any) => fromJSON(arrayTypeData.inner, json));\n    }\n    if (typeData.type === 'option') {\n      let optionTypeData = typeData as OptionLayout<TypeMap>;\n      switch (optionTypeData.optionType) {\n        case 'closedInterval':\n        case 'flaggedOption': {\n          let isSome = TypeMap.Bool.fromJSON(json !== null);\n          let value;\n          if (json !== null) {\n            value = fromJSON(optionTypeData.inner, json);\n          } else {\n            value = empty(optionTypeData.inner);\n            if (optionTypeData.optionType === 'closedInterval') {\n              let innerInner = optionTypeData.inner.entries.lower;\n              let innerType = TypeMap[innerInner.type as keyof TypeMap & keyof JsonMap];\n              value.lower = innerType.fromJSON(optionTypeData.rangeMin);\n              value.upper = innerType.fromJSON(optionTypeData.rangeMax);\n            }\n          }\n          return { isSome, value };\n        }\n        case 'orUndefined': {\n          return json === null ? undefined : fromJSON(optionTypeData.inner, json);\n        }\n        default:\n          throw Error('bug');\n      }\n    }\n    if (typeData.type === 'object') {\n      let { keys, entries } = typeData as ObjectLayout<TypeMap>;\n      let values: Record<string, any> = {};\n      for (let i = 0; i < keys.length; i++) {\n        let typeEntry = entries[keys[i]];\n        values[keys[i]] = fromJSON(typeEntry, json[keys[i]]);\n      }\n      return values;\n    }\n    if (primitiveTypes.has(typeData.type as string)) {\n      return (primitiveTypeMap as any)[typeData.type].fromJSON(json);\n    }\n    return (TypeMap as any)[typeData.type].fromJSON(json);\n  }\n\n  function empty(typeData: Layout) {\n    return layoutFold<undefined, any>(\n      {\n        map(type) {\n          return type.empty();\n        },\n        reduceArray(array) {\n          return array;\n        },\n        reduceObject(_, object) {\n          return object;\n        },\n        reduceFlaggedOption({ isSome, value }, typeData) {\n          if (typeData.optionType === 'closedInterval') {\n            let innerInner = typeData.inner.entries.lower;\n            let innerType = TypeMap[innerInner.type as 'UInt32' | 'UInt64'];\n            value.lower = innerType.fromJSON(typeData.rangeMin);\n            value.upper = innerType.fromJSON(typeData.rangeMax);\n          }\n          return { isSome, value };\n        },\n        reduceOrUndefined() {\n          return undefined;\n        },\n      },\n      typeData,\n      undefined\n    );\n  }\n\n  function toInput(typeData: Layout, value: any) {\n    return layoutFold<any, HashInput>(\n      {\n        map(type, value) {\n          return type.toInput(value);\n        },\n        reduceArray(array) {\n          let acc: HashInput = { fields: [], packed: [] };\n          for (let { fields, packed } of array) {\n            if (fields) acc.fields!.push(...fields);\n            if (packed) acc.packed!.push(...packed);\n          }\n          return acc;\n        },\n        reduceObject(keys, object) {\n          let acc: HashInput = { fields: [], packed: [] };\n          for (let key of keys) {\n            let { fields, packed } = object[key];\n            if (fields) acc.fields!.push(...fields);\n            if (packed) acc.packed!.push(...packed);\n          }\n          return acc;\n        },\n        reduceFlaggedOption({ isSome, value }) {\n          return {\n            fields: value.fields,\n            packed: isSome.packed!.concat(value.packed ?? []),\n          };\n        },\n        reduceOrUndefined(_) {\n          return {};\n        },\n      },\n      typeData,\n      value\n    );\n  }\n\n  // helper for pretty-printing / debugging\n\n  function toJSONEssential(typeData: Layout, value: any) {\n    return layoutFold<any, any>(\n      {\n        map(type, value) {\n          return type.toJSON(value);\n        },\n        reduceArray(array) {\n          if (array.length === 0 || array.every((x) => x === null)) return null;\n          return array;\n        },\n        reduceObject(_, object) {\n          for (let key in object) {\n            if (object[key] === null) {\n              delete object[key];\n            }\n          }\n          if (Object.keys(object).length === 0) return null;\n          return object;\n        },\n        reduceFlaggedOption({ isSome, value }) {\n          return isSome ? value : null;\n        },\n        reduceOrUndefined(value) {\n          return value ?? null;\n        },\n      },\n      typeData,\n      value\n    );\n  }\n\n  return {\n    signableFromLayout,\n    toInput,\n    toJSON,\n    fromJSON,\n    empty,\n    toJSONEssential,\n  };\n}\n\nfunction ProvableFromLayout<\n  TypeMap extends AnyTypeMap,\n  ValueMap extends AnyTypeMap,\n  JsonMap extends AnyTypeMap,\n>(\n  TypeMap: TypeMapProvable<TypeMap, ValueMap, JsonMap>,\n  customTypes: Record<string, GenericProvableExtended<any, any, any, TypeMap['Field']>>\n) {\n  type Field = TypeMap['Field'];\n  const Field = TypeMap.Field;\n  type BaseType = GenericProvableExtended<any, any, any, TypeMap['Field']>;\n  type HashInput = { fields?: Field[]; packed?: [Field, number][] };\n  type Layout = GenericLayout<TypeMap>;\n\n  type FoldSpec<T, R> = GenericFoldSpec<T, R, TypeMap, BaseType>;\n\n  const { toInput, toJSON, fromJSON, empty, toJSONEssential } = SignableFromLayout(\n    TypeMap,\n    customTypes\n  );\n\n  function layoutFold<T, R>(spec: FoldSpec<T, R>, typeData: Layout, value?: T) {\n    return genericLayoutFold(TypeMap, customTypes, spec, typeData, value);\n  }\n  function layoutMap<T, R>(map: (typeData: BaseType, value: T) => R, typeData: Layout, value: T) {\n    return genericLayoutMap(TypeMap, customTypes, map, typeData, value);\n  }\n\n  function provableFromLayout<T, TValue, TJson>(\n    typeData: Layout\n  ): GenericProvableExtended<T, TValue, TJson, Field> {\n    return {\n      sizeInFields(): number {\n        return sizeInFields(typeData);\n      },\n      toFields(value: T): Field[] {\n        return toFields(typeData, value);\n      },\n      toAuxiliary(value?: T): any[] {\n        return toAuxiliary(typeData, value);\n      },\n      fromFields(fields: Field[], aux: any[]): T {\n        return fromFields(typeData, fields, aux);\n      },\n      toJSON(value: T): TJson {\n        return toJSON(typeData, value);\n      },\n      fromJSON(json: TJson): T {\n        return fromJSON(typeData, json);\n      },\n      check(value: T): void {\n        check(typeData, value);\n      },\n      // TODO implement properly\n      // currently, the implementation below is fine because `provableFromLayout()`\n      // is not used on any non-canonical types, so returning the element itself is correct.\n      // (we do need an implementation though and can't just throw an error)\n      toCanonical(value: T): T {\n        return value;\n      },\n      toInput(value: T): HashInput {\n        return toInput(typeData, value);\n      },\n      empty(): T {\n        return empty(typeData);\n      },\n      toValue(value: T): TValue {\n        return toValue(typeData, value);\n      },\n      fromValue(value: TValue | T): T {\n        return fromValue(typeData, value);\n      },\n    };\n  }\n\n  function toFields(typeData: Layout, value: any) {\n    return layoutFold<any, Field[]>(\n      {\n        map(type, value) {\n          return type.toFields(value);\n        },\n        reduceArray(array) {\n          return array.flat();\n        },\n        reduceObject(keys, object) {\n          return keys.map((key) => object![key]).flat();\n        },\n        reduceFlaggedOption({ isSome, value }) {\n          return [isSome, value].flat();\n        },\n        reduceOrUndefined(_) {\n          return [];\n        },\n      },\n      typeData,\n      value\n    );\n  }\n\n  function toAuxiliary(typeData: Layout, value?: any) {\n    return layoutFold<any, any[]>(\n      {\n        map(type, value) {\n          return type.toAuxiliary(value);\n        },\n        reduceArray(array) {\n          return array;\n        },\n        reduceObject(keys, object) {\n          return keys.map((key) => object[key]);\n        },\n        reduceFlaggedOption({ value }) {\n          return value;\n        },\n        reduceOrUndefined(value) {\n          return value === undefined ? [false] : [true, value];\n        },\n      },\n      typeData,\n      value\n    );\n  }\n\n  function sizeInFields(typeData: Layout) {\n    let spec: FoldSpec<any, number> = {\n      map(type) {\n        return type.sizeInFields();\n      },\n      reduceArray(_, { inner, staticLength }): number {\n        let length = staticLength ?? NaN;\n        return length * layoutFold(spec, inner);\n      },\n      reduceObject(keys, object) {\n        return keys.map((key) => object[key]).reduce((x, y) => x + y);\n      },\n      reduceFlaggedOption({ isSome, value }) {\n        return isSome + value;\n      },\n      reduceOrUndefined(_) {\n        return 0;\n      },\n    };\n    return layoutFold<any, number>(spec, typeData);\n  }\n\n  function fromFields(typeData: Layout, fields: Field[], aux: any[]): any {\n    let { checkedTypeName } = typeData;\n    if (checkedTypeName) {\n      // there's a custom type!\n      return customTypes[checkedTypeName].fromFields(fields, aux);\n    }\n    if (typeData.type === 'array') {\n      let arrayTypeData = typeData as ArrayLayout<TypeMap>;\n      let size = sizeInFields(arrayTypeData.inner);\n      let length = aux.length;\n      let value = [];\n      for (let i = 0, offset = 0; i < length; i++, offset += size) {\n        value[i] = fromFields(arrayTypeData.inner, fields.slice(offset, offset + size), aux[i]);\n      }\n      return value;\n    }\n    if (typeData.type === 'option') {\n      let { optionType, inner } = typeData as OptionLayout<TypeMap>;\n      switch (optionType) {\n        case 'closedInterval':\n        case 'flaggedOption': {\n          let [first, ...rest] = fields;\n          let isSome = TypeMap.Bool.fromFields([first], []);\n          let value = fromFields(inner, rest, aux);\n          return { isSome, value };\n        }\n        case 'orUndefined': {\n          let [isDefined, value] = aux;\n          return isDefined ? fromFields(inner, fields, value) : undefined;\n        }\n        default:\n          throw Error('bug');\n      }\n    }\n    if (typeData.type === 'object') {\n      let { keys, entries } = typeData as ObjectLayout<TypeMap>;\n      let values: Record<string, any> = {};\n      let offset = 0;\n      for (let i = 0; i < keys.length; i++) {\n        let typeEntry = entries[keys[i]];\n        let size = sizeInFields(typeEntry);\n        values[keys[i]] = fromFields(typeEntry, fields.slice(offset, offset + size), aux[i]);\n        offset += size;\n      }\n      return values;\n    }\n    if (primitiveTypes.has(typeData.type as string)) {\n      return (primitiveTypeMap as any)[typeData.type].fromFields(fields, aux);\n    }\n    return (TypeMap as any)[typeData.type].fromFields(fields, aux);\n  }\n\n  function check(typeData: Layout, value: any) {\n    return layoutFold<any, void>(\n      {\n        map(type, value) {\n          return type.check(value);\n        },\n        reduceArray() {},\n        reduceObject() {},\n        reduceFlaggedOption() {},\n        reduceOrUndefined() {},\n      },\n      typeData,\n      value\n    );\n  }\n\n  function toValue(typeData: Layout, value: any) {\n    return layoutMap<any, any>((type, value) => type.toValue(value), typeData, value);\n  }\n\n  function fromValue(typeData: Layout, value: any) {\n    return layoutMap<any, any>((type, value) => type.fromValue(value), typeData, value);\n  }\n\n  return { provableFromLayout, toJSONEssential, empty };\n}\n\n// generic over leaf types\n\ntype GenericFoldSpec<T, R, TypeMap extends AnyTypeMap, BaseType> = {\n  map: (type: BaseType, value?: T, name?: string) => R;\n  reduceArray: (array: R[], typeData: ArrayLayout<TypeMap>) => R;\n  reduceObject: (keys: string[], record: Record<string, R>) => R;\n  reduceFlaggedOption: (\n    option: { isSome: R; value: R },\n    typeData: FlaggedOptionLayout<TypeMap>\n  ) => R;\n  reduceOrUndefined: (value: R | undefined, innerTypeData: GenericLayout<TypeMap>) => R;\n};\n\nfunction genericLayoutFold<\n  BaseType,\n  T = any,\n  R = any,\n  TypeMap extends AnyTypeMap = AnyTypeMap,\n  JsonMap extends AnyTypeMap = AnyTypeMap,\n>(\n  TypeMap: TypeMapValues<TypeMap, JsonMap, BaseType>,\n  customTypes: Record<string, BaseType>,\n  spec: GenericFoldSpec<T, R, TypeMap, BaseType>,\n  typeData: GenericLayout<TypeMap>,\n  value?: T\n): R {\n  let { checkedTypeName } = typeData;\n  if (checkedTypeName) {\n    // there's a custom type!\n    return spec.map(customTypes[checkedTypeName], value, checkedTypeName);\n  }\n  if (typeData.type === 'array') {\n    let arrayTypeData = typeData as ArrayLayout<TypeMap>;\n    let v: T[] | undefined[] | undefined = value as any;\n    if (arrayTypeData.staticLength !== null && v === undefined) {\n      v = Array<undefined>(arrayTypeData.staticLength).fill(undefined);\n    }\n    let array =\n      v?.map((x) => genericLayoutFold(TypeMap, customTypes, spec, arrayTypeData.inner, x)) ?? [];\n    return spec.reduceArray(array, arrayTypeData);\n  }\n  if (typeData.type === 'option') {\n    let { optionType, inner } = typeData as OptionLayout<TypeMap, BaseLayout<TypeMap>>;\n    switch (optionType) {\n      case 'closedInterval':\n      case 'flaggedOption':\n        let v: { isSome: T; value: T } | undefined = value as any;\n        return spec.reduceFlaggedOption(\n          {\n            isSome: spec.map(TypeMap.Bool, v?.isSome, 'Bool'),\n            value: genericLayoutFold(TypeMap, customTypes, spec, inner, v?.value),\n          },\n          typeData as FlaggedOptionLayout<TypeMap>\n        );\n      case 'orUndefined':\n        let mapped =\n          value === undefined\n            ? undefined\n            : genericLayoutFold(TypeMap, customTypes, spec, inner, value);\n        return spec.reduceOrUndefined(mapped, inner);\n      default:\n        throw Error('bug');\n    }\n  }\n  if (typeData.type === 'object') {\n    let { keys, entries } = typeData as ObjectLayout<TypeMap>;\n    let v: Record<string, T> | undefined = value as any;\n    let object: Record<string, R> = {};\n    keys.forEach((key) => {\n      object[key] = genericLayoutFold(TypeMap, customTypes, spec, entries[key], v?.[key]);\n    });\n    return spec.reduceObject(keys, object);\n  }\n  if (primitiveTypes.has(typeData.type)) {\n    return spec.map((primitiveTypeMap as any)[typeData.type], value, typeData.type);\n  }\n  return spec.map((TypeMap as any)[typeData.type], value, typeData.type);\n}\n\nfunction genericLayoutMap<\n  BaseType,\n  T = any,\n  R = any,\n  TypeMap extends AnyTypeMap = AnyTypeMap,\n  JsonMap extends AnyTypeMap = AnyTypeMap,\n>(\n  TypeMap: TypeMapValues<TypeMap, JsonMap, BaseType>,\n  customTypes: Record<string, BaseType>,\n  map: (typeData: BaseType, value: T) => R,\n  typeData: GenericLayout<TypeMap>,\n  value: T\n): R {\n  return genericLayoutFold<BaseType, T, any, TypeMap, JsonMap>(\n    TypeMap,\n    customTypes,\n    {\n      map(type, value) {\n        return map(type, value!);\n      },\n      reduceArray(array) {\n        return array;\n      },\n      reduceObject(_, object) {\n        return object;\n      },\n      reduceFlaggedOption(option) {\n        return option;\n      },\n      reduceOrUndefined(value) {\n        return value;\n      },\n    },\n    typeData,\n    value\n  );\n}\n\n// types\n\ntype WithChecked<TypeMap extends AnyTypeMap> = {\n  checkedType?: GenericLayout<TypeMap>;\n  checkedTypeName?: string;\n};\n\ntype BaseLayout<TypeMap extends AnyTypeMap> = {\n  type: keyof TypeMap & string;\n} & WithChecked<TypeMap>;\n\ntype RangeLayout<TypeMap extends AnyTypeMap, T = BaseLayout<TypeMap>> = {\n  type: 'object';\n  name: string;\n  keys: ['lower', 'upper'];\n  entries: { lower: T; upper: T };\n} & WithChecked<TypeMap>;\n\ntype OptionLayout<TypeMap extends AnyTypeMap, T = BaseLayout<AnyTypeMap>> = {\n  type: 'option';\n} & (\n  | {\n      optionType: 'closedInterval';\n      rangeMin: any;\n      rangeMax: any;\n      inner: RangeLayout<TypeMap, T>;\n    }\n  | {\n      optionType: 'flaggedOption';\n      inner: T;\n    }\n  | {\n      optionType: 'orUndefined';\n      inner: T;\n    }\n) &\n  WithChecked<TypeMap>;\n\ntype FlaggedOptionLayout<TypeMap extends AnyTypeMap, T = BaseLayout<AnyTypeMap>> = Exclude<\n  OptionLayout<TypeMap, T>,\n  { optionType: 'orUndefined' }\n>;\n\ntype ArrayLayout<TypeMap extends AnyTypeMap> = {\n  type: 'array';\n  inner: GenericLayout<TypeMap>;\n  staticLength: number | null;\n} & WithChecked<TypeMap>;\n\ntype ObjectLayout<TypeMap extends AnyTypeMap> = {\n  type: 'object';\n  name: string;\n  keys: string[];\n  entries: Record<string, GenericLayout<TypeMap>>;\n} & WithChecked<TypeMap>;\n\ntype GenericLayout<TypeMap extends AnyTypeMap> =\n  | OptionLayout<TypeMap>\n  | BaseLayout<TypeMap>\n  | ObjectLayout<TypeMap>\n  | ArrayLayout<TypeMap>;\n", "import { prefixes } from '../../../bindings/crypto/constants.js';\nimport { prefixToField } from '../../../bindings/lib/binable.js';\nimport { GenericProvableExtended, GenericSignableField } from '../../../bindings/lib/generic.js';\n\nexport { createEvents, dataAsHash };\n\ntype Poseidon<Field> = {\n  update(state: Field[], input: Field[]): Field[];\n};\n\nfunction createEvents<Field>({\n  Field,\n  Poseidon,\n}: {\n  Field: GenericSignableField<Field>;\n  Poseidon: Poseidon<Field>;\n}) {\n  type Event = Field[];\n\n  type Events = {\n    hash: Field;\n    data: Event[];\n  };\n\n  // hashing helpers\n  function initialState() {\n    return [Field(0), Field(0), Field(0)] as [Field, Field, Field];\n  }\n  function salt(prefix: string) {\n    return Poseidon.update(initialState(), [prefixToField(Field, prefix)]);\n  }\n  function hashWithPrefix(prefix: string, input: Field[]) {\n    let init = salt(prefix);\n    return Poseidon.update(init, input)[0];\n  }\n  function emptyHashWithPrefix(prefix: string) {\n    return salt(prefix)[0];\n  }\n\n  const Events = {\n    empty(): Events {\n      let hash = emptyHashWithPrefix('MinaZkappEventsEmpty');\n      return { hash, data: [] };\n    },\n    pushEvent(events: Events, event: Event): Events {\n      let eventHash = hashWithPrefix(prefixes.event, event);\n      let hash = hashWithPrefix(prefixes.events, [events.hash, eventHash]);\n      return { hash, data: [event, ...events.data] };\n    },\n    fromList(events: Event[]): Events {\n      return [...events].reverse().reduce(Events.pushEvent, Events.empty());\n    },\n    hash(events: Event[]) {\n      return Events.fromList(events).hash;\n    },\n  };\n  const EventsProvable = {\n    ...Events,\n    ...dataAsHash<Field[][], bigint[][], string[][], Field>({\n      empty: Events.empty,\n      toValue(data) {\n        return data.map((row) => row.map((e) => Field.toBigint(e)));\n      },\n      fromValue(value) {\n        return value.map((row) => row.map((e) => Field(e)));\n      },\n      toJSON(data) {\n        return data.map((row) => row.map((e) => Field.toJSON(e)));\n      },\n      fromJSON(json) {\n        let data = json.map((row) => row.map((e) => Field.fromJSON(e)));\n        let hash = Events.hash(data);\n        return { data, hash };\n      },\n      Field,\n    }),\n  };\n\n  const Actions = {\n    // same as events but w/ different hash prefixes\n    empty(): Events {\n      let hash = emptyHashWithPrefix('MinaZkappActionsEmpty');\n      return { hash, data: [] };\n    },\n    pushEvent(actions: Events, event: Event): Events {\n      let eventHash = hashWithPrefix(prefixes.event, event);\n      let hash = hashWithPrefix(prefixes.sequenceEvents, [actions.hash, eventHash]);\n      return { hash, data: [event, ...actions.data] };\n    },\n    fromList(events: Event[]): Events {\n      return [...events].reverse().reduce(Actions.pushEvent, Actions.empty());\n    },\n    hash(events: Event[]) {\n      return this.fromList(events).hash;\n    },\n    // different than events\n    emptyActionState() {\n      return emptyHashWithPrefix('MinaZkappActionStateEmptyElt');\n    },\n    updateSequenceState(state: Field, sequenceEventsHash: Field) {\n      return hashWithPrefix(prefixes.sequenceEvents, [state, sequenceEventsHash]);\n    },\n  };\n\n  const ActionsProvable = {\n    ...Actions,\n    ...dataAsHash<Field[][], bigint[][], string[][], Field>({\n      empty: Actions.empty,\n      toValue(data) {\n        return data.map((row) => row.map((e) => Field.toBigint(e)));\n      },\n      fromValue(value) {\n        return value.map((row) => row.map((e) => Field(e)));\n      },\n      toJSON(data: Field[][]) {\n        return data.map((row) => row.map((e) => Field.toJSON(e)));\n      },\n      fromJSON(json: string[][]) {\n        let data = json.map((row) => row.map((e) => Field.fromJSON(e)));\n        let hash = Actions.hash(data);\n        return { data, hash };\n      },\n      Field,\n    }),\n  };\n\n  return { Events: EventsProvable, Actions: ActionsProvable };\n}\n\nfunction dataAsHash<T, V, J, Field>({\n  empty,\n  toValue,\n  fromValue,\n  toJSON,\n  fromJSON,\n  Field,\n}: {\n  empty: () => { data: T; hash: Field };\n  toValue: (value: T) => V;\n  fromValue: (value: V | T) => T;\n  toJSON: (value: T) => J;\n  fromJSON: (json: J) => { data: T; hash: Field };\n  Field: GenericSignableField<Field>;\n}): GenericProvableExtended<{ data: T; hash: Field }, { data: V; hash: bigint }, J, Field> {\n  return {\n    empty,\n    sizeInFields() {\n      return 1;\n    },\n    toFields({ hash }) {\n      return [hash];\n    },\n    toAuxiliary(value) {\n      return [value?.data ?? empty().data];\n    },\n    fromFields([hash], [data]) {\n      return { data, hash };\n    },\n    toValue({ data, hash }) {\n      return { data: toValue(data), hash: Field.toBigint(hash) };\n    },\n    fromValue({ data, hash }) {\n      return { data: fromValue(data), hash: Field(hash) };\n    },\n    toJSON({ data }) {\n      return toJSON(data);\n    },\n    fromJSON(json) {\n      return fromJSON(json);\n    },\n    check() {},\n    toInput({ hash }) {\n      return { fields: [hash] };\n    },\n  };\n}\n", "import {\n  GenericBool,\n  GenericField,\n  GenericHashInput,\n  GenericSignable,\n  GenericSignableBool,\n  GenericSignableField,\n} from '../../lib/generic.js';\nimport { createDerivers } from '../../lib/provable-generic.js';\nimport * as Json from '../gen/v1/transaction-json.js';\nimport {\n  bytesToBits,\n  prefixToField,\n  stringLengthInBytes,\n  stringToBytes,\n} from '../../lib/binable.js';\nimport { Base58, fieldEncodings } from '../../../lib/util/base58.js';\nimport { dataAsHash } from '../../../lib/mina/v1/events.js';\nimport { HashHelpers } from '../../../lib/provable/crypto/hash-generic.js';\nimport { prefixes } from '../../crypto/constants.js';\n\nexport { derivedLeafTypes, derivedLeafTypesSignable, tokenSymbolLength };\n\nconst tokenSymbolLength = 6;\n\nfunction derivedLeafTypes<Field, Bool>({\n  Field,\n  Bool,\n  HashHelpers,\n  packToFields,\n}: {\n  Field: GenericField<Field>;\n  Bool: GenericBool<Field, Bool>;\n  HashHelpers: HashHelpers<Field>;\n  packToFields: (input: GenericHashInput<Field>) => Field[];\n}) {\n  let { provable } = createDerivers<Field>();\n  const Encoding = fieldEncodings<Field>(Field);\n  const fieldBase = provable(Field);\n\n  return {\n    TokenId: createEncodedField(fieldBase, Encoding.TokenId, Field(defaultTokenId)),\n    StateHash: createEncodedField(fieldBase, Encoding.StateHash),\n    TokenSymbol: createTokenSymbol(provable({ field: Field, symbol: String }), Field),\n    AuthRequired: createAuthRequired(\n      provable({\n        constant: Bool,\n        signatureNecessary: Bool,\n        signatureSufficient: Bool,\n      }),\n      Bool\n    ),\n    ZkappUri: createZkappUri(Field, HashHelpers, packToFields),\n  };\n}\n\nfunction derivedLeafTypesSignable<Field, Bool>({\n  Field,\n  Bool,\n  HashHelpers,\n  packToFields,\n}: {\n  Field: GenericSignableField<Field>;\n  Bool: GenericSignableBool<Field, Bool>;\n  HashHelpers: HashHelpers<Field>;\n  packToFields: (input: GenericHashInput<Field>) => Field[];\n}) {\n  let { signable } = createDerivers<Field>();\n  const Encoding = fieldEncodings<Field>(Field);\n  const fieldBase = signable(Field);\n\n  return {\n    TokenId: createEncodedField(fieldBase, Encoding.TokenId, Field(defaultTokenId)),\n    StateHash: createEncodedField(fieldBase, Encoding.StateHash),\n    TokenSymbol: createTokenSymbol(signable({ field: Field, symbol: String }), Field),\n    AuthRequired: createAuthRequired(\n      signable({\n        constant: Bool,\n        signatureNecessary: Bool,\n        signatureSufficient: Bool,\n      }),\n      Bool\n    ),\n    MayUseToken: signable({ parentsOwnToken: Bool, inheritFromParent: Bool }),\n    Bool,\n    ZkappUri: createZkappUri(Field, HashHelpers, packToFields),\n  };\n}\n\nconst defaultTokenId = 1;\n\nfunction createEncodedField<Field, Base extends GenericSignable<Field, string, Field>>(\n  base: Base,\n  encoding: Base58<Field>,\n  empty?: Field\n) {\n  return {\n    ...(base as Omit<Base, 'toJSON' | 'fromJSON'>),\n    empty: empty !== undefined ? () => empty : base.empty,\n    toJSON(x: Field): Json.TokenId {\n      return encoding.toBase58(x);\n    },\n    fromJSON(x: Json.TokenId) {\n      return encoding.fromBase58(x);\n    },\n  };\n}\n\ntype TokenSymbol<Field> = { symbol: string; field: Field };\n\nfunction createTokenSymbol<Field, Base extends GenericSignable<TokenSymbol<Field>, any, Field>>(\n  base: Base,\n  Field: GenericSignableField<Field>\n) {\n  let self = {\n    ...(base as Omit<Base, 'toJSON' | 'fromJSON'>),\n    toInput({ field }: TokenSymbol<Field>): GenericHashInput<Field> {\n      return { packed: [[field, 48]] };\n    },\n    toJSON({ symbol }: TokenSymbol<Field>) {\n      return symbol;\n    },\n    fromJSON(symbol: string): TokenSymbol<Field> {\n      let bytesLength = stringLengthInBytes(symbol);\n      if (bytesLength > tokenSymbolLength)\n        throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);\n      return { symbol, field: prefixToField(Field, symbol) };\n    },\n  };\n  return self;\n}\n\ntype AuthRequired<Bool> = {\n  constant: Bool;\n  signatureNecessary: Bool;\n  signatureSufficient: Bool;\n};\n\nfunction createAuthRequired<\n  Field,\n  Bool,\n  Base extends GenericSignable<AuthRequired<Bool>, AuthRequired<boolean>, Field>,\n>(base: Base, Bool: GenericSignableBool<Field, Bool>) {\n  return {\n    ...(base as Omit<Base, 'toJSON' | 'fromJSON'>),\n    empty(): AuthRequired<Bool> {\n      return {\n        constant: Bool(true),\n        signatureNecessary: Bool(false),\n        signatureSufficient: Bool(true),\n      };\n    },\n    toJSON(x: AuthRequired<Bool>): Json.AuthRequired {\n      let c = Number(Bool.toJSON(x.constant));\n      let n = Number(Bool.toJSON(x.signatureNecessary));\n      let s = Number(Bool.toJSON(x.signatureSufficient));\n      // prettier-ignore\n      switch (`${c}${n}${s}`) {\n        case '110': return 'Impossible';\n        case '101': return 'None';\n        case '000': return 'Proof';\n        case '011': return 'Signature';\n        case '001': return 'Either';\n        default: throw Error('Unexpected permission');\n      }\n    },\n    fromJSON(json: Json.AuthRequired): AuthRequired<Bool> {\n      let map: Record<Json.AuthRequired, string> = {\n        Impossible: '110',\n        None: '101',\n        Proof: '000',\n        Signature: '011',\n        Either: '001',\n      };\n      let code = map[json];\n      if (code === undefined) throw Error('Unexpected permission');\n      let [constant, signatureNecessary, signatureSufficient] = code\n        .split('')\n        .map((s) => Bool(!!Number(s)));\n      return { constant, signatureNecessary, signatureSufficient };\n    },\n  };\n}\n\nfunction createZkappUri<Field>(\n  Field: GenericSignableField<Field>,\n  HashHelpers: HashHelpers<Field>,\n  packToFields: (input: GenericHashInput<Field>) => Field[]\n) {\n  // Mina_base.Zkapp_account.hash_zkapp_uri_opt\n  function hashZkappUri(uri: string) {\n    let bits = bytesToBits(stringToBytes(uri));\n    bits.push(true);\n    let input: GenericHashInput<Field> = {\n      packed: bits.map((b) => [Field(Number(b)), 1]),\n    };\n    let packed = packToFields(input);\n    return HashHelpers.hashWithPrefix(prefixes.zkappUri, packed);\n  }\n\n  return dataAsHash<string, string, string, Field>({\n    empty() {\n      let hash = HashHelpers.hashWithPrefix(prefixes.zkappUri, [Field(0), Field(0)]);\n      return { data: '', hash };\n    },\n    toValue(data) {\n      return data;\n    },\n    fromValue(value) {\n      return value;\n    },\n    toJSON(data: string) {\n      return data;\n    },\n    fromJSON(json: string) {\n      return { data: json, hash: hashZkappUri(json) };\n    },\n    Field,\n  });\n}\n", "import { Field, Bool } from '../../../lib/provable/wrapped.js';\nimport { UInt32, UInt64, Sign, Int64 } from '../../../lib/provable/int.js';\nimport { PublicKey } from '../../../lib/provable/crypto/signature.js';\nimport { derivedLeafTypes } from './derived-leaves.js';\nimport { createEvents } from '../../../lib/mina/v1/events.js';\nimport {\n  Poseidon,\n  HashHelpers,\n  packToFields,\n  emptyHashWithPrefix,\n} from '../../../lib/provable/crypto/poseidon.js';\nimport { provable } from '../../../lib/provable/types/provable-derivers.js';\nimport { mocks, protocolVersions } from '../../crypto/constants.js';\n\nexport { PublicKey, Field, Bool, AuthRequired, UInt64, UInt32, Sign, BalanceChange, TokenId };\n\nexport {\n  Events,\n  Actions,\n  ZkappUri,\n  TokenSymbol,\n  ActionState,\n  VerificationKeyHash,\n  ReceiptChainHash,\n  StateHash,\n  TransactionVersion,\n  MayUseToken,\n};\n\ntype AuthRequired = {\n  constant: Bool;\n  signatureNecessary: Bool;\n  signatureSufficient: Bool;\n};\ntype TokenId = Field;\ntype StateHash = Field;\ntype TokenSymbol = { symbol: string; field: Field };\ntype ZkappUri = { data: string; hash: Field };\n\nconst { TokenId, StateHash, TokenSymbol, AuthRequired, ZkappUri } = derivedLeafTypes({\n  Field,\n  Bool,\n  HashHelpers,\n  packToFields,\n});\n\ntype Event = Field[];\ntype Events = {\n  hash: Field;\n  data: Event[];\n};\ntype Actions = Events;\nconst { Events, Actions } = createEvents({ Field, Poseidon });\n\ntype ActionState = Field;\nconst ActionState = {\n  ...provable(Field),\n  empty: Actions.emptyActionState,\n};\n\ntype VerificationKeyHash = Field;\nconst VerificationKeyHash = {\n  ...provable(Field),\n  empty: () => Field(mocks.dummyVerificationKeyHash),\n};\n\ntype ReceiptChainHash = Field;\nconst ReceiptChainHash = {\n  ...provable(Field),\n  empty: () => emptyHashWithPrefix('CodaReceiptEmpty'),\n};\n\ntype TransactionVersion = Field;\nconst TransactionVersion = {\n  ...provable(UInt32),\n  empty: () => UInt32.from(protocolVersions.txnVersion),\n};\n\ntype BalanceChange = Int64;\nconst BalanceChange = Int64;\ntype MayUseToken = {\n  parentsOwnToken: Bool;\n  inheritFromParent: Bool;\n};\nconst MayUseToken = {\n  ...provable({ parentsOwnToken: Bool, inheritFromParent: Bool }),\n\n  check: ({ parentsOwnToken, inheritFromParent }: MayUseToken) => {\n    Bool.check(parentsOwnToken);\n    Bool.check(inheritFromParent);\n    parentsOwnToken\n      .and(inheritFromParent)\n      .assertFalse('MayUseToken: parentsOwnToken and inheritFromParent cannot both be true');\n  },\n};\n", "// @generated this file is auto-generated - don't edit it directly\nexport { jsLayout };\n\nlet jsLayout = {\n  ZkappCommand: {\n    type: 'object',\n    name: 'ZkappCommand',\n    docs: null,\n    keys: ['feePayer', 'accountUpdates', 'memo'],\n    entries: {\n      feePayer: {\n        type: 'object',\n        name: 'ZkappFeePayer',\n        docs: null,\n        keys: ['body', 'authorization'],\n        entries: {\n          body: {\n            type: 'object',\n            name: 'FeePayerBody',\n            docs: null,\n            keys: ['publicKey', 'fee', 'validUntil', 'nonce'],\n            entries: {\n              publicKey: { type: 'PublicKey' },\n              fee: { type: 'UInt64' },\n              validUntil: { type: 'option', optionType: 'orUndefined', inner: { type: 'UInt32' } },\n              nonce: { type: 'UInt32' },\n            },\n            docEntries: { publicKey: null, fee: null, validUntil: null, nonce: null },\n          },\n          authorization: { type: 'string' },\n        },\n        docEntries: { body: null, authorization: null },\n      },\n      accountUpdates: {\n        type: 'array',\n        inner: {\n          type: 'object',\n          name: 'ZkappAccountUpdate',\n          docs: 'An account update in a zkApp transaction',\n          keys: ['body', 'authorization'],\n          entries: {\n            body: {\n              type: 'object',\n              name: 'AccountUpdateBody',\n              docs: null,\n              keys: [\n                'publicKey',\n                'tokenId',\n                'update',\n                'balanceChange',\n                'incrementNonce',\n                'events',\n                'actions',\n                'callData',\n                'callDepth',\n                'preconditions',\n                'useFullCommitment',\n                'implicitAccountCreationFee',\n                'mayUseToken',\n                'authorizationKind',\n              ],\n              entries: {\n                publicKey: { type: 'PublicKey' },\n                tokenId: { type: 'TokenId' },\n                update: {\n                  type: 'object',\n                  name: 'AccountUpdateModification',\n                  docs: null,\n                  keys: [\n                    'appState',\n                    'delegate',\n                    'verificationKey',\n                    'permissions',\n                    'zkappUri',\n                    'tokenSymbol',\n                    'timing',\n                    'votingFor',\n                  ],\n                  entries: {\n                    appState: {\n                      type: 'array',\n                      inner: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      staticLength: 8,\n                    },\n                    delegate: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: { type: 'PublicKey' },\n                    },\n                    verificationKey: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: {\n                        type: 'object',\n                        name: 'VerificationKeyWithHash',\n                        docs: null,\n                        keys: ['data', 'hash'],\n                        entries: { data: { type: 'string' }, hash: { type: 'Field' } },\n                        docEntries: { data: null, hash: null },\n                      },\n                    },\n                    permissions: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: {\n                        type: 'object',\n                        name: 'Permissions',\n                        docs: null,\n                        keys: [\n                          'editState',\n                          'access',\n                          'send',\n                          'receive',\n                          'setDelegate',\n                          'setPermissions',\n                          'setVerificationKey',\n                          'setZkappUri',\n                          'editActionState',\n                          'setTokenSymbol',\n                          'incrementNonce',\n                          'setVotingFor',\n                          'setTiming',\n                        ],\n                        entries: {\n                          editState: { type: 'AuthRequired' },\n                          access: { type: 'AuthRequired' },\n                          send: { type: 'AuthRequired' },\n                          receive: { type: 'AuthRequired' },\n                          setDelegate: { type: 'AuthRequired' },\n                          setPermissions: { type: 'AuthRequired' },\n                          setVerificationKey: {\n                            type: 'object',\n                            name: 'VerificationKeyPermission',\n                            docs: null,\n                            keys: ['auth', 'txnVersion'],\n                            entries: {\n                              auth: { type: 'AuthRequired' },\n                              txnVersion: {\n                                type: 'UInt32',\n                                checkedType: { type: 'UInt32' },\n                                checkedTypeName: 'TransactionVersion',\n                              },\n                            },\n                            docEntries: { auth: null, txnVersion: null },\n                          },\n                          setZkappUri: { type: 'AuthRequired' },\n                          editActionState: { type: 'AuthRequired' },\n                          setTokenSymbol: { type: 'AuthRequired' },\n                          incrementNonce: { type: 'AuthRequired' },\n                          setVotingFor: { type: 'AuthRequired' },\n                          setTiming: { type: 'AuthRequired' },\n                        },\n                        docEntries: {\n                          editState: null,\n                          access: null,\n                          send: null,\n                          receive: null,\n                          setDelegate: null,\n                          setPermissions: null,\n                          setVerificationKey: null,\n                          setZkappUri: null,\n                          editActionState: null,\n                          setTokenSymbol: null,\n                          incrementNonce: null,\n                          setVotingFor: null,\n                          setTiming: null,\n                        },\n                      },\n                    },\n                    zkappUri: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: {\n                        type: 'string',\n                        checkedType: {\n                          type: 'object',\n                          name: 'Events',\n                          docs: null,\n                          keys: ['data', 'hash'],\n                          entries: { data: { type: 'string' }, hash: { type: 'Field' } },\n                          docEntries: { data: null, hash: null },\n                        },\n                        checkedTypeName: 'ZkappUri',\n                      },\n                    },\n                    tokenSymbol: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: {\n                        type: 'string',\n                        checkedType: {\n                          type: 'object',\n                          name: 'Anonymous',\n                          docs: null,\n                          keys: ['symbol', 'field'],\n                          entries: { symbol: { type: 'string' }, field: { type: 'Field' } },\n                          docEntries: { symbol: '', field: '' },\n                        },\n                        checkedTypeName: 'TokenSymbol',\n                      },\n                    },\n                    timing: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: {\n                        type: 'object',\n                        name: 'Timing',\n                        docs: null,\n                        keys: [\n                          'initialMinimumBalance',\n                          'cliffTime',\n                          'cliffAmount',\n                          'vestingPeriod',\n                          'vestingIncrement',\n                        ],\n                        entries: {\n                          initialMinimumBalance: { type: 'UInt64' },\n                          cliffTime: { type: 'UInt32' },\n                          cliffAmount: { type: 'UInt64' },\n                          vestingPeriod: { type: 'UInt32' },\n                          vestingIncrement: { type: 'UInt64' },\n                        },\n                        docEntries: {\n                          initialMinimumBalance: null,\n                          cliffTime: null,\n                          cliffAmount: null,\n                          vestingPeriod: null,\n                          vestingIncrement: null,\n                        },\n                      },\n                    },\n                    votingFor: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: {\n                        type: 'Field',\n                        checkedType: { type: 'Field' },\n                        checkedTypeName: 'StateHash',\n                      },\n                    },\n                  },\n                  docEntries: {\n                    appState: null,\n                    delegate: null,\n                    verificationKey: null,\n                    permissions: null,\n                    zkappUri: null,\n                    tokenSymbol: null,\n                    timing: null,\n                    votingFor: null,\n                  },\n                },\n                balanceChange: {\n                  type: 'object',\n                  name: 'BalanceChange',\n                  docs: null,\n                  keys: ['magnitude', 'sgn'],\n                  entries: { magnitude: { type: 'UInt64' }, sgn: { type: 'Sign' } },\n                  docEntries: { magnitude: null, sgn: null },\n                  checkedType: { type: 'BalanceChange' },\n                  checkedTypeName: 'BalanceChange',\n                },\n                incrementNonce: { type: 'Bool' },\n                events: {\n                  type: 'array',\n                  inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n                  staticLength: null,\n                  checkedType: {\n                    type: 'object',\n                    name: 'Events',\n                    docs: null,\n                    keys: ['data', 'hash'],\n                    entries: {\n                      data: {\n                        type: 'array',\n                        inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n                        staticLength: null,\n                      },\n                      hash: { type: 'Field' },\n                    },\n                    docEntries: { data: null, hash: null },\n                  },\n                  checkedTypeName: 'Events',\n                },\n                actions: {\n                  type: 'array',\n                  inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n                  staticLength: null,\n                  checkedType: {\n                    type: 'object',\n                    name: 'Events',\n                    docs: null,\n                    keys: ['data', 'hash'],\n                    entries: {\n                      data: {\n                        type: 'array',\n                        inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n                        staticLength: null,\n                      },\n                      hash: { type: 'Field' },\n                    },\n                    docEntries: { data: null, hash: null },\n                  },\n                  checkedTypeName: 'Actions',\n                },\n                callData: { type: 'Field' },\n                callDepth: { type: 'number' },\n                preconditions: {\n                  type: 'object',\n                  name: 'Preconditions',\n                  docs: null,\n                  keys: ['network', 'account', 'validWhile'],\n                  entries: {\n                    network: {\n                      type: 'object',\n                      name: 'NetworkPrecondition',\n                      docs: null,\n                      keys: [\n                        'snarkedLedgerHash',\n                        'blockchainLength',\n                        'minWindowDensity',\n                        'totalCurrency',\n                        'globalSlotSinceGenesis',\n                        'stakingEpochData',\n                        'nextEpochData',\n                      ],\n                      entries: {\n                        snarkedLedgerHash: {\n                          type: 'option',\n                          optionType: 'flaggedOption',\n                          inner: { type: 'Field' },\n                        },\n                        blockchainLength: {\n                          type: 'option',\n                          optionType: 'closedInterval',\n                          rangeMin: '0',\n                          rangeMax: '4294967295',\n                          inner: {\n                            type: 'object',\n                            name: 'LengthInterval',\n                            docs: null,\n                            keys: ['lower', 'upper'],\n                            entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                            docEntries: { lower: null, upper: null },\n                          },\n                        },\n                        minWindowDensity: {\n                          type: 'option',\n                          optionType: 'closedInterval',\n                          rangeMin: '0',\n                          rangeMax: '4294967295',\n                          inner: {\n                            type: 'object',\n                            name: 'LengthInterval',\n                            docs: null,\n                            keys: ['lower', 'upper'],\n                            entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                            docEntries: { lower: null, upper: null },\n                          },\n                        },\n                        totalCurrency: {\n                          type: 'option',\n                          optionType: 'closedInterval',\n                          rangeMin: '0',\n                          rangeMax: '18446744073709551615',\n                          inner: {\n                            type: 'object',\n                            name: 'CurrencyAmountInterval',\n                            docs: null,\n                            keys: ['lower', 'upper'],\n                            entries: { lower: { type: 'UInt64' }, upper: { type: 'UInt64' } },\n                            docEntries: { lower: null, upper: null },\n                          },\n                        },\n                        globalSlotSinceGenesis: {\n                          type: 'option',\n                          optionType: 'closedInterval',\n                          rangeMin: '0',\n                          rangeMax: '4294967295',\n                          inner: {\n                            type: 'object',\n                            name: 'GlobalSlotSinceGenesisInterval',\n                            docs: null,\n                            keys: ['lower', 'upper'],\n                            entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                            docEntries: { lower: null, upper: null },\n                          },\n                        },\n                        stakingEpochData: {\n                          type: 'object',\n                          name: 'EpochDataPrecondition',\n                          docs: null,\n                          keys: [\n                            'ledger',\n                            'seed',\n                            'startCheckpoint',\n                            'lockCheckpoint',\n                            'epochLength',\n                          ],\n                          entries: {\n                            ledger: {\n                              type: 'object',\n                              name: 'EpochLedgerPrecondition',\n                              docs: null,\n                              keys: ['hash', 'totalCurrency'],\n                              entries: {\n                                hash: {\n                                  type: 'option',\n                                  optionType: 'flaggedOption',\n                                  inner: { type: 'Field' },\n                                },\n                                totalCurrency: {\n                                  type: 'option',\n                                  optionType: 'closedInterval',\n                                  rangeMin: '0',\n                                  rangeMax: '18446744073709551615',\n                                  inner: {\n                                    type: 'object',\n                                    name: 'CurrencyAmountInterval',\n                                    docs: null,\n                                    keys: ['lower', 'upper'],\n                                    entries: {\n                                      lower: { type: 'UInt64' },\n                                      upper: { type: 'UInt64' },\n                                    },\n                                    docEntries: { lower: null, upper: null },\n                                  },\n                                },\n                              },\n                              docEntries: { hash: null, totalCurrency: null },\n                            },\n                            seed: {\n                              type: 'option',\n                              optionType: 'flaggedOption',\n                              inner: { type: 'Field' },\n                            },\n                            startCheckpoint: {\n                              type: 'option',\n                              optionType: 'flaggedOption',\n                              inner: { type: 'Field' },\n                            },\n                            lockCheckpoint: {\n                              type: 'option',\n                              optionType: 'flaggedOption',\n                              inner: { type: 'Field' },\n                            },\n                            epochLength: {\n                              type: 'option',\n                              optionType: 'closedInterval',\n                              rangeMin: '0',\n                              rangeMax: '4294967295',\n                              inner: {\n                                type: 'object',\n                                name: 'LengthInterval',\n                                docs: null,\n                                keys: ['lower', 'upper'],\n                                entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                                docEntries: { lower: null, upper: null },\n                              },\n                            },\n                          },\n                          docEntries: {\n                            ledger: null,\n                            seed: null,\n                            startCheckpoint: null,\n                            lockCheckpoint: null,\n                            epochLength: null,\n                          },\n                        },\n                        nextEpochData: {\n                          type: 'object',\n                          name: 'EpochDataPrecondition',\n                          docs: null,\n                          keys: [\n                            'ledger',\n                            'seed',\n                            'startCheckpoint',\n                            'lockCheckpoint',\n                            'epochLength',\n                          ],\n                          entries: {\n                            ledger: {\n                              type: 'object',\n                              name: 'EpochLedgerPrecondition',\n                              docs: null,\n                              keys: ['hash', 'totalCurrency'],\n                              entries: {\n                                hash: {\n                                  type: 'option',\n                                  optionType: 'flaggedOption',\n                                  inner: { type: 'Field' },\n                                },\n                                totalCurrency: {\n                                  type: 'option',\n                                  optionType: 'closedInterval',\n                                  rangeMin: '0',\n                                  rangeMax: '18446744073709551615',\n                                  inner: {\n                                    type: 'object',\n                                    name: 'CurrencyAmountInterval',\n                                    docs: null,\n                                    keys: ['lower', 'upper'],\n                                    entries: {\n                                      lower: { type: 'UInt64' },\n                                      upper: { type: 'UInt64' },\n                                    },\n                                    docEntries: { lower: null, upper: null },\n                                  },\n                                },\n                              },\n                              docEntries: { hash: null, totalCurrency: null },\n                            },\n                            seed: {\n                              type: 'option',\n                              optionType: 'flaggedOption',\n                              inner: { type: 'Field' },\n                            },\n                            startCheckpoint: {\n                              type: 'option',\n                              optionType: 'flaggedOption',\n                              inner: { type: 'Field' },\n                            },\n                            lockCheckpoint: {\n                              type: 'option',\n                              optionType: 'flaggedOption',\n                              inner: { type: 'Field' },\n                            },\n                            epochLength: {\n                              type: 'option',\n                              optionType: 'closedInterval',\n                              rangeMin: '0',\n                              rangeMax: '4294967295',\n                              inner: {\n                                type: 'object',\n                                name: 'LengthInterval',\n                                docs: null,\n                                keys: ['lower', 'upper'],\n                                entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                                docEntries: { lower: null, upper: null },\n                              },\n                            },\n                          },\n                          docEntries: {\n                            ledger: null,\n                            seed: null,\n                            startCheckpoint: null,\n                            lockCheckpoint: null,\n                            epochLength: null,\n                          },\n                        },\n                      },\n                      docEntries: {\n                        snarkedLedgerHash: null,\n                        blockchainLength: null,\n                        minWindowDensity: null,\n                        totalCurrency: null,\n                        globalSlotSinceGenesis: null,\n                        stakingEpochData: null,\n                        nextEpochData: null,\n                      },\n                    },\n                    account: {\n                      type: 'object',\n                      name: 'AccountPrecondition',\n                      docs: null,\n                      keys: [\n                        'balance',\n                        'nonce',\n                        'receiptChainHash',\n                        'delegate',\n                        'state',\n                        'actionState',\n                        'provedState',\n                        'isNew',\n                      ],\n                      entries: {\n                        balance: {\n                          type: 'option',\n                          optionType: 'closedInterval',\n                          rangeMin: '0',\n                          rangeMax: '18446744073709551615',\n                          inner: {\n                            type: 'object',\n                            name: 'BalanceInterval',\n                            docs: null,\n                            keys: ['lower', 'upper'],\n                            entries: { lower: { type: 'UInt64' }, upper: { type: 'UInt64' } },\n                            docEntries: { lower: null, upper: null },\n                          },\n                        },\n                        nonce: {\n                          type: 'option',\n                          optionType: 'closedInterval',\n                          rangeMin: '0',\n                          rangeMax: '4294967295',\n                          inner: {\n                            type: 'object',\n                            name: 'NonceInterval',\n                            docs: null,\n                            keys: ['lower', 'upper'],\n                            entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                            docEntries: { lower: null, upper: null },\n                          },\n                        },\n                        receiptChainHash: {\n                          type: 'option',\n                          optionType: 'flaggedOption',\n                          inner: { type: 'Field' },\n                        },\n                        delegate: {\n                          type: 'option',\n                          optionType: 'flaggedOption',\n                          inner: { type: 'PublicKey' },\n                        },\n                        state: {\n                          type: 'array',\n                          inner: {\n                            type: 'option',\n                            optionType: 'flaggedOption',\n                            inner: { type: 'Field' },\n                          },\n                          staticLength: 8,\n                        },\n                        actionState: {\n                          type: 'option',\n                          optionType: 'flaggedOption',\n                          inner: {\n                            type: 'Field',\n                            checkedType: { type: 'Field' },\n                            checkedTypeName: 'ActionState',\n                          },\n                        },\n                        provedState: {\n                          type: 'option',\n                          optionType: 'flaggedOption',\n                          inner: { type: 'Bool' },\n                        },\n                        isNew: {\n                          type: 'option',\n                          optionType: 'flaggedOption',\n                          inner: { type: 'Bool' },\n                        },\n                      },\n                      docEntries: {\n                        balance: null,\n                        nonce: null,\n                        receiptChainHash: null,\n                        delegate: null,\n                        state: null,\n                        actionState: null,\n                        provedState: null,\n                        isNew: null,\n                      },\n                    },\n                    validWhile: {\n                      type: 'option',\n                      optionType: 'closedInterval',\n                      rangeMin: '0',\n                      rangeMax: '4294967295',\n                      inner: {\n                        type: 'object',\n                        name: 'GlobalSlotSinceGenesisInterval',\n                        docs: null,\n                        keys: ['lower', 'upper'],\n                        entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                        docEntries: { lower: null, upper: null },\n                      },\n                    },\n                  },\n                  docEntries: { network: null, account: null, validWhile: null },\n                },\n                useFullCommitment: { type: 'Bool' },\n                implicitAccountCreationFee: { type: 'Bool' },\n                mayUseToken: {\n                  type: 'object',\n                  name: 'MayUseToken',\n                  docs: null,\n                  keys: ['parentsOwnToken', 'inheritFromParent'],\n                  entries: {\n                    parentsOwnToken: { type: 'Bool' },\n                    inheritFromParent: { type: 'Bool' },\n                  },\n                  docEntries: { parentsOwnToken: null, inheritFromParent: null },\n                  checkedType: {\n                    type: 'object',\n                    name: 'Anonymous',\n                    docs: null,\n                    keys: ['parentsOwnToken', 'inheritFromParent'],\n                    entries: {\n                      parentsOwnToken: { type: 'Bool' },\n                      inheritFromParent: { type: 'Bool' },\n                    },\n                    docEntries: { parentsOwnToken: '', inheritFromParent: '' },\n                  },\n                  checkedTypeName: 'MayUseToken',\n                },\n                authorizationKind: {\n                  type: 'object',\n                  name: 'AuthorizationKindStructured',\n                  docs: null,\n                  keys: ['isSigned', 'isProved', 'verificationKeyHash'],\n                  entries: {\n                    isSigned: { type: 'Bool' },\n                    isProved: { type: 'Bool' },\n                    verificationKeyHash: {\n                      type: 'Field',\n                      checkedType: { type: 'Field' },\n                      checkedTypeName: 'VerificationKeyHash',\n                    },\n                  },\n                  docEntries: { isSigned: null, isProved: null, verificationKeyHash: null },\n                },\n              },\n              docEntries: {\n                publicKey: null,\n                tokenId: null,\n                update: null,\n                balanceChange: null,\n                incrementNonce: null,\n                events: null,\n                actions: null,\n                callData: null,\n                callDepth: null,\n                preconditions: null,\n                useFullCommitment: null,\n                implicitAccountCreationFee: null,\n                mayUseToken: null,\n                authorizationKind: null,\n              },\n            },\n            authorization: {\n              type: 'object',\n              name: 'Control',\n              docs: null,\n              keys: ['proof', 'signature'],\n              entries: {\n                proof: { type: 'option', optionType: 'orUndefined', inner: { type: 'string' } },\n                signature: { type: 'option', optionType: 'orUndefined', inner: { type: 'string' } },\n              },\n              docEntries: { proof: null, signature: null },\n            },\n          },\n          docEntries: { body: null, authorization: null },\n        },\n        staticLength: null,\n      },\n      memo: { type: 'string' },\n    },\n    docEntries: { feePayer: null, accountUpdates: null, memo: null },\n  },\n  AccountUpdate: {\n    type: 'object',\n    name: 'ZkappAccountUpdate',\n    docs: 'An account update in a zkApp transaction',\n    keys: ['body', 'authorization'],\n    entries: {\n      body: {\n        type: 'object',\n        name: 'AccountUpdateBody',\n        docs: null,\n        keys: [\n          'publicKey',\n          'tokenId',\n          'update',\n          'balanceChange',\n          'incrementNonce',\n          'events',\n          'actions',\n          'callData',\n          'callDepth',\n          'preconditions',\n          'useFullCommitment',\n          'implicitAccountCreationFee',\n          'mayUseToken',\n          'authorizationKind',\n        ],\n        entries: {\n          publicKey: { type: 'PublicKey' },\n          tokenId: { type: 'TokenId' },\n          update: {\n            type: 'object',\n            name: 'AccountUpdateModification',\n            docs: null,\n            keys: [\n              'appState',\n              'delegate',\n              'verificationKey',\n              'permissions',\n              'zkappUri',\n              'tokenSymbol',\n              'timing',\n              'votingFor',\n            ],\n            entries: {\n              appState: {\n                type: 'array',\n                inner: { type: 'option', optionType: 'flaggedOption', inner: { type: 'Field' } },\n                staticLength: 8,\n              },\n              delegate: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: { type: 'PublicKey' },\n              },\n              verificationKey: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: {\n                  type: 'object',\n                  name: 'VerificationKeyWithHash',\n                  docs: null,\n                  keys: ['data', 'hash'],\n                  entries: { data: { type: 'string' }, hash: { type: 'Field' } },\n                  docEntries: { data: null, hash: null },\n                },\n              },\n              permissions: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: {\n                  type: 'object',\n                  name: 'Permissions',\n                  docs: null,\n                  keys: [\n                    'editState',\n                    'access',\n                    'send',\n                    'receive',\n                    'setDelegate',\n                    'setPermissions',\n                    'setVerificationKey',\n                    'setZkappUri',\n                    'editActionState',\n                    'setTokenSymbol',\n                    'incrementNonce',\n                    'setVotingFor',\n                    'setTiming',\n                  ],\n                  entries: {\n                    editState: { type: 'AuthRequired' },\n                    access: { type: 'AuthRequired' },\n                    send: { type: 'AuthRequired' },\n                    receive: { type: 'AuthRequired' },\n                    setDelegate: { type: 'AuthRequired' },\n                    setPermissions: { type: 'AuthRequired' },\n                    setVerificationKey: {\n                      type: 'object',\n                      name: 'VerificationKeyPermission',\n                      docs: null,\n                      keys: ['auth', 'txnVersion'],\n                      entries: {\n                        auth: { type: 'AuthRequired' },\n                        txnVersion: {\n                          type: 'UInt32',\n                          checkedType: { type: 'UInt32' },\n                          checkedTypeName: 'TransactionVersion',\n                        },\n                      },\n                      docEntries: { auth: null, txnVersion: null },\n                    },\n                    setZkappUri: { type: 'AuthRequired' },\n                    editActionState: { type: 'AuthRequired' },\n                    setTokenSymbol: { type: 'AuthRequired' },\n                    incrementNonce: { type: 'AuthRequired' },\n                    setVotingFor: { type: 'AuthRequired' },\n                    setTiming: { type: 'AuthRequired' },\n                  },\n                  docEntries: {\n                    editState: null,\n                    access: null,\n                    send: null,\n                    receive: null,\n                    setDelegate: null,\n                    setPermissions: null,\n                    setVerificationKey: null,\n                    setZkappUri: null,\n                    editActionState: null,\n                    setTokenSymbol: null,\n                    incrementNonce: null,\n                    setVotingFor: null,\n                    setTiming: null,\n                  },\n                },\n              },\n              zkappUri: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: {\n                  type: 'string',\n                  checkedType: {\n                    type: 'object',\n                    name: 'Events',\n                    docs: null,\n                    keys: ['data', 'hash'],\n                    entries: { data: { type: 'string' }, hash: { type: 'Field' } },\n                    docEntries: { data: null, hash: null },\n                  },\n                  checkedTypeName: 'ZkappUri',\n                },\n              },\n              tokenSymbol: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: {\n                  type: 'string',\n                  checkedType: {\n                    type: 'object',\n                    name: 'Anonymous',\n                    docs: null,\n                    keys: ['symbol', 'field'],\n                    entries: { symbol: { type: 'string' }, field: { type: 'Field' } },\n                    docEntries: { symbol: '', field: '' },\n                  },\n                  checkedTypeName: 'TokenSymbol',\n                },\n              },\n              timing: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: {\n                  type: 'object',\n                  name: 'Timing',\n                  docs: null,\n                  keys: [\n                    'initialMinimumBalance',\n                    'cliffTime',\n                    'cliffAmount',\n                    'vestingPeriod',\n                    'vestingIncrement',\n                  ],\n                  entries: {\n                    initialMinimumBalance: { type: 'UInt64' },\n                    cliffTime: { type: 'UInt32' },\n                    cliffAmount: { type: 'UInt64' },\n                    vestingPeriod: { type: 'UInt32' },\n                    vestingIncrement: { type: 'UInt64' },\n                  },\n                  docEntries: {\n                    initialMinimumBalance: null,\n                    cliffTime: null,\n                    cliffAmount: null,\n                    vestingPeriod: null,\n                    vestingIncrement: null,\n                  },\n                },\n              },\n              votingFor: {\n                type: 'option',\n                optionType: 'flaggedOption',\n                inner: {\n                  type: 'Field',\n                  checkedType: { type: 'Field' },\n                  checkedTypeName: 'StateHash',\n                },\n              },\n            },\n            docEntries: {\n              appState: null,\n              delegate: null,\n              verificationKey: null,\n              permissions: null,\n              zkappUri: null,\n              tokenSymbol: null,\n              timing: null,\n              votingFor: null,\n            },\n          },\n          balanceChange: {\n            type: 'object',\n            name: 'BalanceChange',\n            docs: null,\n            keys: ['magnitude', 'sgn'],\n            entries: { magnitude: { type: 'UInt64' }, sgn: { type: 'Sign' } },\n            docEntries: { magnitude: null, sgn: null },\n            checkedType: { type: 'BalanceChange' },\n            checkedTypeName: 'BalanceChange',\n          },\n          incrementNonce: { type: 'Bool' },\n          events: {\n            type: 'array',\n            inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n            staticLength: null,\n            checkedType: {\n              type: 'object',\n              name: 'Events',\n              docs: null,\n              keys: ['data', 'hash'],\n              entries: {\n                data: {\n                  type: 'array',\n                  inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n                  staticLength: null,\n                },\n                hash: { type: 'Field' },\n              },\n              docEntries: { data: null, hash: null },\n            },\n            checkedTypeName: 'Events',\n          },\n          actions: {\n            type: 'array',\n            inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n            staticLength: null,\n            checkedType: {\n              type: 'object',\n              name: 'Events',\n              docs: null,\n              keys: ['data', 'hash'],\n              entries: {\n                data: {\n                  type: 'array',\n                  inner: { type: 'array', inner: { type: 'Field' }, staticLength: null },\n                  staticLength: null,\n                },\n                hash: { type: 'Field' },\n              },\n              docEntries: { data: null, hash: null },\n            },\n            checkedTypeName: 'Actions',\n          },\n          callData: { type: 'Field' },\n          callDepth: { type: 'number' },\n          preconditions: {\n            type: 'object',\n            name: 'Preconditions',\n            docs: null,\n            keys: ['network', 'account', 'validWhile'],\n            entries: {\n              network: {\n                type: 'object',\n                name: 'NetworkPrecondition',\n                docs: null,\n                keys: [\n                  'snarkedLedgerHash',\n                  'blockchainLength',\n                  'minWindowDensity',\n                  'totalCurrency',\n                  'globalSlotSinceGenesis',\n                  'stakingEpochData',\n                  'nextEpochData',\n                ],\n                entries: {\n                  snarkedLedgerHash: {\n                    type: 'option',\n                    optionType: 'flaggedOption',\n                    inner: { type: 'Field' },\n                  },\n                  blockchainLength: {\n                    type: 'option',\n                    optionType: 'closedInterval',\n                    rangeMin: '0',\n                    rangeMax: '4294967295',\n                    inner: {\n                      type: 'object',\n                      name: 'LengthInterval',\n                      docs: null,\n                      keys: ['lower', 'upper'],\n                      entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                      docEntries: { lower: null, upper: null },\n                    },\n                  },\n                  minWindowDensity: {\n                    type: 'option',\n                    optionType: 'closedInterval',\n                    rangeMin: '0',\n                    rangeMax: '4294967295',\n                    inner: {\n                      type: 'object',\n                      name: 'LengthInterval',\n                      docs: null,\n                      keys: ['lower', 'upper'],\n                      entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                      docEntries: { lower: null, upper: null },\n                    },\n                  },\n                  totalCurrency: {\n                    type: 'option',\n                    optionType: 'closedInterval',\n                    rangeMin: '0',\n                    rangeMax: '18446744073709551615',\n                    inner: {\n                      type: 'object',\n                      name: 'CurrencyAmountInterval',\n                      docs: null,\n                      keys: ['lower', 'upper'],\n                      entries: { lower: { type: 'UInt64' }, upper: { type: 'UInt64' } },\n                      docEntries: { lower: null, upper: null },\n                    },\n                  },\n                  globalSlotSinceGenesis: {\n                    type: 'option',\n                    optionType: 'closedInterval',\n                    rangeMin: '0',\n                    rangeMax: '4294967295',\n                    inner: {\n                      type: 'object',\n                      name: 'GlobalSlotSinceGenesisInterval',\n                      docs: null,\n                      keys: ['lower', 'upper'],\n                      entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                      docEntries: { lower: null, upper: null },\n                    },\n                  },\n                  stakingEpochData: {\n                    type: 'object',\n                    name: 'EpochDataPrecondition',\n                    docs: null,\n                    keys: ['ledger', 'seed', 'startCheckpoint', 'lockCheckpoint', 'epochLength'],\n                    entries: {\n                      ledger: {\n                        type: 'object',\n                        name: 'EpochLedgerPrecondition',\n                        docs: null,\n                        keys: ['hash', 'totalCurrency'],\n                        entries: {\n                          hash: {\n                            type: 'option',\n                            optionType: 'flaggedOption',\n                            inner: { type: 'Field' },\n                          },\n                          totalCurrency: {\n                            type: 'option',\n                            optionType: 'closedInterval',\n                            rangeMin: '0',\n                            rangeMax: '18446744073709551615',\n                            inner: {\n                              type: 'object',\n                              name: 'CurrencyAmountInterval',\n                              docs: null,\n                              keys: ['lower', 'upper'],\n                              entries: { lower: { type: 'UInt64' }, upper: { type: 'UInt64' } },\n                              docEntries: { lower: null, upper: null },\n                            },\n                          },\n                        },\n                        docEntries: { hash: null, totalCurrency: null },\n                      },\n                      seed: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      startCheckpoint: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      lockCheckpoint: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      epochLength: {\n                        type: 'option',\n                        optionType: 'closedInterval',\n                        rangeMin: '0',\n                        rangeMax: '4294967295',\n                        inner: {\n                          type: 'object',\n                          name: 'LengthInterval',\n                          docs: null,\n                          keys: ['lower', 'upper'],\n                          entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                          docEntries: { lower: null, upper: null },\n                        },\n                      },\n                    },\n                    docEntries: {\n                      ledger: null,\n                      seed: null,\n                      startCheckpoint: null,\n                      lockCheckpoint: null,\n                      epochLength: null,\n                    },\n                  },\n                  nextEpochData: {\n                    type: 'object',\n                    name: 'EpochDataPrecondition',\n                    docs: null,\n                    keys: ['ledger', 'seed', 'startCheckpoint', 'lockCheckpoint', 'epochLength'],\n                    entries: {\n                      ledger: {\n                        type: 'object',\n                        name: 'EpochLedgerPrecondition',\n                        docs: null,\n                        keys: ['hash', 'totalCurrency'],\n                        entries: {\n                          hash: {\n                            type: 'option',\n                            optionType: 'flaggedOption',\n                            inner: { type: 'Field' },\n                          },\n                          totalCurrency: {\n                            type: 'option',\n                            optionType: 'closedInterval',\n                            rangeMin: '0',\n                            rangeMax: '18446744073709551615',\n                            inner: {\n                              type: 'object',\n                              name: 'CurrencyAmountInterval',\n                              docs: null,\n                              keys: ['lower', 'upper'],\n                              entries: { lower: { type: 'UInt64' }, upper: { type: 'UInt64' } },\n                              docEntries: { lower: null, upper: null },\n                            },\n                          },\n                        },\n                        docEntries: { hash: null, totalCurrency: null },\n                      },\n                      seed: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      startCheckpoint: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      lockCheckpoint: {\n                        type: 'option',\n                        optionType: 'flaggedOption',\n                        inner: { type: 'Field' },\n                      },\n                      epochLength: {\n                        type: 'option',\n                        optionType: 'closedInterval',\n                        rangeMin: '0',\n                        rangeMax: '4294967295',\n                        inner: {\n                          type: 'object',\n                          name: 'LengthInterval',\n                          docs: null,\n                          keys: ['lower', 'upper'],\n                          entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                          docEntries: { lower: null, upper: null },\n                        },\n                      },\n                    },\n                    docEntries: {\n                      ledger: null,\n                      seed: null,\n                      startCheckpoint: null,\n                      lockCheckpoint: null,\n                      epochLength: null,\n                    },\n                  },\n                },\n                docEntries: {\n                  snarkedLedgerHash: null,\n                  blockchainLength: null,\n                  minWindowDensity: null,\n                  totalCurrency: null,\n                  globalSlotSinceGenesis: null,\n                  stakingEpochData: null,\n                  nextEpochData: null,\n                },\n              },\n              account: {\n                type: 'object',\n                name: 'AccountPrecondition',\n                docs: null,\n                keys: [\n                  'balance',\n                  'nonce',\n                  'receiptChainHash',\n                  'delegate',\n                  'state',\n                  'actionState',\n                  'provedState',\n                  'isNew',\n                ],\n                entries: {\n                  balance: {\n                    type: 'option',\n                    optionType: 'closedInterval',\n                    rangeMin: '0',\n                    rangeMax: '18446744073709551615',\n                    inner: {\n                      type: 'object',\n                      name: 'BalanceInterval',\n                      docs: null,\n                      keys: ['lower', 'upper'],\n                      entries: { lower: { type: 'UInt64' }, upper: { type: 'UInt64' } },\n                      docEntries: { lower: null, upper: null },\n                    },\n                  },\n                  nonce: {\n                    type: 'option',\n                    optionType: 'closedInterval',\n                    rangeMin: '0',\n                    rangeMax: '4294967295',\n                    inner: {\n                      type: 'object',\n                      name: 'NonceInterval',\n                      docs: null,\n                      keys: ['lower', 'upper'],\n                      entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                      docEntries: { lower: null, upper: null },\n                    },\n                  },\n                  receiptChainHash: {\n                    type: 'option',\n                    optionType: 'flaggedOption',\n                    inner: { type: 'Field' },\n                  },\n                  delegate: {\n                    type: 'option',\n                    optionType: 'flaggedOption',\n                    inner: { type: 'PublicKey' },\n                  },\n                  state: {\n                    type: 'array',\n                    inner: {\n                      type: 'option',\n                      optionType: 'flaggedOption',\n                      inner: { type: 'Field' },\n                    },\n                    staticLength: 8,\n                  },\n                  actionState: {\n                    type: 'option',\n                    optionType: 'flaggedOption',\n                    inner: {\n                      type: 'Field',\n                      checkedType: { type: 'Field' },\n                      checkedTypeName: 'ActionState',\n                    },\n                  },\n                  provedState: {\n                    type: 'option',\n                    optionType: 'flaggedOption',\n                    inner: { type: 'Bool' },\n                  },\n                  isNew: { type: 'option', optionType: 'flaggedOption', inner: { type: 'Bool' } },\n                },\n                docEntries: {\n                  balance: null,\n                  nonce: null,\n                  receiptChainHash: null,\n                  delegate: null,\n                  state: null,\n                  actionState: null,\n                  provedState: null,\n                  isNew: null,\n                },\n              },\n              validWhile: {\n                type: 'option',\n                optionType: 'closedInterval',\n                rangeMin: '0',\n                rangeMax: '4294967295',\n                inner: {\n                  type: 'object',\n                  name: 'GlobalSlotSinceGenesisInterval',\n                  docs: null,\n                  keys: ['lower', 'upper'],\n                  entries: { lower: { type: 'UInt32' }, upper: { type: 'UInt32' } },\n                  docEntries: { lower: null, upper: null },\n                },\n              },\n            },\n            docEntries: { network: null, account: null, validWhile: null },\n          },\n          useFullCommitment: { type: 'Bool' },\n          implicitAccountCreationFee: { type: 'Bool' },\n          mayUseToken: {\n            type: 'object',\n            name: 'MayUseToken',\n            docs: null,\n            keys: ['parentsOwnToken', 'inheritFromParent'],\n            entries: { parentsOwnToken: { type: 'Bool' }, inheritFromParent: { type: 'Bool' } },\n            docEntries: { parentsOwnToken: null, inheritFromParent: null },\n            checkedType: {\n              type: 'object',\n              name: 'Anonymous',\n              docs: null,\n              keys: ['parentsOwnToken', 'inheritFromParent'],\n              entries: { parentsOwnToken: { type: 'Bool' }, inheritFromParent: { type: 'Bool' } },\n              docEntries: { parentsOwnToken: '', inheritFromParent: '' },\n            },\n            checkedTypeName: 'MayUseToken',\n          },\n          authorizationKind: {\n            type: 'object',\n            name: 'AuthorizationKindStructured',\n            docs: null,\n            keys: ['isSigned', 'isProved', 'verificationKeyHash'],\n            entries: {\n              isSigned: { type: 'Bool' },\n              isProved: { type: 'Bool' },\n              verificationKeyHash: {\n                type: 'Field',\n                checkedType: { type: 'Field' },\n                checkedTypeName: 'VerificationKeyHash',\n              },\n            },\n            docEntries: { isSigned: null, isProved: null, verificationKeyHash: null },\n          },\n        },\n        docEntries: {\n          publicKey: null,\n          tokenId: null,\n          update: null,\n          balanceChange: null,\n          incrementNonce: null,\n          events: null,\n          actions: null,\n          callData: null,\n          callDepth: null,\n          preconditions: null,\n          useFullCommitment: null,\n          implicitAccountCreationFee: null,\n          mayUseToken: null,\n          authorizationKind: null,\n        },\n      },\n      authorization: {\n        type: 'object',\n        name: 'Control',\n        docs: null,\n        keys: ['proof', 'signature'],\n        entries: {\n          proof: { type: 'option', optionType: 'orUndefined', inner: { type: 'string' } },\n          signature: { type: 'option', optionType: 'orUndefined', inner: { type: 'string' } },\n        },\n        docEntries: { proof: null, signature: null },\n      },\n    },\n    docEntries: { body: null, authorization: null },\n  },\n  Account: {\n    type: 'object',\n    name: 'Account',\n    docs: null,\n    keys: [\n      'publicKey',\n      'tokenId',\n      'tokenSymbol',\n      'balance',\n      'nonce',\n      'receiptChainHash',\n      'delegate',\n      'votingFor',\n      'timing',\n      'permissions',\n      'zkapp',\n    ],\n    entries: {\n      publicKey: { type: 'PublicKey' },\n      tokenId: { type: 'TokenId' },\n      tokenSymbol: { type: 'string' },\n      balance: { type: 'UInt64' },\n      nonce: { type: 'UInt32' },\n      receiptChainHash: {\n        type: 'Field',\n        checkedType: { type: 'Field' },\n        checkedTypeName: 'ReceiptChainHash',\n      },\n      delegate: { type: 'option', optionType: 'orUndefined', inner: { type: 'PublicKey' } },\n      votingFor: { type: 'Field' },\n      timing: {\n        type: 'object',\n        name: 'AccountTiming',\n        docs: null,\n        keys: [\n          'isTimed',\n          'initialMinimumBalance',\n          'cliffTime',\n          'cliffAmount',\n          'vestingPeriod',\n          'vestingIncrement',\n        ],\n        entries: {\n          isTimed: { type: 'Bool' },\n          initialMinimumBalance: { type: 'UInt64' },\n          cliffTime: { type: 'UInt32' },\n          cliffAmount: { type: 'UInt64' },\n          vestingPeriod: { type: 'UInt32' },\n          vestingIncrement: { type: 'UInt64' },\n        },\n        docEntries: {\n          isTimed: null,\n          initialMinimumBalance: null,\n          cliffTime: null,\n          cliffAmount: null,\n          vestingPeriod: null,\n          vestingIncrement: null,\n        },\n      },\n      permissions: {\n        type: 'object',\n        name: 'Permissions',\n        docs: null,\n        keys: [\n          'editState',\n          'access',\n          'send',\n          'receive',\n          'setDelegate',\n          'setPermissions',\n          'setVerificationKey',\n          'setZkappUri',\n          'editActionState',\n          'setTokenSymbol',\n          'incrementNonce',\n          'setVotingFor',\n          'setTiming',\n        ],\n        entries: {\n          editState: { type: 'AuthRequired' },\n          access: { type: 'AuthRequired' },\n          send: { type: 'AuthRequired' },\n          receive: { type: 'AuthRequired' },\n          setDelegate: { type: 'AuthRequired' },\n          setPermissions: { type: 'AuthRequired' },\n          setVerificationKey: {\n            type: 'object',\n            name: 'VerificationKeyPermission',\n            docs: null,\n            keys: ['auth', 'txnVersion'],\n            entries: {\n              auth: { type: 'AuthRequired' },\n              txnVersion: {\n                type: 'UInt32',\n                checkedType: { type: 'UInt32' },\n                checkedTypeName: 'TransactionVersion',\n              },\n            },\n            docEntries: { auth: null, txnVersion: null },\n          },\n          setZkappUri: { type: 'AuthRequired' },\n          editActionState: { type: 'AuthRequired' },\n          setTokenSymbol: { type: 'AuthRequired' },\n          incrementNonce: { type: 'AuthRequired' },\n          setVotingFor: { type: 'AuthRequired' },\n          setTiming: { type: 'AuthRequired' },\n        },\n        docEntries: {\n          editState: null,\n          access: null,\n          send: null,\n          receive: null,\n          setDelegate: null,\n          setPermissions: null,\n          setVerificationKey: null,\n          setZkappUri: null,\n          editActionState: null,\n          setTokenSymbol: null,\n          incrementNonce: null,\n          setVotingFor: null,\n          setTiming: null,\n        },\n      },\n      zkapp: {\n        type: 'option',\n        optionType: 'orUndefined',\n        inner: {\n          type: 'object',\n          name: 'ZkappAccount',\n          docs: null,\n          keys: [\n            'appState',\n            'verificationKey',\n            'zkappVersion',\n            'actionState',\n            'lastActionSlot',\n            'provedState',\n            'zkappUri',\n          ],\n          entries: {\n            appState: { type: 'array', inner: { type: 'Field' }, staticLength: 8 },\n            verificationKey: {\n              type: 'option',\n              optionType: 'orUndefined',\n              inner: {\n                type: 'object',\n                name: 'VerificationKeyWithHash',\n                docs: null,\n                keys: ['data', 'hash'],\n                entries: { data: { type: 'string' }, hash: { type: 'Field' } },\n                docEntries: { data: null, hash: null },\n              },\n            },\n            zkappVersion: { type: 'UInt32' },\n            actionState: { type: 'array', inner: { type: 'Field' }, staticLength: 5 },\n            lastActionSlot: { type: 'UInt32' },\n            provedState: { type: 'Bool' },\n            zkappUri: { type: 'string' },\n          },\n          docEntries: {\n            appState: null,\n            verificationKey: null,\n            zkappVersion: null,\n            actionState: null,\n            lastActionSlot: null,\n            provedState: null,\n            zkappUri: null,\n          },\n        },\n      },\n    },\n    docEntries: {\n      publicKey: null,\n      tokenId: null,\n      tokenSymbol: null,\n      balance: null,\n      nonce: null,\n      receiptChainHash: null,\n      delegate: null,\n      votingFor: null,\n      timing: null,\n      permissions: null,\n      zkapp: null,\n    },\n  },\n};\n", "// @generated this file is auto-generated - don't edit it directly\n\nimport {\n  AuthRequired,\n  BalanceChange,\n  Bool,\n  Field,\n  PublicKey,\n  Sign,\n  TokenId,\n  UInt32,\n  UInt64,\n} from '../../v1/transaction-leaves-json.js';\n\nexport * from '../../v1/transaction-leaves-json.js';\nexport { Account, AccountUpdate, TypeMap, ZkappCommand };\n\ntype TypeMap = {\n  PublicKey: PublicKey;\n  UInt64: UInt64;\n  UInt32: UInt32;\n  TokenId: TokenId;\n  Field: Field;\n  AuthRequired: AuthRequired;\n  BalanceChange: BalanceChange;\n  Sign: Sign;\n  Bool: Bool;\n};\n\ntype ZkappCommand = {\n  feePayer: {\n    body: {\n      publicKey: PublicKey;\n      fee: UInt64;\n      validUntil: UInt32 | null;\n      nonce: UInt32;\n    };\n    authorization: string;\n  };\n  accountUpdates: {\n    body: {\n      publicKey: PublicKey;\n      tokenId: TokenId;\n      update: {\n        appState: (Field | null)[];\n        delegate: PublicKey | null;\n        verificationKey: {\n          data: string;\n          hash: Field;\n        } | null;\n        permissions: {\n          editState: AuthRequired;\n          access: AuthRequired;\n          send: AuthRequired;\n          receive: AuthRequired;\n          setDelegate: AuthRequired;\n          setPermissions: AuthRequired;\n          setVerificationKey: {\n            auth: AuthRequired;\n            txnVersion: UInt32;\n          };\n          setZkappUri: AuthRequired;\n          editActionState: AuthRequired;\n          setTokenSymbol: AuthRequired;\n          incrementNonce: AuthRequired;\n          setVotingFor: AuthRequired;\n          setTiming: AuthRequired;\n        } | null;\n        zkappUri: string | null;\n        tokenSymbol: string | null;\n        timing: {\n          initialMinimumBalance: UInt64;\n          cliffTime: UInt32;\n          cliffAmount: UInt64;\n          vestingPeriod: UInt32;\n          vestingIncrement: UInt64;\n        } | null;\n        votingFor: Field | null;\n      };\n      balanceChange: {\n        magnitude: UInt64;\n        sgn: Sign;\n      };\n      incrementNonce: Bool;\n      events: Field[][];\n      actions: Field[][];\n      callData: Field;\n      callDepth: number;\n      preconditions: {\n        network: {\n          snarkedLedgerHash: Field | null;\n          blockchainLength: {\n            lower: UInt32;\n            upper: UInt32;\n          } | null;\n          minWindowDensity: {\n            lower: UInt32;\n            upper: UInt32;\n          } | null;\n          totalCurrency: {\n            lower: UInt64;\n            upper: UInt64;\n          } | null;\n          globalSlotSinceGenesis: {\n            lower: UInt32;\n            upper: UInt32;\n          } | null;\n          stakingEpochData: {\n            ledger: {\n              hash: Field | null;\n              totalCurrency: {\n                lower: UInt64;\n                upper: UInt64;\n              } | null;\n            };\n            seed: Field | null;\n            startCheckpoint: Field | null;\n            lockCheckpoint: Field | null;\n            epochLength: {\n              lower: UInt32;\n              upper: UInt32;\n            } | null;\n          };\n          nextEpochData: {\n            ledger: {\n              hash: Field | null;\n              totalCurrency: {\n                lower: UInt64;\n                upper: UInt64;\n              } | null;\n            };\n            seed: Field | null;\n            startCheckpoint: Field | null;\n            lockCheckpoint: Field | null;\n            epochLength: {\n              lower: UInt32;\n              upper: UInt32;\n            } | null;\n          };\n        };\n        account: {\n          balance: {\n            lower: UInt64;\n            upper: UInt64;\n          } | null;\n          nonce: {\n            lower: UInt32;\n            upper: UInt32;\n          } | null;\n          receiptChainHash: Field | null;\n          delegate: PublicKey | null;\n          state: (Field | null)[];\n          actionState: Field | null;\n          provedState: Bool | null;\n          isNew: Bool | null;\n        };\n        validWhile: {\n          lower: UInt32;\n          upper: UInt32;\n        } | null;\n      };\n      useFullCommitment: Bool;\n      implicitAccountCreationFee: Bool;\n      mayUseToken: {\n        parentsOwnToken: Bool;\n        inheritFromParent: Bool;\n      };\n      authorizationKind: {\n        isSigned: Bool;\n        isProved: Bool;\n        verificationKeyHash: Field;\n      };\n    };\n    authorization: {\n      proof: string | null;\n      signature: string | null;\n    };\n  }[];\n  memo: string;\n};\n\ntype AccountUpdate = {\n  body: {\n    publicKey: PublicKey;\n    tokenId: TokenId;\n    update: {\n      appState: (Field | null)[];\n      delegate: PublicKey | null;\n      verificationKey: {\n        data: string;\n        hash: Field;\n      } | null;\n      permissions: {\n        editState: AuthRequired;\n        access: AuthRequired;\n        send: AuthRequired;\n        receive: AuthRequired;\n        setDelegate: AuthRequired;\n        setPermissions: AuthRequired;\n        setVerificationKey: {\n          auth: AuthRequired;\n          txnVersion: UInt32;\n        };\n        setZkappUri: AuthRequired;\n        editActionState: AuthRequired;\n        setTokenSymbol: AuthRequired;\n        incrementNonce: AuthRequired;\n        setVotingFor: AuthRequired;\n        setTiming: AuthRequired;\n      } | null;\n      zkappUri: string | null;\n      tokenSymbol: string | null;\n      timing: {\n        initialMinimumBalance: UInt64;\n        cliffTime: UInt32;\n        cliffAmount: UInt64;\n        vestingPeriod: UInt32;\n        vestingIncrement: UInt64;\n      } | null;\n      votingFor: Field | null;\n    };\n    balanceChange: {\n      magnitude: UInt64;\n      sgn: Sign;\n    };\n    incrementNonce: Bool;\n    events: Field[][];\n    actions: Field[][];\n    callData: Field;\n    callDepth: number;\n    preconditions: {\n      network: {\n        snarkedLedgerHash: Field | null;\n        blockchainLength: {\n          lower: UInt32;\n          upper: UInt32;\n        } | null;\n        minWindowDensity: {\n          lower: UInt32;\n          upper: UInt32;\n        } | null;\n        totalCurrency: {\n          lower: UInt64;\n          upper: UInt64;\n        } | null;\n        globalSlotSinceGenesis: {\n          lower: UInt32;\n          upper: UInt32;\n        } | null;\n        stakingEpochData: {\n          ledger: {\n            hash: Field | null;\n            totalCurrency: {\n              lower: UInt64;\n              upper: UInt64;\n            } | null;\n          };\n          seed: Field | null;\n          startCheckpoint: Field | null;\n          lockCheckpoint: Field | null;\n          epochLength: {\n            lower: UInt32;\n            upper: UInt32;\n          } | null;\n        };\n        nextEpochData: {\n          ledger: {\n            hash: Field | null;\n            totalCurrency: {\n              lower: UInt64;\n              upper: UInt64;\n            } | null;\n          };\n          seed: Field | null;\n          startCheckpoint: Field | null;\n          lockCheckpoint: Field | null;\n          epochLength: {\n            lower: UInt32;\n            upper: UInt32;\n          } | null;\n        };\n      };\n      account: {\n        balance: {\n          lower: UInt64;\n          upper: UInt64;\n        } | null;\n        nonce: {\n          lower: UInt32;\n          upper: UInt32;\n        } | null;\n        receiptChainHash: Field | null;\n        delegate: PublicKey | null;\n        state: (Field | null)[];\n        actionState: Field | null;\n        provedState: Bool | null;\n        isNew: Bool | null;\n      };\n      validWhile: {\n        lower: UInt32;\n        upper: UInt32;\n      } | null;\n    };\n    useFullCommitment: Bool;\n    implicitAccountCreationFee: Bool;\n    mayUseToken: {\n      parentsOwnToken: Bool;\n      inheritFromParent: Bool;\n    };\n    authorizationKind: {\n      isSigned: Bool;\n      isProved: Bool;\n      verificationKeyHash: Field;\n    };\n  };\n  authorization: {\n    proof: string | null;\n    signature: string | null;\n  };\n};\n\ntype Account = {\n  publicKey: PublicKey;\n  tokenId: TokenId;\n  tokenSymbol: string;\n  balance: UInt64;\n  nonce: UInt32;\n  receiptChainHash: Field;\n  delegate: PublicKey | null;\n  votingFor: Field;\n  timing: {\n    isTimed: Bool;\n    initialMinimumBalance: UInt64;\n    cliffTime: UInt32;\n    cliffAmount: UInt64;\n    vestingPeriod: UInt32;\n    vestingIncrement: UInt64;\n  };\n  permissions: {\n    editState: AuthRequired;\n    access: AuthRequired;\n    send: AuthRequired;\n    receive: AuthRequired;\n    setDelegate: AuthRequired;\n    setPermissions: AuthRequired;\n    setVerificationKey: {\n      auth: AuthRequired;\n      txnVersion: UInt32;\n    };\n    setZkappUri: AuthRequired;\n    editActionState: AuthRequired;\n    setTokenSymbol: AuthRequired;\n    incrementNonce: AuthRequired;\n    setVotingFor: AuthRequired;\n    setTiming: AuthRequired;\n  };\n  zkapp: {\n    appState: Field[];\n    verificationKey: {\n      data: string;\n      hash: Field;\n    } | null;\n    zkappVersion: UInt32;\n    actionState: Field[];\n    lastActionSlot: UInt32;\n    provedState: Bool;\n    zkappUri: string;\n  } | null;\n};\n", "// @generated this file is auto-generated - don't edit it directly\n\nimport { GenericLayout, SignableFromLayout } from '../../../lib/from-layout.js';\nimport { GenericSignable } from '../../../lib/generic.js';\nimport {\n  ActionState,\n  Actions,\n  AuthRequired,\n  BalanceChange,\n  Bool,\n  Events,\n  Field,\n  MayUseToken,\n  PublicKey,\n  ReceiptChainHash,\n  Sign,\n  StateHash,\n  TokenId,\n  TokenSymbol,\n  TransactionVersion,\n  UInt32,\n  UInt64,\n  VerificationKeyHash,\n  ZkappUri,\n} from '../../v1/transaction-leaves-bigint.js';\nimport { jsLayout } from './js-layout.js';\nimport * as Json from './transaction-json.js';\n\nexport * from '../../v1/transaction-leaves-bigint.js';\nexport {\n  Account,\n  AccountUpdate,\n  Json,\n  Layout,\n  TypeMap,\n  ZkappCommand,\n  customTypes,\n  empty,\n  signableFromLayout,\n  toJSONEssential,\n};\n\ntype TypeMap = {\n  PublicKey: PublicKey;\n  UInt64: UInt64;\n  UInt32: UInt32;\n  TokenId: TokenId;\n  Field: Field;\n  AuthRequired: AuthRequired;\n  BalanceChange: BalanceChange;\n  Sign: Sign;\n  Bool: Bool;\n};\n\nconst TypeMap: {\n  [K in keyof TypeMap]: Signable<TypeMap[K], Json.TypeMap[K]>;\n} = {\n  PublicKey,\n  UInt64,\n  UInt32,\n  TokenId,\n  Field,\n  AuthRequired,\n  BalanceChange,\n  Sign,\n  Bool,\n};\n\ntype Signable<T, TJson> = GenericSignable<T, TJson, Field>;\ntype Layout = GenericLayout<TypeMap>;\n\ntype CustomTypes = {\n  TransactionVersion: Signable<UInt32, Json.TypeMap['UInt32']>;\n  ZkappUri: Signable<\n    {\n      data: string;\n      hash: Field;\n    },\n    string\n  >;\n  TokenSymbol: Signable<\n    {\n      symbol: string;\n      field: Field;\n    },\n    string\n  >;\n  StateHash: Signable<Field, Json.TypeMap['Field']>;\n  BalanceChange: Signable<\n    BalanceChange,\n    {\n      magnitude: Json.TypeMap['UInt64'];\n      sgn: Json.TypeMap['Sign'];\n    }\n  >;\n  Events: Signable<\n    {\n      data: Field[][];\n      hash: Field;\n    },\n    Json.TypeMap['Field'][][]\n  >;\n  Actions: Signable<\n    {\n      data: Field[][];\n      hash: Field;\n    },\n    Json.TypeMap['Field'][][]\n  >;\n  ActionState: Signable<Field, Json.TypeMap['Field']>;\n  MayUseToken: Signable<\n    {\n      parentsOwnToken: Bool;\n      inheritFromParent: Bool;\n    },\n    {\n      parentsOwnToken: Json.TypeMap['Bool'];\n      inheritFromParent: Json.TypeMap['Bool'];\n    }\n  >;\n  VerificationKeyHash: Signable<Field, Json.TypeMap['Field']>;\n  ReceiptChainHash: Signable<Field, Json.TypeMap['Field']>;\n};\nlet customTypes: CustomTypes = {\n  TransactionVersion,\n  ZkappUri,\n  TokenSymbol,\n  StateHash,\n  BalanceChange,\n  Events,\n  Actions,\n  ActionState,\n  MayUseToken,\n  VerificationKeyHash,\n  ReceiptChainHash,\n};\nlet { signableFromLayout, toJSONEssential, empty } = SignableFromLayout<TypeMap, Json.TypeMap>(\n  TypeMap,\n  customTypes\n);\n\ntype ZkappCommand = {\n  feePayer: {\n    body: {\n      publicKey: PublicKey;\n      fee: UInt64;\n      validUntil?: UInt32;\n      nonce: UInt32;\n    };\n    authorization: string;\n  };\n  accountUpdates: {\n    body: {\n      publicKey: PublicKey;\n      tokenId: TokenId;\n      update: {\n        appState: { isSome: Bool; value: Field }[];\n        delegate: { isSome: Bool; value: PublicKey };\n        verificationKey: {\n          isSome: Bool;\n          value: {\n            data: string;\n            hash: Field;\n          };\n        };\n        permissions: {\n          isSome: Bool;\n          value: {\n            editState: AuthRequired;\n            access: AuthRequired;\n            send: AuthRequired;\n            receive: AuthRequired;\n            setDelegate: AuthRequired;\n            setPermissions: AuthRequired;\n            setVerificationKey: {\n              auth: AuthRequired;\n              txnVersion: UInt32;\n            };\n            setZkappUri: AuthRequired;\n            editActionState: AuthRequired;\n            setTokenSymbol: AuthRequired;\n            incrementNonce: AuthRequired;\n            setVotingFor: AuthRequired;\n            setTiming: AuthRequired;\n          };\n        };\n        zkappUri: {\n          isSome: Bool;\n          value: {\n            data: string;\n            hash: Field;\n          };\n        };\n        tokenSymbol: {\n          isSome: Bool;\n          value: {\n            symbol: string;\n            field: Field;\n          };\n        };\n        timing: {\n          isSome: Bool;\n          value: {\n            initialMinimumBalance: UInt64;\n            cliffTime: UInt32;\n            cliffAmount: UInt64;\n            vestingPeriod: UInt32;\n            vestingIncrement: UInt64;\n          };\n        };\n        votingFor: { isSome: Bool; value: Field };\n      };\n      balanceChange: BalanceChange;\n      incrementNonce: Bool;\n      events: {\n        data: Field[][];\n        hash: Field;\n      };\n      actions: {\n        data: Field[][];\n        hash: Field;\n      };\n      callData: Field;\n      callDepth: number;\n      preconditions: {\n        network: {\n          snarkedLedgerHash: { isSome: Bool; value: Field };\n          blockchainLength: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          minWindowDensity: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          totalCurrency: {\n            isSome: Bool;\n            value: {\n              lower: UInt64;\n              upper: UInt64;\n            };\n          };\n          globalSlotSinceGenesis: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          stakingEpochData: {\n            ledger: {\n              hash: { isSome: Bool; value: Field };\n              totalCurrency: {\n                isSome: Bool;\n                value: {\n                  lower: UInt64;\n                  upper: UInt64;\n                };\n              };\n            };\n            seed: { isSome: Bool; value: Field };\n            startCheckpoint: { isSome: Bool; value: Field };\n            lockCheckpoint: { isSome: Bool; value: Field };\n            epochLength: {\n              isSome: Bool;\n              value: {\n                lower: UInt32;\n                upper: UInt32;\n              };\n            };\n          };\n          nextEpochData: {\n            ledger: {\n              hash: { isSome: Bool; value: Field };\n              totalCurrency: {\n                isSome: Bool;\n                value: {\n                  lower: UInt64;\n                  upper: UInt64;\n                };\n              };\n            };\n            seed: { isSome: Bool; value: Field };\n            startCheckpoint: { isSome: Bool; value: Field };\n            lockCheckpoint: { isSome: Bool; value: Field };\n            epochLength: {\n              isSome: Bool;\n              value: {\n                lower: UInt32;\n                upper: UInt32;\n              };\n            };\n          };\n        };\n        account: {\n          balance: {\n            isSome: Bool;\n            value: {\n              lower: UInt64;\n              upper: UInt64;\n            };\n          };\n          nonce: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n          receiptChainHash: { isSome: Bool; value: Field };\n          delegate: { isSome: Bool; value: PublicKey };\n          state: { isSome: Bool; value: Field }[];\n          actionState: { isSome: Bool; value: Field };\n          provedState: { isSome: Bool; value: Bool };\n          isNew: { isSome: Bool; value: Bool };\n        };\n        validWhile: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n      };\n      useFullCommitment: Bool;\n      implicitAccountCreationFee: Bool;\n      mayUseToken: {\n        parentsOwnToken: Bool;\n        inheritFromParent: Bool;\n      };\n      authorizationKind: {\n        isSigned: Bool;\n        isProved: Bool;\n        verificationKeyHash: Field;\n      };\n    };\n    authorization: {\n      proof?: string;\n      signature?: string;\n    };\n  }[];\n  memo: string;\n};\n\nlet ZkappCommand = signableFromLayout<ZkappCommand, Json.ZkappCommand>(\n  jsLayout.ZkappCommand as any\n);\n\ntype AccountUpdate = {\n  body: {\n    publicKey: PublicKey;\n    tokenId: TokenId;\n    update: {\n      appState: { isSome: Bool; value: Field }[];\n      delegate: { isSome: Bool; value: PublicKey };\n      verificationKey: {\n        isSome: Bool;\n        value: {\n          data: string;\n          hash: Field;\n        };\n      };\n      permissions: {\n        isSome: Bool;\n        value: {\n          editState: AuthRequired;\n          access: AuthRequired;\n          send: AuthRequired;\n          receive: AuthRequired;\n          setDelegate: AuthRequired;\n          setPermissions: AuthRequired;\n          setVerificationKey: {\n            auth: AuthRequired;\n            txnVersion: UInt32;\n          };\n          setZkappUri: AuthRequired;\n          editActionState: AuthRequired;\n          setTokenSymbol: AuthRequired;\n          incrementNonce: AuthRequired;\n          setVotingFor: AuthRequired;\n          setTiming: AuthRequired;\n        };\n      };\n      zkappUri: {\n        isSome: Bool;\n        value: {\n          data: string;\n          hash: Field;\n        };\n      };\n      tokenSymbol: {\n        isSome: Bool;\n        value: {\n          symbol: string;\n          field: Field;\n        };\n      };\n      timing: {\n        isSome: Bool;\n        value: {\n          initialMinimumBalance: UInt64;\n          cliffTime: UInt32;\n          cliffAmount: UInt64;\n          vestingPeriod: UInt32;\n          vestingIncrement: UInt64;\n        };\n      };\n      votingFor: { isSome: Bool; value: Field };\n    };\n    balanceChange: BalanceChange;\n    incrementNonce: Bool;\n    events: {\n      data: Field[][];\n      hash: Field;\n    };\n    actions: {\n      data: Field[][];\n      hash: Field;\n    };\n    callData: Field;\n    callDepth: number;\n    preconditions: {\n      network: {\n        snarkedLedgerHash: { isSome: Bool; value: Field };\n        blockchainLength: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        minWindowDensity: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        totalCurrency: {\n          isSome: Bool;\n          value: {\n            lower: UInt64;\n            upper: UInt64;\n          };\n        };\n        globalSlotSinceGenesis: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        stakingEpochData: {\n          ledger: {\n            hash: { isSome: Bool; value: Field };\n            totalCurrency: {\n              isSome: Bool;\n              value: {\n                lower: UInt64;\n                upper: UInt64;\n              };\n            };\n          };\n          seed: { isSome: Bool; value: Field };\n          startCheckpoint: { isSome: Bool; value: Field };\n          lockCheckpoint: { isSome: Bool; value: Field };\n          epochLength: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n        };\n        nextEpochData: {\n          ledger: {\n            hash: { isSome: Bool; value: Field };\n            totalCurrency: {\n              isSome: Bool;\n              value: {\n                lower: UInt64;\n                upper: UInt64;\n              };\n            };\n          };\n          seed: { isSome: Bool; value: Field };\n          startCheckpoint: { isSome: Bool; value: Field };\n          lockCheckpoint: { isSome: Bool; value: Field };\n          epochLength: {\n            isSome: Bool;\n            value: {\n              lower: UInt32;\n              upper: UInt32;\n            };\n          };\n        };\n      };\n      account: {\n        balance: {\n          isSome: Bool;\n          value: {\n            lower: UInt64;\n            upper: UInt64;\n          };\n        };\n        nonce: {\n          isSome: Bool;\n          value: {\n            lower: UInt32;\n            upper: UInt32;\n          };\n        };\n        receiptChainHash: { isSome: Bool; value: Field };\n        delegate: { isSome: Bool; value: PublicKey };\n        state: { isSome: Bool; value: Field }[];\n        actionState: { isSome: Bool; value: Field };\n        provedState: { isSome: Bool; value: Bool };\n        isNew: { isSome: Bool; value: Bool };\n      };\n      validWhile: {\n        isSome: Bool;\n        value: {\n          lower: UInt32;\n          upper: UInt32;\n        };\n      };\n    };\n    useFullCommitment: Bool;\n    implicitAccountCreationFee: Bool;\n    mayUseToken: {\n      parentsOwnToken: Bool;\n      inheritFromParent: Bool;\n    };\n    authorizationKind: {\n      isSigned: Bool;\n      isProved: Bool;\n      verificationKeyHash: Field;\n    };\n  };\n  authorization: {\n    proof?: string;\n    signature?: string;\n  };\n};\n\nlet AccountUpdate = signableFromLayout<AccountUpdate, Json.AccountUpdate>(\n  jsLayout.AccountUpdate as any\n);\n\ntype Account = {\n  publicKey: PublicKey;\n  tokenId: TokenId;\n  tokenSymbol: string;\n  balance: UInt64;\n  nonce: UInt32;\n  receiptChainHash: Field;\n  delegate?: PublicKey;\n  votingFor: Field;\n  timing: {\n    isTimed: Bool;\n    initialMinimumBalance: UInt64;\n    cliffTime: UInt32;\n    cliffAmount: UInt64;\n    vestingPeriod: UInt32;\n    vestingIncrement: UInt64;\n  };\n  permissions: {\n    editState: AuthRequired;\n    access: AuthRequired;\n    send: AuthRequired;\n    receive: AuthRequired;\n    setDelegate: AuthRequired;\n    setPermissions: AuthRequired;\n    setVerificationKey: {\n      auth: AuthRequired;\n      txnVersion: UInt32;\n    };\n    setZkappUri: AuthRequired;\n    editActionState: AuthRequired;\n    setTokenSymbol: AuthRequired;\n    incrementNonce: AuthRequired;\n    setVotingFor: AuthRequired;\n    setTiming: AuthRequired;\n  };\n  zkapp?: {\n    appState: Field[];\n    verificationKey?: {\n      data: string;\n      hash: Field;\n    };\n    zkappVersion: UInt32;\n    actionState: Field[];\n    lastActionSlot: UInt32;\n    provedState: Bool;\n    zkappUri: string;\n  };\n};\n\nlet Account = signableFromLayout<Account, Json.Account>(jsLayout.Account as any);\n", "import { Field, Bool, UInt32, UInt64, Sign } from '../../../mina-signer/src/field-bigint.js';\nimport { PublicKey } from '../../../mina-signer/src/curve-bigint.js';\nimport { derivedLeafTypesSignable } from './derived-leaves.js';\nimport { createEvents } from '../../../lib/mina/v1/events.js';\nimport { Poseidon, HashHelpers, packToFields } from '../../../mina-signer/src/poseidon-bigint.js';\nimport { mocks, protocolVersions } from '../../crypto/constants.js';\nimport { signable } from '../../../mina-signer/src/derivers-bigint.js';\n\nexport {\n  PublicKey,\n  Field,\n  Bool,\n  AuthRequired,\n  UInt64,\n  UInt32,\n  Sign,\n  BalanceChange,\n  TokenId,\n  MayUseToken,\n};\n\nexport {\n  Events,\n  Actions,\n  ZkappUri,\n  TokenSymbol,\n  ActionState,\n  VerificationKeyHash,\n  ReceiptChainHash,\n  StateHash,\n  TransactionVersion,\n};\n\ntype AuthRequired = {\n  constant: Bool;\n  signatureNecessary: Bool;\n  signatureSufficient: Bool;\n};\ntype TokenId = Field;\ntype StateHash = Field;\ntype TokenSymbol = { symbol: string; field: Field };\ntype ZkappUri = { data: string; hash: Field };\ntype MayUseToken = {\n  parentsOwnToken: Bool;\n  inheritFromParent: Bool;\n};\n\nconst { TokenId, StateHash, TokenSymbol, AuthRequired, ZkappUri, MayUseToken } =\n  derivedLeafTypesSignable({ Field, Bool, HashHelpers, packToFields });\n\ntype Event = Field[];\ntype Events = {\n  hash: Field;\n  data: Event[];\n};\ntype Actions = Events;\nconst { Events, Actions } = createEvents({ Field, Poseidon });\n\ntype ActionState = Field;\nconst ActionState = {\n  ...Field,\n  empty: Actions.emptyActionState,\n};\n\ntype VerificationKeyHash = Field;\nconst VerificationKeyHash = {\n  ...Field,\n  empty: () => Field(mocks.dummyVerificationKeyHash),\n};\n\ntype ReceiptChainHash = Field;\nconst ReceiptChainHash = {\n  ...Field,\n  empty: () => HashHelpers.emptyHashWithPrefix('CodaReceiptEmpty'),\n};\n\ntype TransactionVersion = Field;\nconst TransactionVersion = {\n  ...UInt32,\n  empty: () => UInt32(protocolVersions.txnVersion),\n};\n\ntype BalanceChange = { magnitude: UInt64; sgn: Sign };\nconst BalanceChange = signable({ magnitude: UInt64, sgn: Sign });\n", "import 'reflect-metadata';\nimport { Snarky, initializeBindings } from '../../bindings.js';\nimport { MlFieldArray, MlFieldConstArray } from '../ml/fields.js';\nimport { withThreadPool } from '../../bindings.js';\nimport { Provable } from '../provable/provable.js';\nimport { snarkContext, gatesFromJson } from '../provable/core/provable-context.js';\nimport { prettifyStacktrace, prettifyStacktracePromise } from '../util/errors.js';\nimport { ProvablePure } from '../provable/types/provable-intf.js';\n\n// external API\nexport { public_, circuitMain, Circuit, Keypair, Proof, VerificationKey };\n\n/**\n * @deprecated The `Circuit` API is deprecated in favor of {@link ZkFunction}, which features the same\n * functionality with a more ergonomic and consistent structure, inspired by {@link ZkProgram}.\n */\nclass Circuit {\n  // circuit-writing interface\n\n  static _main: CircuitData<any, any>;\n\n  /**\n   * Generates a proving key and a verification key for this circuit.\n   * @example\n   * ```ts\n   * const keypair = await MyCircuit.generateKeypair();\n   * ```\n   */\n  static async generateKeypair(lazyMode: boolean = false) {\n    let main = mainFromCircuitData(this._main);\n    let publicInputSize = this._main.publicInputType.sizeInFields();\n    await initializeBindings();\n    return prettifyStacktracePromise(\n      withThreadPool(async () => {\n        let keypair = Snarky.circuit.compile(main, publicInputSize, lazyMode);\n        return new Keypair(keypair);\n      })\n    );\n  }\n\n  /**\n   * Proves a statement using the private input, public input, and the {@link Keypair} of the circuit.\n   * @example\n   * ```ts\n   * const keypair = await MyCircuit.generateKeypair();\n   * const proof = await MyCircuit.prove(privateInput, publicInput, keypair);\n   * ```\n   */\n  static async prove(privateInput: any[], publicInput: any[], keypair: Keypair) {\n    let main = mainFromCircuitData(this._main, privateInput);\n    let publicInputSize = this._main.publicInputType.sizeInFields();\n    let publicInputFields = this._main.publicInputType.toFields(publicInput);\n    await initializeBindings();\n    return prettifyStacktracePromise(\n      withThreadPool(async () => {\n        let proof = Snarky.circuit.prove(\n          main,\n          publicInputSize,\n          MlFieldConstArray.to(publicInputFields),\n          keypair.value\n        );\n        return new Proof(proof);\n      })\n    );\n  }\n\n  /**\n   * Verifies a proof using the public input, the proof, and the initial {@link Keypair} of the circuit.\n   * @example\n   * ```ts\n   * const keypair = await MyCircuit.generateKeypair();\n   * const proof = await MyCircuit.prove(privateInput, publicInput, keypair);\n   * const isValid = await MyCircuit.verify(publicInput, keypair.vk, proof);\n   * ```\n   */\n  static async verify(publicInput: any[], verificationKey: VerificationKey, proof: Proof) {\n    let publicInputFields = this._main.publicInputType.toFields(publicInput);\n    await initializeBindings();\n    return prettifyStacktracePromise(\n      withThreadPool(async () =>\n        Snarky.circuit.verify(\n          MlFieldConstArray.to(publicInputFields),\n          proof.value,\n          verificationKey.value\n        )\n      )\n    );\n  }\n}\n\nclass Keypair {\n  value: Snarky.Keypair;\n\n  constructor(value: Snarky.Keypair) {\n    this.value = value;\n  }\n\n  verificationKey() {\n    return new VerificationKey(Snarky.circuit.keypair.getVerificationKey(this.value));\n  }\n\n  /**\n   * Returns a low-level JSON representation of the {@link Circuit} from its {@link Keypair}:\n   * a list of gates, each of which represents a row in a table, with certain coefficients and wires to other (row, column) pairs\n   * @example\n   * ```ts\n   * const keypair = await MyCircuit.generateKeypair();\n   * const json = MyProvable.witnessFromKeypair(keypair);\n   * ```\n   */\n  constraintSystem() {\n    try {\n      return gatesFromJson(Snarky.circuit.keypair.getConstraintSystemJSON(this.value)).gates;\n    } catch (error) {\n      throw prettifyStacktrace(error);\n    }\n  }\n}\n\n/**\n * Proofs can be verified using a {@link VerificationKey} and the public input.\n */\nclass Proof {\n  value: Snarky.Proof;\n\n  constructor(value: Snarky.Proof) {\n    this.value = value;\n  }\n}\n\n/**\n * Part of the circuit {@link Keypair}. A verification key can be used to verify a {@link Proof} when you provide the correct public input.\n */\nclass VerificationKey {\n  value: Snarky.VerificationKey;\n\n  constructor(value: Snarky.VerificationKey) {\n    this.value = value;\n  }\n}\n\nfunction public_(target: any, _key: string | symbol, index: number) {\n  // const fieldType = Reflect.getMetadata('design:paramtypes', target, key);\n\n  if (target._public === undefined) {\n    target._public = [];\n  }\n  target._public.push(index);\n}\n\ntype CircuitData<P, W> = {\n  main(publicInput: P, privateInput: W): void;\n  publicInputType: ProvablePure<P>;\n  privateInputType: ProvablePure<W>;\n};\n\nfunction mainFromCircuitData<P, W>(data: CircuitData<P, W>, privateInput?: W): Snarky.Main {\n  return function main(publicInputFields: MlFieldArray) {\n    let id = snarkContext.enter({ inCheckedComputation: true });\n    try {\n      let publicInput = data.publicInputType.fromFields(MlFieldArray.from(publicInputFields));\n      let privateInput_ = Provable.witness(data.privateInputType, () => privateInput as W);\n      data.main(publicInput, privateInput_);\n    } finally {\n      snarkContext.leave(id);\n    }\n  };\n}\n\nfunction circuitMain(\n  target: typeof Circuit,\n  propertyName: string,\n  _descriptor?: PropertyDescriptor\n): any {\n  const paramTypes = Reflect.getMetadata('design:paramtypes', target, propertyName);\n  const numArgs = paramTypes.length;\n\n  const publicIndexSet: Set<number> = new Set((target as any)._public);\n  const witnessIndexSet: Set<number> = new Set();\n  for (let i = 0; i < numArgs; ++i) {\n    if (!publicIndexSet.has(i)) witnessIndexSet.add(i);\n  }\n\n  target._main = {\n    main(publicInput: any[], privateInput: any[]) {\n      let args = [];\n      for (let i = 0; i < numArgs; ++i) {\n        let nextInput = publicIndexSet.has(i) ? publicInput : privateInput;\n        args.push(nextInput.shift());\n      }\n      return (target as any)[propertyName].apply(target, args);\n    },\n    publicInputType: provableFromTuple(Array.from(publicIndexSet).map((i) => paramTypes[i])),\n    privateInputType: provableFromTuple(Array.from(witnessIndexSet).map((i) => paramTypes[i])),\n  };\n}\n\ntype ProvableInputPure<T> = ProvablePure<T> | { provable: ProvablePure<T> };\n\n// TODO support auxiliary data\nfunction provableFromTuple(inputTypes: ProvableInputPure<any>[]): ProvablePure<any> {\n  let types = inputTypes.map((t) => ('provable' in t ? t.provable : t));\n  return {\n    sizeInFields: () => {\n      return types.reduce((acc, type) => acc + type.sizeInFields(), 0);\n    },\n\n    toFields: (t: Array<any>) => {\n      if (t.length !== types.length) {\n        throw new Error(`typOfArray: Expected ${types.length}, got ${t.length}`);\n      }\n      let res = [];\n      for (let i = 0; i < t.length; ++i) {\n        res.push(...types[i].toFields(t[i]));\n      }\n      return res;\n    },\n\n    toAuxiliary() {\n      return [];\n    },\n\n    fromFields: (xs: Array<any>) => {\n      let offset = 0;\n      let res: Array<any> = [];\n      types.forEach((typ) => {\n        const n = typ.sizeInFields();\n        res.push(typ.fromFields(xs.slice(offset, offset + n)));\n        offset += n;\n      });\n      return res;\n    },\n\n    check(xs: Array<any>) {\n      types.forEach((typ, i) => (typ as any).check(xs[i]));\n    },\n\n    toCanonical(x) {\n      return types.map((typ, i) => Provable.toCanonical(typ, x[i]));\n    },\n\n    toValue(x) {\n      return types.map((typ, i) => typ.toValue(x[i]));\n    },\n\n    fromValue(x) {\n      return types.map((typ, i) => typ.fromValue(x[i]));\n    },\n  };\n}\n", "import { InferValue } from '../../bindings/lib/provable-generic.js';\nimport { Provable } from './provable.js';\nimport { InferProvable, Struct } from './types/struct.js';\nimport { provable, ProvableInferPureFrom } from './types/provable-derivers.js';\nimport { Bool } from './wrapped.js';\nimport { ProvableType } from './types/provable-intf.js';\n\nexport { Option, OptionOrValue };\n\ntype Option<T, V = any> = { isSome: Bool; value: T } & {\n  assertSome(message?: string): T;\n  assertNone(message?: string): void;\n  orElse(defaultValue: T | V): T;\n};\n\ntype OptionOrValue<T, V> = { isSome: boolean | Bool; value: T | V } | T | V | undefined;\n\n/**\n * Define an optional version of a provable type.\n *\n * @example\n * ```ts\n * class OptionUInt64 extends Option(UInt64) {}\n *\n * // create an optional UInt64\n * let some = OptionUInt64.from(5n);\n * let none = OptionUInt64.none();\n *\n * // get back a UInt64\n * let five: UInt64 = some.assertSome('must have a value');\n * let zero: UInt64 = none.orElse(0n); // specify a default value\n * ```\n */\nfunction Option<A extends ProvableType>(\n  type: A\n): ProvableInferPureFrom<A, Option<InferProvable<A>, InferValue<A>>, InferValue<A> | undefined> &\n  (new (option: {\n    isSome: Bool;\n    value: InferProvable<A>;\n  }) => Option<InferProvable<A>, InferValue<A>>) & {\n    fromValue(\n      value:\n        | { isSome: boolean | Bool; value: InferProvable<A> | InferValue<A> }\n        | InferProvable<A>\n        | InferValue<A>\n        | undefined\n    ): Option<InferProvable<A>, InferValue<A>>;\n    from(value?: InferProvable<A> | InferValue<A>): Option<InferProvable<A>, InferValue<A>>;\n    none(): Option<InferProvable<A>, InferValue<A>>;\n  } {\n  type T = InferProvable<A>;\n  type V = InferValue<A>;\n  let strictType: Provable<T, V> = ProvableType.get(type);\n\n  // construct a provable with a JS type of `T | undefined`\n  type PlainOption = { isSome: Bool; value: T };\n  const PlainOption: Provable<{ isSome: Bool; value: T }, { isSome: boolean; value: V }> = provable(\n    { isSome: Bool, value: strictType }\n  );\n\n  const RawOption = {\n    ...PlainOption,\n\n    toValue({ isSome, value }: { isSome: Bool; value: T }) {\n      return isSome.toBoolean() ? strictType.toValue(value) : undefined;\n    },\n\n    fromValue(value: OptionOrValue<T, V>) {\n      if (value === undefined)\n        return {\n          isSome: Bool(false),\n          value: ProvableType.synthesize(strictType),\n        };\n      // TODO: this isn't 100% robust. We would need recursive type validation on any nested objects to make it work\n      if (typeof value === 'object' && 'isSome' in value)\n        return PlainOption.fromValue(value as any); // type-cast here is ok, matches implementation\n      return { isSome: Bool(true), value: strictType.fromValue(value) };\n    },\n  };\n\n  const Super = Struct(RawOption);\n  return class Option_ extends Super {\n    orElse(defaultValue: T | V): T {\n      return Provable.if(this.isSome, strictType, this.value, strictType.fromValue(defaultValue));\n    }\n\n    assertSome(message?: string): T {\n      this.isSome.assertTrue(message);\n      return this.value;\n    }\n\n    assertNone(message?: string): void {\n      this.isSome.assertFalse(message);\n    }\n\n    static from(value?: V | T) {\n      return value === undefined\n        ? new Option_({\n            isSome: Bool(false),\n            value: ProvableType.synthesize(strictType),\n          })\n        : new Option_({\n            isSome: Bool(true),\n            value: strictType.fromValue(value),\n          });\n    }\n    static none() {\n      return Option_.from(undefined);\n    }\n\n    static fromFields(fields: any[], aux?: any): Option_ {\n      return new Option_(Super.fromFields(fields, aux));\n    }\n    static fromValue(value: OptionOrValue<T, V>) {\n      return new Option_(Super.fromValue(value));\n    }\n    static toCanonical(value: PlainOption) {\n      return new Option_(Super.toCanonical?.(value) ?? value);\n    }\n  };\n}\n", "/*\n * Array type inspired by zksecurity's implementation at\n * https://github.com/zksecurity/mina-attestations and\n * gretke's at https://github.com/gretzke/zkApp-data-types\n */\nimport { Bool } from './bool.js';\nimport { Field } from './field.js';\nimport { Provable } from './provable.js';\nimport { type InferProvable, provable as struct } from './types/provable-derivers.js';\nimport { Option } from './option.js';\nimport { ProvableHashable, ProvableType } from './types/provable-intf.js';\nimport { assert } from './gadgets/common.js';\nimport { type From, type InferValue } from '../../bindings/lib/provable-generic.js';\nimport { zip, pad } from '../util/arrays.js';\nimport { arrayGet } from './gadgets/basic.js';\n\n// external API\nexport { DynamicArray };\n\ntype DynamicArray<T = any, V = any> = DynamicArrayBase<T, V>;\n\n/**\n * Dynamic-length array type that has a\n * - constant maximum capacity, but\n * - dynamic actual length\n *\n * ```ts\n * const Bytes = DynamicArray(UInt8, { capacity: 32 });\n * ```\n *\n * `capacity` can be any number from 0 to 2^16-1.\n *\n * **Details**: Internally, this is represented as a static-sized array, plus a\n * Field element that represents the length.\n * The _only_ requirement on these is that the length is less or equal capacity.\n * In particular, there are no provable guarantees maintained on the content of\n * the static-sized array beyond the actual length. Instead, our methods ensure\n * integrity of array operations _within_ the actual length.\n */\nfunction DynamicArray<\n  ElementType extends ProvableType,\n  ProvableValue extends InferProvable<ElementType> = InferProvable<ElementType>,\n  Value extends InferValue<ElementType> = InferValue<ElementType>,\n>(\n  type: ElementType,\n  {\n    capacity,\n  }: {\n    capacity: number;\n  }\n): typeof DynamicArrayBase<ProvableValue, Value> & {\n  provable: ProvableHashable<DynamicArrayBase<ProvableValue, Value>, Value[]>;\n\n  /**\n   * Create a new DynamicArray from an array of values.\n   *\n   * Note: Both the actual length and the values beyond the original ones will\n   * be constant.\n   */\n  from(\n    v: (ProvableValue | Value)[] | DynamicArrayBase<ProvableValue, Value>\n  ): DynamicArrayBase<ProvableValue, Value>;\n} {\n  let innerType: Provable<ProvableValue, Value> = ProvableType.get(type);\n\n  // assert capacity bounds\n  assert(capacity >= 0, 'DynamicArray(): capacity must be >= 0');\n  assert(capacity < 2 ** 16, 'DynamicArray(): capacity must be < 2^16');\n\n  class DynamicArray_ extends DynamicArrayBase<ProvableValue, Value> {\n    get innerType() {\n      return innerType;\n    }\n    static get capacity() {\n      return capacity;\n    }\n    static get provable() {\n      return provableArray;\n    }\n\n    static from(input: (ProvableValue | Value)[] | DynamicArrayBase<ProvableValue, Value>) {\n      return provableArray.fromValue(input);\n    }\n  }\n  const provableArray = provable<ProvableValue, Value>(innerType, DynamicArray_);\n\n  return DynamicArray_;\n}\n\nclass DynamicArrayBase<ProvableValue = any, Value = any> {\n  /**\n   * The internal array, which includes the actual values, padded up to\n   * `capacity` with unconstrained values.\n   */\n  array: ProvableValue[];\n\n  /**\n   * Length of the array. Guaranteed to be in [0, capacity].\n   */\n  length: Field;\n\n  // properties to override in subclass\n  get innerType(): Provable<ProvableValue, Value> {\n    throw Error('Inner type must be defined in a subclass');\n  }\n  static get capacity(): number {\n    throw Error('Capacity must be defined in a subclass');\n  }\n\n  // derived property\n  get capacity(): number {\n    return (this.constructor as typeof DynamicArrayBase).capacity;\n  }\n\n  get Constructor() {\n    return this.constructor as typeof DynamicArrayBase;\n  }\n\n  /**\n   * Create a new {@link DynamicArrayBase} instance from an optional list of\n   * {@link ProvableValue} elements, and optional length.\n   *\n   * - If no parameters are passed, it creates an empty array of length 0.\n   * - If only `array` is passed, it creates a new array with the elements\n   *   of the array.\n   * - If only `length` is passed, it creates a dummy array of the given length\n   *   filled with NULL values.\n   * - If both `array` and `length` are passed, it creates a new array with the\n   *   elements of the array, and the length of the dynamic array is set to the\n   *   `length` passed, which should be less or equal than the length of the\n   *   `array` passed (this is to allow for arrays with dummy values at the end).\n   * - In any case, if `length` is larger than the capacity, it throws.\n   *\n   * @example\n   * ```ts\n   * let arr = new DynamicArray([new Field(1), new Field(2), new Field(3)]);\n   * let empty = new DynamicArray();\n   * ```\n   *\n   * Note: this is different from `ProvableValue[]` because it is a provable type.\n   */\n  constructor(array?: ProvableValue[], length?: Field) {\n    const NULL = ProvableType.synthesize(this.innerType);\n\n    const a = array ?? [];\n    const l = length ?? new Field(a.length);\n\n    assert(a.length <= this.capacity, 'DynamicArray(): array must not exceed capacity');\n    if (length?.isConstant()) {\n      assert(\n        l.toBigInt() <= BigInt(a.length),\n        'DynamicArray(): length must be at most as long as the array'\n      );\n    }\n\n    this.array = pad(a, this.capacity, NULL);\n    this.length = l;\n  }\n\n  /**\n   * In-circuit assertion that the given index is within the bounds of the\n   * dynamic array.\n   * Asserts 0 <= i < this.length, using a cached check that's not\n   * duplicated when doing it on the same variable multiple times, failing\n   * with an error message otherwise.\n   *\n   * @param i - the index to check\n   * @param message - optional error message to use in case the assertion fails\n   */\n  assertIndexInRange(i: Field, message?: string): void {\n    let errorMessage = message ?? `assertIndexInRange(): index must be in range [0, length]`;\n    if (!this.#indicesInRange.has(i)) {\n      if (i.isConstant() && this.length.isConstant()) {\n        assert(i.toBigInt() < this.length.toBigInt(), errorMessage);\n      }\n      i.assertLessThan(this.length, errorMessage);\n      this.#indicesInRange.add(i);\n    }\n  }\n\n  /**\n   * Gets value at index i, and proves that the index is in the array.\n   * It uses an internal cache to avoid duplication of constraints when the\n   * same index is used multiple times.\n   */\n  get(i: Field): ProvableValue {\n    this.assertIndexInRange(i);\n    return this.getOrUnconstrained(i);\n  }\n\n  /**\n   * Gets a value at index i, as an option that is None if the index is not in\n   * the array.\n   *\n   * Note: The correct type for `i` is actually UInt16 which doesn't exist. The\n   * method is not complete (but sound) for i >= 2^16. This means that if the\n   * index is larger than 2^16, the constraints could be satisfiable but the\n   * result is not correct (because the capacity can at most be 2^16).\n   */\n  getOption(i: Field): Option<ProvableValue> {\n    let type = this.innerType;\n    let isContained = i.lessThan(this.length);\n    let value = this.getOrUnconstrained(i);\n    const OptionT = Option(type);\n    return OptionT.fromValue({ isSome: isContained, value });\n  }\n\n  /**\n   * Gets a value at index i, ASSUMING that the index is in the array.\n   *\n   * If the index is in fact not in the array, the return value is completely\n   * unconstrained.\n   *\n   * **Warning**: Only use this if you already know/proved by other means that\n   * the index is within bounds.\n   */\n  getOrUnconstrained(i: Field): ProvableValue {\n    let type = this.innerType;\n    let NULL = ProvableType.synthesize(type);\n    let ai = Provable.witness(type, () => this.array[Number(i)] ?? NULL);\n    let aiFields = type.toFields(ai);\n\n    // assert a is correct on every field column with arrayGet()\n    let fields = this.array.map((t) => type.toFields(t));\n\n    // this allows each array entry to be larger than a single field element\n    for (let j = 0; j < type.sizeInFields(); j++) {\n      let column = fields.map((x) => x[j]!);\n      arrayGet(column, i).assertEquals(aiFields[j]!);\n    }\n    return ai;\n  }\n\n  /**\n   * Sets a value at index i and proves that the index is in the array.\n   */\n  set(i: Field, value: ProvableValue, message?: string): void {\n    let errorMessage = message ?? `set(): index must be in range [0, length]`;\n    this.assertIndexInRange(i, errorMessage);\n    this.setOrDoNothing(i, value);\n  }\n\n  /**\n   * Sets a value at index i, or does nothing if the index is not in the array\n   */\n  setOrDoNothing(i: Field, value: ProvableValue): void {\n    zip(this.array, this.#indexMask(i)).forEach(([t, equalsIJ], i) => {\n      this.array[i] = Provable.if(equalsIJ, this.innerType, value, t);\n    });\n  }\n\n  /**\n   * Map every element of the array to a new value.\n   *\n   * **Warning**: The callback will be passed unconstrained dummy values.\n   */\n  map<MapType extends ProvableType>(\n    type: MapType,\n    f: (t: ProvableValue) => From<MapType>\n  ): DynamicArray<InferProvable<MapType>, InferValue<MapType>> {\n    let Array = DynamicArray(type, { capacity: this.capacity });\n    let provable = ProvableType.get(type);\n    let array = this.array.map((x) => provable.fromValue(f(x)));\n    let newArray = new Array(array, this.length);\n\n    // new array has same length/capacity, so it can use the same cached masks\n    newArray.#indexMasks = this.#indexMasks;\n    newArray.#indicesInRange = this.#indicesInRange;\n    newArray.#dummies = this.#dummies;\n    return newArray;\n  }\n\n  /**\n   * Iterate over all elements of the array.\n   *\n   * The callback will be passed an element and a boolean `isDummy` indicating\n   * whether the value is part of the actual array. Optionally, an index can be\n   * passed as a third argument (used in `forEachReversed`)\n   */\n  forEach(f: (t: ProvableValue, isDummy: Bool, i?: number) => void): void {\n    zip(this.array, this.#dummyMask()).forEach(([t, isDummy], i) => f(t, isDummy, i));\n  }\n\n  /**\n   * Iterate over all elements of the array, in reverse order.\n   *\n   * The callback will be passed an element and a boolean `isDummy` indicating whether the value is part of the actual array.\n   *\n   * Note: the indices are also passed in reverse order, i.e. we always have `t = this.array[i]`.\n   */\n  forEachReverse(f: (t: ProvableValue, isDummy: Bool, i: number) => void) {\n    zip(this.array, this.#dummyMask())\n      .reverse()\n      .forEach(([t, isDummy], i) => {\n        f(t, isDummy, this.capacity - 1 - i);\n      });\n  }\n\n  /**\n   * Return a version of the same array with a larger capacity.\n   *\n   * **Warning**: Does not modify the array, but returns a new one.\n   *\n   * **Note**: this doesn't cost constraints, but currently doesn't preserve any\n   * cached constraints.\n   *\n   * @param capacity - the new capacity of the array\n   */\n  growCapacityTo(capacity: number, message?: string): DynamicArray<ProvableValue, Value> {\n    let errorMessage =\n      message ??\n      `growCapacityTo: new capacity ${capacity} must be greater than current capacity ${this.capacity}`;\n    assert(capacity >= this.capacity, errorMessage);\n    let NewArray = DynamicArray(this.innerType, { capacity });\n    let NULL = ProvableType.synthesize(this.innerType);\n    let array = pad(this.array, capacity, NULL);\n    return new NewArray(array, this.length);\n  }\n\n  /**\n   * Return a version of the same array with a larger capacity.\n   *\n   * **Warning**: Does not modify the array, but returns a new one.\n   *\n   * **Note**: this doesn't cost constraints, but currently doesn't preserve any\n   * cached constraints.\n   *\n   * @param increment - the amount to increase the capacity by\n   */\n  growCapacityBy(increment: number): DynamicArray<ProvableValue> {\n    return this.growCapacityTo(this.capacity + increment);\n  }\n\n  /**\n   * Increments the length of the current array by n elements, checking that the\n   * new length is within the capacity, failing with the error message otherwise.\n   *\n   * @param n - the number of elements to increase the length by\n   * @param message - optional error message to use in case the assertion fails\n   */\n  increaseLengthBy(n: Field, message?: string): void {\n    let errorMessage =\n      message ??\n      `increaseLengthBy: cannot increase length because provided n would exceed capacity ${this.capacity}.`;\n\n    let newLength = this.length.add(n).seal();\n    newLength.assertLessThanOrEqual(new Field(this.capacity), errorMessage);\n    this.length = newLength;\n  }\n\n  /**\n   * Decrements the length of the current array by `n` elements, checking that\n   * the `n` is less or equal than the current length, failing with the error\n   * message otherwise.\n   *\n   * @param n - the number of elements to decrease the length by\n   * @param message - optional error message to use in case the assertion fails\n   */\n  decreaseLengthBy(n: Field, message?: string): void {\n    let errorMessage =\n      message ??\n      `decreaseLengthBy: cannot decrease length because provided n is larger than current array length`;\n\n    let oldLength = this.length;\n    n.assertLessThanOrEqual(this.length, errorMessage);\n    this.length = oldLength.sub(n).seal();\n  }\n\n  /**\n   * Sets the length of the current array to a new value, checking that the\n   * new length is less or equal than the capacity.\n   *\n   * An optional error message can be provided to be used in case the inner\n   * assertion fails.\n   *\n   * @param newLength - the new length to set the array to\n   * @param message - optional error message\n   *\n   * **Warning**: This does not change (add nor remove) the values of the array.\n   */\n  setLengthTo(n: Field, message?: string): void {\n    let errorMessage =\n      message ?? `setLengthTo: cannot set length to n because it exceeds capacity ${this.capacity}`;\n    n.assertLessThanOrEqual(new Field(this.capacity), errorMessage);\n    this.length = n;\n  }\n\n  /**\n   * Push a value, without changing the capacity.\n   *\n   * Proves that the new length is still within the capacity, fails otherwise.\n   *\n   * To grow the capacity along with the actual length, you can use:\n   *\n   * ```ts\n   * array = array.growCapacityBy(1);\n   * array.push(value);\n   * ```\n   *\n   * @param value - the value to push into the array\n   * @param message - optional error message to use in case the assertion fails\n   */\n  push(value: ProvableValue, message?: string): void {\n    let errorMessage =\n      message ?? `push(): cannot push value because it would exceed capacity ${this.capacity}.`;\n    let oldLength = this.length;\n    this.increaseLengthBy(new Field(1), errorMessage);\n    this.setOrDoNothing(oldLength, value);\n  }\n\n  /**\n   * Removes the last `n` elements from the dynamic array, decreasing the length\n   * by n. If no amount is provided, only one element is popped. The popped\n   * positions are set to NULL values.\n   *\n   * @param n - the number of elements to pop (one if not provided)\n   * @param message - optional error message to use in case the assertion fails\n   */\n  pop(n?: Field, message?: string): void {\n    let errorMessage = message ?? `pop(): cannot pop n elements because the length is smaller`;\n\n    let dec = n !== undefined ? n : new Field(1);\n    this.decreaseLengthBy(dec, errorMessage);\n\n    let NULL: ProvableValue = ProvableType.synthesize(this.innerType);\n    if (n !== undefined) {\n      // set the last n elements to NULL\n      for (let i = 0; i < this.capacity; i++) {\n        this.array[i] = Provable.if(\n          new Field(i).lessThanOrEqual(this.length),\n          this.innerType,\n          this.array[i],\n          NULL\n        );\n      }\n    } else {\n      // set the last element to NULL\n      this.setOrDoNothing(this.length, NULL);\n    }\n  }\n\n  /**\n   * In-circuit check whether the array is empty.\n   *\n   * @returns true or false depending on whether the dynamic array is empty\n   */\n  isEmpty(): Bool {\n    return this.length.equals(0);\n  }\n\n  /**\n   * Shifts all elements of the array to the left by `n` positions, reducing\n   * the length by `n`, which must be less than or equal to the current length\n   * (failing with an error message otherwise).\n   *\n   * @param n - the number of positions to shift left\n   * @param message - optional error message to use in case the assertion fails\n   */\n  shiftLeft(n: Field, message?: string): void {\n    let errorMessage =\n      message ?? `shiftLeft(): cannot shift left because provided n would exceed current length.`;\n    let NULL = ProvableType.synthesize(this.innerType);\n    for (let i = 0; i < this.capacity; i++) {\n      let offset = new Field(i).add(n);\n      this.array[i] = Provable.if(\n        offset.lessThan(this.length),\n        this.innerType,\n        this.getOrUnconstrained(offset),\n        NULL\n      );\n    }\n    this.decreaseLengthBy(n, errorMessage);\n  }\n\n  /**\n   * Shifts all elements of the array to the right by `n` positions, increasing\n   * the length by `n`, which must result in less than or equal to the capacity\n   * (failing with an error message otherwise). The new elements on the left are\n   * set to NULL values.\n   *\n   * @param n - the number of positions to shift right\n   * @param message - optional error message to use in case the assertion fails\n   */\n  shiftRight(n: Field, message?: string): void {\n    let errorMessage =\n      message ??\n      `shiftRight(): cannot shift right because provided n would exceed capacity ${this.capacity}`;\n    this.increaseLengthBy(n, errorMessage);\n    let NULL = ProvableType.synthesize(this.innerType);\n\n    for (let i = this.capacity - 1; i >= 0; i--) {\n      let offset = new Field(i).sub(n);\n      this.array[i] = Provable.if(\n        new Field(i).lessThan(n),\n        this.innerType,\n        NULL,\n        this.getOrUnconstrained(offset)\n      );\n    }\n  }\n\n  /**\n   * Copies the current dynamic array, returning a new instance with the same\n   * values and length.\n   *\n   * @returns a new DynamicArray instance with the same values as the current.\n   *\n   */\n  copy(): this {\n    let newArr = new (<any>this.constructor)();\n    newArr.array = this.array.slice();\n    newArr.length = this.length;\n    return newArr;\n  }\n\n  /**\n   * Creates a new dynamic array with the values of the current array from\n   * index `start` (included) to index `end` (excluded). If `start` is not\n   * provided, it defaults to 0. If `end` is not provided, it defaults to the\n   * length of the array.\n   *\n   * @param start - the starting index of the slice (inclusive)\n   * @param end - the ending index of the slice (exclusive)\n   *\n   * @returns a new DynamicArray instance with the sliced values\n   */\n  slice(start?: Field, end?: Field): DynamicArray<ProvableValue, Value> {\n    start ??= new Field(0);\n    end ??= this.length;\n    let sliced = this.copy();\n    sliced.shiftLeft(start, `slice(): provided start is greater than current length`);\n    sliced.pop(this.length.sub(end), `slice(): provided end is greater than current length`);\n    return sliced;\n  }\n\n  /**\n   * Returns a new array with the elements reversed.\n   */\n  reverse(): DynamicArray<ProvableValue, Value> {\n    let Array = DynamicArray(this.innerType, { capacity: this.capacity });\n    // first, copy the inner array of length capacity and reverse it\n    let array = this.array.slice().reverse();\n\n    // now, slice off the padding that is now at the beginning of the array\n    let capacity = new Field(this.capacity);\n    return new Array(array, capacity).slice(capacity.sub(this.length).seal());\n  }\n\n  /**\n   * Concatenates the current array with another dynamic array, returning a new\n   * dynamic array with the values of both arrays. The capacity of the new array\n   * is the sum of the capacities of the two arrays.\n   *\n   * @param other - the dynamic array to concatenate\n   *\n   * @returns a new DynamicArray instance with the concatenated values\n   */\n  concat(other: DynamicArray<ProvableValue, Value>): DynamicArray<ProvableValue, Value> {\n    let res = this.growCapacityTo(this.capacity + other.capacity);\n    let offset = new Field(0).sub(new Field(this.length));\n    for (let i = 0; i < res.capacity; i++) {\n      res.array[i] = Provable.if(\n        new Field(i).lessThan(this.length),\n        this.innerType,\n        this.getOrUnconstrained(new Field(i)),\n        other.getOrUnconstrained(offset)\n      );\n      offset = offset.add(new Field(1));\n    }\n    res.length = this.length.add(other.length);\n    return res;\n  }\n\n  /**\n   * Inserts a value at index i, shifting all elements after that position to\n   * the right by one. The length of the array is increased by one, which must\n   * result in less than or equal to the capacity.\n   *\n   * @param i - the index at which to insert the value\n   * @param value - the value to insert\n   * @param message - optional error message to use in case the assertion fails\n   */\n  insert(index: Field, value: ProvableValue, message?: string): void {\n    let errorMessage =\n      message ??\n      `insert(): cannot insert value at index because it would exceed capacity ${this.capacity}.`;\n    const right = this.slice(index, this.length);\n    this.increaseLengthBy(new Field(1), errorMessage);\n    this.set(index, value);\n    for (let i = 0; i < this.capacity; i++) {\n      let offset = new Field(i).sub(index).sub(new Field(1));\n      this.array[i] = Provable.if(\n        new Field(i).lessThanOrEqual(index),\n        this.innerType,\n        this.getOrUnconstrained(new Field(i)),\n        right.getOrUnconstrained(offset)\n      );\n    }\n  }\n\n  /**\n   * Checks whether the dynamic array includes a value.\n   *\n   * @param value - the value to check for inclusion in the array\n   * @returns\n   */\n  includes(value: ProvableValue): Bool {\n    let type = this.innerType;\n    let isIncluded = this.array.map((t) => Provable.equal(type, t, value));\n    let isSome = isIncluded.reduce((acc, curr) => acc.or(curr), new Bool(false));\n    return isSome;\n  }\n\n  // cached variables to not duplicate constraints if we do something like\n  // array.get(i), array.set(i, ..) on the same index\n  #indexMasks: Map<Field, Bool[]> = new Map();\n  #indicesInRange: Set<Field> = new Set();\n  #dummies?: Bool[];\n\n  /**\n   * Compute i.equals(j) for all indices j in the static-size array.\n   *\n   * j = 0           n\n   *     0 0 1 0 0 0 0\n   *         ^\n   *         i\n   */\n  #indexMask(i: Field): Bool[] {\n    let mask = this.#indexMasks.get(i);\n    mask ??= this.array.map((_, j) => i.equals(j));\n    this.#indexMasks.set(i, mask);\n    return mask;\n  }\n\n  /**\n   * Tells us which elements are dummies = not actually in the array.\n   *\n   * 0 0 0 1 1 1 1 1 1\n   *       ^\n   *       length\n   */\n  #dummyMask(): Bool[] {\n    if (this.#dummies !== undefined) return this.#dummies;\n    let isLength = this.#indexMask(this.length);\n    let wasLength = new Bool(false);\n\n    let mask = isLength.map((isLength) => {\n      wasLength = wasLength.or(isLength);\n      return wasLength;\n    });\n    this.#dummies = mask;\n    return mask;\n  }\n\n  /**\n   * Converts the current instance of the dynamic array to a plain array of values.\n   *\n   * @returns An array of values representing the elements in the dynamic array.\n   */\n  toValue(): Value[] {\n    return (this.constructor as any as { provable: Provable<any, Value[]> }).provable.toValue(this);\n  }\n}\n\n/**\n * Base class of all DynamicArray subclasses\n */\nDynamicArray.Base = DynamicArrayBase;\n\nfunction provable<ProvableValue, Value>(\n  type: Provable<ProvableValue, Value>,\n  Class: typeof DynamicArrayBase<ProvableValue, Value>\n): ProvableHashable<DynamicArrayBase<ProvableValue, Value>, Value[]> {\n  let capacity = Class.capacity;\n  let NULL = ProvableType.synthesize(type);\n\n  let PlainArray = struct({\n    array: Provable.Array(type, capacity),\n    length: Field,\n  });\n  return {\n    ...PlainArray,\n\n    // make fromFields return a class instance\n    fromFields(fields, aux) {\n      let raw = PlainArray.fromFields(fields, aux);\n      return new Class(raw.array, raw.length);\n    },\n\n    // convert to/from plain array that has the correct length\n    toValue(value) {\n      let length = Number(value.length);\n      return value.array.map((t) => type.toValue(t)).slice(0, length);\n    },\n    fromValue(value) {\n      if (value instanceof DynamicArrayBase) return value;\n      let array = value.map((t) => type.fromValue(t));\n      let padded = pad(array, capacity, NULL);\n      return new Class(padded, new Field(value.length));\n    },\n\n    toCanonical(value) {\n      return value;\n    },\n\n    // check has to validate length in addition to the other checks\n    check(value) {\n      PlainArray.check(value);\n      value.length.lessThanOrEqual(new Field(capacity)).assertTrue();\n    },\n\n    empty() {\n      return new Class();\n    },\n  };\n}\n", "/**\n * This module defines the `RuntimeTable` class, which represents a provable table whose entries\n * can be defined at runtime within the SNARK circuit. It allows inserting key-value pairs and\n * checking for their existence.\n */\n\nimport { assert } from '../../util/assert.js';\nimport { Field } from \"../field.js\";\nimport { Gates } from \"../gates.js\";\n\nexport {\n  RuntimeTable,\n};\n\n/**\n * # RuntimeTable\n *\n * A **provable lookup table** whose entries are defined at runtime (during circuit construction).\n * It constrains that certain `(index, value)` pairs *exist* in a table identified by `id`, using\n * efficient **lookup gates** under the hood. Each inner lookup gate can batch up to **3 pairs**.\n *\n * ## When to use\n * - **small/medium, runtime-chosen set** of `(index, value)` pairs and want to prove\n *   **membership** of queried pairs in that set.\n * - **ergonomic batching**: repeated `lookup()` calls automatically group into 3-tuples\n *   so it creates pay fewer gates when possible (instead of writing repetitive `Gates.lookup(...)`\n *   calls and manually handling batching of lookup entries).\n * - **expressiveness**: all runtime tables will be condensed into one long table under the hood, \n *   so it is highly recommended to use distinct `id`s for unrelated tables to achieve better\n *   separation of concerns and avoid accidental collisions, at no extra cost. \n *\n * ## When *not* to use\n * - **static and global tables**: Prefer built-ins for fixed-tables that already exist in the system.\n *   (a.k.a. standard 4-bit XOR or 12-bit length range-check tables).\n * - **hiding properties**: lookup tables **constrain membership**, but don\u2019t provide secrecy \n *   of the values by themselves. If data privacy is needed, consider using the **witness** to hold \n *   the values and protect from exposure to the verifier.\n * - **huge tables**: runtime lookups are efficient for a limited amount of entries, but their\n *   size is limited by the underlying circuit size (i.e. 2^16). Applications needing more storage\n *   should consider an optimized custom solution.\n * - **mutable data**: runtime tables are write-once only, so once inserted entries in table are\n *   remain fixed. To represent changing data, consider using DynamicArrays.\n * - **unknown bounded size**: runtime lookup tables require all possible `indices` to be preallocated\n *   at construction time. If the set of possible indices is not known in advance, consider using\n *   DynamicArrays instead.\n * \n * ## Invariants & constraints\n * - `id !== 0 && id !== 1`. (Reserved for XOR and range-check tables.)\n * - `indices` are **unique**. Duplicates are rejected.\n * - `indices` must be **known** at construction time.\n * - `lookup()` **batches** each 3 calls (for the same table) into **one** gate automatically.\n * - `check()` call is required for soundness to flush 1\u20132 pending pairs before the end of the circuit.\n *\n * ## Complexity\n * - Gate cost for membership checks is ~`ceil(#pairs / 3)` lookup gates per table id,\n *   plus one lookup gate per `insert()` triplet.\n *\n * ## Example\n * ```ts\n * // Define a runtime table with id=5 and allowed indices {10n, 20n, 30n}\n * const rt = new RuntimeTable(5, [10n, 20n, 30n]);\n *\n * // Populate some pairs (you can insert in chunks of up to 3)\n * rt.insert([\n *   [10n, Field.from(123)],\n *   [20n, Field.from(456)],\n *   [30n, Field.from(789)],\n * ]);\n *\n * // Constrain that these pairs exist in the table\n * rt.lookup(10n, Field.from(123));\n * rt.lookup(20n, Field.from(456));\n * // These two calls will be grouped; add a third, or call check() to flush\n * rt.check(); // flush pending lookups (important!)\n * ```\n *\n * ## Gotchas\n * - **Don\u2019t forget `check()`**: If you finish a proof block with 1\u20132 pending `lookup()` calls,\n *   call `check()` to emit the final lookup gate. Otherwise those constraints won\u2019t land.\n * - **Index validation**: `insert()` and `lookup()` throw if the index isn\u2019t whitelisted in `indices`.\n * - **ID collisions**: Pick distinct `id`s for unrelated runtime tables.\n * - **flag settings**: zkApps with runtime tables must be compiled with the `withRuntimeTables` flag.\n *\n * @remarks\n * Construction registers the table configuration via `Gates.addRuntimeTableConfig(id, indices)`.\n * Subsequent `insert()`/`lookup()` use that configuration to emit lookup gates. Please refrain from\n * using that function directly, as it will be deprecated in the future.\n *\n * @see Gates.lookup\n * @see Gates.addRuntimeTableConfig\n * @see Gadgets.inTable\n * @see DynamicArray for a mutable alternative to store runtime data.\n * @public\n */\nclass RuntimeTable {\n    /** \n     * Unique identifier for the runtime table. \n     * Must be different than 0 and 1, as those values are reserved\n     * for the XOR and range-check tables, respectively.\n     */\n    readonly id: number;\n    /**\n     * Indices that define the structure of the runtime table.\n     * They can be consecutive or not, but they must be unique.\n     */\n    readonly indices: Set<bigint>;\n    /**\n     * Pending pairs to be checked on the runtime table.\n     */\n    pairs: Array<[bigint, Field]> = [];\n\n    constructor(id: number, indices: bigint[]) {\n        // check that id is not 0 or 1, as those are reserved values\n        assert(id !== 0 && id !== 1, \"Runtime table id must be different than 0 and 1\");\n \n        // check that all the indices are unique\n        let uniqueIndices = new Set(indices);\n        assert(uniqueIndices.size === indices.length, \"Runtime table indices must be unique\");\n\n        // initialize the runtime table\n        this.id = id;\n        this.indices = uniqueIndices;\n        Gates.addRuntimeTableConfig(id, indices);\n    }\n\n    /**\n     * Inserts key-value pairs into the runtime table.\n     * Under the hood, this method uses the `Gates.lookup` function to perform\n     * lookups to the table with identifier `this.id`. One single lookup gate\n     * can store up to 3 different pairs of index and value.\n     * \n     * It throws when trying to insert a pair with an index that is not part of\n     * the runtime table.\n     *\n     * @param pairs Array of pairs [index, value] to insert into the runtime table.\n     */\n    insert(pairs: [bigint, Field][]) {\n        for (let i = 0; i < pairs.length; i += 3) {\n            const chunk = pairs.slice(i, i + 3);\n            const [idx0, value0] = chunk[0];\n            const [idx1, value1] = chunk[1] || [idx0, value0];\n            const [idx2, value2] = chunk[2] || [idx0, value0];\n\n            assert(this.indices.has(idx0) && this.indices.has(idx1) && this.indices.has(idx2),\n                `Indices must be part of the runtime table with id ${this.id}`);\n\n            Gates.lookup(Field.from(this.id), Field.from(idx0), value0, Field.from(idx1), value1, Field.from(idx2), value2);\n        }\n    }\n\n    /**\n     * In-circuit checks if a key-value pair exists in the runtime table. Note\n     * that the same index can be queried several times as long as the value \n     * remains the same.\n     * \n     * Every three calls to this method for the same identifier will be grouped \n     * into a single lookup gate for efficiency.\n     * \n     * @param idx The index of the key to check.\n     * @param value The value to check.\n     */\n    lookup(idx: bigint, value: Field) {\n        if (this.pairs.length == 2) {\n            let [idx0, value0] = this.pairs[0];\n            let [idx1, value1] = this.pairs[1];\n            Gates.lookup(Field.from(this.id), Field.from(idx0), value0, Field.from(idx1), value1, Field.from(idx), value);\n            this.pairs = [];\n        } else {\n            this.pairs.push([idx, value]);\n        }\n    }\n\n    /**\n     * Finalizes any pending checks by creating a Lookup when necessary.\n     * This function must be called after all `lookup()` calls of the table\n     * to ensure that all pending checks are looked up in the circuit.\n     */\n    check() {\n        // If there are any pending checks, perform one lookup with them.\n        // Because the lookup gate takes 3 pairs, we add redundancy if needed.\n        if (this.pairs.length > 0) {\n            let [idx0, value0] = this.pairs[0];\n            let [idx1, value1] = this.pairs.length > 1 ? this.pairs[1] : [idx0, value0];\n            let [idx2, value2] = this.pairs.length > 2 ? this.pairs[2] : [idx0, value0];\n            Gates.lookup(Field.from(this.id), Field.from(idx0), value0, Field.from(idx1), value1, Field.from(idx2), value2);\n            this.pairs = [];\n        }\n    }\n}\n", "import { Poseidon, ProvableHashable, packToFields } from './crypto/poseidon.js';\nimport { Field } from './field.js';\nimport { assert } from './gadgets/common.js';\nimport { Provable } from './provable.js';\nimport { fields, modifiedField } from './types/fields.js';\nimport { mapValue, provableFromClass } from './types/provable-derivers.js';\nimport { ProvableType, WithProvable } from './types/provable-intf.js';\nimport { HashInput } from './types/struct.js';\nimport { Unconstrained } from './types/unconstrained.js';\n\nexport { Hashed, Packed };\n\n/**\n * `Packed<T>` is a \"packed\" representation of any type `T`.\n *\n * \"Packed\" means that field elements which take up fewer than 254 bits are packed together into\n * as few field elements as possible.\n *\n * For example, you can pack several Bools (1 bit) or UInt32s (32 bits) into a single field element.\n *\n * Using a packed representation can make sense in provable code where the number of constraints\n * depends on the number of field elements per value.\n *\n * For example, `Provable.if(bool, x, y)` takes O(n) constraints, where n is the number of field\n * elements in x and y.\n *\n * Usage:\n *\n * ```ts\n * // define a packed type from a type\n * let PackedType = Packed.create(MyType);\n *\n * // pack a value\n * let packed = PackedType.pack(value);\n *\n * // ... operations on packed values, more efficient than on plain values ...\n *\n * // unpack a value\n * let value = packed.unpack();\n * ```\n *\n * **Warning**: Packing only makes sense where packing actually reduces the number of field elements.\n * For example, it doesn't make sense to pack a _single_ Bool, because it will be 1 field element before\n * and after packing. On the other hand, it does makes sense to pack a type that holds 10 or 20 Bools.\n *\n * **Warning**: When wrapping a type with `Packed`, make sure that that type is safe to automatically _pack_\n * and _unpack_ in provable code. In particular, do not use `Packed` with types that define a custom `toInput()`\n * (specifying a certain bit packing) but no corresponding `check()` method (that constrains the bit lengths of the packed parts).\n */\nclass Packed<T> {\n  packed: Field[];\n  value: Unconstrained<T>;\n\n  /**\n   * Create a packed representation of `type`. You can then use `PackedType.pack(x)` to pack a value.\n   */\n  static create<T, V>(\n    type: WithProvable<ProvableHashable<T, V>>\n  ): typeof Packed<T> & {\n    provable: ProvableHashable<Packed<T>, V>;\n\n    /**\n     * Pack a value.\n     */\n    pack(x: T): Packed<T>;\n  } {\n    let provable = ProvableType.get(type);\n    // compute size of packed representation\n    let input = provable.toInput(provable.empty());\n    let packedSize = countFields(input);\n    let packedFields = fields(packedSize);\n\n    return class Packed_ extends Packed<T> {\n      static _innerProvable = provable;\n      static _provable = mapValue(\n        provableFromClass(Packed_, {\n          packed: packedFields,\n          value: Unconstrained,\n        }),\n        ({ value }: { value: Unconstrained<T> }) => provable.toValue(value.get()),\n        (x) => {\n          if (x instanceof Packed) return x;\n          let { packed, value } = Packed_.pack(provable.fromValue(x));\n          return {\n            packed: packedFields.toValue(packed),\n            value: Unconstrained.from(value),\n          };\n        }\n      ) satisfies ProvableHashable<Packed<T>, V> as ProvableHashable<Packed<T>, V>;\n\n      static pack(x: T): Packed<T> {\n        let input = provable.toInput(x);\n        let packed = packToFields(input);\n        let unconstrained = Unconstrained.witness(() => Provable.toConstant(provable, x));\n        return new Packed_(packed, unconstrained);\n      }\n\n      static empty(): Packed<T> {\n        return Packed_.pack(provable.empty());\n      }\n\n      static get provable() {\n        assert(this._provable !== undefined, 'Packed not initialized');\n        return this._provable;\n      }\n    };\n  }\n\n  constructor(packed: Field[], value: Unconstrained<T>) {\n    this.packed = packed;\n    this.value = value;\n  }\n\n  /**\n   * Unpack a value.\n   */\n  unpack(): T {\n    let value = Provable.witness(this.Constructor.innerProvable, () => this.value.get());\n\n    // prove that the value packs to the packed fields\n    let input = this.Constructor.innerProvable.toInput(value);\n    let packed = packToFields(input);\n    for (let i = 0; i < this.packed.length; i++) {\n      this.packed[i].assertEquals(packed[i]);\n    }\n\n    return value;\n  }\n\n  toFields(): Field[] {\n    return this.packed;\n  }\n\n  // dynamic subclassing infra\n  static _provable: ProvableHashable<Packed<any>> | undefined;\n  static _innerProvable: ProvableHashable<any> | undefined;\n\n  get Constructor(): typeof Packed {\n    return this.constructor as typeof Packed;\n  }\n\n  static get innerProvable(): ProvableHashable<any> {\n    assert(this._innerProvable !== undefined, 'Packed not initialized');\n    return this._innerProvable;\n  }\n}\n\nfunction countFields(input: HashInput) {\n  let n = input.fields?.length ?? 0;\n  let pendingBits = 0;\n\n  for (let [, bits] of input.packed ?? []) {\n    pendingBits += bits;\n    if (pendingBits >= Field.sizeInBits) {\n      n++;\n      pendingBits = bits;\n    }\n  }\n  if (pendingBits > 0) n++;\n\n  return n;\n}\n\n/**\n * `Hashed<T>` represents a type `T` by its hash.\n *\n * Since a hash is only a single field element, this can be more efficient in provable code\n * where the number of constraints depends on the number of field elements per value.\n *\n * For example, `Provable.if(bool, x, y)` takes O(n) constraints, where n is the number of field\n * elements in x and y. With Hashed, this is reduced to O(1).\n *\n * The downside is that you will pay the overhead of hashing your values, so it helps to experiment\n * in which parts of your code a hashed representation is beneficial.\n *\n * Usage:\n *\n * ```ts\n * // define a hashed type from a type\n * let HashedType = Hashed.create(MyType);\n *\n * // hash a value\n * let hashed = HashedType.hash(value);\n *\n * // ... operations on hashes, more efficient than on plain values ...\n *\n * // unhash to get the original value\n * let value = hashed.unhash();\n * ```\n *\n * **Warning**: When wrapping a type with `Hashed`, make sure that that type is safe to automatically _pack_\n * and _unpack_ in provable code. In particular, do not use `Hashed` with types that define a custom `toInput()`\n * (specifying a certain bit packing) but no corresponding `check()` method  (that constrains the bit lengths of the packed parts).\n */\nclass Hashed<T> {\n  hash: Field;\n  value: Unconstrained<T>;\n\n  /**\n   * Create a hashed representation of `type`. You can then use `HashedType.hash(x)` to wrap a value in a `Hashed`.\n   */\n  static create<T>(\n    type: WithProvable<ProvableHashable<T>>,\n    hash?: (t: T) => Field\n  ): typeof Hashed<T> & {\n    provable: ProvableHashable<Hashed<T>>;\n    empty(): Hashed<T>;\n  } {\n    let provable = ProvableType.get(type);\n    let _hash = hash ?? ((t: T) => Poseidon.hashPacked(provable, t));\n\n    return class Hashed_ extends Hashed<T> {\n      static _innerProvable = provable;\n      static _provable = provableFromClass(Hashed_, {\n        hash: modifiedField({ empty: () => _hash(provable.empty()) }),\n        value: Unconstrained,\n      }) satisfies ProvableHashable<Hashed<T>> as ProvableHashable<Hashed<T>>;\n\n      static _hash = _hash satisfies (t: T) => Field;\n\n      static empty(): Hashed<T> {\n        let empty = provable.empty();\n        return new this(_hash(empty), Unconstrained.from(empty));\n      }\n\n      static get provable() {\n        assert(this._provable !== undefined, 'Hashed not initialized');\n        return this._provable;\n      }\n    };\n  }\n\n  constructor(hash: Field, value: Unconstrained<T>) {\n    this.hash = hash;\n    this.value = value;\n  }\n\n  static _hash(_: any): Field {\n    assert(false, 'Hashed not initialized');\n  }\n\n  /**\n   * Wrap a value, and represent it by its hash in provable code.\n   *\n   * ```ts\n   * let hashed = HashedType.hash(value);\n   * ```\n   *\n   * Optionally, if you already have the hash, you can pass it in and avoid recomputing it.\n   */\n  static hash<T>(value: T, hash?: Field): Hashed<T> {\n    hash ??= this._hash(value);\n    let unconstrained = Unconstrained.witness(() => Provable.toConstant(this.innerProvable, value));\n    return new this(hash, unconstrained);\n  }\n\n  /**\n   * Unwrap a value from its hashed variant.\n   */\n  unhash(): T {\n    let value = Provable.witness(this.Constructor.innerProvable, () => this.value.get());\n\n    // prove that the value hashes to the hash\n    let hash = this.Constructor._hash(value);\n    this.hash.assertEquals(hash);\n\n    return value;\n  }\n\n  toFields(): Field[] {\n    return [this.hash];\n  }\n\n  // dynamic subclassing infra\n  static _provable: ProvableHashable<Hashed<any>> | undefined;\n  static _innerProvable: ProvableHashable<any> | undefined;\n\n  get Constructor(): typeof Hashed {\n    return this.constructor as typeof Hashed;\n  }\n\n  static get innerProvable(): ProvableHashable<any> {\n    assert(this._innerProvable !== undefined, 'Hashed not initialized');\n    return this._innerProvable;\n  }\n}\n", "import { Bool, Field } from './wrapped.js';\nimport { Provable } from './provable.js';\nimport { Struct } from './types/struct.js';\nimport { assert } from './gadgets/common.js';\nimport { provableFromClass } from './types/provable-derivers.js';\nimport { Poseidon, packToFields, ProvableHashable } from './crypto/poseidon.js';\nimport { Unconstrained } from './types/unconstrained.js';\nimport { ProvableType, WithProvable } from './types/provable-intf.js';\nimport { Option } from './option.js';\n\nexport {\n  MerkleListBase,\n  MerkleList,\n  MerkleListIteratorBase,\n  MerkleListIterator,\n  WithHash,\n  emptyHash,\n  genericHash,\n  merkleListHash,\n  withHashes,\n};\n\n// common base types for both MerkleList and MerkleListIterator\n\nconst emptyHash = Field(0);\n\ntype WithHash<T> = { previousHash: Field; element: T };\n\nfunction WithHash<T>(type: ProvableHashable<T>): ProvableHashable<WithHash<T>> {\n  return Struct({ previousHash: Field, element: type });\n}\nfunction toConstant<T>(type: Provable<T>, node: WithHash<T>): WithHash<T> {\n  return {\n    previousHash: node.previousHash.toConstant(),\n    element: Provable.toConstant(type, node.element),\n  };\n}\n\n/**\n * Common base type for {@link MerkleList} and {@link MerkleListIterator}\n */\ntype MerkleListBase<T> = {\n  hash: Field;\n  data: Unconstrained<WithHash<T>[]>;\n};\n\nfunction MerkleListBase<T>(): ProvableHashable<MerkleListBase<T>> {\n  return class extends Struct({ hash: Field, data: Unconstrained }) {\n    static empty(): MerkleListBase<T> {\n      return { hash: emptyHash, data: Unconstrained.from([]) };\n    }\n  };\n}\n\n// merkle list\n\n/**\n * Dynamic-length list which is represented as a single hash\n *\n * Supported operations are {@link push()} and {@link pop()} and some variants thereof.\n *\n *\n * A Merkle list is generic over its element types, so before using it you must create a subclass for your element type:\n *\n * ```ts\n * class MyList extends MerkleList.create(MyType) {}\n *\n * // now use it\n * let list = MyList.empty();\n *\n * list.push(new MyType(...));\n *\n * let element = list.pop();\n * ```\n *\n * Internal detail: `push()` adds elements to the _start_ of the internal array and `pop()` removes them from the start.\n * This is so that the hash which represents the list is consistent with {@link MerkleListIterator},\n * and so a `MerkleList` can be used as input to `MerkleListIterator.startIterating(list)`\n * (which will then iterate starting from the last pushed element).\n */\nclass MerkleList<T> implements MerkleListBase<T> {\n  hash: Field;\n  data: Unconstrained<WithHash<T>[]>;\n\n  constructor({ hash, data }: MerkleListBase<T>) {\n    this.hash = hash;\n    this.data = data;\n  }\n\n  isEmpty() {\n    return this.hash.equals(this.Constructor.emptyHash);\n  }\n\n  /**\n   * Push a new element to the list.\n   */\n  push(element: T) {\n    let previousHash = this.hash;\n    this.hash = this.nextHash(previousHash, element);\n    this.data.updateAsProver((data) => [\n      toConstant(this.innerProvable, { previousHash, element }),\n      ...data,\n    ]);\n  }\n\n  /**\n   * Push a new element to the list, if the `condition` is true.\n   */\n  pushIf(condition: Bool, element: T) {\n    let previousHash = this.hash;\n\n    this.hash = Provable.if(condition, this.nextHash(previousHash, element), previousHash);\n    this.data.updateAsProver((data) =>\n      condition.toBoolean()\n        ? [toConstant(this.innerProvable, { previousHash, element }), ...data]\n        : data\n    );\n  }\n\n  private popWitness() {\n    return Provable.witness(WithHash(this.innerProvable), () => {\n      let [value, ...data] = this.data.get();\n      let head = value ?? {\n        previousHash: this.Constructor.emptyHash,\n        element: this.innerProvable.empty(),\n      };\n      this.data.set(data);\n      return head;\n    });\n  }\n\n  /**\n   * Remove the last element from the list and return it.\n   *\n   * This proves that the list is non-empty, and fails otherwise.\n   */\n  popExn(): T {\n    let { previousHash, element } = this.popWitness();\n\n    let currentHash = this.nextHash(previousHash, element);\n    this.hash.assertEquals(currentHash);\n\n    this.hash = previousHash;\n    return element;\n  }\n\n  /**\n   * Remove the last element from the list and return it.\n   *\n   * If the list is empty, returns a dummy element.\n   */\n  pop(): T {\n    let { previousHash, element } = this.popWitness();\n    let isEmpty = this.isEmpty();\n    let emptyHash = this.Constructor.emptyHash;\n\n    let currentHash = this.nextHash(previousHash, element);\n    currentHash = Provable.if(isEmpty, emptyHash, currentHash);\n    this.hash.assertEquals(currentHash);\n\n    this.hash = Provable.if(isEmpty, emptyHash, previousHash);\n    let provable = this.innerProvable;\n    return Provable.if(isEmpty, provable, provable.empty(), element);\n  }\n\n  /**\n   * Remove the last element from the list and return it as an option:\n   * Some(element) if the list is non-empty, None if the list is empty.\n   *\n   * **Warning**: If the list is empty, the the option's .value is entirely unconstrained.\n   */\n  popOption(): Option<T> {\n    let { previousHash, element } = this.popWitness();\n    let isEmpty = this.isEmpty();\n    let emptyHash = this.Constructor.emptyHash;\n\n    let currentHash = this.nextHash(previousHash, element);\n    currentHash = Provable.if(isEmpty, emptyHash, currentHash);\n    this.hash.assertEquals(currentHash);\n\n    this.hash = Provable.if(isEmpty, emptyHash, previousHash);\n    let provable = this.innerProvable;\n    const OptionT = Option(provable);\n    return new OptionT({ isSome: isEmpty.not(), value: element });\n  }\n\n  /**\n   * Return the last element, but only remove it if `condition` is true.\n   *\n   * If the list is empty, returns a dummy element.\n   */\n  popIf(condition: Bool) {\n    let originalHash = this.hash;\n    let element = this.pop();\n\n    // if the condition is false, we restore the original state\n    this.data.updateAsProver((data) => {\n      let node = { previousHash: this.hash, element };\n      return condition.toBoolean() ? data : [toConstant(this.innerProvable, node), ...data];\n    });\n    this.hash = Provable.if(condition, this.hash, originalHash);\n\n    return element;\n  }\n\n  /**\n   * Low-level, minimal version of `pop()` which lets the _caller_ decide whether there is an element to pop.\n   *\n   * I.e. this proves:\n   * - If the input condition is true, this returns the last element and removes it from the list.\n   * - If the input condition is false, the list is unchanged and the return value is garbage.\n   *\n   * Note that if the caller passes `true` but the list is empty, this will fail.\n   * If the caller passes `false` but the list is non-empty, this succeeds and just doesn't pop off an element.\n   */\n  popIfUnsafe(shouldPop: Bool) {\n    let { previousHash, element } = Provable.witness(WithHash(this.innerProvable), () => {\n      let dummy = {\n        previousHash: this.hash,\n        element: this.innerProvable.empty(),\n      };\n      if (!shouldPop.toBoolean()) return dummy;\n      let [value, ...data] = this.data.get();\n      this.data.set(data);\n      return value ?? dummy;\n    });\n\n    let nextHash = this.nextHash(previousHash, element);\n    let currentHash = Provable.if(shouldPop, nextHash, this.hash);\n    this.hash.assertEquals(currentHash);\n    this.hash = Provable.if(shouldPop, previousHash, this.hash);\n\n    return element;\n  }\n\n  clone(): MerkleList<T> {\n    let data = Unconstrained.witness(() => [...this.data.get()]);\n    return new this.Constructor({ hash: this.hash, data });\n  }\n\n  /**\n   * Iterate through the list in a fixed number of steps any apply a given callback on each element.\n   *\n   * Proves that the iteration traverses the entire list.\n   * Once past the last element, dummy elements will be passed to the callback.\n   *\n   * Note: There are no guarantees about the contents of dummy elements, so the callback is expected\n   * to handle the `isDummy` flag separately.\n   */\n  forEach(length: number, callback: (element: T, isDummy: Bool, i: number) => void) {\n    let iter = this.startIterating();\n    for (let i = 0; i < length; i++) {\n      let { element, isDummy } = iter.Unsafe.next();\n      callback(element, isDummy, i);\n    }\n    iter.assertAtEnd(`Expected MerkleList to have at most ${length} elements, but it has more.`);\n  }\n\n  startIterating(): MerkleListIterator<T> {\n    let merkleArray = MerkleListIterator.createFromList<T>(this.Constructor);\n    return merkleArray.startIterating(this);\n  }\n\n  startIteratingFromLast(): MerkleListIterator<T> {\n    let merkleArray = MerkleListIterator.createFromList<T>(this.Constructor);\n    return merkleArray.startIteratingFromLast(this);\n  }\n\n  toArrayUnconstrained(): Unconstrained<T[]> {\n    return Unconstrained.witness(() => [...this.data.get()].reverse().map((x) => x.element));\n  }\n\n  lengthUnconstrained(): Unconstrained<number> {\n    return Unconstrained.witness(() => this.data.get().length);\n  }\n\n  /**\n   * Create a Merkle list type\n   *\n   * Optionally, you can tell `create()` how to do the hash that pushes a new list element, by passing a `nextHash` function.\n   *\n   * @example\n   * ```ts\n   * class MyList extends MerkleList.create(Field, (hash, x) =>\n   *   Poseidon.hashWithPrefix('custom', [hash, x])\n   * ) {}\n   * ```\n   */\n  static create<T>(\n    type: WithProvable<ProvableHashable<T>>,\n    nextHash: (hash: Field, value: T) => Field = merkleListHash(ProvableType.get(type)),\n    emptyHash_ = emptyHash\n  ): typeof MerkleList<T> & {\n    // override static methods with strict types\n    empty: () => MerkleList<T>;\n    from: (array: T[]) => MerkleList<T>;\n    fromReverse: (array: T[]) => MerkleList<T>;\n    provable: ProvableHashable<MerkleList<T>>;\n  } {\n    let provable = ProvableType.get(type);\n\n    class MerkleListTBase extends MerkleList<T> {\n      static _innerProvable = provable;\n\n      static _provable = provableFromClass(MerkleListTBase, {\n        hash: Field,\n        data: Unconstrained,\n      }) satisfies ProvableHashable<MerkleList<T>> as ProvableHashable<MerkleList<T>>;\n\n      static _nextHash = nextHash;\n      static _emptyHash = emptyHash_;\n\n      static empty(): MerkleList<T> {\n        return new this({ hash: emptyHash_, data: Unconstrained.from([]) });\n      }\n\n      static from(array: T[]): MerkleList<T> {\n        array = [...array].reverse();\n        let { hash, data } = withHashes(array, nextHash, emptyHash_);\n        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant(provable, x)));\n        return new this({ data: unconstrained, hash });\n      }\n\n      static fromReverse(array: T[]): MerkleList<T> {\n        let { hash, data } = withHashes(array, nextHash, emptyHash_);\n        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant(provable, x)));\n        return new this({ data: unconstrained, hash });\n      }\n\n      static get provable(): ProvableHashable<MerkleList<T>> {\n        assert(this._provable !== undefined, 'MerkleList not initialized');\n        return this._provable;\n      }\n      static set provable(_provable: ProvableHashable<MerkleList<T>>) {\n        this._provable = _provable;\n      }\n    }\n    // override `instanceof` for subclasses\n    return class MerkleListT extends MerkleListTBase {\n      static [Symbol.hasInstance](x: any): boolean {\n        return x instanceof MerkleListTBase;\n      }\n    };\n  }\n\n  // dynamic subclassing infra\n  static _nextHash: ((hash: Field, t: any) => Field) | undefined;\n  static _emptyHash: Field | undefined;\n\n  static _provable: ProvableHashable<MerkleList<any>> | undefined;\n  static _innerProvable: ProvableHashable<any> | undefined;\n\n  get Constructor() {\n    return this.constructor as typeof MerkleList;\n  }\n\n  nextHash(hash: Field, value: T): Field {\n    assert(this.Constructor._nextHash !== undefined, 'MerkleList not initialized');\n    return this.Constructor._nextHash(hash, value);\n  }\n\n  static get emptyHash() {\n    assert(this._emptyHash !== undefined, 'MerkleList not initialized');\n    return this._emptyHash;\n  }\n\n  get innerProvable(): ProvableHashable<T> {\n    assert(this.Constructor._innerProvable !== undefined, 'MerkleList not initialized');\n    return this.Constructor._innerProvable;\n  }\n}\n\n// merkle list iterator\n\ntype MerkleListIteratorBase<T> = {\n  readonly hash: Field;\n  readonly data: Unconstrained<WithHash<T>[]>;\n\n  /**\n   * The merkle list hash of `[data[currentIndex], ..., data[length-1]]` (when hashing from right to left).\n   *\n   * For example:\n   * - If `currentIndex === 0`, then `currentHash === this.hash` is the hash of the entire array.\n   * - If `currentIndex === length`, then `currentHash === emptyHash` is the hash of an empty array.\n   */\n  currentHash: Field;\n  /**\n   * The index of the element that will be returned by the next call to `next()`.\n   */\n  currentIndex: Unconstrained<number>;\n};\n\n/**\n * MerkleListIterator helps iterating through a Merkle list.\n * This works similar to calling `list.pop()` or `list.push()` repeatedly, but maintaining the entire list instead of removing elements.\n *\n * The core methods that support iteration are {@link next()} and {@link previous()}.\n *\n * ```ts\n * let iterator = MerkleListIterator.startIterating(list);\n *\n * let firstElement = iterator.next();\n * ```\n *\n * We maintain two commitments:\n * - One to the entire array, to be able to prove that we end iteration at the correct point.\n * - One to the array from the current index until the end, to efficiently step forward.\n */\nclass MerkleListIterator<T> implements MerkleListIteratorBase<T> {\n  // fixed parts\n  readonly data: Unconstrained<WithHash<T>[]>;\n  readonly hash: Field;\n\n  // mutable parts\n  currentHash: Field;\n  currentIndex: Unconstrained<number>;\n\n  constructor(value: MerkleListIteratorBase<T>) {\n    Object.assign(this, value);\n  }\n\n  assertAtStart() {\n    return this.currentHash.assertEquals(this.Constructor.emptyHash);\n  }\n\n  isAtEnd() {\n    return this.currentHash.equals(this.hash);\n  }\n\n  jumpToEnd() {\n    this.currentIndex.setTo(Unconstrained.witness(() => 0));\n    this.currentHash = this.hash;\n  }\n\n  jumpToEndIf(condition: Bool) {\n    Provable.asProver(() => {\n      if (condition.toBoolean()) {\n        this.currentIndex.set(0);\n      }\n    });\n    this.currentHash = Provable.if(condition, this.hash, this.currentHash);\n  }\n\n  assertAtEnd(message?: string) {\n    return this.currentHash.assertEquals(\n      this.hash,\n      message ?? 'Merkle list iterator is not at the end'\n    );\n  }\n\n  isAtStart() {\n    return this.currentHash.equals(this.Constructor.emptyHash);\n  }\n\n  jumpToStart() {\n    this.currentIndex.setTo(Unconstrained.witness(() => this.data.get().length));\n    this.currentHash = this.Constructor.emptyHash;\n  }\n\n  jumpToStartIf(condition: Bool) {\n    Provable.asProver(() => {\n      if (condition.toBoolean()) {\n        this.currentIndex.set(this.data.get().length);\n      }\n    });\n    this.currentHash = Provable.if(condition, this.Constructor.emptyHash, this.currentHash);\n  }\n\n  _index(direction: 'next' | 'previous', i?: number) {\n    i ??= this.currentIndex.get();\n    if (direction === 'next') {\n      return Math.min(Math.max(i, -1), this.data.get().length - 1);\n    } else {\n      return Math.max(Math.min(i, this.data.get().length), 0);\n    }\n  }\n  _updateIndex(direction: 'next' | 'previous') {\n    this.currentIndex.updateAsProver(() => {\n      let i = this._index(direction);\n      return this._index(direction, direction === 'next' ? i - 1 : i + 1);\n    });\n  }\n\n  previous() {\n    // `previous()` corresponds to `pop()` in MerkleList\n    // it returns a dummy element if we're at the start of the array\n    let { previousHash, element } = Provable.witness(\n      WithHash(this.innerProvable),\n      () =>\n        this.data.get()[this._index('previous')] ?? {\n          previousHash: this.Constructor.emptyHash,\n          element: this.innerProvable.empty(),\n        }\n    );\n\n    let isDummy = this.isAtStart();\n    let emptyHash = this.Constructor.emptyHash;\n    let correctHash = this.nextHash(previousHash, element);\n    let requiredHash = Provable.if(isDummy, emptyHash, correctHash);\n\n    this.currentHash.assertEquals(requiredHash);\n\n    this._updateIndex('previous');\n\n    this.currentHash = Provable.if(isDummy, emptyHash, previousHash);\n\n    return Provable.if(isDummy, this.innerProvable, this.innerProvable.empty(), element);\n  }\n\n  next() {\n    // instead of starting from index `0`, we start at index `length - 1` and go in reverse\n    // this is like MerkleList.push() but we witness the next element instead of taking it as input,\n    // and we return a dummy element if we're at the end of the array\n    let element = Provable.witness(\n      this.innerProvable,\n      () => this.data.get()[this._index('next')]?.element ?? this.innerProvable.empty()\n    );\n\n    let isDummy = this.isAtEnd();\n    let currentHash = this.nextHash(this.currentHash, element);\n    this.currentHash = Provable.if(isDummy, this.hash, currentHash);\n    this._updateIndex('next');\n\n    return Provable.if(isDummy, this.innerProvable, this.innerProvable.empty(), element);\n  }\n\n  /**\n   * Low-level APIs for advanced uses\n   */\n  get Unsafe() {\n    let self = this;\n    return {\n      /**\n       * Version of {@link previous} which doesn't guarantee anything about\n       * the returned element in case the iterator is at the start.\n       *\n       * Instead, the `isDummy` flag is also returned so that this case can\n       * be handled in a custom way.\n       */\n      previous() {\n        let { previousHash, element } = Provable.witness(\n          WithHash(self.innerProvable),\n          () =>\n            self.data.get()[self._index('previous')] ?? {\n              previousHash: self.Constructor.emptyHash,\n              element: self.innerProvable.empty(),\n            }\n        );\n\n        let isDummy = self.isAtStart();\n        let emptyHash = self.Constructor.emptyHash;\n        let correctHash = self.nextHash(previousHash, element);\n        let requiredHash = Provable.if(isDummy, emptyHash, correctHash);\n\n        self.currentHash.assertEquals(requiredHash);\n\n        self._updateIndex('previous');\n        self.currentHash = Provable.if(isDummy, emptyHash, previousHash);\n        return { element, isDummy };\n      },\n\n      /**\n       * Version of {@link next} which doesn't guarantee anything about\n       * the returned element in case the iterator is at the end.\n       *\n       * Instead, the `isDummy` flag is also returned so that this case can\n       * be handled in a custom way.\n       */\n      next() {\n        let element = Provable.witness(self.innerProvable, () => {\n          return self.data.get()[self._index('next')]?.element ?? self.innerProvable.empty();\n        });\n\n        let isDummy = self.isAtEnd();\n        let currentHash = self.nextHash(self.currentHash, element);\n        self.currentHash = Provable.if(isDummy, self.hash, currentHash);\n        self._updateIndex('next');\n\n        return { element, isDummy };\n      },\n    };\n  }\n\n  clone(): MerkleListIterator<T> {\n    let data = Unconstrained.witness(() => [...this.data.get()]);\n    let currentIndex = Unconstrained.witness(() => this.currentIndex.get());\n    return new this.Constructor({\n      data,\n      hash: this.hash,\n      currentHash: this.currentHash,\n      currentIndex,\n    });\n  }\n\n  /**\n   * Create a Merkle array type\n   */\n  static create<T>(\n    type: WithProvable<ProvableHashable<T>>,\n    nextHash: (hash: Field, value: T) => Field = merkleListHash(ProvableType.get(type)),\n    emptyHash_ = emptyHash\n  ): typeof MerkleListIterator<T> & {\n    from: (array: T[]) => MerkleListIterator<T>;\n    startIterating: (list: MerkleListBase<T>) => MerkleListIterator<T>;\n    startIteratingFromLast: (list: MerkleListBase<T>) => MerkleListIterator<T>;\n    empty: () => MerkleListIterator<T>;\n    provable: ProvableHashable<MerkleListIterator<T>>;\n  } {\n    let provable = ProvableType.get(type);\n    return class Iterator extends MerkleListIterator<T> {\n      static _innerProvable = ProvableType.get(provable);\n\n      static _provable = provableFromClass(Iterator, {\n        hash: Field,\n        data: Unconstrained,\n        currentHash: Field,\n        currentIndex: Unconstrained,\n      }) satisfies ProvableHashable<MerkleListIterator<T>> as ProvableHashable<\n        MerkleListIterator<T>\n      >;\n\n      static _nextHash = nextHash;\n      static _emptyHash = emptyHash_;\n\n      static from(array: T[]): MerkleListIterator<T> {\n        let { hash, data } = withHashes(array, nextHash, emptyHash_);\n        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant(provable, x)));\n        return this.startIterating({ data: unconstrained, hash });\n      }\n\n      static fromLast(array: T[]): MerkleListIterator<T> {\n        array = [...array].reverse();\n        let { hash, data } = withHashes(array, nextHash, emptyHash_);\n        let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant(provable, x)));\n        return this.startIteratingFromLast({ data: unconstrained, hash });\n      }\n\n      static startIterating({ data, hash }: MerkleListBase<T>): MerkleListIterator<T> {\n        return new this({\n          data,\n          hash,\n          currentHash: emptyHash_,\n          // note: for an empty list or any list which is \"at the end\", the currentIndex is -1\n          currentIndex: Unconstrained.witness(() => data.get().length - 1),\n        });\n      }\n\n      static startIteratingFromLast({ data, hash }: MerkleListBase<T>): MerkleListIterator<T> {\n        return new this({\n          data,\n          hash,\n          currentHash: hash,\n          currentIndex: Unconstrained.from(0),\n        });\n      }\n\n      static empty(): MerkleListIterator<T> {\n        return this.from([]);\n      }\n\n      static get provable(): ProvableHashable<MerkleListIterator<T>> {\n        assert(this._provable !== undefined, 'MerkleListIterator not initialized');\n        return this._provable;\n      }\n    };\n  }\n\n  static createFromList<T>(merkleList: typeof MerkleList<T>) {\n    return this.create<T>(\n      merkleList.prototype.innerProvable,\n      merkleList._nextHash,\n      merkleList.emptyHash\n    );\n  }\n\n  // dynamic subclassing infra\n  static _nextHash: ((hash: Field, value: any) => Field) | undefined;\n  static _emptyHash: Field | undefined;\n\n  static _provable: ProvableHashable<MerkleListIterator<any>> | undefined;\n  static _innerProvable: ProvableHashable<any> | undefined;\n\n  get Constructor() {\n    return this.constructor as typeof MerkleListIterator;\n  }\n\n  nextHash(hash: Field, value: T): Field {\n    assert(this.Constructor._nextHash !== undefined, 'MerkleListIterator not initialized');\n    return this.Constructor._nextHash(hash, value);\n  }\n\n  static get emptyHash() {\n    assert(this._emptyHash !== undefined, 'MerkleList not initialized');\n    return this._emptyHash;\n  }\n\n  get innerProvable(): ProvableHashable<T> {\n    assert(this.Constructor._innerProvable !== undefined, 'MerkleListIterator not initialized');\n    return this.Constructor._innerProvable;\n  }\n}\n\n// hash helpers\n\nfunction genericHash<T>(provable: ProvableHashable<T>, prefix: string, value: T) {\n  let input = provable.toInput(value);\n  let packed = packToFields(input);\n  return Poseidon.hashWithPrefix(prefix, packed);\n}\n\nfunction merkleListHash<T>(provable: ProvableHashable<T>, prefix = '') {\n  return function nextHash(hash: Field, value: T) {\n    let input = provable.toInput(value);\n    let packed = packToFields(input);\n    return Poseidon.hashWithPrefix(prefix, [hash, ...packed]);\n  };\n}\n\nfunction withHashes<T>(\n  data: T[],\n  nextHash: (hash: Field, value: T) => Field,\n  emptyHash: Field\n): { data: WithHash<T>[]; hash: Field } {\n  let n = data.length;\n  let arrayWithHashes = Array<WithHash<T>>(n);\n  let currentHash = emptyHash;\n\n  for (let i = n - 1; i >= 0; i--) {\n    arrayWithHashes[i] = { previousHash: currentHash, element: data[i] };\n    currentHash = nextHash(currentHash, data[i]);\n  }\n\n  return { data: arrayWithHashes, hash: currentHash };\n}\n", "/**\n * This file contains all code related to the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) implementation available in o1js.\n */\n\nimport { CircuitValue, arrayProp } from './types/circuit-value.js';\nimport { Poseidon } from './crypto/poseidon.js';\nimport { Bool, Field } from './wrapped.js';\nimport { Provable } from './provable.js';\n\n// external API\nexport { Witness, MerkleTree, MerkleWitness, BaseMerkleWitness };\n\n// internal API\nexport { conditionalSwap };\n\ntype Witness = { isLeft: boolean; sibling: Field }[];\n\n/**\n * A [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) is a binary tree in which every leaf is the cryptography hash of a piece of data,\n * and every node is the hash of the concatenation of its two child nodes.\n *\n * A Merkle Tree allows developers to easily and securely verify the integrity of large amounts of data.\n *\n * Take a look at our [documentation](https://docs.minaprotocol.com/en/zkapps) on how to use Merkle Trees in combination with zkApps and zero knowledge programming!\n *\n * Levels are indexed from leaves (level 0) to root (level N - 1).\n */\nclass MerkleTree {\n  nodes: Record<number, Record<string, Field>> = {};\n  zeroes: Field[];\n\n  /**\n   * Creates a new, empty [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).\n   * @param height The height of Merkle Tree.\n   * @returns A new MerkleTree\n   */\n  constructor(public readonly height: number) {\n    this.zeroes = new Array(height);\n    this.zeroes[0] = Field(0);\n    for (let i = 1; i < height; i += 1) {\n      this.zeroes[i] = Poseidon.hash([this.zeroes[i - 1], this.zeroes[i - 1]]);\n    }\n  }\n\n  /**\n   * Return a new MerkleTree with the same contents as this one.\n   */\n  clone() {\n    let newTree = new MerkleTree(this.height);\n    for (let [level, nodes] of Object.entries(this.nodes)) {\n      newTree.nodes[level as any as number] = { ...nodes };\n    }\n    return newTree;\n  }\n\n  /**\n   * Returns a node which lives at a given index and level.\n   * @param level Level of the node.\n   * @param index Index of the node.\n   * @returns The data of the node.\n   */\n  getNode(level: number, index: bigint): Field {\n    return this.nodes[level]?.[index.toString()] ?? this.zeroes[level];\n  }\n\n  /**\n   * Returns a leaf at a given index.\n   * @param index Index of the leaf.\n   * @returns The data of the leaf.\n   */\n  getLeaf(index: bigint) {\n    return this.getNode(0, index);\n  }\n\n  /**\n   * Returns the root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).\n   * @returns The root of the Merkle Tree.\n   */\n  getRoot(): Field {\n    return this.getNode(this.height - 1, 0n);\n  }\n\n  // TODO: this allows to set a node at an index larger than the size. OK?\n  private setNode(level: number, index: bigint, value: Field) {\n    (this.nodes[level] ??= {})[index.toString()] = value;\n  }\n\n  // TODO: if this is passed an index bigger than the max, it will set a couple of out-of-bounds nodes but not affect the real Merkle root. OK?\n  /**\n   * Sets the value of a leaf node at a given index to a given value.\n   * @param index Position of the leaf node.\n   * @param leaf New value.\n   */\n  setLeaf(index: bigint, leaf: Field) {\n    if (index >= this.leafCount) {\n      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);\n    }\n    this.setNode(0, index, leaf);\n    let currIndex = index;\n    for (let level = 1; level < this.height; level++) {\n      currIndex /= 2n;\n\n      const left = this.getNode(level - 1, currIndex * 2n);\n      const right = this.getNode(level - 1, currIndex * 2n + 1n);\n\n      this.setNode(level, currIndex, Poseidon.hash([left, right]));\n    }\n  }\n\n  /**\n   * Returns the witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the leaf at the given index.\n   * @param index Position of the leaf node.\n   * @returns The witness that belongs to the leaf.\n   */\n  getWitness(index: bigint): Witness {\n    if (index >= this.leafCount) {\n      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);\n    }\n    const witness = [];\n    for (let level = 0; level < this.height - 1; level++) {\n      const isLeft = index % 2n === 0n;\n      const sibling = this.getNode(level, isLeft ? index + 1n : index - 1n);\n      witness.push({ isLeft, sibling });\n      index /= 2n;\n    }\n    return witness;\n  }\n\n  // TODO: this will always return true if the merkle tree was constructed normally; seems to be only useful for testing. remove?\n  /**\n   * Checks if the witness that belongs to the leaf at the given index is a valid witness.\n   * @param index Position of the leaf node.\n   * @returns True if the witness for the leaf node is valid.\n   */\n  validate(index: bigint): boolean {\n    const path = this.getWitness(index);\n    let hash = this.getNode(0, index);\n    for (const node of path) {\n      hash = Poseidon.hash(node.isLeft ? [hash, node.sibling] : [node.sibling, hash]);\n    }\n\n    return hash.toString() === this.getRoot().toString();\n  }\n\n  // TODO: should this take an optional offset? should it fail if the array is too long?\n  /**\n   * Fills all leaves of the tree.\n   * @param leaves Values to fill the leaves with.\n   */\n  fill(leaves: Field[]) {\n    leaves.forEach((value, index) => {\n      this.setLeaf(BigInt(index), value);\n    });\n  }\n\n  /**\n   * Returns the amount of leaf nodes.\n   * @returns Amount of leaf nodes.\n   */\n  get leafCount(): bigint {\n    return 2n ** BigInt(this.height - 1);\n  }\n}\n\n/**\n * The {@link BaseMerkleWitness} class defines a circuit-compatible base class for [Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof).\n */\nclass BaseMerkleWitness extends CircuitValue {\n  static height: number;\n  path: Field[];\n  isLeft: Bool[];\n  height(): number {\n    return (this.constructor as any).height;\n  }\n\n  /**\n   * Takes a {@link Witness} and turns it into a circuit-compatible Witness.\n   * @param witness Witness.\n   * @returns A circuit-compatible Witness.\n   */\n  constructor(witness: Witness) {\n    super();\n    let height = witness.length + 1;\n    if (height !== this.height()) {\n      throw Error(\n        `Length of witness ${height}-1 doesn't match static tree height ${this.height()}.`\n      );\n    }\n    this.path = witness.map((item) => item.sibling);\n    this.isLeft = witness.map((item) => Bool(item.isLeft));\n  }\n\n  /**\n   * Calculates a root depending on the leaf value.\n   * @param leaf Value of the leaf node that belongs to this Witness.\n   * @returns The calculated root.\n   */\n  calculateRoot(leaf: Field): Field {\n    let hash = leaf;\n    let n = this.height();\n\n    for (let i = 1; i < n; ++i) {\n      let isLeft = this.isLeft[i - 1];\n      const [left, right] = conditionalSwap(isLeft, hash, this.path[i - 1]);\n      hash = Poseidon.hash([left, right]);\n    }\n\n    return hash;\n  }\n\n  /**\n   * Calculates the index of the leaf node that belongs to this Witness.\n   * @returns Index of the leaf.\n   */\n  calculateIndex(): Field {\n    let powerOfTwo = Field(1);\n    let index = Field(0);\n    let n = this.height();\n\n    for (let i = 1; i < n; ++i) {\n      index = Provable.if(this.isLeft[i - 1], index, index.add(powerOfTwo));\n      powerOfTwo = powerOfTwo.mul(2);\n    }\n\n    return index;\n  }\n}\n\n/**\n * Returns a circuit-compatible Witness for a specific Tree height.\n * @param height Height of the Merkle Tree that this Witness belongs to.\n * @returns A circuit-compatible Merkle Witness.\n */\nfunction MerkleWitness(height: number): typeof BaseMerkleWitness {\n  class MerkleWitness_ extends BaseMerkleWitness {\n    static height = height;\n  }\n  arrayProp(Field, height - 1)(MerkleWitness_.prototype, 'path');\n  arrayProp(Bool, height - 1)(MerkleWitness_.prototype, 'isLeft');\n  return MerkleWitness_;\n}\n\n// swap two values if the boolean is false, otherwise keep them as they are\n// more efficient than 2x `Provable.if()` by reusing an intermediate variable\nfunction conditionalSwap(b: Bool, x: Field, y: Field): [Field, Field] {\n  let m = b.toField().mul(x.sub(y)); // b*(x - y)\n  const x_ = y.add(m); // y + b*(x - y)\n  const y_ = x.sub(m); // x - b*(x - y) = x + b*(y - x)\n  return [x_, y_];\n}\n", "import { Poseidon as PoseidonBigint } from '../../bindings/crypto/poseidon.js';\nimport { Bool, Field } from './wrapped.js';\nimport { Option } from './option.js';\nimport { Struct } from './types/struct.js';\nimport { From, InferValue } from '../../bindings/lib/provable-generic.js';\nimport { assert } from './gadgets/common.js';\nimport { Unconstrained } from './types/unconstrained.js';\nimport { Provable } from './provable.js';\nimport { Poseidon } from './crypto/poseidon.js';\nimport { conditionalSwap } from './merkle-tree.js';\nimport { provableFromClass } from './types/provable-derivers.js';\n\n// external API\nexport { IndexedMerkleMap, IndexedMerkleMapBase };\n\n// internal API\nexport { Leaf };\n\n/**\n * Class factory for an Indexed Merkle Map with a given height.\n *\n * ```ts\n * class MerkleMap extends IndexedMerkleMap(33) {}\n *\n * let map = new MerkleMap();\n *\n * map.insert(2n, 14n);\n * map.insert(1n, 13n);\n *\n * let x = map.get(2n); // 14\n * ```\n *\n * Indexed Merkle maps can be used directly in provable code:\n *\n * ```ts\n * ZkProgram({\n *   methods: {\n *     test: {\n *       privateInputs: [MerkleMap, Field],\n *\n *       method(map: MerkleMap, key: Field) {\n *         // get the value associated with `key`\n *         let value = map.getOption(key).orElse(0n);\n *\n *         // increment the value by 1\n *         map.set(key, value.add(1));\n *       }\n *     }\n *   }\n * })\n * ```\n *\n * Initially, every `IndexedMerkleMap` is populated by a single key-value pair: `(0, 0)`. The value for key `0` can be updated like any other.\n * When keys and values are hash outputs, `(0, 0)` can serve as a convenient way to represent a dummy update to the tree, since 0 is not\n * efficiently computable as a hash image, and this update doesn't affect the Merkle root.\n */\nfunction IndexedMerkleMap(height: number): typeof IndexedMerkleMapBase {\n  assert(height > 0, 'height must be positive');\n  assert(\n    height < 53,\n    'height must be less than 53, so that we can use 64-bit floats to represent indices.'\n  );\n\n  return class IndexedMerkleMap extends IndexedMerkleMapBase {\n    get height() {\n      return height;\n    }\n\n    static provable = provableFromClass(IndexedMerkleMap, provableBase);\n  };\n}\n\nconst provableBase = {\n  _internalRoot: Field,\n  length: Field,\n  data: Unconstrained.withEmpty({\n    nodes: [] as (bigint | undefined)[][],\n    sortedLeaves: [] as StoredLeaf[],\n  }),\n};\n\nclass IndexedMerkleMapBase {\n  // data defining the provable interface of a tree\n  _internalRoot: Field;\n  length: Field; // length of the leaves array\n\n  // static data defining constraints\n  get height(): number {\n    throw Error('Height must be defined in a subclass');\n  }\n\n  // the raw data stored in the tree\n  readonly data: Unconstrained<{\n    // for every level, an array of hashes\n    readonly nodes: (bigint | undefined)[][];\n\n    // leaves sorted by key, with a linked list encoded by nextKey\n    // we always have\n    // sortedLeaves[0].key = 0\n    // sortedLeaves[n-1].nextKey = Field.ORDER - 1\n    // for i=0,...n-2, sortedLeaves[i].nextKey = sortedLeaves[i+1].key\n    readonly sortedLeaves: StoredLeaf[];\n  }>;\n\n  /**\n   * Public getter for the root(commitment) that combines the internal root of the indexed merkle tree and length.\n   * This provides protection against a attack vector mentioned in https://github.com/o1-labs/o1js/pull/2114#issuecomment-2948339955\n   */\n  get root(): Field {\n    return Poseidon.hash([this._internalRoot, this.length]);\n  }\n\n  // we'd like to do `abstract static provable` here but that's not supported\n  static provable: Provable<IndexedMerkleMapBase, InferValue<typeof provableBase>> =\n    undefined as any;\n\n  /**\n   * Creates a new, empty Indexed Merkle Map.\n   */\n  constructor() {\n    let height = this.height;\n\n    let nodes: (bigint | undefined)[][] = Array(height);\n    for (let level = 0; level < height; level++) {\n      nodes[level] = [];\n    }\n\n    let firstLeaf = IndexedMerkleMapBase._firstLeaf;\n    let firstNode = Leaf.hashNode(firstLeaf).toBigInt();\n    let root = Nodes.setLeaf(nodes, 0, firstNode);\n    this._internalRoot = Field(root);\n    this.length = Field(1);\n\n    this.data = Unconstrained.from({ nodes, sortedLeaves: [firstLeaf] });\n  }\n\n  static _firstLeaf = {\n    key: 0n,\n    value: 0n,\n    // the 0 key encodes the minimum and maximum at the same time\n    // so, if a second node is inserted, it will get `nextKey = 0`, and thus point to the first node\n    nextKey: 0n,\n    index: 0,\n  };\n\n  /**\n   * Clone the entire Merkle map.\n   *\n   * This method is provable.\n   */\n  clone() {\n    let cloned = new (this.constructor as typeof IndexedMerkleMapBase)();\n    cloned._internalRoot = this._internalRoot;\n    cloned.length = this.length;\n    cloned.data.updateAsProver(() => {\n      let { nodes, sortedLeaves } = this.data.get();\n      return {\n        nodes: nodes.map((row) => [...row]),\n        sortedLeaves: [...sortedLeaves],\n      };\n    });\n    return cloned;\n  }\n\n  /**\n   * Overwrite the entire Merkle map with another one.\n   *\n   * This method is provable.\n   */\n  overwrite(other: IndexedMerkleMapBase) {\n    this.overwriteIf(true, other);\n  }\n\n  /**\n   * Overwrite the entire Merkle map with another one, if the condition is true.\n   *\n   * This method is provable.\n   */\n  overwriteIf(condition: Bool | boolean, other: IndexedMerkleMapBase) {\n    condition = Bool(condition);\n\n    this._internalRoot = Provable.if(condition, other._internalRoot, this._internalRoot);\n    this.length = Provable.if(condition, other.length, this.length);\n    this.data.updateAsProver(() =>\n      Bool(condition).toBoolean() ? other.clone().data.get() : this.data.get()\n    );\n  }\n\n  /**\n   * Insert a new leaf `(key, value)`.\n   *\n   * Proves that `key` doesn't exist yet.\n   */\n  insert(key: Field | bigint, value: Field | bigint) {\n    key = Field(key);\n    value = Field(value);\n\n    // check that we can insert a new leaf, by asserting the length fits in the tree\n    let index = this.length;\n    let indexBits = index.toBits(this.height - 1);\n\n    // prove that the key doesn't exist yet by presenting a valid low node\n    let low = Provable.witness(Leaf, () => this._findLeaf(key).low);\n    let lowPath = this._proveInclusion(low, 'Invalid low node (root)');\n    // if the key does exist, we have lowNode.nextKey == key, and this line fails\n    assertStrictlyBetween(low.key, key, low.nextKey, 'Key already exists in the tree');\n\n    // at this point, we know that we have a valid insertion; so we can mutate internal data\n\n    // update low node\n    let newLow = { ...low, nextKey: key };\n    this._internalRoot = this._proveUpdate(newLow, lowPath);\n    this._setLeafUnconstrained(true, newLow);\n\n    // create new leaf to append\n    let leaf = Leaf.nextAfter(newLow, index, {\n      key,\n      value,\n      nextKey: low.nextKey,\n    });\n\n    // prove empty slot in the tree, and insert our leaf\n    let path = this._proveEmpty(indexBits);\n    this._internalRoot = this._proveUpdate(leaf, path);\n    this.length = this.length.add(1);\n    this._setLeafUnconstrained(false, leaf);\n  }\n\n  /**\n   * Update an existing leaf `(key, value)`.\n   *\n   * Proves that the `key` exists.\n   *\n   * Returns the previous value.\n   */\n  update(key: Field | bigint, value: Field | bigint): Field {\n    key = Field(key);\n    value = Field(value);\n\n    // prove that the key exists by presenting a leaf that contains it\n    let self = Provable.witness(Leaf, () => this._findLeaf(key).self);\n    let path = this._proveInclusion(self, 'Key does not exist in the tree');\n    self.key.assertEquals(key, 'Invalid leaf (key)');\n\n    // at this point, we know that we have a valid update; so we can mutate internal data\n\n    // update leaf\n    let newSelf = { ...self, value };\n    this._internalRoot = this._proveUpdate(newSelf, path);\n    this._setLeafUnconstrained(true, newSelf);\n\n    return self.value;\n  }\n\n  /**\n   * Perform _either_ an insertion or update, depending on whether the key exists.\n   *\n   * Note: This method is handling both the `insert()` and `update()` case at the same time, so you\n   * can use it if you don't know whether the key exists or not.\n   *\n   * However, this comes at an efficiency cost, so prefer to use `insert()` or `update()` if you know whether the key exists.\n   *\n   * Returns the previous value, as an option (which is `None` if the key didn't exist before).\n   */\n  set(key: Field | bigint, value: Field | bigint): Option<Field, bigint> {\n    key = Field(key);\n    value = Field(value);\n\n    // prove whether the key exists or not, by showing a valid low node\n    let { low, self } = Provable.witness(LeafPair, () => this._findLeaf(key));\n    let lowPath = this._proveInclusion(low, 'Invalid low node (root)');\n    assertBetween(low.key, key, low.nextKey, 'Invalid low node (key)');\n\n    // the key exists iff lowNode.nextKey == key\n    let keyExists = low.nextKey.equals(key);\n\n    // the leaf's index depends on whether it exists\n    let index = Provable.witness(Field, () => self.index.get());\n    index = Provable.if(keyExists, index, this.length);\n    let indexBits = index.toBits(this.height - 1);\n\n    // at this point, we know that we have a valid update or insertion; so we can mutate internal data\n\n    // update low node, or leave it as is\n    let newLow = { ...low, nextKey: key };\n    this._internalRoot = this._proveUpdate(newLow, lowPath);\n    this._setLeafUnconstrained(true, newLow);\n\n    // prove inclusion of this leaf if it exists\n    let path = this._proveInclusionOrEmpty(keyExists, indexBits, self, 'Invalid leaf (root)');\n    assert(keyExists.implies(self.key.equals(key)), 'Invalid leaf (key)');\n\n    // update leaf, or append a new one\n    let newLeaf = Leaf.nextAfter(newLow, index, {\n      key,\n      value,\n      nextKey: Provable.if(keyExists, self.nextKey, low.nextKey),\n    });\n    this._internalRoot = this._proveUpdate(newLeaf, path);\n    this.length = Provable.if(keyExists, this.length, this.length.add(1));\n    this._setLeafUnconstrained(keyExists, newLeaf);\n\n    // return the previous value\n    return new OptionField({ isSome: keyExists, value: self.value });\n  }\n\n  /**\n   * Perform an insertion or update, if the enabling condition is true.\n   *\n   * If the condition is false, we instead set the 0 key to the value 0.\n   * This is the initial value and for typical uses of `IndexedMerkleMap`, it is guaranteed to be a no-op because the 0 key is never used.\n   *\n   * **Warning**: Only use this method if you are sure that the 0 key is not used in your application.\n   * Otherwise, you might accidentally overwrite a valid key-value pair.\n   */\n  setIf(condition: Bool | boolean, key: Field | bigint, value: Field | bigint) {\n    return this.set(\n      Provable.if(Bool(condition), Field(key), Field(0n)),\n      Provable.if(Bool(condition), Field(value), Field(0n))\n    );\n  }\n\n  /**\n   * Get a value from a key.\n   *\n   * Proves that the key already exists in the map yet and fails otherwise.\n   */\n  get(key: Field | bigint): Field {\n    key = Field(key);\n\n    // prove that the key exists by presenting a leaf that contains it\n    let self = Provable.witness(Leaf, () => this._findLeaf(key).self);\n    this._proveInclusion(self, 'Key does not exist in the tree');\n    self.key.assertEquals(key, 'Invalid leaf (key)');\n\n    return self.value;\n  }\n\n  /**\n   * Get a value from a key.\n   *\n   * Returns an option which is `None` if the key doesn't exist. (In that case, the option's value is unconstrained.)\n   *\n   * Note that this is more flexible than `get()` and allows you to handle the case where the key doesn't exist.\n   * However, it uses about twice as many constraints for that reason.\n   */\n  getOption(key: Field | bigint): Option<Field, bigint> {\n    key = Field(key);\n\n    // prove whether the key exists or not, by showing a valid low node\n    let { low, self } = Provable.witness(LeafPair, () => this._findLeaf(key));\n    this._proveInclusion(low, 'Invalid low node (root)');\n    assertBetween(low.key, key, low.nextKey, 'Invalid low node (key)');\n\n    // the key exists iff lowNode.nextKey == key\n    let keyExists = low.nextKey.equals(key);\n\n    // prove inclusion of this leaf if it exists\n    this._proveInclusionIf(keyExists, self, 'Invalid leaf (root)');\n    assert(keyExists.implies(self.key.equals(key)), 'Invalid leaf (key)');\n\n    return new OptionField({ isSome: keyExists, value: self.value });\n  }\n\n  // methods to check for inclusion for a key without being concerned about the value\n\n  /**\n   * Prove that the given key exists in the map.\n   */\n  assertIncluded(key: Field | bigint, message?: string) {\n    key = Field(key);\n\n    // prove that the key exists by presenting a leaf that contains it\n    let self = Provable.witness(Leaf, () => this._findLeaf(key).self);\n    this._proveInclusion(self, message ?? 'Key does not exist in the tree');\n    self.key.assertEquals(key, 'Invalid leaf (key)');\n  }\n\n  /**\n   * Prove that the given key does not exist in the map.\n   */\n  assertNotIncluded(key: Field | bigint, message?: string) {\n    key = Field(key);\n\n    // prove that the key does not exist yet, by showing a valid low node\n    let low = Provable.witness(Leaf, () => this._findLeaf(key).low);\n    this._proveInclusion(low, 'Invalid low node (root)');\n    assertStrictlyBetween(low.key, key, low.nextKey, message ?? 'Key already exists in the tree');\n  }\n\n  /**\n   * Check whether the given key exists in the map.\n   */\n  isIncluded(key: Field | bigint): Bool {\n    key = Field(key);\n\n    // prove that the key does not exist yet, by showing a valid low node\n    let low = Provable.witness(Leaf, () => this._findLeaf(key).low);\n    this._proveInclusion(low, 'Invalid low node (root)');\n    assertBetween(low.key, key, low.nextKey, 'Invalid low node (key)');\n\n    return low.nextKey.equals(key);\n  }\n\n  // helper methods\n\n  /**\n   * Helper method to prove inclusion of a leaf in the tree.\n   */\n  _proveInclusion(leaf: Leaf, message?: string) {\n    let node = Leaf.hashNode(leaf);\n    // here, we don't care at which index the leaf is included, so we pass it in as unconstrained\n    let { root, path } = this._computeRoot(node, leaf.index);\n    root.assertEquals(this._internalRoot, message ?? 'Leaf is not included in the tree');\n\n    return path;\n  }\n\n  /**\n   * Helper method to conditionally prove inclusion of a leaf in the tree.\n   */\n  _proveInclusionIf(condition: Bool, leaf: Leaf, message?: string) {\n    let node = Leaf.hashNode(leaf);\n    // here, we don't care at which index the leaf is included, so we pass it in as unconstrained\n    let { root } = this._computeRoot(node, leaf.index);\n    assert(\n      condition.implies(root.equals(this._internalRoot)),\n      message ?? 'Leaf is not included in the tree'\n    );\n  }\n\n  /**\n   * Helper method to prove inclusion of an empty leaf in the tree.\n   *\n   * This validates the path against the current root, so that we can use it to insert a new leaf.\n   */\n  _proveEmpty(index: Bool[]) {\n    let node = Field(0n);\n    let { root, path } = this._computeRoot(node, index);\n    root.assertEquals(this._internalRoot, 'Leaf is not empty');\n\n    return path;\n  }\n\n  /**\n   * Helper method to conditionally prove inclusion of a leaf in the tree.\n   *\n   * If the condition is false, we prove that the tree contains an empty leaf instead.\n   */\n  _proveInclusionOrEmpty(condition: Bool, index: Bool[], leaf: BaseLeaf, message?: string) {\n    let node = Provable.if(condition, Leaf.hashNode(leaf), Field(0n));\n    let { root, path } = this._computeRoot(node, index);\n    root.assertEquals(this._internalRoot, message ?? 'Leaf is not included in the tree');\n\n    return path;\n  }\n\n  /**\n   * Helper method to update the root against a previously validated path.\n   *\n   * Returns the new root.\n   */\n  _proveUpdate(leaf: BaseLeaf, path: { index: Bool[]; witness: Field[] }) {\n    let node = Leaf.hashNode(leaf);\n    let { root } = this._computeRoot(node, path.index, path.witness);\n    return root;\n  }\n\n  /**\n   * Helper method to compute the root given a leaf node and its index.\n   *\n   * The index can be given as a `Field` or as an array of bits.\n   */\n  _computeRoot(node: Field, index: Unconstrained<number> | Bool[], witness?: Field[]) {\n    // if the index was passed in as unconstrained, we witness its bits here\n    let indexBits =\n      index instanceof Unconstrained\n        ? Provable.witness(Provable.Array(Bool, this.height - 1), () =>\n            Field(index.get()).toBits(this.height - 1)\n          )\n        : index;\n\n    // if the witness was not passed in, we create it here\n    let witness_ =\n      witness ??\n      Provable.witnessFields(this.height - 1, () => {\n        let witness: bigint[] = [];\n        let index = Number(Field.fromBits(indexBits));\n        let { nodes } = this.data.get();\n\n        for (let level = 0; level < this.height - 1; level++) {\n          let i = index % 2 === 0 ? index + 1 : index - 1;\n          let sibling = Nodes.getNode(nodes, level, i, false);\n          witness.push(sibling);\n          index >>= 1;\n        }\n\n        return witness;\n      });\n\n    assert(indexBits.length === this.height - 1, 'Invalid index size');\n    assert(witness_.length === this.height - 1, 'Invalid witness size');\n\n    for (let level = 0; level < this.height - 1; level++) {\n      let isRight = indexBits[level];\n      let sibling = witness_[level];\n\n      let [right, left] = conditionalSwap(isRight, node, sibling);\n      node = Poseidon.hash([left, right]);\n    }\n    // now, `node` is the root of the tree\n    return { root: node, path: { witness: witness_, index: indexBits } };\n  }\n\n  /**\n   * Given a key, returns both the low node and the leaf that contains the key.\n   *\n   * If the key does not exist, a dummy value is returned for the leaf.\n   *\n   * Can only be called outside provable code.\n   */\n  _findLeaf(key_: Field | bigint): InferValue<typeof LeafPair> {\n    let key = typeof key_ === 'bigint' ? key_ : key_.toBigInt();\n    assert(key >= 0n, 'key must be positive');\n    let leaves = this.data.get().sortedLeaves;\n\n    // this case is typically invalid, but we want to handle it gracefully here\n    // and reject it using comparison constraints\n    if (key === 0n)\n      return {\n        low: Leaf.fromStored(leaves[leaves.length - 1], leaves.length - 1),\n        self: Leaf.fromStored(leaves[0], 0),\n      };\n\n    let { lowIndex, foundValue } = bisectUnique(key, (i) => leaves[i].key, leaves.length);\n    let iLow = foundValue ? lowIndex - 1 : lowIndex;\n    let low = Leaf.fromStored(leaves[iLow], iLow);\n\n    let iSelf = foundValue ? lowIndex : 0;\n    let selfBase = foundValue ? leaves[lowIndex] : Leaf.toStored(Leaf.empty());\n    let self = Leaf.fromStored(selfBase, iSelf);\n    return { low, self };\n  }\n\n  /**\n   * Update or append a leaf in our internal data structures\n   */\n  _setLeafUnconstrained(leafExists: Bool | boolean, leaf: Leaf) {\n    Provable.asProver(() => {\n      let { nodes, sortedLeaves } = this.data.get();\n\n      // update internal hash nodes\n      let i = leaf.index.get();\n      Nodes.setLeaf(nodes, i, Leaf.hashNode(leaf).toBigInt());\n\n      // update sorted list\n      let leafValue = Leaf.toStored(leaf);\n      let iSorted = leaf.sortedIndex.get();\n\n      if (Bool(leafExists).toBoolean()) {\n        // for key=0, the sorted index overflows the length because we compute it as low.sortedIndex + 1\n        // in that case, it should wrap back to 0\n        sortedLeaves[iSorted % sortedLeaves.length] = leafValue;\n      } else {\n        sortedLeaves.splice(iSorted, 0, leafValue);\n      }\n    });\n  }\n}\n\n// helpers for updating nodes\n\ntype Nodes = (bigint | undefined)[][];\nnamespace Nodes {\n  /**\n   * Sets the leaf node at the given index, updates all parent nodes and returns the new root.\n   */\n  export function setLeaf(nodes: Nodes, index: number, leaf: bigint) {\n    nodes[0][index] = leaf;\n    let height = nodes.length;\n\n    for (let level = 0; level < height - 1; level++) {\n      let isLeft = index % 2 === 0;\n      index = Math.floor(index / 2);\n\n      let left = getNode(nodes, level, index * 2, isLeft);\n      let right = getNode(nodes, level, index * 2 + 1, !isLeft);\n      nodes[level + 1][index] = PoseidonBigint.hash([left, right]);\n    }\n    return getNode(nodes, height - 1, 0, true);\n  }\n\n  export function getNode(\n    nodes: Nodes,\n    level: number,\n    index: number,\n    // whether the node is required to be non-empty\n    nonEmpty: boolean\n  ) {\n    let node = nodes[level]?.[index];\n    if (node === undefined) {\n      if (nonEmpty)\n        throw Error(`node at level=${level}, index=${index} was expected to be known, but isn't.`);\n      node = empty(level);\n    }\n    return node;\n  }\n\n  // cache of empty nodes (=: zero leaves and nodes with only empty nodes below them)\n  const emptyNodes = [0n];\n\n  export function empty(level: number) {\n    for (let i = emptyNodes.length; i <= level; i++) {\n      let zero = emptyNodes[i - 1];\n      emptyNodes[i] = PoseidonBigint.hash([zero, zero]);\n    }\n    return emptyNodes[level];\n  }\n}\n\n// leaf\n\nclass BaseLeaf extends Struct({\n  key: Field,\n  value: Field,\n  nextKey: Field,\n}) {}\n\nclass Leaf extends Struct({\n  value: Field,\n  key: Field,\n  nextKey: Field,\n\n  // auxiliary data that tells us where the leaf is stored\n  index: Unconstrained.withEmpty(0),\n  sortedIndex: Unconstrained.withEmpty(0),\n}) {\n  /**\n   * Compute a leaf node: the hash of a leaf that becomes part of the Merkle tree.\n   */\n  static hashNode(leaf: From<typeof BaseLeaf>) {\n    // note: we don't have to include the index in the leaf hash,\n    // because computing the root already commits to the index\n    return Poseidon.hashPacked(BaseLeaf, BaseLeaf.fromValue(leaf));\n  }\n\n  /**\n   * Create a new leaf, given its low node and index.\n   */\n  static nextAfter(low: Leaf, index: Field, leaf: BaseLeaf): Leaf {\n    return {\n      key: leaf.key,\n      value: leaf.value,\n      nextKey: leaf.nextKey,\n      index: Unconstrained.witness(() => Number(index)),\n      sortedIndex: Unconstrained.witness(() => low.sortedIndex.get() + 1),\n    };\n  }\n\n  // convert to/from internally stored format\n\n  static toStored(leaf: Leaf): StoredLeaf {\n    return {\n      key: leaf.key.toBigInt(),\n      value: leaf.value.toBigInt(),\n      nextKey: leaf.nextKey.toBigInt(),\n      index: leaf.index.get(),\n    };\n  }\n\n  static fromStored(leaf: StoredLeaf, sortedIndex: number) {\n    return { ...leaf, sortedIndex };\n  }\n}\n\ntype StoredLeaf = {\n  readonly value: bigint;\n  readonly key: bigint;\n  readonly nextKey: bigint;\n  readonly index: number;\n};\n\nclass LeafPair extends Struct({ low: Leaf, self: Leaf }) {}\n\nclass OptionField extends Option(Field) {}\n\n// helper\n\n/**\n * Bisect indices in an array of unique values that is sorted in ascending order.\n *\n * `getValue()` returns the value at the given index.\n *\n * We return\n * - `lowIndex := max { i in [0, length) | getValue(i) <= target }`\n * - `foundValue` := whether `getValue(lowIndex) == target`\n */\nfunction bisectUnique(\n  target: bigint,\n  getValue: (index: number) => bigint,\n  length: number\n): {\n  lowIndex: number;\n  foundValue: boolean;\n} {\n  let [iLow, iHigh] = [0, length - 1];\n  // handle out of bounds\n  if (getValue(iLow) > target) return { lowIndex: -1, foundValue: false };\n  if (getValue(iHigh) < target) return { lowIndex: iHigh, foundValue: false };\n\n  // invariant: 0 <= iLow <= lowIndex <= iHigh < length\n  // since we are decreasing (iHigh - iLow) in every iteration, we'll terminate\n  while (iHigh !== iLow) {\n    // we have iLow < iMid <= iHigh\n    // in both branches, the range gets strictly smaller\n    let iMid = Math.ceil((iLow + iHigh) / 2);\n    if (getValue(iMid) <= target) {\n      // iMid is in the candidate set, and strictly larger than iLow\n      // preserves iLow <= lowIndex\n      iLow = iMid;\n    } else {\n      // iMid is no longer in the candidate set, so we can exclude it right away\n      // preserves lowIndex <= iHigh\n      iHigh = iMid - 1;\n    }\n  }\n\n  return { lowIndex: iLow, foundValue: getValue(iLow) === target };\n}\n\n// custom comparison methods where 0 can act as the min and max value simultaneously\n\n/**\n * Assert that `x in (low, high)`, i.e. low < x < high, with the following exceptions:\n *\n * - high=0 is treated as the maximum value, so `x in (low, 0)` always succeeds if only low < x; except for x = 0.\n * - x=0 is also treated as the maximum value, so `0 in (low, high)` always fails, because x >= high.\n */\nfunction assertStrictlyBetween(low: Field, x: Field, high: Field, message?: string) {\n  // exclude x=0\n  x.assertNotEquals(0n, message ?? '0 is not in any strict range');\n\n  // normal assertion for low < x\n  low.assertLessThan(x, message);\n\n  // for x < high, use a safe comparison that also works if high=0\n  let highIsZero = high.equals(0n);\n  let xSafe = Provable.witness(Field, () => (highIsZero.toBoolean() ? 0n : x));\n  let highSafe = Provable.witness(Field, () => (highIsZero.toBoolean() ? 1n : high));\n  xSafe.assertLessThan(highSafe, message);\n  assert(xSafe.equals(x).or(highIsZero), message);\n  assert(highSafe.equals(high).or(highIsZero), message);\n}\n\n/**\n * Assert that `x in (low, high]`, i.e. low < x <= high, with the following exceptions:\n *\n * - high=0 is treated as the maximum value, so `x in (low, 0]` always succeeds if only low < x.\n * - x=0 is also treated as the maximum value, so `0 in (low, high]` fails except if high=0.\n * - note: `0 in (n, 0]` succeeds for any n!\n */\nfunction assertBetween(low: Field, x: Field, high: Field, message?: string) {\n  // for low < x, we need to handle the x=0 case separately\n  let xIsZero = x.equals(0n);\n  let lowSafe = Provable.witness(Field, () => (xIsZero.toBoolean() ? 0n : low));\n  let xSafe1 = Provable.witness(Field, () => (xIsZero.toBoolean() ? 1n : x));\n  lowSafe.assertLessThan(xSafe1, message);\n  assert(lowSafe.equals(low).or(xIsZero), message);\n  assert(xSafe1.equals(x).or(xIsZero), message);\n\n  // for x <= high, we need to handle the high=0 case separately\n  let highIsZero = high.equals(0n);\n  let xSafe0 = Provable.witness(Field, () => (highIsZero.toBoolean() ? 0n : x));\n  xSafe0.assertLessThanOrEqual(high, message);\n  assert(xSafe0.equals(x).or(highIsZero), message);\n}\n", "/**\n * This module holds the global Mina instance and its interface.\n */\nimport { Field } from '../../provable/wrapped.js';\nimport { UInt64, UInt32 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport type { EventActionFilterOptions } from '././../../mina/v1/graphql.js';\nimport type { NetworkId } from '../../../mina-signer/src/types.js';\nimport type { Account } from './account.js';\nimport type { NetworkValue } from './precondition.js';\nimport type * as Fetch from './fetch.js';\nimport type { TransactionPromise, PendingTransactionPromise, Transaction } from './transaction.js';\n\nexport {\n  Mina,\n  FeePayerSpec,\n  ActionStates,\n  NetworkConstants,\n  defaultNetworkConstants,\n  activeInstance,\n  setActiveInstance,\n  ZkappStateLength,\n  currentSlot,\n  getAccount,\n  hasAccount,\n  getBalance,\n  getNetworkId,\n  getNetworkConstants,\n  getNetworkState,\n  fetchEvents,\n  fetchActions,\n  getActions,\n  getProofsEnabled,\n};\n\nconst defaultAccountCreationFee = 1_000_000_000;\nconst defaultNetworkConstants: NetworkConstants = {\n  genesisTimestamp: UInt64.from(0),\n  slotTime: UInt64.from(3 * 60 * 1000),\n  accountCreationFee: UInt64.from(defaultAccountCreationFee),\n};\n\nconst ZkappStateLength = 8;\n\n/**\n * Allows you to specify information about the fee payer account and the transaction.\n */\ntype FeePayerSpec =\n  | PublicKey\n  | {\n      sender: PublicKey;\n      fee?: number | string | UInt64;\n      memo?: string;\n      nonce?: number;\n    }\n  | undefined;\n\ntype ActionStates = {\n  fromActionState?: Field;\n  endActionState?: Field;\n};\n\ntype NetworkConstants = {\n  genesisTimestamp: UInt64;\n  /**\n   * Duration of 1 slot in milliseconds\n   */\n  slotTime: UInt64;\n  accountCreationFee: UInt64;\n};\n\ntype Mina = {\n  transaction(sender: FeePayerSpec, f: () => Promise<void>): TransactionPromise<false, false>;\n  currentSlot(): UInt32;\n  hasAccount(publicKey: PublicKey, tokenId?: Field): boolean;\n  getAccount(publicKey: PublicKey, tokenId?: Field): Account;\n  getNetworkState(): NetworkValue;\n  getNetworkConstants(): NetworkConstants;\n  sendTransaction(transaction: Transaction<boolean, boolean>): PendingTransactionPromise;\n  fetchEvents: (\n    publicKey: PublicKey,\n    tokenId?: Field,\n    filterOptions?: EventActionFilterOptions,\n    headers?: HeadersInit\n  ) => ReturnType<typeof Fetch.fetchEvents>;\n  fetchActions: (\n    publicKey: PublicKey,\n    actionStates?: ActionStates,\n    tokenId?: Field,\n    from?: number,\n    to?: number,\n    headers?: HeadersInit\n  ) => ReturnType<typeof Fetch.fetchActions>;\n  getActions: (\n    publicKey: PublicKey,\n    actionStates?: ActionStates,\n    tokenId?: Field\n  ) => { hash: string; actions: string[][] }[];\n  proofsEnabled: boolean;\n  getNetworkId(): NetworkId;\n};\n\nlet activeInstance: Mina = {\n  getNetworkConstants: () => defaultNetworkConstants,\n  currentSlot: noActiveInstance,\n  hasAccount: noActiveInstance,\n  getAccount: noActiveInstance,\n  getNetworkState: noActiveInstance,\n  sendTransaction: noActiveInstance,\n  transaction: noActiveInstance,\n  fetchEvents: noActiveInstance,\n  fetchActions: noActiveInstance,\n  getActions: noActiveInstance,\n  proofsEnabled: true,\n  getNetworkId: () => 'devnet',\n};\n\n/**\n * Set the currently used Mina instance.\n */\nfunction setActiveInstance(m: Mina) {\n  activeInstance = m;\n}\n\nfunction noActiveInstance(): never {\n  throw Error('Must call Mina.setActiveInstance first');\n}\n\n/**\n * @return The current slot number, according to the active Mina instance.\n */\nfunction currentSlot(): UInt32 {\n  return activeInstance.currentSlot();\n}\n\n/**\n * @return The account data associated to the given public key.\n */\nfunction getAccount(publicKey: PublicKey, tokenId?: Field): Account {\n  return activeInstance.getAccount(publicKey, tokenId);\n}\n\n/**\n * Checks if an account exists within the ledger.\n */\nfunction hasAccount(publicKey: PublicKey, tokenId?: Field): boolean {\n  return activeInstance.hasAccount(publicKey, tokenId);\n}\n\n/**\n * @return The current Mina network ID.\n */\nfunction getNetworkId() {\n  return activeInstance.getNetworkId();\n}\n\n/**\n * @return Data associated with the current Mina network constants.\n */\nfunction getNetworkConstants() {\n  return activeInstance.getNetworkConstants();\n}\n\n/**\n * @return Data associated with the current state of the Mina network.\n */\nfunction getNetworkState() {\n  return activeInstance.getNetworkState();\n}\n\n/**\n * @return The balance associated to the given public key.\n */\nfunction getBalance(publicKey: PublicKey, tokenId?: Field) {\n  return activeInstance.getAccount(publicKey, tokenId).balance;\n}\n\n/**\n * @return A list of emitted events associated to the given public key.\n */\nasync function fetchEvents(\n  publicKey: PublicKey,\n  tokenId: Field,\n  filterOptions: EventActionFilterOptions = {},\n  headers?: HeadersInit\n) {\n  return await activeInstance.fetchEvents(publicKey, tokenId, filterOptions, headers);\n}\n\n/**\n * @return A list of emitted sequencing actions associated to the given public key.\n */\nasync function fetchActions(\n  publicKey: PublicKey,\n  actionStates?: ActionStates,\n  tokenId?: Field,\n  from?: number,\n  to?: number,\n  headers?: HeadersInit\n) {\n  return await activeInstance.fetchActions(publicKey, actionStates, tokenId, from, to, headers);\n}\n\n/**\n * @return A list of emitted sequencing actions associated to the given public key.\n */\nfunction getActions(publicKey: PublicKey, actionStates?: ActionStates, tokenId?: Field) {\n  return activeInstance.getActions(publicKey, actionStates, tokenId);\n}\n\nfunction getProofsEnabled() {\n  return activeInstance.proofsEnabled;\n}\n", "import { Bool, Field } from '../../provable/wrapped.js';\nimport { circuitValueEquals, cloneCircuitValue } from '../../provable/types/struct.js';\nimport { Provable } from '../../provable/provable.js';\nimport { activeInstance as Mina } from './mina-instance.js';\nimport type { AccountUpdate } from './account-update.js';\nimport { Int64, UInt32, UInt64 } from '../../provable/int.js';\nimport { Layout } from '../../../bindings/mina-transaction/gen/v1/transaction.js';\nimport { jsLayout } from '../../../bindings/mina-transaction/gen/v1/js-layout.js';\nimport { emptyReceiptChainHash, TokenSymbol } from '../../provable/crypto/poseidon.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport {\n  ActionState,\n  Actions,\n  ZkappUri,\n} from '../../../bindings/mina-transaction/v1/transaction-leaves.js';\nimport type { Types } from '../../../bindings/mina-transaction/v1/types.js';\nimport type { Permissions } from './account-update.js';\nimport { ZkappStateLength } from './mina-instance.js';\nimport { assertInternal } from '../../util/errors.js';\n\nexport {\n  preconditions,\n  Account,\n  Network,\n  CurrentSlot,\n  assertPreconditionInvariants,\n  cleanPreconditionsCache,\n  ensureConsistentPrecondition,\n  AccountValue,\n  NetworkValue,\n  getAccountPreconditions,\n  Preconditions,\n  OrIgnore,\n  ClosedInterval,\n};\n\ntype AccountUpdateBody = Types.AccountUpdate['body'];\n\n/**\n * Preconditions for the network and accounts\n */\ntype Preconditions = AccountUpdateBody['preconditions'];\n\n/**\n * Either check a value or ignore it.\n *\n * Used within [[ AccountPredicate ]]s and [[ ProtocolStatePredicate ]]s.\n */\ntype OrIgnore<T> = { isSome: Bool; value: T };\n\n/**\n * An interval representing all the values between `lower` and `upper` inclusive\n * of both the `lower` and `upper` values.\n *\n * @typeParam A something with an ordering where one can quantify a lower and\n *            upper bound.\n */\ntype ClosedInterval<T> = { lower: T; upper: T };\n\ntype NetworkPrecondition = Preconditions['network'];\nlet NetworkPrecondition = {\n  ignoreAll(): NetworkPrecondition {\n    let stakingEpochData = {\n      ledger: { hash: ignore(Field(0)), totalCurrency: ignore(uint64()) },\n      seed: ignore(Field(0)),\n      startCheckpoint: ignore(Field(0)),\n      lockCheckpoint: ignore(Field(0)),\n      epochLength: ignore(uint32()),\n    };\n    let nextEpochData = cloneCircuitValue(stakingEpochData);\n    return {\n      snarkedLedgerHash: ignore(Field(0)),\n      blockchainLength: ignore(uint32()),\n      minWindowDensity: ignore(uint32()),\n      totalCurrency: ignore(uint64()),\n      globalSlotSinceGenesis: ignore(uint32()),\n      stakingEpochData,\n      nextEpochData,\n    };\n  },\n};\n\n/**\n * Ignores a `dummy`\n *\n * @param dummy The value to ignore\n * @returns Always an ignored value regardless of the input.\n */\nfunction ignore<T>(dummy: T): OrIgnore<T> {\n  return { isSome: Bool(false), value: dummy };\n}\n\n/**\n * Ranges between all uint32 values\n */\nconst uint32 = () => ({ lower: UInt32.from(0), upper: UInt32.MAXINT() });\n\n/**\n * Ranges between all uint64 values\n */\nconst uint64 = () => ({ lower: UInt64.from(0), upper: UInt64.MAXINT() });\n\ntype AccountPrecondition = Preconditions['account'];\nconst AccountPrecondition = {\n  ignoreAll(): AccountPrecondition {\n    let appState: Array<OrIgnore<Field>> = [];\n    for (let i = 0; i < ZkappStateLength; ++i) {\n      appState.push(ignore(Field(0)));\n    }\n    return {\n      balance: ignore(uint64()),\n      nonce: ignore(uint32()),\n      receiptChainHash: ignore(Field(0)),\n      delegate: ignore(PublicKey.empty()),\n      state: appState,\n      actionState: ignore(Actions.emptyActionState()),\n      provedState: ignore(Bool(false)),\n      isNew: ignore(Bool(false)),\n    };\n  },\n};\n\ntype GlobalSlotPrecondition = Preconditions['validWhile'];\nconst GlobalSlotPrecondition = {\n  ignoreAll(): GlobalSlotPrecondition {\n    return ignore(uint32());\n  },\n};\n\nconst Preconditions = {\n  ignoreAll(): Preconditions {\n    return {\n      account: AccountPrecondition.ignoreAll(),\n      network: NetworkPrecondition.ignoreAll(),\n      validWhile: GlobalSlotPrecondition.ignoreAll(),\n    };\n  },\n};\n\nfunction preconditions(accountUpdate: AccountUpdate, isSelf: boolean) {\n  initializePreconditions(accountUpdate, isSelf);\n  return {\n    account: Account(accountUpdate),\n    network: Network(accountUpdate),\n    currentSlot: CurrentSlot(accountUpdate),\n  };\n}\n\n// note: please keep the two precondition implementations separate\n// so we can add customized fields easily\n\nfunction Network(accountUpdate: AccountUpdate): Network {\n  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.network;\n  let context = getPreconditionContextExn(accountUpdate);\n  let network: RawNetwork = preconditionClass(layout as Layout, 'network', accountUpdate, context);\n  let timestamp = {\n    get() {\n      let slot = network.globalSlotSinceGenesis.get();\n      return globalSlotToTimestamp(slot);\n    },\n    getAndRequireEquals() {\n      let slot = network.globalSlotSinceGenesis.getAndRequireEquals();\n      return globalSlotToTimestamp(slot);\n    },\n    requireEquals(value: UInt64) {\n      let { genesisTimestamp, slotTime } = Mina.getNetworkConstants();\n      let slot = timestampToGlobalSlot(\n        value,\n        `Timestamp precondition unsatisfied: the timestamp can only equal numbers of the form ${genesisTimestamp} + k*${slotTime},\\n` +\n          `i.e., the genesis timestamp plus an integer number of slots.`\n      );\n      return network.globalSlotSinceGenesis.requireEquals(slot);\n    },\n    requireEqualsIf(condition: Bool, value: UInt64) {\n      let { genesisTimestamp, slotTime } = Mina.getNetworkConstants();\n      let slot = timestampToGlobalSlot(\n        value,\n        `Timestamp precondition unsatisfied: the timestamp can only equal numbers of the form ${genesisTimestamp} + k*${slotTime},\\n` +\n          `i.e., the genesis timestamp plus an integer number of slots.`\n      );\n      return network.globalSlotSinceGenesis.requireEqualsIf(condition, slot);\n    },\n    requireBetween(lower: UInt64, upper: UInt64) {\n      let [slotLower, slotUpper] = timestampToGlobalSlotRange(lower, upper);\n      return network.globalSlotSinceGenesis.requireBetween(slotLower, slotUpper);\n    },\n    requireNothing() {\n      return network.globalSlotSinceGenesis.requireNothing();\n    },\n  };\n  return { ...network, timestamp };\n}\n\nfunction Account(accountUpdate: AccountUpdate): Account {\n  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.account;\n  let context = getPreconditionContextExn(accountUpdate);\n  let identity = (x: any) => x;\n  let update: Update = {\n    delegate: {\n      ...preconditionSubclass(accountUpdate, 'account.delegate', PublicKey, context),\n      ...updateSubclass(accountUpdate, 'delegate', identity),\n    },\n    verificationKey: updateSubclass(accountUpdate, 'verificationKey', identity),\n    permissions: updateSubclass(accountUpdate, 'permissions', identity),\n    zkappUri: updateSubclass(accountUpdate, 'zkappUri', ZkappUri.fromJSON),\n    tokenSymbol: updateSubclass(accountUpdate, 'tokenSymbol', TokenSymbol.from),\n    timing: updateSubclass(accountUpdate, 'timing', identity),\n    votingFor: updateSubclass(accountUpdate, 'votingFor', identity),\n  };\n  return {\n    ...preconditionClass(layout as Layout, 'account', accountUpdate, context),\n    ...update,\n  };\n}\n\nfunction updateSubclass<K extends keyof Update>(\n  accountUpdate: AccountUpdate,\n  key: K,\n  transform: (value: UpdateValue[K]) => UpdateValueOriginal[K]\n) {\n  return {\n    set(value: UpdateValue[K]) {\n      accountUpdate.body.update[key].isSome = Bool(true);\n      accountUpdate.body.update[key].value = transform(value);\n    },\n  };\n}\n\nfunction CurrentSlot(accountUpdate: AccountUpdate): CurrentSlot {\n  let context = getPreconditionContextExn(accountUpdate);\n  return {\n    requireBetween(lower: UInt32, upper: UInt32) {\n      context.constrained.add('validWhile');\n      let property: RangeCondition<UInt32> = accountUpdate.body.preconditions.validWhile;\n      ensureConsistentPrecondition(property, Bool(true), { lower, upper }, 'validWhile');\n      property.isSome = Bool(true);\n      property.value.lower = lower;\n      property.value.upper = upper;\n    },\n  };\n}\n\nlet unimplementedPreconditions: LongKey[] = [\n  // unimplemented because its not checked in the protocol\n  'network.stakingEpochData.seed',\n  'network.nextEpochData.seed',\n];\n\nlet baseMap = { UInt64, UInt32, Field, Bool, PublicKey, ActionState };\n\nfunction getProvableType(layout: { type: string; checkedTypeName?: string }) {\n  let typeName = layout.checkedTypeName ?? layout.type;\n  let type = baseMap[typeName as keyof typeof baseMap];\n  assertInternal(type !== undefined, `Unknown precondition base type ${typeName}`);\n  return type;\n}\n\nfunction preconditionClass(\n  layout: Layout,\n  baseKey: any,\n  accountUpdate: AccountUpdate,\n  context: PreconditionContext\n): any {\n  if (layout.type === 'option') {\n    // range condition\n    if (layout.optionType === 'closedInterval') {\n      let baseType = getProvableType(layout.inner.entries.lower);\n      return preconditionSubClassWithRange(accountUpdate, baseKey, baseType, context);\n    }\n    // value condition\n    else if (layout.optionType === 'flaggedOption') {\n      let baseType = getProvableType(layout.inner);\n      return preconditionSubclass(accountUpdate, baseKey, baseType, context);\n    }\n  } else if (layout.type === 'array') {\n    return {}; // not applicable yet, TODO if we implement state\n  } else if (layout.type === 'object') {\n    // for each field, create a recursive object\n    return Object.fromEntries(\n      layout.keys.map((key) => {\n        let value = layout.entries[key];\n        return [key, preconditionClass(value, `${baseKey}.${key}`, accountUpdate, context)];\n      })\n    );\n  } else throw Error('bug');\n}\n\nfunction preconditionSubClassWithRange<K extends LongKey, U extends FlatPreconditionValue[K]>(\n  accountUpdate: AccountUpdate,\n  longKey: K,\n  fieldType: Provable<U>,\n  context: PreconditionContext\n) {\n  return {\n    ...preconditionSubclass(accountUpdate, longKey, fieldType as any, context),\n    requireBetween(lower: any, upper: any) {\n      context.constrained.add(longKey);\n      let property: RangeCondition<any> = getPath(accountUpdate.body.preconditions, longKey);\n      let newValue = { lower, upper };\n      ensureConsistentPrecondition(property, Bool(true), newValue, longKey);\n      property.isSome = Bool(true);\n      property.value = newValue;\n    },\n  };\n}\n\nfunction defaultLower(fieldType: any) {\n  assertInternal(fieldType === UInt32 || fieldType === UInt64);\n  return (fieldType as typeof UInt32 | typeof UInt64).zero;\n}\nfunction defaultUpper(fieldType: any) {\n  assertInternal(fieldType === UInt32 || fieldType === UInt64);\n  return (fieldType as typeof UInt32 | typeof UInt64).MAXINT();\n}\n\nfunction preconditionSubclass<K extends LongKey, U extends FlatPreconditionValue[K]>(\n  accountUpdate: AccountUpdate,\n  longKey: K,\n  fieldType: Provable<U> & { empty(): U },\n  context: PreconditionContext\n) {\n  if (fieldType === undefined) {\n    throw Error(`this.${longKey}: fieldType undefined`);\n  }\n\n  let obj = {\n    get() {\n      if (unimplementedPreconditions.includes(longKey)) {\n        let self = context.isSelf ? 'this' : 'accountUpdate';\n        throw Error(`${self}.${longKey}.get() is not implemented yet.`);\n      }\n      let { read, vars } = context;\n      read.add(longKey);\n      return (vars[longKey] ??= getVariable(accountUpdate, longKey, fieldType)) as U;\n    },\n    getAndRequireEquals() {\n      let value = obj.get();\n      obj.requireEquals(value);\n      return value;\n    },\n    requireEquals(value: U) {\n      context.constrained.add(longKey);\n      let property = getPath(accountUpdate.body.preconditions, longKey) as AnyCondition<U>;\n      if ('isSome' in property) {\n        let isInterval = 'lower' in property.value && 'upper' in property.value;\n        let newValue = isInterval ? { lower: value, upper: value } : value;\n        ensureConsistentPrecondition(property, Bool(true), newValue, longKey);\n        property.isSome = Bool(true);\n        property.value = newValue;\n      } else {\n        setPath(accountUpdate.body.preconditions, longKey, value);\n      }\n    },\n    requireEqualsIf(condition: Bool, value: U) {\n      context.constrained.add(longKey);\n      let property = getPath(accountUpdate.body.preconditions, longKey) as AnyCondition<U>;\n      assertInternal('isSome' in property);\n      if ('lower' in property.value && 'upper' in property.value) {\n        let lower = Provable.if(condition, fieldType, value, defaultLower(fieldType) as U);\n        let upper = Provable.if(condition, fieldType, value, defaultUpper(fieldType) as U);\n        ensureConsistentPrecondition(property, condition, { lower, upper }, longKey);\n        property.isSome = condition;\n        property.value.lower = lower;\n        property.value.upper = upper;\n      } else {\n        let newValue = Provable.if(condition, fieldType, value, fieldType.empty());\n        ensureConsistentPrecondition(property, condition, newValue, longKey);\n        property.isSome = condition;\n        property.value = newValue;\n      }\n    },\n    requireNothing() {\n      let property = getPath(accountUpdate.body.preconditions, longKey) as AnyCondition<U>;\n      if ('isSome' in property) {\n        property.isSome = Bool(false);\n        if ('lower' in property.value && 'upper' in property.value) {\n          property.value.lower = defaultLower(fieldType) as U;\n          property.value.upper = defaultUpper(fieldType) as U;\n        } else {\n          property.value = fieldType.empty();\n        }\n      }\n      context.constrained.add(longKey);\n    },\n  };\n  return obj;\n}\n\nfunction getVariable<K extends LongKey, U extends FlatPreconditionValue[K]>(\n  accountUpdate: AccountUpdate,\n  longKey: K,\n  fieldType: Provable<U>\n): U {\n  return Provable.witness(fieldType, () => {\n    let [accountOrNetwork, ...rest] = longKey.split('.');\n    let key = rest.join('.');\n    let value: U;\n    if (accountOrNetwork === 'account') {\n      let account = getAccountPreconditions(accountUpdate.body);\n      value = account[key as keyof AccountValue] as U;\n    } else if (accountOrNetwork === 'network') {\n      let networkState = Mina.getNetworkState();\n      value = getPath(networkState, key);\n    } else if (accountOrNetwork === 'validWhile') {\n      let networkState = Mina.getNetworkState();\n      value = networkState.globalSlotSinceGenesis as U;\n    } else {\n      throw Error('impossible');\n    }\n    return value;\n  });\n}\n\nfunction globalSlotToTimestamp(slot: UInt32) {\n  let { genesisTimestamp, slotTime } = Mina.getNetworkConstants();\n  return UInt64.from(slot).mul(slotTime).add(genesisTimestamp);\n}\nfunction timestampToGlobalSlot(timestamp: UInt64, message: string) {\n  let { genesisTimestamp, slotTime } = Mina.getNetworkConstants();\n  let { quotient: slot, rest } = timestamp.sub(genesisTimestamp).divMod(slotTime);\n  rest.value.assertEquals(Field(0), message);\n  return slot.toUInt32();\n}\n\nfunction timestampToGlobalSlotRange(\n  tsLower: UInt64,\n  tsUpper: UInt64\n): [lower: UInt32, upper: UInt32] {\n  // we need `slotLower <= current slot <= slotUpper` to imply `tsLower <= current timestamp <= tsUpper`\n  // so we have to make the range smaller -- round up `tsLower` and round down `tsUpper`\n  // also, we should clamp to the UInt32 max range [0, 2**32-1]\n  let { genesisTimestamp, slotTime } = Mina.getNetworkConstants();\n  let tsLowerInt = Int64.from(tsLower).sub(genesisTimestamp).add(slotTime).sub(1);\n  let lowerCapped = Provable.if<UInt64>(\n    tsLowerInt.isPositive(),\n    UInt64,\n    tsLowerInt.magnitude,\n    UInt64.from(0)\n  );\n  let slotLower = lowerCapped.div(slotTime).toUInt32Clamped();\n  // unsafe `sub` means the error in case tsUpper underflows slot 0 is ugly, but should not be relevant in practice\n  let slotUpper = tsUpper.sub(genesisTimestamp).div(slotTime).toUInt32Clamped();\n  return [slotLower, slotUpper];\n}\n\nfunction getAccountPreconditions(body: { publicKey: PublicKey; tokenId?: Field }): AccountValue {\n  let { publicKey, tokenId } = body;\n  let hasAccount = Mina.hasAccount(publicKey, tokenId);\n  if (!hasAccount) {\n    return {\n      balance: UInt64.zero,\n      nonce: UInt32.zero,\n      receiptChainHash: emptyReceiptChainHash(),\n      actionState: Actions.emptyActionState(),\n      delegate: publicKey,\n      provedState: Bool(false),\n      isNew: Bool(true),\n    };\n  }\n  let account = Mina.getAccount(publicKey, tokenId);\n  return {\n    balance: account.balance,\n    nonce: account.nonce,\n    receiptChainHash: account.receiptChainHash,\n    actionState: account.zkapp?.actionState?.[0] ?? Actions.emptyActionState(),\n    delegate: account.delegate ?? account.publicKey,\n    provedState: account.zkapp?.provedState ?? Bool(false),\n    isNew: Bool(false),\n  };\n}\n\n// per account update context for checking invariants on precondition construction\ntype PreconditionContext = {\n  isSelf: boolean;\n  vars: Partial<FlatPreconditionValue>;\n  read: Set<LongKey>;\n  constrained: Set<LongKey>;\n};\n\nfunction initializePreconditions(accountUpdate: AccountUpdate, isSelf: boolean) {\n  preconditionContexts.set(accountUpdate, {\n    read: new Set(),\n    constrained: new Set(),\n    vars: {},\n    isSelf,\n  });\n}\n\nfunction cleanPreconditionsCache(accountUpdate: AccountUpdate) {\n  let context = preconditionContexts.get(accountUpdate);\n  if (context !== undefined) context.vars = {};\n}\n\nfunction assertPreconditionInvariants(accountUpdate: AccountUpdate) {\n  let context = getPreconditionContextExn(accountUpdate);\n  let self = context.isSelf ? 'this' : 'accountUpdate';\n  let dummyPreconditions = Preconditions.ignoreAll();\n  for (let preconditionPath of context.read) {\n    // check if every precondition that was read was also constrained\n    if (context.constrained.has(preconditionPath)) continue;\n\n    // check if the precondition was modified manually, which is also a valid way of avoiding an error\n    let precondition = getPath(accountUpdate.body.preconditions, preconditionPath);\n    let dummy = getPath(dummyPreconditions, preconditionPath);\n    if (!circuitValueEquals(precondition, dummy)) continue;\n\n    // we accessed a precondition field but not constrained it explicitly - throw an error\n    let hasRequireBetween = isRangeCondition(precondition);\n    let shortPath = preconditionPath.split('.').pop();\n    let errorMessage = `You used \\`${self}.${preconditionPath}.get()\\` without adding a precondition that links it to the actual ${shortPath}.\nConsider adding this line to your code:\n${self}.${preconditionPath}.requireEquals(${self}.${preconditionPath}.get());${\n      hasRequireBetween\n        ? `\nYou can also add more flexible preconditions with \\`${self}.${preconditionPath}.requireBetween(...)\\`.`\n        : ''\n    }`;\n    throw Error(errorMessage);\n  }\n}\n\nfunction getPreconditionContextExn(accountUpdate: AccountUpdate) {\n  let c = preconditionContexts.get(accountUpdate);\n  if (c === undefined) throw Error('bug: precondition context not found');\n  return c;\n}\n\n/**\n * Asserts that a precondition is not already set or that it matches the new values.\n *\n * This function checks if a precondition is already set for a given property and compares it\n * with new values. If the precondition is not set, it allows the new values. If it's already set,\n * it ensures consistency with the existing precondition.\n *\n * @param property - The property object containing the precondition information.\n * @param newIsSome - A boolean or CircuitValue indicating whether the new precondition should exist.\n * @param value - The new value for the precondition. Can be a simple value or an object with 'lower' and 'upper' properties for range preconditions.\n * @param name - The name of the precondition for error messages.\n *\n * @throws {Error} Throws an error with a detailed message if attempting to set an inconsistent precondition.\n * @todo It would be nice to have the input parameter types more specific, but it's hard to do with the current implementation.\n */\nfunction ensureConsistentPrecondition(property: any, newIsSome: any, value: any, name: any) {\n  if (!property.isSome.isConstant() || property.isSome.toBoolean()) {\n    let errorMessage = `\nPrecondition Error: Precondition Error: Attempting to set a precondition that is already set for '${name}'.\n'${name}' represents the field or value you're trying to set a precondition for.\nPreconditions must be set only once to avoid overwriting previous assertions. \nFor example, do not use 'requireBetween()' or 'requireEquals()' multiple times on the same field.\n\nRecommendation:\nEnsure that preconditions for '${name}' are set in a single place and are not overwritten. If you need to update a precondition,\nconsider refactoring your code to consolidate all assertions for '${name}' before setting the precondition.\n\nExample of Correct Usage:\n// Incorrect Usage:\ntimestamp.requireBetween(newUInt32(0n), newUInt32(2n));\ntimestamp.requireBetween(newUInt32(1n), newUInt32(3n));\n\n// Correct Usage:\ntimestamp.requireBetween(new UInt32(1n), new UInt32(2n));\n`;\n    property.isSome.assertEquals(newIsSome, errorMessage);\n    if ('lower' in property.value && 'upper' in property.value) {\n      property.value.lower.assertEquals(value.lower, errorMessage);\n      property.value.upper.assertEquals(value.lower, errorMessage);\n    } else {\n      property.value.assertEquals(value, errorMessage);\n    }\n  }\n}\n\nconst preconditionContexts = new WeakMap<AccountUpdate, PreconditionContext>();\n\n// exported types\n\ntype NetworkValue = PreconditionBaseTypes<NetworkPrecondition>;\ntype RawNetwork = PreconditionClassType<NetworkPrecondition>;\ntype Network = RawNetwork & {\n  timestamp: PreconditionSubclassRangeType<UInt64>;\n};\n\n// TODO: should we add account.state?\n// then can just use circuitArray(Field, 8) as the type\ntype AccountPreconditionNoState = Omit<Preconditions['account'], 'state'>;\ntype AccountValue = PreconditionBaseTypes<AccountPreconditionNoState>;\ntype Account = PreconditionClassType<AccountPreconditionNoState> & Update;\n\ntype CurrentSlotPrecondition = Preconditions['validWhile'];\ntype CurrentSlot = {\n  requireBetween(lower: UInt32, upper: UInt32): void;\n};\n\ntype PreconditionBaseTypes<T> = {\n  [K in keyof T]: T[K] extends RangeCondition<infer U>\n    ? U\n    : T[K] extends FlaggedOptionCondition<infer U>\n      ? U\n      : T[K] extends Field\n        ? Field\n        : PreconditionBaseTypes<T[K]>;\n};\n\ntype PreconditionSubclassType<U> = {\n  get(): U;\n  getAndRequireEquals(): U;\n  requireEquals(value: U): void;\n  requireEqualsIf(condition: Bool, value: U): void;\n  requireNothing(): void;\n};\ntype PreconditionSubclassRangeType<U> = PreconditionSubclassType<U> & {\n  requireBetween(lower: U, upper: U): void;\n};\n\ntype PreconditionClassType<T> = {\n  [K in keyof T]: T[K] extends RangeCondition<infer U>\n    ? PreconditionSubclassRangeType<U>\n    : T[K] extends FlaggedOptionCondition<infer U>\n      ? PreconditionSubclassType<U>\n      : T[K] extends Field\n        ? PreconditionSubclassType<Field>\n        : PreconditionClassType<T[K]>;\n};\n\n// update\n\ntype Update_ = Omit<AccountUpdate['body']['update'], 'appState'>;\ntype Update = {\n  [K in keyof Update_]: { set(value: UpdateValue[K]): void };\n};\ntype UpdateValueOriginal = {\n  [K in keyof Update_]: Update_[K]['value'];\n};\ntype UpdateValue = {\n  [K in keyof Update_]: K extends 'zkappUri' | 'tokenSymbol'\n    ? string\n    : K extends 'permissions'\n      ? Permissions\n      : Update_[K]['value'];\n};\n\n// TS magic for computing flattened precondition types\n\ntype JoinEntries<K, P> = K extends string\n  ? P extends [string, unknown, unknown]\n    ? [`${K}${P[0] extends '' ? '' : '.'}${P[0]}`, P[1], P[2]]\n    : never\n  : never;\n\ntype PreconditionFlatEntry<T> =\n  T extends RangeCondition<infer V>\n    ? ['', T, V]\n    : T extends FlaggedOptionCondition<infer U>\n      ? ['', T, U]\n      : { [K in keyof T]: JoinEntries<K, PreconditionFlatEntry<T[K]>> }[keyof T];\n\ntype FlatPreconditionValue = {\n  [S in PreconditionFlatEntry<NetworkPrecondition> as `network.${S[0]}`]: S[2];\n} & {\n  [S in PreconditionFlatEntry<AccountPreconditionNoState> as `account.${S[0]}`]: S[2];\n} & { validWhile: PreconditionFlatEntry<CurrentSlotPrecondition>[2] };\n\ntype LongKey = keyof FlatPreconditionValue;\n\n// types for the two kinds of conditions\ntype RangeCondition<T> = { isSome: Bool; value: { lower: T; upper: T } };\ntype FlaggedOptionCondition<T> = { isSome: Bool; value: T };\ntype AnyCondition<T> = RangeCondition<T> | FlaggedOptionCondition<T>;\n\nfunction isRangeCondition<T extends object>(\n  condition: AnyCondition<T>\n): condition is RangeCondition<T> {\n  return 'isSome' in condition && 'lower' in condition.value;\n}\n\n// helper. getPath({a: {b: 'x'}}, 'a.b') === 'x'\n// TODO: would be awesome to type this\nfunction getPath(obj: any, path: string) {\n  let pathArray = path.split('.').reverse();\n  while (pathArray.length > 0) {\n    let key = pathArray.pop();\n    obj = obj[key as any];\n  }\n  return obj;\n}\nfunction setPath(obj: any, path: string, value: any) {\n  let pathArray = path.split('.');\n  let key = pathArray.pop()!;\n  getPath(obj, pathArray.join('.'))[key] = value;\n}\n", "import { ProvableType } from './provable-intf.js';\nimport { witness } from './witness.js';\n\nexport { emptyWitness };\n\nfunction emptyWitness<T>(type: ProvableType<T>) {\n  return witness(type, () => ProvableType.synthesize(type));\n}\n", "/**\n * This file provides helpers to\n * - encode and decode all 4 kinds of snark keys to/from bytes\n * - create a header which is passed to the `Cache` so that it can figure out where and if to read from cache\n *\n * The inputs are `SnarkKeyHeader` and `SnarkKey`, which are OCaml tagged enums defined in pickles_bindings.ml\n */\nimport {\n  WasmPastaFpPlonkIndex,\n  WasmPastaFqPlonkIndex,\n} from '../../bindings/compiled/node_bindings/plonk_wasm.cjs';\nimport { Pickles, wasm } from '../../bindings.js';\nimport { VerifierIndex } from '../../bindings/crypto/bindings/kimchi-types.js';\nimport { getRustConversion } from '../../bindings/crypto/bindings.js';\nimport { MlString } from '../ml/base.js';\nimport { CacheHeader, cacheHeaderVersion } from './cache.js';\nimport type { MethodInterface } from './zkprogram.js';\n\nexport { parseHeader, encodeProverKey, decodeProverKey, SnarkKeyHeader, SnarkKey };\nexport type { MlWrapVerificationKey };\n\n// there are 4 types of snark keys in Pickles which we all handle at once\nenum KeyType {\n  StepProvingKey,\n  StepVerificationKey,\n  WrapProvingKey,\n  WrapVerificationKey,\n}\n\ntype SnarkKeyHeader =\n  | [KeyType.StepProvingKey, MlStepProvingKeyHeader]\n  | [KeyType.StepVerificationKey, MlStepVerificationKeyHeader]\n  | [KeyType.WrapProvingKey, MlWrapProvingKeyHeader]\n  | [KeyType.WrapVerificationKey, MlWrapVerificationKeyHeader];\n\ntype SnarkKey =\n  | [KeyType.StepProvingKey, MlBackendKeyPair<WasmPastaFpPlonkIndex>]\n  | [KeyType.StepVerificationKey, VerifierIndex]\n  | [KeyType.WrapProvingKey, MlBackendKeyPair<WasmPastaFqPlonkIndex>]\n  | [KeyType.WrapVerificationKey, MlWrapVerificationKey];\n\n/**\n * Create `CacheHeader` from a `SnarkKeyHeader` plus some context available to `compile()`\n */\nfunction parseHeader(\n  programName: string,\n  methods: MethodInterface[],\n  header: SnarkKeyHeader\n): CacheHeader {\n  let hash = Pickles.util.fromMlString(header[1][2][6]);\n  switch (header[0]) {\n    case KeyType.StepProvingKey:\n    case KeyType.StepVerificationKey: {\n      let kind = snarkKeyStringKind[header[0]];\n      let methodIndex = header[1][3];\n      let methodName = methods[methodIndex].methodName;\n      let persistentId = sanitize(`${kind}-${programName}-${methodName}`);\n      let uniqueId = sanitize(`${kind}-${programName}-${methodIndex}-${methodName}-${hash}`);\n      return {\n        version: cacheHeaderVersion,\n        uniqueId,\n        kind,\n        persistentId,\n        programName,\n        methodName,\n        methodIndex,\n        hash,\n        dataType: snarkKeySerializationType[header[0]],\n      };\n    }\n    case KeyType.WrapProvingKey:\n    case KeyType.WrapVerificationKey: {\n      let kind = snarkKeyStringKind[header[0]];\n      let dataType = snarkKeySerializationType[header[0]];\n      let persistentId = sanitize(`${kind}-${programName}`);\n      let uniqueId = sanitize(`${kind}-${programName}-${hash}`);\n      return {\n        version: cacheHeaderVersion,\n        uniqueId,\n        kind,\n        persistentId,\n        programName,\n        hash,\n        dataType,\n      };\n    }\n  }\n}\n\n/**\n * Encode a snark key to bytes\n */\nfunction encodeProverKey(value: SnarkKey): Uint8Array {\n  switch (value[0]) {\n    case KeyType.StepProvingKey: {\n      let index = value[1][1];\n      let encoded = wasm.caml_pasta_fp_plonk_index_encode(index);\n      return encoded;\n    }\n    case KeyType.StepVerificationKey: {\n      let vkMl = value[1];\n      const rustConversion = getRustConversion(wasm);\n      let vkWasm = rustConversion.fp.verifierIndexToRust(vkMl);\n      let string = wasm.caml_pasta_fp_plonk_verifier_index_serialize(vkWasm);\n      return new TextEncoder().encode(string);\n    }\n    case KeyType.WrapProvingKey: {\n      let index = value[1][1];\n      let encoded = wasm.caml_pasta_fq_plonk_index_encode(index);\n      return encoded;\n    }\n    case KeyType.WrapVerificationKey: {\n      let vk = value[1];\n      let string = Pickles.encodeVerificationKey(vk);\n      return new TextEncoder().encode(string);\n    }\n    default:\n      value satisfies never;\n      throw Error('unreachable');\n  }\n}\n\n/**\n * Decode bytes to a snark key with the help of its header\n */\nfunction decodeProverKey(header: SnarkKeyHeader, bytes: Uint8Array): SnarkKey {\n  switch (header[0]) {\n    case KeyType.StepProvingKey: {\n      let srs = Pickles.loadSrsFp();\n      let index = wasm.caml_pasta_fp_plonk_index_decode(bytes, srs);\n      let cs = header[1][4];\n      return [KeyType.StepProvingKey, [0, index, cs]];\n    }\n    case KeyType.StepVerificationKey: {\n      let srs = Pickles.loadSrsFp();\n      let string = new TextDecoder().decode(bytes);\n      let vkWasm = wasm.caml_pasta_fp_plonk_verifier_index_deserialize(srs, string);\n      const rustConversion = getRustConversion(wasm);\n      let vkMl = rustConversion.fp.verifierIndexFromRust(vkWasm);\n      return [KeyType.StepVerificationKey, vkMl];\n    }\n    case KeyType.WrapProvingKey: {\n      let srs = Pickles.loadSrsFq();\n      let index = wasm.caml_pasta_fq_plonk_index_decode(bytes, srs);\n      let cs = header[1][3];\n      return [KeyType.WrapProvingKey, [0, index, cs]];\n    }\n    case KeyType.WrapVerificationKey: {\n      let string = new TextDecoder().decode(bytes);\n      let vk = Pickles.decodeVerificationKey(string);\n      return [KeyType.WrapVerificationKey, vk];\n    }\n    default:\n      header satisfies never;\n      throw Error('unreachable');\n  }\n}\n\n/**\n * Sanitize a string so that it can be used as a file name\n */\nfunction sanitize(string: string): string {\n  return string.toLowerCase().replace(/[^a-z0-9_-]/g, '_');\n}\n\nconst snarkKeyStringKind = {\n  [KeyType.StepProvingKey]: 'step-pk',\n  [KeyType.StepVerificationKey]: 'step-vk',\n  [KeyType.WrapProvingKey]: 'wrap-pk',\n  [KeyType.WrapVerificationKey]: 'wrap-vk',\n} as const;\n\nconst snarkKeySerializationType = {\n  [KeyType.StepProvingKey]: 'bytes',\n  [KeyType.StepVerificationKey]: 'string',\n  [KeyType.WrapProvingKey]: 'bytes',\n  [KeyType.WrapVerificationKey]: 'string',\n} as const;\n\n// pickles types\n\n// Plonk_constraint_system.Make()().t\n\nclass MlConstraintSystem {\n  // opaque type\n}\n\n// Dlog_plonk_based_keypair.Make().t\n\ntype MlBackendKeyPair<WasmIndex> = [_: 0, index: WasmIndex, cs: MlConstraintSystem];\n\n// Snarky_keys_header.t\n\ntype MlSnarkKeysHeader = [\n  _: 0,\n  headerVersion: number,\n  kind: [_: 0, type: MlString, identifier: MlString],\n  constraintConstants: unknown,\n  length: number,\n  constraintSystemHash: MlString,\n  identifyingHash: MlString,\n];\n\n// Pickles.Cache.{Step,Wrap}.Key.Proving.t\n\ntype MlStepProvingKeyHeader = [\n  _: 0,\n  typeEqual: number,\n  snarkKeysHeader: MlSnarkKeysHeader,\n  index: number,\n  constraintSystem: MlConstraintSystem,\n];\n\ntype MlStepVerificationKeyHeader = [\n  _: 0,\n  typeEqual: number,\n  snarkKeysHeader: MlSnarkKeysHeader,\n  index: number,\n  digest: unknown,\n];\n\ntype MlWrapProvingKeyHeader = [\n  _: 0,\n  typeEqual: number,\n  snarkKeysHeader: MlSnarkKeysHeader,\n  constraintSystem: MlConstraintSystem,\n];\n\ntype MlWrapVerificationKeyHeader = [\n  _: 0,\n  typeEqual: number,\n  snarkKeysHeader: MlSnarkKeysHeader,\n  digest: unknown,\n];\n\n// Pickles.Verification_key.t\n\nclass MlWrapVerificationKey {\n  // opaque type\n}\n", "import { initializeBindings, Pickles } from '../../bindings.js';\nimport { synchronousRunners } from '../provable/core/provable-context.js';\nimport { provable } from '../provable/types/provable-derivers.js';\nimport { Struct } from '../provable/types/struct.js';\nimport { Field } from '../provable/wrapped.js';\nimport { inCircuitVkHash } from './zkprogram.js';\n\nexport { VerificationKey };\n\nclass VerificationKey extends Struct({\n  ...provable({ data: String, hash: Field }),\n  toJSON({ data }: { data: string }) {\n    return data;\n  },\n}) {\n  static async dummy(): Promise<VerificationKey> {\n    await initializeBindings();\n    const [, data, hash] = Pickles.dummyVerificationKey();\n    return new VerificationKey({\n      data,\n      hash: Field(hash),\n    });\n  }\n\n  static dummySync(): VerificationKey {\n    return new VerificationKey({\n      ...RAW_VERIFICATION_KEY,\n      hash: Field(RAW_VERIFICATION_KEY.hash),\n    });\n  }\n\n  static async checkValidity(key: VerificationKey): Promise<boolean> {\n    try {\n      let { runAndCheckSync } = await synchronousRunners();\n\n      runAndCheckSync(() => {\n        let vk = Pickles.sideLoaded.vkToCircuit(() => key.data);\n        let inCircuitHash = inCircuitVkHash(vk);\n        inCircuitHash.assertEquals(key.hash);\n      });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\nconst RAW_VERIFICATION_KEY = {\n  hash: '3392518251768960475377392625298437850623664973002200885669375116181514017494',\n  // oxlint-disable-line\n  data: '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',\n};\n", "import {\n  Base64ProofString,\n  Base64VerificationKeyString,\n  Gate,\n  Pickles,\n  Snarky,\n  initializeBindings,\n  withThreadPool,\n} from '../../bindings.js';\nimport { setSrsCache, unsetSrsCache } from '../../bindings/crypto/bindings/srs.js';\nimport { prefixes } from '../../bindings/crypto/constants.js';\nimport { prefixToField } from '../../bindings/lib/binable.js';\nimport { EmptyUndefined, EmptyVoid } from '../../bindings/lib/generic.js';\nimport { From, InferValue } from '../../bindings/lib/provable-generic.js';\nimport { MlArray, MlBool, MlPair, MlResult } from '../ml/base.js';\nimport { MlFieldArray, MlFieldConstArray } from '../ml/fields.js';\nimport { FieldConst, FieldVar } from '../provable/core/fieldvar.js';\nimport { ConstraintSystemSummary, snarkContext } from '../provable/core/provable-context.js';\nimport { hashConstant } from '../provable/crypto/poseidon.js';\nimport { Provable } from '../provable/provable.js';\nimport { InferProvableType } from '../provable/types/provable-derivers.js';\nimport { ProvableType, ToProvable } from '../provable/types/provable-intf.js';\nimport { FlexibleProvable, InferProvable, ProvablePureExtended } from '../provable/types/struct.js';\nimport { emptyWitness } from '../provable/types/util.js';\nimport { Field } from '../provable/wrapped.js';\nimport { mapObject, mapToObject, zip } from '../util/arrays.js';\nimport { assert, prettifyStacktracePromise } from '../util/errors.js';\nimport { Get, Subclass, Tuple } from '../util/types.js';\nimport { Cache, readCache, writeCache } from './cache.js';\nimport { featureFlagsFromGates, featureFlagsToMlOption } from './feature-flags.js';\nimport {\n  DynamicProof,\n  Proof,\n  ProofBase,\n  ProofClass,\n  ProofValue,\n  dummyProof,\n  extractProofTypes,\n  extractProofs,\n} from './proof.js';\nimport { decodeProverKey, encodeProverKey, parseHeader } from './prover-keys.js';\nimport { VerificationKey } from './verification-key.js';\nimport { DeclaredProof, ZkProgramContext } from './zkprogram-context.js';\n\n// public API\nexport { Empty, JsonProof, Method, SelfProof, Undefined, Void, ZkProgram, verify };\n\n// internal API\nexport {\n  CompiledTag,\n  MethodInterface,\n  MethodReturnType,\n  PrivateInput,\n  Proof,\n  Prover,\n  RegularProver,\n  TupleToInstances,\n  analyzeMethod,\n  compileProgram,\n  computeMaxProofsVerified,\n  dummyBase64Proof,\n  inCircuitVkHash,\n  picklesRuleFromFunction,\n  sortMethodArguments,\n};\n\ntype Undefined = undefined;\nconst Undefined: ProvablePureExtended<undefined, undefined, null> = EmptyUndefined<Field>();\ntype Empty = Undefined;\nconst Empty = Undefined;\ntype Void = undefined;\nconst Void: ProvablePureExtended<void, void, null> = EmptyVoid<Field>();\n\ntype MethodAnalysis = ConstraintSystemSummary & {\n  proofs: ProofClass[];\n};\n\nfunction createProgramState() {\n  let methodCache: Map<string, unknown> = new Map();\n  return {\n    setNonPureOutput(value: any[]) {\n      methodCache.set('__nonPureOutput__', value);\n    },\n    getNonPureOutput(): any[] {\n      let entry = methodCache.get('__nonPureOutput__');\n      if (entry === undefined) return [];\n      return entry as any[];\n    },\n    setAuxiliaryOutput(value: unknown, methodName: string) {\n      methodCache.set(methodName, value);\n    },\n    getAuxiliaryOutput(methodName: string): unknown {\n      let entry = methodCache.get(methodName);\n      if (entry === undefined) throw Error(`Auxiliary value for method ${methodName} not defined`);\n      return entry;\n    },\n    reset(key: string) {\n      methodCache.delete(key);\n    },\n  };\n}\n\n/**\n * Initializes Pickles bindings, serializes the input proof and verification key for use in OCaml, then calls into the Pickles verify function and returns the result.\n *\n * @note This function is meant to be called in JavaScript, not for use in a circuit.  The verification key data and hash are not confirmed to match.\n * @param proof Either a `Proof` instance or a serialized JSON proof\n * @param verificationKey Either a base64 serialized verification key or a `VerificationKey` instance which will be base64 serialized for use in the bindings.\n * @returns A promise that resolves to a boolean indicating whether the proof is valid.\n */\nasync function verify(\n  proof: ProofBase<any, any> | JsonProof,\n  verificationKey: Base64VerificationKeyString | VerificationKey\n) {\n  await initializeBindings();\n  let picklesProof: Pickles.Proof;\n  let statement: Pickles.Statement<FieldConst>;\n  if (typeof proof.proof === 'string') {\n    // json proof\n    [, picklesProof] = Pickles.proofOfBase64(proof.proof, proof.maxProofsVerified);\n    let input = MlFieldConstArray.to((proof as JsonProof).publicInput.map(Field));\n    let output = MlFieldConstArray.to((proof as JsonProof).publicOutput.map(Field));\n    statement = MlPair(input, output);\n  } else {\n    // proof class\n    picklesProof = proof.proof;\n    let fields = (proof as ProofBase).publicFields();\n    let input = MlFieldConstArray.to(fields.input);\n    let output = MlFieldConstArray.to(fields.output);\n    statement = MlPair(input, output);\n  }\n  let vk = typeof verificationKey === 'string' ? verificationKey : verificationKey.data;\n  return prettifyStacktracePromise(\n    withThreadPool(() => Pickles.verify(statement, picklesProof, vk))\n  );\n}\n\n/**\n * Serializable representation of a Pickles proof, useful for caching compiled proofs.\n */\ntype JsonProof = {\n  /** Array of string, where each string is a `Field` in the publicInput of this proof */\n  publicInput: string[];\n  /** Array of string, where each string is a `Field` in the publicOutput of this proof */\n  publicOutput: string[];\n  maxProofsVerified: 0 | 1 | 2;\n  proof: Base64ProofString;\n};\ntype CompiledTag = unknown;\n\nlet compiledTags = new WeakMap<any, CompiledTag>();\nlet CompiledTag = {\n  get(tag: any): CompiledTag | undefined {\n    return compiledTags.get(tag);\n  },\n  store(tag: any, compiledTag: CompiledTag) {\n    compiledTags.set(tag, compiledTag);\n  },\n};\n\nlet sideloadedKeysMap: Record<string, unknown> = {};\nlet SideloadedTag = {\n  get(tag: string): unknown | undefined {\n    return sideloadedKeysMap[tag];\n  },\n  store(tag: string, compiledTag: unknown) {\n    sideloadedKeysMap[tag] = compiledTag;\n  },\n};\n\ntype ConfigBaseType = {\n  publicInput?: ProvableType;\n  publicOutput?: ProvableType;\n  methods: {\n    [I in string]: {\n      privateInputs: Tuple<PrivateInput>;\n      auxiliaryOutput?: ProvableType;\n    };\n  };\n};\n\ntype InferMethodSignatures<Config extends ConfigBaseType> = Config['methods'];\ntype InferPrivateInput<Config extends ConfigBaseType> = {\n  [I in keyof Config['methods']]: Config['methods'][I]['privateInputs'];\n};\ntype InferAuxiliaryOutputs<Config extends ConfigBaseType> = {\n  [I in keyof InferMethodSignatures<Config>]: Get<\n    InferMethodSignatures<Config>[I],\n    'auxiliaryOutput'\n  >;\n};\ntype InferMethodType<Config extends ConfigBaseType> = {\n  [I in keyof Config['methods']]: Method<\n    InferProvableOrUndefined<Get<Config, 'publicInput'>>,\n    InferProvableOrVoid<Get<Config, 'publicOutput'>>,\n    Config['methods'][I]\n  >;\n};\n\n/**\n * Wraps config + provable code into a program capable of producing {@link Proof}s.\n *\n * @example\n * ```ts\n * const ExampleProgram = ZkProgram({\n *   name: 'ExampleProgram',\n *   publicOutput: Int64,\n *   methods: {\n *     // Prove that I know 2 numbers less than 100 each, whose product is greater than 1000\n *     provableMultiply: {\n *       privateInputs: [Int64, Int64],\n *       method: async (n1: Int64, n2: Int64) => {\n *         n1.assertLessThan(100);\n *         n2.assertLessThan(100);\n *         const publicOutput = n1.mul(n2);\n *         publicOutput.assertGreaterThan(1000);\n *         return { publicOutput: n1.mul(n2) }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @param config The configuration of the program, describing the type of the public input and public output, as well as defining the methods which can be executed provably.\n * @returns an object that can be used to compile, prove, and verify the program.\n */\nfunction ZkProgram<\n  Config extends ConfigBaseType,\n  _ extends unknown = unknown, // weird hack that makes methods infer correctly when their inputs are not annotated\n>(\n  config: Config & {\n    name: string;\n    methods: {\n      [I in keyof Config['methods']]: InferMethodType<Config>[I];\n    };\n    overrideWrapDomain?: 0 | 1 | 2;\n    numChunks?: number;\n  }\n): {\n  name: string;\n  maxProofsVerified(): Promise<0 | 1 | 2>;\n\n  compile: (options?: {\n    cache?: Cache;\n    forceRecompile?: boolean;\n    proofsEnabled?: boolean;\n    withRuntimeTables?: boolean;\n    numChunks?: number;\n    lazyMode?: boolean;\n  }) => Promise<{\n    verificationKey: { data: string; hash: Field };\n  }>;\n  verify: (\n    proof: Proof<\n      InferProvableOrUndefined<Get<Config, 'publicInput'>>,\n      InferProvableOrVoid<Get<Config, 'publicOutput'>>\n    >\n  ) => Promise<boolean>;\n  digest: () => Promise<string>;\n  /**\n   * Analyze the constraint system created by each method in the program.\n   * Every method is executed in a circuit, and the constraints are analyzed.\n   *\n   * @returns A summary of this ZkProgram, keyed by the method name, with a value of the {@link MethodAnalysis} for that method\n   */\n  analyzeMethods: () => Promise<{\n    [I in keyof Config['methods']]: MethodAnalysis;\n  }>;\n  /**\n   * Analyze the constraint system created by a single method in the program without analyzing any other methods and executing them.\n   *\n   * @returns A summary of this method, with a value of the {@link MethodAnalysis} for that method\n   */\n  analyzeSingleMethod<K extends keyof Config['methods']>(methodName: K): Promise<MethodAnalysis>;\n  publicInputType: ProvableOrUndefined<Get<Config, 'publicInput'>>;\n  publicOutputType: ProvableOrVoid<Get<Config, 'publicOutput'>>;\n  privateInputTypes: InferPrivateInput<Config>;\n  auxiliaryOutputTypes: InferAuxiliaryOutputs<Config>;\n  rawMethods: {\n    [I in keyof Config['methods']]: InferMethodType<Config>[I]['method'];\n  };\n\n  Proof: typeof Proof<\n    InferProvableOrUndefined<Get<Config, 'publicInput'>>,\n    InferProvableOrVoid<Get<Config, 'publicOutput'>>\n  >;\n\n  proofsEnabled: boolean;\n  setProofsEnabled(proofsEnabled: boolean): void;\n} & {\n  [I in keyof Config['methods']]: Prover<\n    InferProvableOrUndefined<Get<Config, 'publicInput'>>,\n    ProvableOrUndefined<Get<Config, 'publicInput'>>,\n    InferProvableOrVoid<Get<Config, 'publicOutput'>>,\n    InferPrivateInput<Config>[I],\n    InferProvableOrUndefined<InferAuxiliaryOutputs<Config>[I]>\n  >;\n} {\n  type PublicInputType = ProvableOrUndefined<Get<Config, 'publicInput'>>;\n  type PublicInput = InferProvableOrUndefined<Get<Config, 'publicInput'>>;\n  type PublicOutput = InferProvableOrVoid<Get<Config, 'publicOutput'>>;\n  // derived types for convenience\n  type Methods = InferMethodSignatures<Config>;\n  type PrivateInputs = InferPrivateInput<Config>;\n  type AuxiliaryOutputs = InferAuxiliaryOutputs<Config>;\n\n  let doProving = true;\n\n  let methods = config.methods;\n  let publicInputType: Provable<any> = ProvableType.get(config.publicInput ?? Undefined);\n  let hasPublicInput = publicInputType !== Undefined && publicInputType !== Void;\n  let publicOutputType: Provable<any> = ProvableType.get(config.publicOutput ?? Void);\n\n  let selfTag = { name: config.name };\n\n  class SelfProof extends Proof<PublicInput, PublicOutput> {\n    static publicInputType = publicInputType;\n    static publicOutputType = publicOutputType;\n    static tag = () => selfTag;\n  }\n\n  type MethodKey = keyof Config['methods'];\n  // TODO remove sort()! Object.keys() has a deterministic order\n  let methodKeys: MethodKey[] = Object.keys(methods).sort(); // need to have methods in (any) fixed order\n  let methodIntfs = methodKeys.map((key) =>\n    sortMethodArguments(\n      'program',\n      key as string,\n      methods[key].privateInputs,\n      ProvableType.get(methods[key].auxiliaryOutput) ?? Undefined,\n      SelfProof\n    )\n  );\n  let methodFunctions = methodKeys.map((key) => methods[key].method);\n  let privateInputTypes = methodIntfs.map((m) => m.args);\n  let maxProofsVerified: undefined | 0 | 1 | 2 = undefined;\n\n  async function getMaxProofsVerified() {\n    if (maxProofsVerified !== undefined) return maxProofsVerified;\n    let methodsMeta = await analyzeMethods();\n    let proofs = methodKeys.map((k) => methodsMeta[k].proofs.length);\n    maxProofsVerified = computeMaxProofsVerified(proofs);\n    return maxProofsVerified;\n  }\n\n  async function analyzeMethods() {\n    let methodsMeta: Record<string, MethodAnalysis> = {};\n    for (let i = 0; i < methodIntfs.length; i++) {\n      let methodEntry = methodIntfs[i];\n      methodsMeta[methodEntry.methodName] = await analyzeMethod(\n        publicInputType,\n        methodEntry,\n        methodFunctions[i]\n      );\n    }\n    return methodsMeta as {\n      [I in keyof Methods]: MethodAnalysis;\n    };\n  }\n\n  async function analyzeSingleMethod<K extends keyof Methods>(\n    methodName: K\n  ): Promise<MethodAnalysis> {\n    let methodIntf = methodIntfs[methodKeys.indexOf(methodName)];\n    let methodImpl = methodFunctions[methodKeys.indexOf(methodName)];\n    return await analyzeMethod(publicInputType, methodIntf, methodImpl);\n  }\n\n  let compileOutput:\n    | {\n        provers: Pickles.Prover[];\n        maxProofsVerified: 0 | 1 | 2;\n        verify: (\n          statement: Pickles.Statement<FieldConst>,\n          proof: Pickles.Proof\n        ) => Promise<boolean>;\n      }\n    | undefined;\n\n  const programState = createProgramState();\n\n  async function compile({\n    cache = Cache.FileSystemDefault,\n    forceRecompile = false,\n    proofsEnabled = undefined as boolean | undefined,\n    withRuntimeTables = false,\n    lazyMode = false,\n  } = {}) {\n    doProving = proofsEnabled ?? doProving;\n\n    if (doProving) {\n      let methodsMeta = await analyzeMethods();\n      let gates = methodKeys.map((k) => methodsMeta[k].gates);\n      let proofs = methodKeys.map((k) => methodsMeta[k].proofs);\n      maxProofsVerified = computeMaxProofsVerified(proofs.map((p) => p.length));\n\n      let { provers, verify, verificationKey } = await compileProgram({\n        publicInputType,\n        publicOutputType,\n        methodIntfs,\n        methods: methodFunctions,\n        gates,\n        proofs,\n        proofSystemTag: selfTag,\n        cache,\n        forceRecompile,\n        overrideWrapDomain: config.overrideWrapDomain,\n        numChunks: config.numChunks,\n        state: programState,\n        withRuntimeTables,\n        lazyMode,\n      });\n\n      compileOutput = { provers, verify, maxProofsVerified };\n      return { verificationKey };\n    } else {\n      return {\n        verificationKey: VerificationKey.empty(),\n      };\n    }\n  }\n\n  // for each of the methods, create a prover function.\n  // in the first step, these are \"regular\" in that they always expect the public input as the first argument,\n  // which is easier to use internally.\n  type RegularProver_<K extends MethodKey> = RegularProver<\n    PublicInput,\n    PublicInputType,\n    PublicOutput,\n    PrivateInputs[K],\n    InferProvableOrUndefined<AuxiliaryOutputs[K]>\n  >;\n\n  function toRegularProver<K extends MethodKey>(key: K, i: number): RegularProver_<K> {\n    return async function prove_(inputPublicInput, ...inputArgs) {\n      let publicInput = publicInputType.fromValue(inputPublicInput);\n      let args = zip(inputArgs, privateInputTypes[i]).map(([arg, type]) =>\n        ProvableType.get(type).fromValue(arg)\n      );\n      if (!doProving) {\n        // we step into a ZkProgramContext here to match the context nesting\n        // that would happen if proofs were enabled -- otherwise, proofs declared\n        // in an inner program could be counted to the outer program\n        let id = ZkProgramContext.enter();\n        try {\n          let { publicOutput, auxiliaryOutput } =\n            (hasPublicInput\n              ? await (methods[key].method as any)(publicInput, ...args)\n              : await (methods[key].method as any)(...args)) ?? {};\n\n          let proof = await SelfProof.dummy(\n            publicInput,\n            publicOutput,\n            await getMaxProofsVerified()\n          );\n          return { proof, auxiliaryOutput };\n        } finally {\n          ZkProgramContext.leave(id);\n        }\n      }\n\n      if (compileOutput === undefined) {\n        throw Error(\n          `Cannot prove execution of program.${String(key)}(), no prover found. ` +\n            `Try calling \\`await program.compile()\\` first, this will cache provers in the background.\\nIf you compiled your zkProgram with proofs disabled (\\`proofsEnabled = false\\`), you have to compile it with proofs enabled first.`\n        );\n      }\n      let picklesProver = compileOutput.provers[i];\n      let maxProofsVerified = compileOutput.maxProofsVerified;\n\n      let { publicInputFields, publicInputAux } = toFieldAndAuxConsts(publicInputType, publicInput);\n\n      let id = snarkContext.enter({\n        witnesses: args,\n        inProver: true,\n        auxInputData: publicInputAux,\n      });\n\n      let result: UnwrapPromise<ReturnType<typeof picklesProver>>;\n      try {\n        result = await picklesProver(publicInputFields);\n      } finally {\n        snarkContext.leave(id);\n      }\n\n      let auxiliaryType = methodIntfs[i].auxiliaryType;\n      let auxiliaryOutputExists = auxiliaryType && auxiliaryType.sizeInFields() !== 0;\n\n      let auxiliaryOutput;\n      if (auxiliaryOutputExists) {\n        auxiliaryOutput = programState.getAuxiliaryOutput(methodIntfs[i].methodName);\n\n        programState.reset(methodIntfs[i].methodName);\n      }\n\n      let [publicOutputFields, proof] = MlPair.from(result);\n\n      let nonPureOutput = programState.getNonPureOutput();\n\n      let publicOutput = fromFieldConsts(publicOutputType, publicOutputFields, nonPureOutput);\n\n      programState.reset('__nonPureOutput__');\n\n      return {\n        proof: new SelfProof({\n          publicInput,\n          publicOutput,\n          proof,\n          maxProofsVerified,\n        }),\n        auxiliaryOutput,\n      };\n    };\n  }\n  let regularProvers = mapToObject(methodKeys, toRegularProver);\n\n  // wrap \"regular\" provers to remove an `undefined` public input argument,\n  // this matches how the method itself was defined in the case of no public input\n  type Prover_<K extends MethodKey = MethodKey> = Prover<\n    PublicInput,\n    PublicInputType,\n    PublicOutput,\n    PrivateInputs[K],\n    InferProvableOrUndefined<AuxiliaryOutputs[K]>\n  >;\n  type Provers = {\n    [K in MethodKey]: Prover_<K>;\n  };\n  let provers: Provers = mapObject(regularProvers, (prover): Prover_ => {\n    if (publicInputType === Undefined || publicInputType === Void) {\n      return ((...args: any) => prover(undefined as any, ...args)) as any;\n    } else {\n      return prover as any;\n    }\n  });\n\n  function verify(proof: Proof<PublicInput, PublicOutput>) {\n    if (!doProving) {\n      return Promise.resolve(true);\n    }\n    if (compileOutput?.verify === undefined) {\n      throw Error(\n        `Cannot verify proof, verification key not found. Try calling \\`await program.compile()\\` first.`\n      );\n    }\n    let statement = MlPair(\n      toFieldConsts(publicInputType, proof.publicInput),\n      toFieldConsts(publicOutputType, proof.publicOutput)\n    );\n    return compileOutput.verify(statement, proof.proof);\n  }\n\n  async function digest() {\n    let methodsMeta = await analyzeMethods();\n    let digests: Field[] = methodKeys.map((k) => Field(BigInt('0x' + methodsMeta[k].digest)));\n    return hashConstant(digests).toBigInt().toString(16);\n  }\n\n  const program = Object.assign(\n    selfTag,\n    {\n      maxProofsVerified: getMaxProofsVerified,\n\n      compile,\n      verify,\n      digest,\n\n      analyzeMethods,\n      analyzeSingleMethod,\n\n      publicInputType: publicInputType as ProvableOrUndefined<Get<Config, 'publicInput'>>,\n      publicOutputType: publicOutputType as ProvableOrVoid<Get<Config, 'publicOutput'>>,\n      privateInputTypes: mapToObject(methodKeys, (_, i) => privateInputTypes[i]) as any,\n      auxiliaryOutputTypes: Object.fromEntries(\n        methodKeys.map((key) => [key, methods[key].auxiliaryOutput])\n      ) as any,\n      rawMethods: Object.fromEntries(methodKeys.map((key) => [key, methods[key].method])) as any,\n\n      Proof: SelfProof,\n\n      proofsEnabled: doProving,\n      setProofsEnabled(proofsEnabled: boolean) {\n        doProving = proofsEnabled;\n      },\n    },\n    provers\n  );\n\n  // Object.assign only shallow-copies, hence we can't use this getter and have to define it explicitly\n  Object.defineProperty(program, 'proofsEnabled', {\n    get: () => doProving,\n  });\n\n  return program;\n}\n\ntype ZkProgram<\n  Config extends {\n    publicInput?: ProvableType;\n    publicOutput?: ProvableType;\n    methods: {\n      [I in string]: {\n        privateInputs: Tuple<PrivateInput>;\n        auxiliaryOutput?: ProvableType;\n      };\n    };\n  },\n> = ReturnType<typeof ZkProgram<Config>>;\n\n/**\n * A class representing the type of Proof produced by the {@link ZkProgram} in which it is used.\n *\n * @example\n * ```ts\n * const ExampleProgram = ZkProgram({\n *   name: 'ExampleProgram',\n *   publicOutput: Field,\n *   methods: {\n *     baseCase: {\n *       privateInputs: [],\n *       method: async () => {\n *         return { publicOutput: Field(0) }\n *       }\n *     },\n *     add: {\n *       privateInputs: [SelfProof, Field],\n *       // `previous` is the type of proof produced by ExampleProgram\n *       method: async (previous: SelfProof<undefined, Field>, f: Field) => {\n *         previous.verify();\n *         return { publicOutput: previous.publicOutput.add(f) }\n *       }\n *     }\n *   }\n * });\n * ```\n */\nclass SelfProof<PublicInput, PublicOutput> extends Proof<PublicInput, PublicOutput> {}\n\nfunction sortMethodArguments(\n  programName: string,\n  methodName: string,\n  privateInputs: unknown[],\n  auxiliaryType: Provable<any> | undefined,\n  selfProof: Subclass<typeof Proof>\n): MethodInterface {\n  // replace SelfProof with the actual selfProof\n  // TODO this does not handle SelfProof nested in inputs\n  privateInputs = privateInputs.map((input) => (input === SelfProof ? selfProof : input));\n\n  // check if all arguments are provable\n  let args: ProvableType<unknown>[] = privateInputs.map((input, i) => {\n    if (isProvable(input)) return input;\n\n    throw Error(`Argument ${i + 1} of method ${methodName} is not a provable type: ${input}`);\n  });\n\n  // extract input proofs to count them and for sanity checks\n  // WARNING: this doesn't include internally declared proofs!\n  let proofs = args.flatMap(extractProofTypes);\n  let numberOfProofs = proofs.length;\n\n  // don't allow base classes for proofs\n  proofs.forEach((proof) => {\n    if (proof === ProofBase || proof === Proof || proof === DynamicProof) {\n      throw Error(\n        `You cannot use the \\`${proof.name}\\` class directly. Instead, define a subclass:\\n` +\n          `class MyProof extends ${proof.name}<PublicInput, PublicOutput> { ... }`\n      );\n    }\n  });\n\n  // don't allow more than 2 proofs\n  if (numberOfProofs > 2) {\n    throw Error(\n      `${programName}.${methodName}() has more than two proof arguments, which is not supported.\\n` +\n        `Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`\n    );\n  }\n  return { methodName, args, auxiliaryType };\n}\n\nfunction isProvable(type: unknown): type is ProvableType<unknown> {\n  let type_ = ProvableType.get(type);\n  return (\n    (typeof type_ === 'function' || typeof type_ === 'object') &&\n    type_ !== null &&\n    ['toFields', 'fromFields', 'sizeInFields', 'toAuxiliary'].every((s) => s in type_)\n  );\n}\n\nfunction isDynamicProof(type: Subclass<typeof ProofBase>): type is Subclass<typeof DynamicProof> {\n  return typeof type === 'function' && type.prototype instanceof DynamicProof;\n}\n\ntype MethodInterface = {\n  methodName: string;\n  args: ProvableType<unknown>[];\n  returnType?: Provable<any>;\n  auxiliaryType?: Provable<any>;\n};\n\n// reasonable default choice for `overrideWrapDomain`\nconst maxProofsToWrapDomain = { 0: 0, 1: 1, 2: 1 } as const;\n\nasync function compileProgram({\n  publicInputType,\n  publicOutputType,\n  methodIntfs,\n  methods,\n  gates,\n  proofs,\n  proofSystemTag,\n  cache,\n  forceRecompile,\n  overrideWrapDomain,\n  numChunks,\n  state,\n  withRuntimeTables,\n  lazyMode,\n}: {\n  publicInputType: Provable<any>;\n  publicOutputType: Provable<any>;\n  methodIntfs: MethodInterface[];\n  methods: ((...args: any) => unknown)[];\n  gates: Gate[][];\n  proofs: ProofClass[][];\n  proofSystemTag: { name: string };\n  cache: Cache;\n  forceRecompile: boolean;\n  overrideWrapDomain?: 0 | 1 | 2;\n  numChunks?: number;\n  state?: ReturnType<typeof createProgramState>;\n  withRuntimeTables?: boolean;\n  lazyMode?: boolean;\n}) {\n  await initializeBindings();\n  if (methodIntfs.length === 0)\n    throw Error(`The Program you are trying to compile has no methods.\nTry adding a method to your ZkProgram or SmartContract.\nIf you are using a SmartContract, make sure you are using the @method decorator.`);\n\n  let rules = methodIntfs.map((methodEntry, i) =>\n    picklesRuleFromFunction(\n      publicInputType,\n      publicOutputType,\n      methods[i],\n      proofSystemTag,\n      methodEntry,\n      gates[i],\n      proofs[i],\n      state,\n      withRuntimeTables\n    )\n  );\n\n  let maxProofs = computeMaxProofsVerified(proofs.map((p) => p.length));\n  overrideWrapDomain ??= maxProofsToWrapDomain[maxProofs];\n  let picklesCache: Pickles.Cache = [\n    0,\n    function read_(mlHeader) {\n      if (forceRecompile) return MlResult.unitError();\n      let header = parseHeader(proofSystemTag.name, methodIntfs, mlHeader);\n      let result = readCache(cache, header, (bytes) => decodeProverKey(mlHeader, bytes));\n      if (result === undefined) return MlResult.unitError();\n      return MlResult.ok(result);\n    },\n    function write_(mlHeader, value) {\n      if (!cache.canWrite) return MlResult.unitError();\n\n      let header = parseHeader(proofSystemTag.name, methodIntfs, mlHeader);\n      let didWrite = writeCache(cache, header, encodeProverKey(value));\n\n      if (!didWrite) return MlResult.unitError();\n      return MlResult.ok(undefined);\n    },\n    MlBool(cache.canWrite),\n  ];\n\n  let { verificationKey, provers, verify, tag } = await prettifyStacktracePromise(\n    withThreadPool(async () => {\n      let result: ReturnType<typeof Pickles.compile>;\n      let id = snarkContext.enter({ inCompile: true });\n      setSrsCache(cache);\n      try {\n        result = Pickles.compile(MlArray.to(rules), {\n          publicInputSize: publicInputType.sizeInFields(),\n          publicOutputSize: publicOutputType.sizeInFields(),\n          storable: picklesCache,\n          overrideWrapDomain,\n          numChunks: numChunks ?? 1,\n          lazyMode: lazyMode ?? false,\n        });\n        let { getVerificationKey, provers, verify, tag } = result;\n        CompiledTag.store(proofSystemTag, tag);\n        let [, data, hash] = await getVerificationKey();\n        let verificationKey = { data, hash: Field(hash) };\n        return {\n          verificationKey,\n          provers: MlArray.from(provers),\n          verify,\n          tag,\n        };\n      } finally {\n        snarkContext.leave(id);\n        unsetSrsCache();\n      }\n    })\n  );\n  // wrap provers\n  let wrappedProvers = provers.map(\n    (prover): Pickles.Prover =>\n      async function picklesProver(publicInput: MlFieldConstArray) {\n        return prettifyStacktracePromise(withThreadPool(() => prover(publicInput)));\n      }\n  );\n  // wrap verify\n  let wrappedVerify = async function picklesVerify(\n    statement: Pickles.Statement<FieldConst>,\n    proof: Pickles.Proof\n  ) {\n    return prettifyStacktracePromise(withThreadPool(() => verify(statement, proof)));\n  };\n  return {\n    verificationKey,\n    provers: wrappedProvers,\n    verify: wrappedVerify,\n    tag,\n  };\n}\n\nasync function analyzeMethod(\n  publicInputType: Provable<any>,\n  methodIntf: MethodInterface,\n  method: (...args: any) => unknown\n): Promise<MethodAnalysis> {\n  let result: ConstraintSystemSummary;\n  let proofs: ProofClass[];\n  let id = ZkProgramContext.enter();\n  try {\n    result = await Provable.constraintSystem(() => {\n      let args = methodIntf.args.map(emptyWitness);\n      args.forEach((value) => extractProofs(value).forEach((proof) => proof.declare()));\n\n      let publicInput = emptyWitness(publicInputType);\n      // note: returning the method result here makes this handle async methods\n      if (publicInputType === Undefined || publicInputType === Void) return method(...args);\n      return method(publicInput, ...args);\n    });\n    proofs = ZkProgramContext.getDeclaredProofs().map(({ ProofClass }) => ProofClass);\n  } finally {\n    ZkProgramContext.leave(id);\n  }\n  return { ...result, proofs };\n}\n\nfunction inCircuitVkHash(inCircuitVk: unknown): Field {\n  const digest = Pickles.sideLoaded.vkDigest(inCircuitVk);\n\n  const salt = Snarky.poseidon.update(\n    MlFieldArray.to([Field(0), Field(0), Field(0)]),\n    MlFieldArray.to([prefixToField(Field, prefixes.sideLoadedVK)])\n  );\n\n  const newState = Snarky.poseidon.update(salt, digest);\n  const stateFields = MlFieldArray.from(newState) as [Field, Field, Field];\n  return stateFields[0];\n}\n\nfunction picklesRuleFromFunction(\n  publicInputType: Provable<unknown>,\n  publicOutputType: Provable<unknown>,\n  func: (...args: unknown[]) => unknown,\n  proofSystemTag: { name: string },\n  { methodName, args, auxiliaryType }: MethodInterface,\n  gates: Gate[],\n  verifiedProofs: ProofClass[],\n  state?: ReturnType<typeof createProgramState>,\n  withRuntimeTables?: boolean\n): Pickles.Rule {\n  async function main(publicInput: MlFieldArray): ReturnType<Pickles.Rule['main']> {\n    let { witnesses: argsWithoutPublicInput, inProver, auxInputData } = snarkContext.get();\n    assert(!(inProver && argsWithoutPublicInput === undefined));\n\n    // witness private inputs and declare input proofs\n    let id = ZkProgramContext.enter();\n    let finalArgs = [];\n    for (let i = 0; i < args.length; i++) {\n      try {\n        let type = args[i];\n        let value = Provable.witness(type, () => {\n          return argsWithoutPublicInput?.[i] ?? ProvableType.synthesize(type);\n        });\n        finalArgs[i] = value;\n\n        extractProofs(value).forEach((proof) => proof.declare());\n      } catch (e: any) {\n        ZkProgramContext.leave(id);\n        e.message = `Error when witnessing in ${methodName}, argument ${i}: ${e.message}`;\n        throw e;\n      }\n    }\n\n    // run the user circuit\n    let result: { publicOutput?: any; auxiliaryOutput?: any };\n    let proofs: DeclaredProof[];\n\n    try {\n      if (publicInputType === Undefined || publicInputType === Void) {\n        result = (await func(...finalArgs)) as any;\n      } else {\n        let input = fromFieldVars(publicInputType, publicInput, auxInputData);\n        result = (await func(input, ...finalArgs)) as any;\n      }\n      proofs = ZkProgramContext.getDeclaredProofs();\n    } finally {\n      ZkProgramContext.leave(id);\n    }\n\n    if (result?.publicOutput) {\n      // store the nonPure auxiliary data in program state cache if it exists\n      let nonPureOutput = publicOutputType.toAuxiliary(result.publicOutput);\n      state?.setNonPureOutput(nonPureOutput);\n    }\n\n    // now all proofs are declared - check that we got as many as during compile time\n    assert(\n      proofs.length === verifiedProofs.length,\n      `Expected ${verifiedProofs.length} proofs, but got ${proofs.length}`\n    );\n\n    // extract proof statements for Pickles\n    let previousStatements = proofs.map(({ proofInstance }): Pickles.Statement<FieldVar> => {\n      let fields = proofInstance.publicFields();\n      let input = MlFieldArray.to(fields.input);\n      let output = MlFieldArray.to(fields.output);\n      return MlPair(input, output);\n    });\n\n    // handle dynamic proofs\n    proofs.forEach(({ ProofClass, proofInstance }) => {\n      if (!(proofInstance instanceof DynamicProof)) return;\n\n      // Initialize side-loaded verification key\n      const tag = ProofClass.tag();\n      const computedTag = SideloadedTag.get(tag.name);\n      const vk = proofInstance.usedVerificationKey;\n\n      if (vk === undefined) {\n        throw new Error('proof.verify() not called, call it at least once in your circuit');\n      }\n\n      if (Provable.inProver()) {\n        Pickles.sideLoaded.inProver(computedTag, vk.data);\n      }\n      const circuitVk = Pickles.sideLoaded.vkToCircuit(() => vk.data);\n\n      // Assert the validity of the auxiliary vk-data by comparing the witnessed and computed hash\n      const hash = inCircuitVkHash(circuitVk);\n      Field(hash).assertEquals(vk.hash, 'Provided VerificationKey hash not correct');\n      Pickles.sideLoaded.inCircuit(computedTag, circuitVk);\n    });\n\n    // if the output is empty, we don't evaluate `toFields(result)` to allow the function to return something else in that case\n    let hasPublicOutput = publicOutputType.sizeInFields() !== 0;\n    let publicOutput = hasPublicOutput ? publicOutputType.toFields(result.publicOutput) : [];\n\n    if (state !== undefined && auxiliaryType !== undefined && auxiliaryType.sizeInFields() !== 0) {\n      Provable.asProver(() => {\n        let { auxiliaryOutput } = result;\n        assert(\n          auxiliaryOutput !== undefined,\n          `${proofSystemTag.name}.${methodName}(): Auxiliary output is undefined even though the method declares it.`\n        );\n        state.setAuxiliaryOutput(Provable.toConstant(auxiliaryType, auxiliaryOutput), methodName);\n      });\n    }\n\n    return {\n      publicOutput: MlFieldArray.to(publicOutput),\n      previousStatements: MlArray.to(previousStatements),\n      previousProofs: MlArray.to(proofs.map((p) => p.proofInstance.proof)),\n      shouldVerify: MlArray.to(\n        proofs.map((proof) => proof.proofInstance.shouldVerify.toField().value)\n      ),\n    };\n  }\n\n  if (verifiedProofs.length > 2) {\n    throw Error(\n      `${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.\\n` +\n        `Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`\n    );\n  }\n  let proofsToVerify = verifiedProofs.map((Proof) => {\n    let tag = Proof.tag();\n    if (tag === proofSystemTag) return { isSelf: true as const };\n    else if (isDynamicProof(Proof)) {\n      let computedTag: unknown;\n      // Only create the tag if it hasn't already been created for this specific Proof class\n      if (SideloadedTag.get(tag.name) === undefined) {\n        computedTag = Pickles.sideLoaded.create(\n          tag.name,\n          Proof.maxProofsVerified,\n          Proof.publicInputType?.sizeInFields() ?? 0,\n          Proof.publicOutputType?.sizeInFields() ?? 0,\n          featureFlagsToMlOption(Proof.featureFlags, withRuntimeTables)\n        );\n        SideloadedTag.store(tag.name, computedTag);\n      } else {\n        computedTag = SideloadedTag.get(tag.name);\n      }\n      return { isSelf: false, tag: computedTag };\n    } else {\n      let compiledTag = CompiledTag.get(tag);\n      if (compiledTag === undefined) {\n        throw Error(\n          `${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.\\n` +\n            `Try to run ${tag.name}.compile() first.`\n        );\n      }\n      return { isSelf: false, tag: compiledTag };\n    }\n  });\n\n  let featureFlags = featureFlagsToMlOption(featureFlagsFromGates(gates, withRuntimeTables));\n\n  return {\n    identifier: methodName,\n    main,\n    featureFlags,\n    proofsToVerify: MlArray.to(proofsToVerify),\n  };\n}\n\nfunction computeMaxProofsVerified(proofs: number[]) {\n  return proofs.reduce((acc: number, n) => {\n    assert(n <= 2, 'Too many proofs');\n    return Math.max(acc, n);\n  }, 0) as 0 | 1 | 2;\n}\n\nfunction fromFieldVars<T>(type: Provable<T>, fields: MlFieldArray, auxData: any[] = []) {\n  return type.fromFields(MlFieldArray.from(fields), auxData);\n}\n\nfunction fromFieldConsts<T>(type: Provable<T>, fields: MlFieldConstArray, aux: any[] = []) {\n  return type.fromFields(MlFieldConstArray.from(fields), aux);\n}\n\nfunction toFieldConsts<T>(type: Provable<T>, value: T) {\n  return MlFieldConstArray.to(type.toFields(value));\n}\n\nfunction toFieldAndAuxConsts<T>(type: Provable<T>, value: T) {\n  return {\n    publicInputFields: MlFieldConstArray.to(type.toFields(value)),\n    publicInputAux: type.toAuxiliary(value),\n  };\n}\n\nZkProgram.Proof = function <\n  PublicInputType extends FlexibleProvable<any>,\n  PublicOutputType extends FlexibleProvable<any>,\n>(program: {\n  name: string;\n  publicInputType: PublicInputType;\n  publicOutputType: PublicOutputType;\n}): typeof Proof<InferProvable<PublicInputType>, InferProvable<PublicOutputType>> & {\n  provable: Provable<\n    Proof<InferProvable<PublicInputType>, InferProvable<PublicOutputType>>,\n    ProofValue<InferValue<PublicInputType>, InferValue<PublicOutputType>>\n  >;\n} {\n  return class ZkProgramProof extends Proof<any, any> {\n    static publicInputType = program.publicInputType;\n    static publicOutputType = program.publicOutputType;\n    static tag = () => program;\n  };\n};\n\nlet dummyProofCache: string | undefined;\n\nasync function dummyBase64Proof() {\n  if (dummyProofCache) return dummyProofCache;\n  let proof = await dummyProof(2, 15);\n  let base64Proof = Pickles.proofToBase64([2, proof]);\n  dummyProofCache = base64Proof;\n  return base64Proof;\n}\n\n// helpers for circuit context\n\nfunction Prover<ProverData>() {\n  return {\n    async run<Result>(\n      witnesses: unknown[],\n      proverData: ProverData,\n      callback: () => Promise<Result>\n    ) {\n      let id = snarkContext.enter({ witnesses, proverData, inProver: true });\n      try {\n        return await callback();\n      } finally {\n        snarkContext.leave(id);\n      }\n    },\n    getData(): ProverData {\n      return snarkContext.get().proverData;\n    },\n  };\n}\n\n// helper types\n\ntype Infer<T> =\n  T extends Subclass<typeof ProofBase>\n    ? InstanceType<T>\n    : T extends ProvableType\n      ? InferProvableType<T>\n      : never;\n\ntype TupleToInstances<T> = {\n  [I in keyof T]: Infer<T[I]>;\n};\ntype TupleFrom<T> = {\n  [I in keyof T]: From<T[I]>;\n};\n\ntype PrivateInput = ProvableType | Subclass<typeof ProofBase>;\n\ntype MethodReturnType<PublicOutput, AuxiliaryOutput> = PublicOutput extends void\n  ? AuxiliaryOutput extends undefined\n    ? void\n    : {\n        auxiliaryOutput: AuxiliaryOutput;\n      }\n  : AuxiliaryOutput extends undefined\n    ? {\n        publicOutput: PublicOutput;\n      }\n    : {\n        publicOutput: PublicOutput;\n        auxiliaryOutput: AuxiliaryOutput;\n      };\n\ntype Method<\n  PublicInput,\n  PublicOutput,\n  MethodSignature extends {\n    privateInputs: Tuple<PrivateInput>;\n    auxiliaryOutput?: ProvableType;\n  },\n> = PublicInput extends undefined\n  ? {\n      method(\n        ...args: TupleToInstances<MethodSignature['privateInputs']>\n      ): Promise<\n        MethodReturnType<\n          PublicOutput,\n          InferProvableOrUndefined<Get<MethodSignature, 'auxiliaryOutput'>>\n        >\n      >;\n    }\n  : {\n      method(\n        publicInput: PublicInput,\n        ...args: TupleToInstances<MethodSignature['privateInputs']>\n      ): Promise<\n        MethodReturnType<\n          PublicOutput,\n          InferProvableOrUndefined<Get<MethodSignature, 'auxiliaryOutput'>>\n        >\n      >;\n    };\n\ntype RegularProver<\n  PublicInput,\n  PublicInputType,\n  PublicOutput,\n  Args extends Tuple<PrivateInput>,\n  AuxiliaryOutput,\n> = (\n  publicInput: From<PublicInputType>,\n  ...args: TupleFrom<Args>\n) => Promise<{\n  proof: Proof<PublicInput, PublicOutput>;\n  auxiliaryOutput: AuxiliaryOutput;\n}>;\n\ntype Prover<\n  PublicInput,\n  PublicInputType,\n  PublicOutput,\n  Args extends Tuple<PrivateInput>,\n  AuxiliaryOutput,\n> = PublicInput extends undefined\n  ? (...args: TupleFrom<Args>) => Promise<{\n      proof: Proof<PublicInput, PublicOutput>;\n      auxiliaryOutput: AuxiliaryOutput;\n    }>\n  : (\n      publicInput: From<PublicInputType>,\n      ...args: TupleFrom<Args>\n    ) => Promise<{\n      proof: Proof<PublicInput, PublicOutput>;\n      auxiliaryOutput: AuxiliaryOutput;\n    }>;\n\ntype ProvableOrUndefined<A> = A extends undefined ? typeof Undefined : ToProvable<A>;\ntype ProvableOrVoid<A> = A extends undefined ? typeof Void : ToProvable<A>;\n\ntype InferProvableOrUndefined<A> = A extends undefined\n  ? undefined\n  : A extends ProvableType\n    ? InferProvable<A>\n    : InferProvable<A> | undefined;\ntype InferProvableOrVoid<A> = A extends undefined ? void : InferProvable<A>;\n\ntype UnwrapPromise<P> = P extends Promise<infer T> ? T : never;\n", "import {\n  Binable,\n  defineBinable,\n  stringFromBytes,\n  stringLengthInBytes,\n  stringToBytes,\n  withBits,\n} from '../../bindings/lib/binable.js';\nimport { base58 } from '../../lib/util/base58.js';\nimport {\n  HashInputLegacy,\n  hashWithPrefix,\n  packToFieldsLegacy,\n  prefixes,\n} from './poseidon-bigint.js';\nimport { versionBytes } from '../../bindings/crypto/constants.js';\n\nexport { Memo };\n\nfunction fromString(memo: string) {\n  let length = stringLengthInBytes(memo);\n  if (length > 32) throw Error('Memo.fromString: string too long');\n  return `\\x01${String.fromCharCode(length)}${memo}` + '\\x00'.repeat(32 - length);\n}\nfunction toString(memo: string) {\n  let totalLength = stringLengthInBytes(memo);\n  if (totalLength !== 34) {\n    throw Error(`Memo.toString: length ${totalLength} does not equal 34`);\n  }\n  if (memo[0] !== '\\x01') {\n    throw Error('Memo.toString: expected memo to start with 0x01 byte');\n  }\n  let length = memo.charCodeAt(1);\n  if (length > 32) throw Error('Memo.toString: invalid length encoding');\n  let bytes = stringToBytes(memo).slice(2, 2 + length);\n  return stringFromBytes(bytes);\n}\n\nfunction hash(memo: string) {\n  let bits = Memo.toBits(memo);\n  let fields = packToFieldsLegacy(HashInputLegacy.bits(bits));\n  return hashWithPrefix(prefixes.zkappMemo, fields);\n}\n\nconst SIZE = 34;\nconst Binable: Binable<string> = defineBinable({\n  toBytes(memo) {\n    return stringToBytes(memo);\n  },\n  readBytes(bytes, start) {\n    let end = start + SIZE;\n    let memo = stringFromBytes(bytes.slice(start, end));\n    return [memo, end];\n  },\n});\n\nconst Memo = {\n  fromString,\n  toString,\n  hash,\n  ...withBits(Binable, SIZE * 8),\n  ...base58(Binable, versionBytes.userCommandMemo),\n  sizeInBytes: SIZE,\n  empty() {\n    return Memo.fromString('');\n  },\n  toValidString(memo = '') {\n    if (stringLengthInBytes(memo) > 32) throw Error('Memo: string too long');\n    return memo;\n  },\n};\n", "import { fieldEncodings } from '../../util/base58.js';\nimport { Field } from '../../provable/wrapped.js';\n\nexport { TokenId, ReceiptChainHash, LedgerHash, EpochSeed, StateHash };\n\nconst { TokenId, ReceiptChainHash, EpochSeed, LedgerHash, StateHash } = fieldEncodings(Field);\n", "import { Bool, Field, Sign, UInt32 } from './field-bigint.js';\nimport { PrivateKey, PublicKey } from './curve-bigint.js';\nimport {\n  Json,\n  AccountUpdate,\n  ZkappCommand,\n} from '../../bindings/mina-transaction/gen/v1/transaction-bigint.js';\nimport { hashWithPrefix, packToFields, prefixes } from './poseidon-bigint.js';\nimport { Memo } from './memo.js';\nimport { Signature, signFieldElement, verifyFieldElement, zkAppBodyPrefix } from './signature.js';\nimport { mocks } from '../../bindings/crypto/constants.js';\nimport { NetworkId } from './types.js';\n\n// external API\nexport { signZkappCommand, verifyZkappCommandSignature };\n\n// internal API\nexport {\n  transactionCommitments,\n  verifyAccountUpdateSignature,\n  accountUpdatesToCallForest,\n  callForestHash,\n  callForestHashGeneric,\n  accountUpdateHash,\n  feePayerHash,\n  createFeePayer,\n  accountUpdateFromFeePayer,\n  isCallDepthValid,\n  CallForest,\n};\n\n/**\n * Signs a zkApp command JSON object with the provided private key.\n *\n * This function applies a Schnorr signature to the fee payer and any account\n * updates within the command that require signatures and are owned by the same\n * public key. \n * \n * If this method is not called as the fee payer (i.e. the private key provided \n * does not match the fee payer's public key), the fee payer authorization will \n * remain unsigned after this method returns. This behavior allows for collaborative\n * construction of zkApp commands where two different users sign the account update\n * and pay the fee.\n *\n * @param zkappCommand_ - The zkApp command in JSON format, before signatures.\n * @param privateKeyBase58 - The Base58-encoded private key used for signing.\n * @param networkId - The network identifier that determines the signature domain.\n * @returns The signed zkApp command in JSON format.\n */\nfunction signZkappCommand(\n  zkappCommand_: Json.ZkappCommand,\n  privateKeyBase58: string,\n  networkId: NetworkId\n): Json.ZkappCommand {\n  let zkappCommand = ZkappCommand.fromJSON(zkappCommand_);\n\n  let { commitment, fullCommitment } = transactionCommitments(zkappCommand, networkId);\n  let privateKey = PrivateKey.fromBase58(privateKeyBase58);\n  let publicKey = PrivateKey.toPublicKey(privateKey);\n\n  let signature = signFieldElement(fullCommitment, privateKey, networkId);\n\n  // sign fee payer whenever the public key matches\n  if (PublicKey.equal(zkappCommand.feePayer.body.publicKey, publicKey)) {\n    zkappCommand.feePayer.authorization = Signature.toBase58(signature);\n  }\n\n  // sign other updates with the same public key that require a signature\n  for (let update of zkappCommand.accountUpdates) {\n    if (!update.body.authorizationKind.isSigned) continue;\n    if (!PublicKey.equal(update.body.publicKey, publicKey)) continue;\n    let { useFullCommitment } = update.body;\n    let usedCommitment = useFullCommitment ? fullCommitment : commitment;\n    let signature = signFieldElement(usedCommitment, privateKey, networkId);\n    update.authorization = { signature: Signature.toBase58(signature) };\n  }\n  return ZkappCommand.toJSON(zkappCommand);\n}\n\n/**\n * Verifies the signature of a zkApp command JSON object.\n * \n * This function verifies the signatures of the fee payer and any account\n * updates within the command that require signatures and are owned by the\n * same public key. \n *\n * @param zkappCommand_ - The zkApp command in JSON format, after signatures.\n * @param publicKeyBase58 - The Base58-encoded public key used for verification.\n * @param networkId - The network identifier that determines the signature domain.\n * @param feePayerPublicKeyBase58 - Optional Base58-encoded public key of the fee\n *                            payer, required if the provided public key does not\n *                            match the fee payer's public key.\n * @returns True if the signature is valid, false otherwise.\n *\n * @warning To verify the zkApp command signature, the public key must match the\n * fee payer's public key, or the parameter `feePayerPublicKey` must be provided.\n */\nfunction verifyZkappCommandSignature(\n  zkappCommand_: Json.ZkappCommand,\n  publicKeyBase58: string,\n  networkId: NetworkId,\n  feePayerPublicKeyBase58?: string\n) {\n  let zkappCommand = ZkappCommand.fromJSON(zkappCommand_);\n\n  let { commitment, fullCommitment } = transactionCommitments(zkappCommand, networkId);\n  let publicKey = PublicKey.fromBase58(publicKeyBase58);\n\n  // verify fee payer signature when public keys match\n  let feePayerPublicKey = feePayerPublicKeyBase58 ? PublicKey.fromBase58(feePayerPublicKeyBase58) : publicKey;\n  let signature = Signature.fromBase58(zkappCommand.feePayer.authorization);\n  let ok = verifyFieldElement(signature, fullCommitment, feePayerPublicKey, networkId) && PublicKey.equal(zkappCommand.feePayer.body.publicKey, feePayerPublicKey);\n  if (!ok) return false;\n\n  // verify other signatures for the same public key\n  for (let update of zkappCommand.accountUpdates) {\n    if (!update.body.authorizationKind.isSigned) continue;\n    if (!PublicKey.equal(update.body.publicKey, publicKey)) continue;\n    let { useFullCommitment } = update.body;\n    let usedCommitment = useFullCommitment ? fullCommitment : commitment;\n    if (update.authorization.signature === undefined) return false;\n    let signature = Signature.fromBase58(update.authorization.signature);\n    ok = verifyFieldElement(signature, usedCommitment, publicKey, networkId);\n    if (!ok) return false;\n  }\n  return ok;\n}\n\nfunction verifyAccountUpdateSignature(\n  update: AccountUpdate,\n  transactionCommitments: { commitment: bigint; fullCommitment: bigint },\n  networkId: NetworkId\n) {\n  if (update.authorization.signature === undefined) return false;\n\n  let { publicKey, useFullCommitment } = update.body;\n  let { commitment, fullCommitment } = transactionCommitments;\n  let usedCommitment = useFullCommitment ? fullCommitment : commitment;\n  let signature = Signature.fromBase58(update.authorization.signature);\n\n  return verifyFieldElement(signature, usedCommitment, publicKey, networkId);\n}\n\nfunction transactionCommitments(zkappCommand: ZkappCommand, networkId: NetworkId) {\n  if (!isCallDepthValid(zkappCommand)) {\n    throw Error('zkapp command: invalid call depth');\n  }\n  let callForest = accountUpdatesToCallForest(zkappCommand.accountUpdates);\n  let commitment = callForestHash(callForest, networkId);\n  let memoHash = Memo.hash(Memo.fromBase58(zkappCommand.memo));\n  let feePayerDigest = feePayerHash(zkappCommand.feePayer, networkId);\n  let fullCommitment = hashWithPrefix(prefixes.accountUpdateCons, [\n    memoHash,\n    feePayerDigest,\n    commitment,\n  ]);\n  return { commitment, fullCommitment };\n}\n\ntype CallTree<AccountUpdate> = {\n  accountUpdate: AccountUpdate;\n  children: CallForest<AccountUpdate>;\n};\ntype CallForest<AccountUpdate> = CallTree<AccountUpdate>[];\n\n/**\n * Turn flat list into a hierarchical structure (forest) by letting the callDepth\n * determine parent-child relationships\n */\nfunction accountUpdatesToCallForest<A extends { body: { callDepth: number } }>(\n  updates: A[],\n  callDepth = 0\n) {\n  let remainingUpdates = callDepth > 0 ? updates : [...updates];\n  let forest: CallForest<A> = [];\n  while (remainingUpdates.length > 0) {\n    let accountUpdate = remainingUpdates[0];\n    if (accountUpdate.body.callDepth < callDepth) return forest;\n    remainingUpdates.shift();\n    let children = accountUpdatesToCallForest(remainingUpdates, callDepth + 1);\n    forest.push({ accountUpdate, children });\n  }\n  return forest;\n}\n\nfunction accountUpdateHash(update: AccountUpdate, networkId: NetworkId) {\n  assertAuthorizationKindValid(update);\n  let input = AccountUpdate.toInput(update);\n  let fields = packToFields(input);\n  return hashWithPrefix(zkAppBodyPrefix(networkId), fields);\n}\n\nfunction callForestHash(forest: CallForest<AccountUpdate>, networkId: NetworkId): bigint {\n  return callForestHashGeneric(forest, accountUpdateHash, hashWithPrefix, 0n, networkId);\n}\n\nfunction callForestHashGeneric<A, F>(\n  forest: CallForest<A>,\n  hash: (a: A, networkId: NetworkId) => F,\n  hashWithPrefix: (prefix: string, input: F[]) => F,\n  emptyHash: F,\n  networkId: NetworkId\n): F {\n  let stackHash = emptyHash;\n  for (let callTree of [...forest].reverse()) {\n    let calls = callForestHashGeneric(\n      callTree.children,\n      hash,\n      hashWithPrefix,\n      emptyHash,\n      networkId\n    );\n    let treeHash = hash(callTree.accountUpdate, networkId);\n    let nodeHash = hashWithPrefix(prefixes.accountUpdateNode, [treeHash, calls]);\n    stackHash = hashWithPrefix(prefixes.accountUpdateCons, [nodeHash, stackHash]);\n  }\n  return stackHash;\n}\n\ntype FeePayer = ZkappCommand['feePayer'];\n\nfunction createFeePayer(feePayer: FeePayer['body']): FeePayer {\n  return { authorization: '', body: feePayer };\n}\nfunction feePayerHash(feePayer: FeePayer, networkId: NetworkId) {\n  let accountUpdate = accountUpdateFromFeePayer(feePayer);\n  return accountUpdateHash(accountUpdate, networkId);\n}\n\nfunction accountUpdateFromFeePayer({\n  body: { fee, nonce, publicKey, validUntil },\n  authorization: signature,\n}: FeePayer): AccountUpdate {\n  let { body } = AccountUpdate.empty();\n  body.publicKey = publicKey;\n  body.balanceChange = { magnitude: fee, sgn: Sign(-1) };\n  body.incrementNonce = Bool(true);\n  body.preconditions.network.globalSlotSinceGenesis = {\n    isSome: Bool(true),\n    value: { lower: UInt32(0), upper: validUntil ?? UInt32.maxValue },\n  };\n  body.preconditions.account.nonce = {\n    isSome: Bool(true),\n    value: { lower: nonce, upper: nonce },\n  };\n  body.useFullCommitment = Bool(true);\n  body.implicitAccountCreationFee = Bool(true);\n  body.authorizationKind = {\n    isProved: Bool(false),\n    isSigned: Bool(true),\n    verificationKeyHash: Field(mocks.dummyVerificationKeyHash),\n  };\n  return { body, authorization: { signature } };\n}\n\nfunction isCallDepthValid(zkappCommand: ZkappCommand) {\n  let callDepths = zkappCommand.accountUpdates.map((a) => a.body.callDepth);\n  let current = callDepths.shift() ?? 0;\n  if (current !== 0) return false;\n  for (let callDepth of callDepths) {\n    if (callDepth < 0) return false;\n    if (callDepth - current > 1) return false;\n    current = callDepth;\n  }\n  return true;\n}\n\nfunction assertAuthorizationKindValid(accountUpdate: AccountUpdate) {\n  let { isSigned, isProved, verificationKeyHash } = accountUpdate.body.authorizationKind;\n  if (isProved && isSigned)\n    throw Error('Invalid authorization kind: Only one of `isProved` and `isSigned` may be true.');\n  if (!isProved && verificationKeyHash !== Field(mocks.dummyVerificationKeyHash))\n    throw Error(\n      `Invalid authorization kind: If \\`isProved\\` is false, verification key hash must be ${mocks.dummyVerificationKeyHash}, got ${verificationKeyHash}`\n    );\n}\n", "import type { AccountUpdateLayout } from './account-update.js';\nimport type { PublicKey } from '../../provable/crypto/signature.js';\nimport { Context } from '../../util/global-context.js';\n\nexport { currentTransaction, CurrentTransaction, FetchMode };\n\ntype FetchMode = 'fetch' | 'cached' | 'test';\ntype CurrentTransaction = {\n  sender?: PublicKey;\n  layout: AccountUpdateLayout;\n  fetchMode: FetchMode;\n  isFinalRunOutsideCircuit: boolean;\n  numberOfRuns: 0 | 1 | undefined;\n};\n\nlet currentTransaction = Context.create<CurrentTransaction>();\n", "/**\n * This file exists to avoid an import cycle between code that just needs access\n * to a smart contract base class, and the code that implements `SmartContract`.\n */\nimport type { SmartContract } from './zkapp.js';\n\nexport { isSmartContract, SmartContractBase };\n\nclass SmartContractBase {}\n\nfunction isSmartContract(object: unknown): object is SmartContract {\n  return object instanceof SmartContractBase;\n}\n", "import type { SmartContract } from './zkapp.js';\nimport type { AccountUpdate, AccountUpdateLayout } from './account-update.js';\nimport { Context } from '../../util/global-context.js';\nimport { currentTransaction } from './transaction-context.js';\nimport { assert } from '../../util/assert.js';\n\nexport { smartContractContext, SmartContractContext, accountUpdateLayout, contract };\n\ntype SmartContractContext = {\n  this: SmartContract;\n  selfUpdate: AccountUpdate;\n  selfLayout: AccountUpdateLayout;\n};\nlet smartContractContext = Context.create<null | SmartContractContext>({\n  default: null,\n});\n\nfunction accountUpdateLayout() {\n  // in a smart contract, return the layout currently created in the contract call\n  let layout = smartContractContext.get()?.selfLayout;\n\n  // if not in a smart contract but in a transaction, return the layout of the transaction\n  layout ??= currentTransaction()?.layout;\n\n  return layout;\n}\n\nfunction contract<S extends SmartContract>(expectedConstructor?: new (...args: any) => S): S {\n  let ctx = smartContractContext.get();\n  assert(ctx !== null, 'This method must be called within a contract method');\n  if (expectedConstructor !== undefined) {\n    assert(\n      ctx.this.constructor === expectedConstructor,\n      `This method must be called on a ${expectedConstructor.name} contract`\n    );\n  }\n  return ctx.this as S;\n}\n", "import type { ProvableHashable } from '../crypto/poseidon.js';\n\nexport { RandomId };\n\nconst RandomId: ProvableHashable<number> = {\n  sizeInFields: () => 0,\n  toFields: () => [],\n  toAuxiliary: (v = Math.random()) => [v],\n  fromFields: (_, [v]) => v,\n  check: () => {},\n  toValue: (x) => x,\n  fromValue: (x) => x,\n  toInput: () => ({}),\n  empty: () => Math.random(),\n};\n", "import { cloneCircuitValue, FlexibleProvable, StructNoJson } from '../../provable/types/struct.js';\nimport { provable, provableExtends, provablePure } from '../../provable/types/provable-derivers.js';\nimport { memoizationContext, memoizeWitness, Provable } from '../../provable/provable.js';\nimport { Field, Bool } from '../../provable/wrapped.js';\nimport { Pickles } from '../../../bindings.js';\nimport { jsLayout } from '../../../bindings/mina-transaction/gen/v1/js-layout.js';\nimport { Types, toJSONEssential } from '../../../bindings/mina-transaction/v1/types.js';\nimport { PrivateKey, PublicKey } from '../../provable/crypto/signature.js';\nimport { UInt64, UInt32, Int64 } from '../../provable/int.js';\nimport type { SmartContract } from './zkapp.js';\nimport {\n  Preconditions,\n  Account,\n  Network,\n  CurrentSlot,\n  preconditions,\n  OrIgnore,\n  ClosedInterval,\n  getAccountPreconditions,\n} from './precondition.js';\nimport { dummyBase64Proof, Empty, Prover } from '../../proof-system/zkprogram.js';\nimport { Proof } from '../../proof-system/proof.js';\nimport { Memo } from '../../../mina-signer/src/memo.js';\nimport {\n  Events as BaseEvents,\n  Actions as BaseActions,\n  MayUseToken as BaseMayUseToken,\n} from '../../../bindings/mina-transaction/v1/transaction-leaves.js';\nimport { TokenId as Base58TokenId } from './base58-encodings.js';\nimport { hashWithPrefix, packToFields, Poseidon } from '../../provable/crypto/poseidon.js';\nimport { mocks, prefixes, protocolVersions } from '../../../bindings/crypto/constants.js';\nimport {\n  Signature,\n  signFieldElement,\n  zkAppBodyPrefix,\n} from '../../../mina-signer/src/signature.js';\nimport { MlFieldConstArray } from '../../ml/fields.js';\nimport {\n  accountUpdatesToCallForest,\n  CallForest,\n  callForestHashGeneric,\n  transactionCommitments,\n} from '../../../mina-signer/src/sign-zkapp-command.js';\nimport { currentTransaction } from './transaction-context.js';\nimport { isSmartContract } from './smart-contract-base.js';\nimport { activeInstance } from './mina-instance.js';\nimport { emptyHash, genericHash, MerkleList, MerkleListBase } from '../../provable/merkle-list.js';\nimport { Hashed } from '../../provable/packed.js';\nimport { accountUpdateLayout, smartContractContext } from './smart-contract-context.js';\nimport { assert } from '../../util/assert.js';\nimport { RandomId } from '../../provable/types/auxiliary.js';\nimport { From } from '../../../bindings/lib/provable-generic.js';\n\n// external API\nexport {\n  AccountUpdate,\n  Permissions,\n  ZkappPublicInput,\n  TransactionVersion,\n  AccountUpdateForest,\n  AccountUpdateTree,\n};\n// internal API\nexport {\n  SetOrKeep,\n  Permission,\n  Preconditions,\n  Body,\n  Authorization,\n  FeePayerUnsigned,\n  ZkappCommand,\n  addMissingSignatures,\n  addMissingProofs,\n  Events,\n  Actions,\n  TokenId,\n  CallForest,\n  zkAppProver,\n  dummySignature,\n  LazyProof,\n  AccountUpdateTreeBase,\n  AccountUpdateLayout,\n  hashAccountUpdate,\n  HashedAccountUpdate,\n};\n\nconst TransactionVersion = {\n  current: () => UInt32.from(protocolVersions.txnVersion),\n};\n\ntype ZkappProverData = {\n  transaction: ZkappCommand;\n  accountUpdate: AccountUpdate;\n  index: number;\n};\nlet zkAppProver = Prover<ZkappProverData>();\n\ntype AuthRequired = Types.Json.AuthRequired;\n\ntype AccountUpdateBody = Types.AccountUpdate['body'];\ntype Update = AccountUpdateBody['update'];\n\ntype MayUseToken = BaseMayUseToken;\nconst MayUseToken = {\n  type: BaseMayUseToken,\n  No: {\n    parentsOwnToken: Bool(false),\n    inheritFromParent: Bool(false),\n  },\n  ParentsOwnToken: {\n    parentsOwnToken: Bool(true),\n    inheritFromParent: Bool(false),\n  },\n  InheritFromParent: {\n    parentsOwnToken: Bool(false),\n    inheritFromParent: Bool(true),\n  },\n  isNo: ({\n    body: {\n      mayUseToken: { parentsOwnToken, inheritFromParent },\n    },\n  }: AccountUpdate) => parentsOwnToken.or(inheritFromParent).not(),\n  isParentsOwnToken: (a: AccountUpdate) => a.body.mayUseToken.parentsOwnToken,\n  isInheritFromParent: (a: AccountUpdate) => a.body.mayUseToken.inheritFromParent,\n};\n\ntype Events = BaseEvents;\nconst Events = {\n  ...BaseEvents,\n  pushEvent(events: Events, event: Field[]): Events {\n    events = BaseEvents.pushEvent(events, event);\n    Provable.asProver(() => {\n      // make sure unconstrained data is stored as constants\n      events.data[0] = events.data[0].map((e) => Field(Field.toBigint(e)));\n    });\n    return events;\n  },\n};\ntype Actions = BaseActions;\nconst Actions = {\n  ...BaseActions,\n  pushEvent(actions: Actions, action: Field[]): Actions {\n    actions = BaseActions.pushEvent(actions, action);\n    Provable.asProver(() => {\n      // make sure unconstrained data is stored as constants\n      actions.data[0] = actions.data[0].map((e) => Field(Field.toBigint(e)));\n    });\n    return actions;\n  },\n};\n\n/**\n * Either set a value or keep it the same.\n */\ntype SetOrKeep<T> = { isSome: Bool; value: T };\n\nconst True = () => Bool(true);\nconst False = () => Bool(false);\n\n/**\n * One specific permission value.\n *\n * A {@link Permission} tells one specific permission for our zkapp how it\n * should behave when presented with requested modifications.\n *\n * Use static factory methods on this class to use a specific behavior. See\n * documentation on those methods to learn more.\n */\ntype Permission = Types.AuthRequired;\n\nclass VerificationKeyPermission {\n  constructor(public auth: Permission, public txnVersion: UInt32) {}\n\n  // TODO this class could be made incompatible with a plain object (breaking change)\n  // private _ = undefined;\n\n  static withCurrentVersion(perm: Permission) {\n    return new VerificationKeyPermission(perm, TransactionVersion.current());\n  }\n}\n\nlet Permission = {\n  /**\n   * Modification is impossible.\n   */\n  impossible: (): Permission => ({\n    constant: True(),\n    signatureNecessary: True(),\n    signatureSufficient: False(),\n  }),\n\n  /**\n   * Modification is always permitted\n   */\n  none: (): Permission => ({\n    constant: True(),\n    signatureNecessary: False(),\n    signatureSufficient: True(),\n  }),\n\n  /**\n   * Modification is permitted by zkapp proofs only\n   */\n  proof: (): Permission => ({\n    constant: False(),\n    signatureNecessary: False(),\n    signatureSufficient: False(),\n  }),\n\n  /**\n   * Modification is permitted by signatures only, using the private key of the zkapp account\n   */\n  signature: (): Permission => ({\n    constant: False(),\n    signatureNecessary: True(),\n    signatureSufficient: True(),\n  }),\n\n  /**\n   * Modification is permitted by zkapp proofs or signatures\n   */\n  proofOrSignature: (): Permission => ({\n    constant: False(),\n    signatureNecessary: False(),\n    signatureSufficient: True(),\n  }),\n\n  /**\n   * Special Verification key permissions.\n   *\n   * The difference to normal permissions is that `Permission.proof` and `Permission.impossible` are replaced by less restrictive permissions:\n   * - `impossible` is replaced by `impossibleDuringCurrentVersion`\n   * - `proof` is replaced by `proofDuringCurrentVersion`\n   *\n   * The issue is that a future hardfork which changes the proof system could mean that old verification keys can no longer\n   * be used to verify proofs in the new proof system, and the zkApp would have to be redeployed to adapt the verification key.\n   *\n   * Having either `impossible` or `proof` would mean that these zkApps can't be upgraded after this hypothetical hardfork, and would become unusable.\n   *\n   * Such a future hardfork would manifest as an increment in the \"transaction version\" of zkApps, which you can check with {@link TransactionVersion.current()}.\n   *\n   * The `impossibleDuringCurrentVersion` and `proofDuringCurrentVersion` have an additional `txnVersion` field.\n   * These permissions follow the same semantics of not upgradable, or only upgradable with proofs,\n   * _as long as_ the current transaction version is the same as the one on the permission.\n   *\n   * Once the current transaction version is higher than the one on the permission, the permission is treated as `signature`,\n   * and the zkApp can be redeployed with a signature of the original account owner.\n   */\n  VerificationKey: {\n    /**\n     * Modification is impossible, as long as the network accepts the current {@link TransactionVersion}.\n     *\n     * After a hardfork that increments the transaction version, the permission is treated as `signature`.\n     */\n    impossibleDuringCurrentVersion: () =>\n      VerificationKeyPermission.withCurrentVersion(Permission.impossible()),\n\n    /**\n     * Modification is always permitted\n     */\n    none: () => VerificationKeyPermission.withCurrentVersion(Permission.none()),\n\n    /**\n     * Modification is permitted by zkapp proofs only; as long as the network accepts the current {@link TransactionVersion}.\n     *\n     * After a hardfork that increments the transaction version, the permission is treated as `signature`.\n     */\n    proofDuringCurrentVersion: () =>\n      VerificationKeyPermission.withCurrentVersion(Permission.proof()),\n\n    /**\n     * Modification is permitted by signatures only, using the private key of the zkapp account\n     */\n    signature: () => VerificationKeyPermission.withCurrentVersion(Permission.signature()),\n\n    /**\n     * Modification is permitted by zkapp proofs or signatures\n     */\n    proofOrSignature: () =>\n      VerificationKeyPermission.withCurrentVersion(Permission.proofOrSignature()),\n  },\n};\n\n// TODO: we could replace the interface below if we could bridge annotations from OCaml\ntype Permissions_ = Update['permissions']['value'];\n\n/**\n * Permissions specify how specific aspects of the zkapp account are allowed\n * to be modified. All fields are denominated by a {@link Permission}.\n */\ninterface Permissions extends Permissions_ {\n  /**\n   * The {@link Permission} corresponding to the 8 state fields associated with\n   * an account.\n   */\n  editState: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to send transactions\n   * from this account.\n   */\n  send: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to receive transactions\n   * to this account.\n   */\n  receive: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to set the delegate\n   * field of the account.\n   */\n  setDelegate: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to set the permissions\n   * field of the account.\n   */\n  setPermissions: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to set the verification\n   * key associated with the circuit tied to this account. Effectively\n   * \"upgradeability\" of the smart contract.\n   */\n  setVerificationKey: VerificationKeyPermission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to set the zkapp uri\n   * typically pointing to the source code of the smart contract. Usually this\n   * should be changed whenever the {@link Permissions.setVerificationKey} is\n   * changed. Effectively \"upgradeability\" of the smart contract.\n   */\n  setZkappUri: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to emit actions to the account.\n   */\n  editActionState: Permission;\n\n  /**\n   * The {@link Permission} corresponding to the ability to set the token symbol\n   * for this account.\n   */\n  setTokenSymbol: Permission;\n\n  // TODO: doccomments\n  incrementNonce: Permission;\n  setVotingFor: Permission;\n  setTiming: Permission;\n\n  /**\n   * Permission to control the ability to include _any_ account update for this\n   * account in a transaction. Note that this is more restrictive than all other\n   * permissions combined. For normal accounts it can safely be set to `none`,\n   * but for token contracts this has to be more restrictive, to prevent\n   * unauthorized token interactions -- for example, it could be\n   * `proofOrSignature`.\n   */\n  access: Permission;\n}\nlet Permissions = {\n  ...Permission,\n\n  /**\n   * Default permissions are:\n   *\n   *   {@link Permissions.editState} = {@link Permission.proof}\n   *\n   *   {@link Permissions.send} = {@link Permission.signature}\n   *\n   *   {@link Permissions.receive} = {@link Permission.none}\n   *\n   *   {@link Permissions.setDelegate} = {@link Permission.signature}\n   *\n   *   {@link Permissions.setPermissions} = {@link Permission.signature}\n   *\n   *   {@link Permissions.setVerificationKey} = {@link Permission.signature}\n   *\n   *   {@link Permissions.setZkappUri} = {@link Permission.signature}\n   *\n   *   {@link Permissions.editActionState} = {@link Permission.proof}\n   *\n   *   {@link Permissions.setTokenSymbol} = {@link Permission.signature}\n   *\n   */\n  default: (): Permissions => ({\n    editState: Permission.proof(),\n    send: Permission.proof(),\n    receive: Permission.none(),\n    setDelegate: Permission.signature(),\n    setPermissions: Permission.signature(),\n    setVerificationKey: Permission.VerificationKey.signature(),\n    setZkappUri: Permission.signature(),\n    editActionState: Permission.proof(),\n    setTokenSymbol: Permission.signature(),\n    incrementNonce: Permission.signature(),\n    setVotingFor: Permission.signature(),\n    setTiming: Permission.signature(),\n    access: Permission.none(),\n  }),\n\n  initial: (): Permissions => ({\n    editState: Permission.signature(),\n    send: Permission.signature(),\n    receive: Permission.none(),\n    setDelegate: Permission.signature(),\n    setPermissions: Permission.signature(),\n    setVerificationKey: Permission.VerificationKey.signature(),\n    setZkappUri: Permission.signature(),\n    editActionState: Permission.signature(),\n    setTokenSymbol: Permission.signature(),\n    incrementNonce: Permission.signature(),\n    setVotingFor: Permission.signature(),\n    setTiming: Permission.signature(),\n    access: Permission.none(),\n  }),\n\n  dummy: (): Permissions => ({\n    editState: Permission.none(),\n    send: Permission.none(),\n    receive: Permission.none(),\n    access: Permission.none(),\n    setDelegate: Permission.none(),\n    setPermissions: Permission.none(),\n    setVerificationKey: Permission.VerificationKey.none(),\n    setZkappUri: Permission.none(),\n    editActionState: Permission.none(),\n    setTokenSymbol: Permission.none(),\n    incrementNonce: Permission.none(),\n    setVotingFor: Permission.none(),\n    setTiming: Permission.none(),\n  }),\n\n  allImpossible: (): Permissions => ({\n    editState: Permission.impossible(),\n    send: Permission.impossible(),\n    receive: Permission.impossible(),\n    access: Permission.impossible(),\n    setDelegate: Permission.impossible(),\n    setPermissions: Permission.impossible(),\n    setVerificationKey: Permission.VerificationKey.impossibleDuringCurrentVersion(),\n    setZkappUri: Permission.impossible(),\n    editActionState: Permission.impossible(),\n    setTokenSymbol: Permission.impossible(),\n    incrementNonce: Permission.impossible(),\n    setVotingFor: Permission.impossible(),\n    setTiming: Permission.impossible(),\n  }),\n\n  fromString: (permission: AuthRequired): Permission => {\n    switch (permission) {\n      case 'None':\n        return Permission.none();\n      case 'Either':\n        return Permission.proofOrSignature();\n      case 'Proof':\n        return Permission.proof();\n      case 'Signature':\n        return Permission.signature();\n      case 'Impossible':\n        return Permission.impossible();\n      default:\n        throw Error(`Cannot parse invalid permission. ${permission} does not exist.`);\n    }\n  },\n\n  fromJSON: (\n    permissions: NonNullable<Types.Json.AccountUpdate['body']['update']['permissions']>\n  ): Permissions => {\n    return Object.fromEntries(\n      Object.entries(permissions).map(([k, v]) => [\n        k,\n        Permissions.fromString(typeof v === 'string' ? v : v.auth),\n      ])\n    ) as unknown as Permissions;\n  },\n};\n\n// TODO: get docstrings from OCaml and delete this interface\n\n/**\n * The body of describing how some [[ AccountUpdate ]] should change.\n */\ninterface Body extends AccountUpdateBody {\n  /**\n   * The address for this body.\n   */\n  publicKey: PublicKey;\n\n  /**\n   * @internal\n   *\n   * Specify {@link Update}s to tweakable pieces of the account record backing\n   * this address in the ledger.\n   */\n  update: Update;\n\n  /**\n   * The TokenId for this account.\n   */\n  tokenId: Field;\n\n  /**\n   * By what {@link Int64} should the balance of this account change. All\n   * balanceChanges must balance by the end of smart contract execution.\n   */\n  balanceChange: Int64;\n\n  /**\n   * Recent events that have been emitted from this account.\n   * Events can be collected by archive nodes.\n   *\n   * [Check out our documentation about\n   * Events!](https://docs.minaprotocol.com/zkapps/writing-a-zkapp/feature-overview/events)\n   */\n  events: Events;\n  /**\n   * @internal\n   *\n   * Recent {@link Action}s emitted from this account.\n   * Actions can be collected by archive nodes and used in combination with\n   * a {@link Reducer}.\n   *\n   * [Check out our documentation about\n   * Actions!](https://docs.minaprotocol.com/zkapps/writing-a-zkapp/feature-overview/actions-and-reducer)\n   */\n  actions: Events;\n  /**\n   * The type of call.\n   */\n  mayUseToken: MayUseToken;\n  callData: Field;\n  callDepth: number;\n  /**\n   * A list of {@link Preconditions} that need to be fulfilled in order for\n   * the {@link AccountUpdate} to be valid.\n   */\n  preconditions: Preconditions;\n  /**\n   * Defines if a full commitment is required for this transaction.\n   */\n  useFullCommitment: Bool;\n  /**\n   * Defines if the fee for creating this account should be paid out of this\n   * account's balance change.\n   *\n   * This must only be true if the balance change is larger than the account\n   * creation fee and the token ID is the default.\n   */\n  implicitAccountCreationFee: Bool;\n  /**\n   * Defines if the nonce should be incremented with this {@link AccountUpdate}.\n   */\n  incrementNonce: Bool;\n  /**\n   * Defines the type of authorization that is needed for this {@link\n   * AccountUpdate}.\n   *\n   * A authorization can be one of three types: None, Proof or Signature\n   */\n  authorizationKind: AccountUpdateBody['authorizationKind'];\n}\nconst Body = {\n  /**\n   * A body that doesn't change the underlying account record\n   */\n  keepAll(publicKey: PublicKey, tokenId?: Field, mayUseToken?: MayUseToken): Body {\n    let { body } = Types.AccountUpdate.empty();\n    body.publicKey = publicKey;\n    if (tokenId) {\n      body.tokenId = tokenId;\n      body.mayUseToken = Provable.if(\n        tokenId.equals(TokenId.default),\n        AccountUpdate.MayUseToken.type,\n        AccountUpdate.MayUseToken.No,\n        AccountUpdate.MayUseToken.ParentsOwnToken\n      );\n    }\n    if (mayUseToken) {\n      body.mayUseToken = mayUseToken;\n    }\n    return body;\n  },\n\n  dummy(): Body {\n    return Types.AccountUpdate.empty().body;\n  },\n};\n\ntype FeePayer = Types.ZkappCommand['feePayer'];\ntype FeePayerBody = FeePayer['body'];\nconst FeePayerBody = {\n  keepAll(publicKey: PublicKey, nonce: UInt32): FeePayerBody {\n    return {\n      publicKey,\n      nonce,\n      fee: UInt64.zero,\n      validUntil: undefined,\n    };\n  },\n};\n\ntype FeePayerUnsigned = FeePayer & {\n  lazyAuthorization?: LazySignature | undefined;\n};\n\ntype Control = Types.AccountUpdate['authorization'];\ntype LazyNone = {\n  kind: 'lazy-none';\n};\ntype LazySignature = { kind: 'lazy-signature' };\ntype LazyProof = {\n  kind: 'lazy-proof';\n  methodName: string;\n  args: any[];\n  ZkappClass: typeof SmartContract;\n  memoized: { fields: Field[]; aux: any[] }[];\n  blindingValue: Field;\n};\n\nconst AccountId = provable({ tokenOwner: PublicKey, parentTokenId: Field });\n\nconst TokenId = {\n  ...Types.TokenId,\n  ...Base58TokenId,\n  get default() {\n    return Field(1);\n  },\n  derive(tokenOwner: PublicKey, parentTokenId = Field(1)): Field {\n    let input = AccountId.toInput({ tokenOwner, parentTokenId });\n    return hashWithPrefix(prefixes.deriveTokenId, packToFields(input));\n  },\n};\n\n/**\n * An {@link AccountUpdate} is a set of instructions for the Mina network.\n * It includes {@link Preconditions} and a list of state updates, which need to\n * be authorized by either a {@link Signature} or {@link Proof}.\n */\nclass AccountUpdate implements Types.AccountUpdate {\n  id: number;\n  /**\n   * A human-readable label for the account update, indicating how that update\n   * was created. Can be modified by applications to add richer information.\n   */\n  label: string = '';\n  body: Body;\n  authorization: Control;\n  lazyAuthorization: LazySignature | LazyProof | LazyNone | undefined = undefined;\n  account: Account;\n  network: Network;\n  currentSlot: CurrentSlot;\n\n  private isSelf: boolean;\n\n  static Actions = Actions;\n  static Events = Events;\n\n  constructor(body: Body, authorization?: Control);\n  constructor(body: Body, authorization: Control = {}, isSelf = false) {\n    this.id = Math.random();\n    this.body = body;\n    this.authorization = authorization;\n    let { account, network, currentSlot } = preconditions(this, isSelf);\n    this.account = account;\n    this.network = network;\n    this.currentSlot = currentSlot;\n    this.isSelf = isSelf;\n  }\n\n  /**\n   * Clones the {@link AccountUpdate}.\n   */\n  static clone(accountUpdate: AccountUpdate) {\n    let body = cloneCircuitValue(accountUpdate.body);\n    let authorization = cloneCircuitValue(accountUpdate.authorization);\n    let cloned: AccountUpdate = new (AccountUpdate as any)(\n      body,\n      authorization,\n      accountUpdate.isSelf\n    );\n    cloned.lazyAuthorization = accountUpdate.lazyAuthorization;\n    cloned.id = accountUpdate.id;\n    cloned.label = accountUpdate.label;\n    return cloned;\n  }\n\n  get tokenId() {\n    return this.body.tokenId;\n  }\n\n  send({\n    to,\n    amount,\n  }: {\n    to: PublicKey | AccountUpdate | SmartContract;\n    amount: number | bigint | UInt64;\n  }) {\n    let receiver: AccountUpdate;\n    if (to instanceof AccountUpdate) {\n      receiver = to;\n      receiver.body.tokenId.assertEquals(this.body.tokenId);\n    } else if (isSmartContract(to)) {\n      receiver = to.self;\n      receiver.body.tokenId.assertEquals(this.body.tokenId);\n    } else {\n      receiver = AccountUpdate.default(to, this.body.tokenId);\n      receiver.label = `${this.label ?? 'Unlabeled'}.send()`;\n      this.approve(receiver);\n    }\n\n    // Sub the amount from the sender's account\n    this.body.balanceChange = this.body.balanceChange.sub(amount);\n    // Add the amount to the receiver's account\n    receiver.body.balanceChange = receiver.body.balanceChange.add(amount);\n    return receiver;\n  }\n\n  /**\n   * Makes another {@link AccountUpdate} a child of this one.\n   *\n   * The parent-child relationship means that the child becomes part of the \"statement\"\n   * of the parent, and goes into the commitment that is authorized by either a signature\n   * or a proof.\n   *\n   * For a proof in particular, child account updates are contained in the public input\n   * of the proof that authorizes the parent account update.\n   */\n  approve(child: AccountUpdate | AccountUpdateTree | AccountUpdateForest) {\n    if (child instanceof AccountUpdateForest) {\n      accountUpdateLayout()?.setChildren(this, child);\n      return;\n    }\n    if (child instanceof AccountUpdate) {\n      child.body.callDepth = this.body.callDepth + 1;\n    }\n    accountUpdateLayout()?.disattach(child);\n    accountUpdateLayout()?.pushChild(this, child);\n  }\n\n  get balance() {\n    let accountUpdate = this;\n\n    return {\n      addInPlace(x: Int64 | UInt32 | UInt64 | string | number | bigint) {\n        accountUpdate.body.balanceChange = accountUpdate.body.balanceChange.add(x);\n      },\n      subInPlace(x: Int64 | UInt32 | UInt64 | string | number | bigint) {\n        accountUpdate.body.balanceChange = accountUpdate.body.balanceChange.sub(x);\n      },\n    };\n  }\n\n  get balanceChange() {\n    return this.body.balanceChange;\n  }\n  set balanceChange(x: Int64) {\n    this.body.balanceChange = x;\n  }\n\n  get update(): Update {\n    return this.body.update;\n  }\n\n  static setValue<T>(maybeValue: SetOrKeep<T>, value: T) {\n    maybeValue.isSome = Bool(true);\n    maybeValue.value = value;\n  }\n\n  /**\n   * Constrain a property to lie between lower and upper bounds.\n   *\n   * @param property The property to constrain\n   * @param lower The lower bound\n   * @param upper The upper bound\n   *\n   * Example: To constrain the account balance of a SmartContract to lie between\n   * 0 and 20 MINA, you can use\n   *\n   * ```ts\n   * \\@method onlyRunsWhenBalanceIsLow() {\n   *   let lower = UInt64.zero;\n   *   let upper = UInt64.from(20e9);\n   *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);\n   *   // ...\n   * }\n   * ```\n   */\n  static assertBetween<T>(property: OrIgnore<ClosedInterval<T>>, lower: T, upper: T) {\n    property.isSome = Bool(true);\n    property.value.lower = lower;\n    property.value.upper = upper;\n  }\n\n  // TODO: assertGreaterThan, assertLowerThan?\n\n  /**\n   * Fix a property to a certain value.\n   *\n   * @param property The property to constrain\n   * @param value The value it is fixed to\n   *\n   * Example: To fix the account nonce of a SmartContract to 0, you can use\n   *\n   * ```ts\n   * \\@method onlyRunsWhenNonceIsZero() {\n   *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);\n   *   // ...\n   * }\n   * ```\n   */\n  static assertEquals<T extends object>(property: OrIgnore<ClosedInterval<T> | T>, value: T) {\n    property.isSome = Bool(true);\n    if ('lower' in property.value && 'upper' in property.value) {\n      property.value.lower = value;\n      property.value.upper = value;\n    } else {\n      property.value = value;\n    }\n  }\n\n  get publicKey(): PublicKey {\n    return this.body.publicKey;\n  }\n\n  /**\n   * Use this command if this account update should be signed by the account\n   * owner, instead of not having any authorization.\n   *\n   * If you use this and are not relying on a wallet to sign your transaction,\n   * then you should use the following code before sending your transaction:\n   *\n   * ```ts\n   * let tx = await Mina.transaction(...); // create transaction as usual, using `requireSignature()` somewhere\n   * tx.sign([privateKey]); // pass the private key of this account to `sign()`!\n   * ```\n   *\n   * Note that an account's {@link Permissions} determine which updates have to\n   * be (can be) authorized by a signature.\n   */\n  requireSignature() {\n    let { nonce, isSameAsFeePayer } = AccountUpdate.getSigningInfo(this);\n    // if this account is the same as the fee payer, we use the \"full commitment\" for replay protection\n    this.body.useFullCommitment = isSameAsFeePayer;\n    this.body.implicitAccountCreationFee = Bool(false);\n    // otherwise, we increment the nonce\n    let doIncrementNonce = isSameAsFeePayer.not();\n    this.body.incrementNonce = doIncrementNonce;\n    // in this case, we also have to set a nonce precondition\n    let lower = Provable.if(doIncrementNonce, UInt32, nonce, UInt32.zero);\n    let upper = Provable.if(doIncrementNonce, UInt32, nonce, UInt32.MAXINT());\n    this.body.preconditions.account.nonce.isSome = doIncrementNonce;\n    this.body.preconditions.account.nonce.value.lower = lower;\n    this.body.preconditions.account.nonce.value.upper = upper;\n    // set lazy signature\n    Authorization.setLazySignature(this);\n  }\n\n  static signFeePayerInPlace(feePayer: FeePayerUnsigned) {\n    feePayer.body.nonce = this.getNonce(feePayer);\n    feePayer.authorization = dummySignature();\n    feePayer.lazyAuthorization = { kind: 'lazy-signature' };\n  }\n\n  static getNonce(accountUpdate: AccountUpdate | FeePayerUnsigned) {\n    return AccountUpdate.getSigningInfo(accountUpdate).nonce;\n  }\n\n  private static signingInfo = provable({\n    isSameAsFeePayer: Bool,\n    nonce: UInt32,\n  });\n\n  private static getSigningInfo(accountUpdate: AccountUpdate | FeePayerUnsigned) {\n    return memoizeWitness(AccountUpdate.signingInfo, () =>\n      AccountUpdate.getSigningInfoUnchecked(accountUpdate)\n    );\n  }\n\n  private static getSigningInfoUnchecked(update: AccountUpdate | FeePayerUnsigned) {\n    let publicKey = update.body.publicKey;\n    let tokenId = update instanceof AccountUpdate ? update.body.tokenId : TokenId.default;\n    let nonce = Number(getAccountPreconditions(update.body).nonce.toString());\n    // if the fee payer is the same account update as this one, we have to start\n    // the nonce predicate at one higher, bc the fee payer already increases its\n    // nonce\n    let isFeePayer = currentTransaction()?.sender?.equals(publicKey);\n    let isSameAsFeePayer = !!isFeePayer?.and(tokenId.equals(TokenId.default)).toBoolean();\n    if (isSameAsFeePayer) nonce++;\n    // now, we check how often this account update already updated its nonce in\n    // this tx, and increase nonce from `getAccount` by that amount\n    let layout = currentTransaction()?.layout;\n    layout?.forEachPredecessor(update as AccountUpdate, (otherUpdate) => {\n      let shouldIncreaseNonce = otherUpdate.publicKey\n        .equals(publicKey)\n        .and(otherUpdate.tokenId.equals(tokenId))\n        .and(otherUpdate.body.incrementNonce);\n      if (shouldIncreaseNonce.toBoolean()) nonce++;\n    });\n    return {\n      nonce: UInt32.from(nonce),\n      isSameAsFeePayer: Bool(isSameAsFeePayer),\n    };\n  }\n\n  toJSON() {\n    return Types.AccountUpdate.toJSON(this);\n  }\n  static toJSON(a: AccountUpdate) {\n    return Types.AccountUpdate.toJSON(a);\n  }\n  static fromJSON(json: Types.Json.AccountUpdate) {\n    let accountUpdate = Types.AccountUpdate.fromJSON(json);\n    return new AccountUpdate(accountUpdate.body, accountUpdate.authorization);\n  }\n\n  hash(): Field {\n    let input = Types.AccountUpdate.toInput(this);\n    return hashWithPrefix(zkAppBodyPrefix(activeInstance.getNetworkId()), packToFields(input));\n  }\n\n  toPublicInput({ accountUpdates }: { accountUpdates: AccountUpdate[] }): ZkappPublicInput {\n    let accountUpdate = this.hash();\n\n    // collect this update's descendants\n    let descendants: AccountUpdate[] = [];\n    let callDepth = this.body.callDepth;\n    let i = accountUpdates.findIndex((a) => a.id === this.id);\n    assert(i !== -1, 'Account update not found in transaction');\n    for (i++; i < accountUpdates.length; i++) {\n      let update = accountUpdates[i];\n      if (update.body.callDepth <= callDepth) break;\n      descendants.push(update);\n    }\n\n    // call forest hash\n    let forest = accountUpdatesToCallForest(descendants, callDepth + 1);\n    let calls = callForestHashGeneric(\n      forest,\n      (a) => a.hash(),\n      Poseidon.hashWithPrefix,\n      emptyHash,\n      activeInstance.getNetworkId()\n    );\n    return { accountUpdate, calls };\n  }\n\n  toPrettyLayout() {\n    let node = accountUpdateLayout()?.get(this);\n    assert(node !== undefined, 'AccountUpdate not found in layout');\n    node.children.print();\n  }\n\n  extractTree(): AccountUpdateTree {\n    let layout = accountUpdateLayout();\n    let hash = layout?.get(this)?.final?.hash;\n    let id = this.id;\n    let children = layout?.finalizeAndRemove(this) ?? AccountUpdateForest.empty();\n    let accountUpdate = HashedAccountUpdate.hash(this, hash);\n    return new AccountUpdateTree({ accountUpdate, id, children });\n  }\n\n  /**\n   * Create an account update from a public key and an optional token id.\n   *\n   * **Important**: This method is different from `AccountUpdate.create()`, in that it really just creates the account update object.\n   * It does not attach the update to the current transaction or smart contract.\n   * Use this method for lower-level operations with account updates.\n   */\n  static default(address: PublicKey, tokenId?: Field) {\n    return new AccountUpdate(Body.keepAll(address, tokenId));\n  }\n\n  static dummy() {\n    let dummy = new AccountUpdate(Body.dummy());\n    dummy.label = 'Dummy';\n    return dummy;\n  }\n  isDummy() {\n    return this.body.publicKey.isEmpty();\n  }\n\n  static defaultFeePayer(address: PublicKey, nonce: UInt32): FeePayerUnsigned {\n    let body = FeePayerBody.keepAll(address, nonce);\n    return {\n      body,\n      authorization: dummySignature(),\n      lazyAuthorization: { kind: 'lazy-signature' },\n    };\n  }\n\n  static dummyFeePayer(): FeePayerUnsigned {\n    let body = FeePayerBody.keepAll(PublicKey.empty(), UInt32.zero);\n    return { body, authorization: dummySignature() };\n  }\n\n  /**\n   * Creates an account update. If this is inside a transaction, the account\n   * update becomes part of the transaction. If this is inside a smart contract\n   * method, the account update will not only become part of the transaction,\n   * but also becomes available for the smart contract to modify, in a way that\n   * becomes part of the proof.\n   */\n  static create(publicKey: PublicKey, tokenId?: Field) {\n    let accountUpdate = AccountUpdate.default(publicKey, tokenId);\n    let insideContract = smartContractContext.get();\n    if (insideContract) {\n      let self = insideContract.this.self;\n      self.approve(accountUpdate);\n      accountUpdate.label = `${self.label || 'Unlabeled'} > AccountUpdate.create()`;\n    } else {\n      currentTransaction()?.layout.pushTopLevel(accountUpdate);\n      accountUpdate.label = `Mina.transaction() > AccountUpdate.create()`;\n    }\n    return accountUpdate;\n  }\n\n  /**\n   * Create an account update that is added to the transaction only if a condition is met.\n   *\n   * See {@link AccountUpdate.create} for more information. In this method, you can pass in\n   * a condition that determines whether the account update should be added to the transaction.\n   */\n  static createIf(condition: Bool, publicKey: PublicKey, tokenId?: Field) {\n    return AccountUpdate.create(\n      // if the condition is false, we use an empty public key, which causes the account update to be ignored\n      // as a dummy when building the transaction\n      Provable.if(condition, publicKey, PublicKey.empty()),\n      tokenId\n    );\n  }\n\n  /**\n   * Attach account update to the current transaction\n   * -- if in a smart contract, to its children\n   */\n  static attachToTransaction(accountUpdate: AccountUpdate) {\n    let insideContract = smartContractContext.get();\n    if (insideContract) {\n      let selfUpdate = insideContract.this.self;\n      // avoid redundant attaching & cycle in account update structure, happens\n      // when calling attachToTransaction(this.self) inside a @method\n      // TODO avoid account update cycles more generally\n      if (selfUpdate === accountUpdate) return;\n      insideContract.this.self.approve(accountUpdate);\n    } else {\n      if (!currentTransaction.has()) return;\n      currentTransaction.get().layout.pushTopLevel(accountUpdate);\n    }\n  }\n  /**\n   * Disattach an account update from where it's currently located in the transaction\n   */\n  static unlink(accountUpdate: AccountUpdate) {\n    accountUpdateLayout()?.disattach(accountUpdate);\n  }\n\n  /**\n   * Creates an account update, like {@link AccountUpdate.create}, but also\n   * makes sure this account update will be authorized with a signature.\n   *\n   * If you use this and are not relying on a wallet to sign your transaction,\n   * then you should use the following code before sending your transaction:\n   *\n   * ```ts\n   * let tx = await Mina.transaction(...); // create transaction as usual, using `createSigned()` somewhere\n   * tx.sign([privateKey]); // pass the private key of this account to `sign()`!\n   * ```\n   *\n   * Note that an account's {@link Permissions} determine which updates have to\n   * be (can be) authorized by a signature.\n   */\n  static createSigned(publicKey: PublicKey, tokenId?: Field) {\n    let accountUpdate = AccountUpdate.create(publicKey, tokenId);\n    accountUpdate.label = accountUpdate.label.replace('.create()', '.createSigned()');\n    accountUpdate.requireSignature();\n    return accountUpdate;\n  }\n\n  /**\n   * Use this method to pay the account creation fee for another account (or, multiple accounts using the optional second argument).\n   *\n   * Beware that you _don't_ need to specify the account that is created!\n   * Instead, the protocol will automatically identify that accounts need to be created,\n   * and require that the net balance change of the transaction covers the account creation fee.\n   *\n   * @param feePayer the address of the account that pays the fee\n   * @param numberOfAccounts the number of new accounts to fund (default: 1)\n   * @returns they {@link AccountUpdate} for the account which pays the fee\n   */\n  static fundNewAccount(feePayer: PublicKey, numberOfAccounts = 1) {\n    let accountUpdate = AccountUpdate.createSigned(feePayer);\n    accountUpdate.label = 'AccountUpdate.fundNewAccount()';\n    let fee = activeInstance.getNetworkConstants().accountCreationFee;\n    fee = fee.mul(numberOfAccounts);\n    accountUpdate.balance.subInPlace(fee);\n    return accountUpdate;\n  }\n\n  // static methods that implement Provable<AccountUpdate>\n  static sizeInFields = Types.AccountUpdate.sizeInFields;\n  static toFields = Types.AccountUpdate.toFields;\n  static toAuxiliary(a?: AccountUpdate) {\n    let aux = Types.AccountUpdate.toAuxiliary(a);\n    let lazyAuthorization = a && a.lazyAuthorization;\n    let id = a?.id ?? Math.random();\n    let label = a?.label ?? '';\n    return [{ lazyAuthorization, id, label }, aux];\n  }\n  static toInput = Types.AccountUpdate.toInput;\n  static empty() {\n    return AccountUpdate.dummy();\n  }\n  static check = Types.AccountUpdate.check;\n  static fromFields(fields: Field[], [other, aux]: any[]): AccountUpdate {\n    let accountUpdate = Types.AccountUpdate.fromFields(fields, aux);\n    return Object.assign(new AccountUpdate(accountUpdate.body, accountUpdate.authorization), other);\n  }\n  static toValue = Types.AccountUpdate.toValue;\n  static fromValue(value: From<typeof Types.AccountUpdate> | AccountUpdate): AccountUpdate {\n    if (value instanceof AccountUpdate) return value;\n    let accountUpdate = Types.AccountUpdate.fromValue(value);\n    return new AccountUpdate(accountUpdate.body, accountUpdate.authorization);\n  }\n\n  /**\n   * This function acts as the `check()` method on an `AccountUpdate` that is sent to the Mina node as part of a transaction.\n   *\n   * Background: the Mina node performs most necessary validity checks on account updates, both in- and outside of circuits.\n   * To save constraints, we don't repeat these checks in zkApps in places where we can be sure the checked account updates\n   * will be part of a transaction.\n   *\n   * However, there are a few checks skipped by the Mina node, that could cause vulnerabilities in zkApps if\n   * not checked in the zkApp proof itself. Adding these extra checks is the purpose of this function.\n   */\n  private static clientSideOnlyChecks(au: AccountUpdate) {\n    // canonical int64 representation of the balance change\n    Int64.check(au.body.balanceChange);\n  }\n\n  static witness<T>(\n    resultType: FlexibleProvable<T>,\n    compute: () => Promise<{ accountUpdate: AccountUpdate; result: T }>,\n    { skipCheck = false } = {}\n  ) {\n    // construct the circuit type for a accountUpdate + other result\n    let accountUpdate = skipCheck\n      ? {\n          ...provable(AccountUpdate),\n          check: AccountUpdate.clientSideOnlyChecks,\n        }\n      : AccountUpdate;\n    let combinedType = provable({ accountUpdate, result: resultType });\n    return Provable.witnessAsync(combinedType, compute);\n  }\n\n  static MayUseToken = MayUseToken;\n\n  /**\n   * Returns a JSON representation of only the fields that differ from the\n   * default {@link AccountUpdate}.\n   */\n  toPretty() {\n    function short(s: string) {\n      return '..' + s.slice(-4);\n    }\n    let jsonUpdate: Partial<Types.Json.AccountUpdate> = toJSONEssential(\n      jsLayout.AccountUpdate as any,\n      this\n    );\n    let body: Partial<Types.Json.AccountUpdate['body']> = jsonUpdate.body as any;\n    delete body.callData;\n    body.publicKey = short(body.publicKey!);\n    if (body.balanceChange?.magnitude === '0') delete body.balanceChange;\n    if (body.tokenId === TokenId.toBase58(TokenId.default)) {\n      delete body.tokenId;\n    } else {\n      body.tokenId = short(body.tokenId!);\n    }\n    if (body.callDepth === 0) delete body.callDepth;\n    if (body.incrementNonce === false) delete body.incrementNonce;\n    if (body.useFullCommitment === false) delete body.useFullCommitment;\n    if (body.implicitAccountCreationFee === false) delete body.implicitAccountCreationFee;\n    if (body.events?.length === 0) delete body.events;\n    if (body.actions?.length === 0) delete body.actions;\n    if (body.preconditions?.account) {\n      body.preconditions.account = JSON.stringify(body.preconditions.account) as any;\n    }\n    if (body.preconditions?.network) {\n      body.preconditions.network = JSON.stringify(body.preconditions.network) as any;\n    }\n    if (body.preconditions?.validWhile) {\n      body.preconditions.validWhile = JSON.stringify(body.preconditions.validWhile) as any;\n    }\n    if (jsonUpdate.authorization?.proof) {\n      jsonUpdate.authorization.proof = short(jsonUpdate.authorization.proof);\n    }\n    if (jsonUpdate.authorization?.signature) {\n      jsonUpdate.authorization.signature = short(jsonUpdate.authorization.signature);\n    }\n    if (body.update?.verificationKey) {\n      body.update.verificationKey = JSON.stringify({\n        data: short(body.update.verificationKey.data),\n        hash: short(body.update.verificationKey.hash),\n      }) as any;\n    }\n    for (let key of ['permissions', 'appState', 'timing'] as const) {\n      if (body.update?.[key]) {\n        body.update[key] = JSON.stringify(body.update[key]) as any;\n      }\n    }\n    for (let key of ['events', 'actions'] as const) {\n      if (body[key]) {\n        body[key] = JSON.stringify(body[key]) as any;\n      }\n    }\n    if (body.authorizationKind?.isProved === false) {\n      delete (body as any).authorizationKind?.verificationKeyHash;\n    }\n    if (body.authorizationKind?.isProved === false && body.authorizationKind?.isSigned === false) {\n      delete (body as any).authorizationKind;\n    }\n    if (\n      jsonUpdate.authorization !== undefined ||\n      body.authorizationKind?.isProved === true ||\n      body.authorizationKind?.isSigned === true\n    ) {\n      (body as any).authorization = jsonUpdate.authorization;\n    }\n\n    body.mayUseToken = {\n      parentsOwnToken: this.body.mayUseToken.parentsOwnToken.toBoolean(),\n      inheritFromParent: this.body.mayUseToken.inheritFromParent.toBoolean(),\n    };\n    let pretty: any = { ...body };\n    let withId = false;\n    if (withId) pretty = { id: Math.floor(this.id * 1000), ...pretty };\n    if (this.label) pretty = { label: this.label, ...pretty };\n    return pretty;\n  }\n}\n\n// call forest stuff\n\nfunction hashAccountUpdate(update: AccountUpdate) {\n  return genericHash(AccountUpdate, zkAppBodyPrefix(activeInstance.getNetworkId()), update);\n}\n\nclass HashedAccountUpdate extends Hashed.create(AccountUpdate, hashAccountUpdate) {}\n\ntype AccountUpdateTreeBase = {\n  id: number;\n  accountUpdate: Hashed<AccountUpdate>;\n  children: AccountUpdateForestBase;\n};\ntype AccountUpdateForestBase = MerkleListBase<AccountUpdateTreeBase>;\n\nconst AccountUpdateTreeBase = StructNoJson({\n  id: RandomId,\n  accountUpdate: HashedAccountUpdate,\n  children: MerkleListBase<AccountUpdateTreeBase>(),\n});\n\n/**\n * Class which represents a forest (list of trees) of account updates,\n * in a compressed way which allows iterating and selectively witnessing the account updates.\n *\n * The (recursive) type signature is:\n * ```\n * type AccountUpdateForest = MerkleList<AccountUpdateTree>;\n * type AccountUpdateTree = {\n *   accountUpdate: Hashed<AccountUpdate>;\n *   children: AccountUpdateForest;\n * };\n * ```\n */\nclass AccountUpdateForest extends MerkleList.create(AccountUpdateTreeBase, merkleListHash) {\n  static provable = provableExtends(AccountUpdateForest, super.provable);\n\n  push(update: AccountUpdate | AccountUpdateTreeBase) {\n    return super.push(update instanceof AccountUpdate ? AccountUpdateTree.from(update) : update);\n  }\n  pushIf(condition: Bool, update: AccountUpdate | AccountUpdateTreeBase) {\n    return super.pushIf(\n      condition,\n      update instanceof AccountUpdate ? AccountUpdateTree.from(update) : update\n    );\n  }\n\n  static fromFlatArray(updates: AccountUpdate[]): AccountUpdateForest {\n    let simpleForest = accountUpdatesToCallForest(updates);\n    return this.fromSimpleForest(simpleForest);\n  }\n\n  toFlatArray(mutate = true, depth = 0) {\n    return AccountUpdateForest.toFlatArray(this, mutate, depth);\n  }\n\n  static toFlatArray(forest: AccountUpdateForestBase, mutate = true, depth = 0) {\n    let flat: AccountUpdate[] = [];\n    for (let { element: tree } of forest.data.get()) {\n      let update = tree.accountUpdate.value.get();\n      if (mutate) update.body.callDepth = depth;\n      flat.push(update);\n      flat.push(...this.toFlatArray(tree.children, mutate, depth + 1));\n    }\n    return flat;\n  }\n\n  private static fromSimpleForest(simpleForest: CallForest<AccountUpdate>): AccountUpdateForest {\n    let nodes = simpleForest.map((node) => {\n      let accountUpdate = HashedAccountUpdate.hash(node.accountUpdate);\n      let children = AccountUpdateForest.fromSimpleForest(node.children);\n      return { accountUpdate, children, id: node.accountUpdate.id };\n    });\n    return AccountUpdateForest.fromReverse(nodes);\n  }\n\n  // TODO this comes from paranoia and might be removed later\n  static assertConstant(forest: AccountUpdateForestBase) {\n    Provable.asProver(() => {\n      forest.data.get().forEach(({ element: tree }) => {\n        assert(\n          Provable.isConstant(AccountUpdate, tree.accountUpdate.value.get()),\n          'account update not constant'\n        );\n        AccountUpdateForest.assertConstant(tree.children);\n      });\n    });\n  }\n\n  // fix static methods\n  static empty() {\n    return AccountUpdateForest.provable.empty();\n  }\n  static from(array: AccountUpdateTreeBase[]) {\n    return new AccountUpdateForest(super.from(array));\n  }\n  static fromReverse(array: AccountUpdateTreeBase[]) {\n    return new AccountUpdateForest(super.fromReverse(array));\n  }\n}\n\n/**\n * Class which represents a tree of account updates,\n * in a compressed way which allows iterating and selectively witnessing the account updates.\n *\n * The (recursive) type signature is:\n * ```\n * type AccountUpdateTree = {\n *   accountUpdate: Hashed<AccountUpdate>;\n *   children: AccountUpdateForest;\n * };\n * type AccountUpdateForest = MerkleList<AccountUpdateTree>;\n * ```\n */\nclass AccountUpdateTree extends StructNoJson({\n  id: RandomId,\n  accountUpdate: HashedAccountUpdate,\n  children: AccountUpdateForest,\n}) {\n  /**\n   * Create a tree of account updates which only consists of a root.\n   */\n  static from(update: AccountUpdate | AccountUpdateTree, hash?: Field) {\n    if (update instanceof AccountUpdateTree) return update;\n    return new AccountUpdateTree({\n      accountUpdate: HashedAccountUpdate.hash(update, hash),\n      id: update.id,\n      children: AccountUpdateForest.empty(),\n    });\n  }\n\n  /**\n   * Add an {@link AccountUpdate} or {@link AccountUpdateTree} to the children of this tree's root.\n   *\n   * See {@link AccountUpdate.approve}.\n   */\n  approve(update: AccountUpdate | AccountUpdateTree, hash?: Field) {\n    accountUpdateLayout()?.disattach(update);\n    if (update instanceof AccountUpdate) {\n      this.children.pushIf(update.isDummy().not(), AccountUpdateTree.from(update, hash));\n    } else {\n      this.children.push(update);\n    }\n  }\n\n  // fix Struct type\n  static fromFields(fields: Field[], aux: any) {\n    return new AccountUpdateTree(super.fromFields(fields, aux));\n  }\n  static empty() {\n    return new AccountUpdateTree(super.empty());\n  }\n}\n\n// how to hash a forest\n\nfunction merkleListHash(forestHash: Field, tree: AccountUpdateTreeBase) {\n  return hashCons(forestHash, hashNode(tree));\n}\n\nfunction hashNode(tree: AccountUpdateTreeBase) {\n  return Poseidon.hashWithPrefix(prefixes.accountUpdateNode, [\n    tree.accountUpdate.hash,\n    tree.children.hash,\n  ]);\n}\nfunction hashCons(forestHash: Field, nodeHash: Field) {\n  return Poseidon.hashWithPrefix(prefixes.accountUpdateCons, [nodeHash, forestHash]);\n}\n\n/**\n * `UnfinishedForest` / `UnfinishedTree` are structures for constructing the forest of child account updates from a circuit.\n *\n * The circuit can mutate account updates and change their array of children, so here we can't hash\n * everything immediately. Instead, we maintain a structure consisting of either hashes or full account\n * updates that can be hashed into a final call forest at the end.\n *\n * `UnfinishedForest` and `UnfinishedTree` behave like a tagged enum type:\n * ```\n * type UnfinishedForest =\n *  | Mutable of UnfinishedTree[]\n *  | Final of AccountUpdateForest;\n *\n * type UnfinishedTree = (\n *  | Mutable of AccountUpdate\n *  | Final of HashedAccountUpdate\n * ) & { children: UnfinishedForest, ... }\n * ```\n */\ntype UnfinishedTree = {\n  id: number;\n  isDummy: Bool;\n  // `children` must be readonly since it's referenced in each child's siblings\n  readonly children: UnfinishedForest;\n  siblings?: UnfinishedForest;\n} & (\n  | { final: HashedAccountUpdate; mutable?: undefined }\n  | { final?: undefined; mutable: AccountUpdate }\n);\n\ntype UnfinishedForestFinal = UnfinishedForest & {\n  final: AccountUpdateForest;\n  mutable?: undefined;\n};\n\ntype UnfinishedForestMutable = UnfinishedForest & {\n  final?: undefined;\n  mutable: UnfinishedTree[];\n};\n\nclass UnfinishedForest {\n  final?: AccountUpdateForest;\n  mutable?: UnfinishedTree[];\n\n  isFinal(): this is UnfinishedForestFinal {\n    return this.final !== undefined;\n  }\n  isMutable(): this is UnfinishedForestMutable {\n    return this.mutable !== undefined;\n  }\n\n  constructor(mutable?: UnfinishedTree[], final?: AccountUpdateForest) {\n    assert((final === undefined) !== (mutable === undefined), 'final or mutable');\n    this.final = final;\n    this.mutable = mutable;\n  }\n\n  static empty(): UnfinishedForestMutable {\n    return new UnfinishedForest([]) as any;\n  }\n\n  private setFinal(final: AccountUpdateForest): UnfinishedForestFinal {\n    return Object.assign(this, { final, mutable: undefined });\n  }\n\n  finalize(): AccountUpdateForest {\n    if (this.isFinal()) return this.final;\n    assert(this.isMutable(), 'final or mutable');\n\n    let nodes = this.mutable.map(UnfinishedTree.finalize);\n    let finalForest = AccountUpdateForest.empty();\n\n    for (let { isDummy, ...tree } of [...nodes].reverse()) {\n      finalForest.pushIf(isDummy.not(), tree);\n    }\n    this.setFinal(finalForest);\n    return finalForest;\n  }\n\n  witnessHash(): UnfinishedForestFinal {\n    let final = Provable.witness(AccountUpdateForest, () => this.finalize());\n    return this.setFinal(final);\n  }\n\n  push(node: UnfinishedTree) {\n    if (node.siblings === this) return;\n    assert(node.siblings === undefined, 'Cannot push node that already has a parent.');\n    node.siblings = this;\n    assert(this.isMutable(), 'Cannot push to an immutable forest');\n    this.mutable.push(node);\n  }\n\n  remove(node: UnfinishedTree) {\n    assert(this.isMutable(), 'Cannot remove from an immutable forest');\n    // find by .id\n    let index = this.mutable.findIndex((n) => n.id === node.id);\n\n    // nothing to do if it's not there\n    if (index === -1) return;\n\n    // remove it\n    node.siblings = undefined;\n    this.mutable.splice(index, 1);\n  }\n\n  setToForest(forest: AccountUpdateForestBase) {\n    if (this.isMutable()) {\n      assert(\n        this.mutable.length === 0,\n        'Replacing a mutable forest that has existing children might be a mistake.'\n      );\n    }\n    return this.setFinal(new AccountUpdateForest(forest));\n  }\n\n  static fromForest(forest: AccountUpdateForestBase) {\n    return UnfinishedForest.empty().setToForest(forest);\n  }\n\n  toFlatArray(mutate = true, depth = 0): AccountUpdate[] {\n    if (this.isFinal()) return this.final.toFlatArray(mutate, depth);\n    assert(this.isMutable(), 'final or mutable');\n    let flatUpdates: AccountUpdate[] = [];\n    for (let node of this.mutable) {\n      if (node.isDummy.toBoolean()) continue;\n      let update = node.mutable ?? node.final.value.get();\n      if (mutate) update.body.callDepth = depth;\n      let children = node.children.toFlatArray(mutate, depth + 1);\n      flatUpdates.push(update, ...children);\n    }\n    return flatUpdates;\n  }\n\n  toConstantInPlace() {\n    if (this.isFinal()) {\n      this.final.hash = this.final.hash.toConstant();\n      return;\n    }\n    assert(this.isMutable(), 'final or mutable');\n    for (let node of this.mutable) {\n      if (node.mutable !== undefined) {\n        node.mutable = Provable.toConstant(AccountUpdate, node.mutable);\n      } else {\n        node.final.hash = node.final.hash.toConstant();\n      }\n      node.isDummy = Provable.toConstant(Bool, node.isDummy);\n      node.children.toConstantInPlace();\n    }\n  }\n\n  print() {\n    let indent = 0;\n    let layout = '';\n\n    let toPretty = (a: UnfinishedForest) => {\n      if (a.isFinal()) {\n        layout += ' '.repeat(indent) + ' ( finalized forest )\\n';\n        return;\n      }\n      assert(a.isMutable(), 'final or mutable');\n      indent += 2;\n      for (let tree of a.mutable) {\n        let label = tree.mutable?.label || '<no label>';\n        if (tree.final !== undefined) {\n          Provable.asProver(() => (label = tree.final!.value.get().label));\n        }\n        layout += ' '.repeat(indent) + `( ${label} )` + '\\n';\n        toPretty(tree.children);\n      }\n      indent -= 2;\n    };\n\n    toPretty(this);\n    console.log(layout);\n  }\n}\n\nconst UnfinishedTree = {\n  create(update: AccountUpdate | AccountUpdateTree): UnfinishedTree {\n    if (update instanceof AccountUpdate) {\n      return {\n        mutable: update,\n        id: update.id,\n        isDummy: update.isDummy(),\n        children: UnfinishedForest.empty(),\n      };\n    }\n    return {\n      final: update.accountUpdate,\n      id: update.id,\n      isDummy: Bool(false),\n      children: UnfinishedForest.fromForest(update.children),\n    };\n  },\n\n  setTo(node: UnfinishedTree, update: AccountUpdate | AccountUpdateTree) {\n    if (update instanceof AccountUpdate) {\n      if (node.final !== undefined) {\n        Object.assign(node, {\n          mutable: update,\n          final: undefined,\n          children: UnfinishedForest.empty(),\n        });\n      }\n    } else if (node.mutable !== undefined) {\n      Object.assign(node, {\n        mutable: undefined,\n        final: update.accountUpdate,\n        children: UnfinishedForest.fromForest(update.children),\n      });\n    }\n  },\n\n  finalize(node: UnfinishedTree): AccountUpdateTreeBase & { isDummy: Bool } {\n    let accountUpdate = node.final ?? HashedAccountUpdate.hash(node.mutable);\n    let children = node.children.finalize();\n    return { accountUpdate, id: node.id, isDummy: node.isDummy, children };\n  },\n\n  isUnfinished(input: AccountUpdate | AccountUpdateTree | UnfinishedTree): input is UnfinishedTree {\n    return 'final' in input || 'mutable' in input;\n  },\n};\n\nclass AccountUpdateLayout {\n  readonly map: Map<number, UnfinishedTree>;\n  readonly root: UnfinishedTree;\n  final?: AccountUpdateForest;\n\n  constructor(root?: AccountUpdate) {\n    this.map = new Map();\n    root ??= AccountUpdate.dummy();\n    let rootTree: UnfinishedTree = {\n      mutable: root,\n      id: root.id,\n      isDummy: Bool(false),\n      children: UnfinishedForest.empty(),\n    };\n    this.map.set(root.id, rootTree);\n    this.root = rootTree;\n  }\n\n  get(update: AccountUpdate | AccountUpdateTree) {\n    return this.map.get(update.id);\n  }\n\n  private getOrCreate(update: AccountUpdate | AccountUpdateTree | UnfinishedTree): UnfinishedTree {\n    if (UnfinishedTree.isUnfinished(update)) {\n      if (!this.map.has(update.id)) {\n        this.map.set(update.id, update);\n      }\n      return update;\n    }\n    let node = this.map.get(update.id);\n\n    if (node !== undefined) {\n      // might have to change node\n      UnfinishedTree.setTo(node, update);\n      return node;\n    }\n\n    node = UnfinishedTree.create(update);\n    this.map.set(update.id, node);\n    return node;\n  }\n\n  pushChild(parent: AccountUpdate | UnfinishedTree, child: AccountUpdate | AccountUpdateTree) {\n    let parentNode = this.getOrCreate(parent);\n    let childNode = this.getOrCreate(child);\n    parentNode.children.push(childNode);\n  }\n\n  pushTopLevel(child: AccountUpdate) {\n    this.pushChild(this.root, child);\n  }\n\n  setChildren(parent: AccountUpdate | UnfinishedTree, children: AccountUpdateForest) {\n    let parentNode = this.getOrCreate(parent);\n    parentNode.children.setToForest(children);\n  }\n\n  setTopLevel(children: AccountUpdateForest) {\n    this.setChildren(this.root, children);\n  }\n\n  disattach(update: AccountUpdate | AccountUpdateTree) {\n    let node = this.get(update);\n    node?.siblings?.remove(node);\n    return node;\n  }\n\n  finalizeAndRemove(update: AccountUpdate | AccountUpdateTree) {\n    let node = this.get(update);\n    if (node === undefined) return;\n    this.disattach(update);\n    return node.children.finalize();\n  }\n\n  finalizeChildren() {\n    let final = this.root.children.finalize();\n    this.final = final;\n    AccountUpdateForest.assertConstant(final);\n    return final;\n  }\n\n  toFlatList({ mutate }: { mutate: boolean }) {\n    return this.root.children.toFlatArray(mutate);\n  }\n\n  forEachPredecessor(update: AccountUpdate, callback: (update: AccountUpdate) => void) {\n    let updates = this.toFlatList({ mutate: false });\n    for (let otherUpdate of updates) {\n      if (otherUpdate.id === update.id) return;\n      callback(otherUpdate);\n    }\n  }\n\n  toConstantInPlace() {\n    this.root.children.toConstantInPlace();\n  }\n}\n\n// authorization\n\ntype ZkappCommand = {\n  feePayer: FeePayerUnsigned;\n  accountUpdates: AccountUpdate[];\n  memo: string;\n};\ntype ZkappCommandSigned = {\n  feePayer: FeePayer;\n  accountUpdates: (AccountUpdate & { lazyAuthorization?: LazyProof })[];\n  memo: string;\n};\ntype ZkappCommandProved = {\n  feePayer: FeePayerUnsigned;\n  accountUpdates: (AccountUpdate & { lazyAuthorization?: LazySignature })[];\n  memo: string;\n};\n\nconst ZkappCommand = {\n  toPretty(transaction: ZkappCommand) {\n    let feePayer = ZkappCommand.toJSON(transaction).feePayer as any;\n    feePayer.body.publicKey = '..' + feePayer.body.publicKey.slice(-4);\n    feePayer.body.authorization = '..' + feePayer.authorization.slice(-4);\n    if (feePayer.body.validUntil === null) delete feePayer.body.validUntil;\n    return [\n      { label: 'feePayer', ...feePayer.body },\n      ...transaction.accountUpdates.map((a) => a.toPretty()),\n    ];\n  },\n  parse(json: string): ZkappCommand {\n    let parsedJson: Types.Json.ZkappCommand;\n    try {\n      parsedJson = JSON.parse(json) as Types.Json.ZkappCommand;\n    } catch (error) {\n      throw new Error(\n        `Failed to parse ZkappCommand from JSON string: ${\n          error instanceof Error ? error.message : 'Invalid JSON'\n        }`\n      );\n    }\n\n    try {\n      return this.fromJSON(parsedJson);\n    } catch (error) {\n      throw new Error(\n        `Failed to construct ZkappCommand from parsed JSON: ${\n          error instanceof Error ? error.message : 'Invalid ZkappCommand structure'\n        }`\n      );\n    }\n  },\n  fromJSON(json: Types.Json.ZkappCommand | string): ZkappCommand {\n    // If it's a string, parse it and return\n    if (typeof json === 'string') {\n      return this.parse(json);\n    }\n\n    // Handle the Types.Json.ZkappCommand case\n    let { feePayer } = Types.ZkappCommand.fromJSON({\n      feePayer: json.feePayer,\n      accountUpdates: [],\n      memo: json.memo,\n    });\n    let memo = Memo.toString(Memo.fromBase58(json.memo));\n    let accountUpdates = json.accountUpdates.map(AccountUpdate.fromJSON);\n    return { feePayer, accountUpdates, memo };\n  },\n  toJSON({ feePayer, accountUpdates, memo }: ZkappCommand) {\n    memo = Memo.toBase58(Memo.fromString(memo));\n    return Types.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });\n  },\n};\n\ntype AccountUpdateProved = AccountUpdate & {\n  lazyAuthorization?: LazySignature;\n};\n\nconst Authorization = {\n  hasLazyProof(accountUpdate: AccountUpdate) {\n    return accountUpdate.lazyAuthorization?.kind === 'lazy-proof';\n  },\n  hasAny(accountUpdate: AccountUpdate) {\n    let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;\n    return !!(lazyAuth || 'proof' in auth || 'signature' in auth);\n  },\n  setSignature(accountUpdate: AccountUpdate, signature: string) {\n    accountUpdate.authorization = { signature };\n    accountUpdate.lazyAuthorization = undefined;\n  },\n  setProof(accountUpdate: AccountUpdate, proof: string): AccountUpdateProved {\n    accountUpdate.authorization = { proof };\n    accountUpdate.lazyAuthorization = undefined;\n    return accountUpdate as AccountUpdateProved;\n  },\n  setLazySignature(accountUpdate: AccountUpdate) {\n    accountUpdate.body.authorizationKind.isSigned = Bool(true);\n    accountUpdate.body.authorizationKind.isProved = Bool(false);\n    accountUpdate.body.authorizationKind.verificationKeyHash = Field(\n      mocks.dummyVerificationKeyHash\n    );\n    accountUpdate.authorization = {};\n    accountUpdate.lazyAuthorization = { kind: 'lazy-signature' };\n  },\n  setLazyNone(accountUpdate: AccountUpdate) {\n    accountUpdate.body.authorizationKind.isSigned = Bool(false);\n    accountUpdate.body.authorizationKind.isProved = Bool(false);\n    accountUpdate.body.authorizationKind.verificationKeyHash = Field(\n      mocks.dummyVerificationKeyHash\n    );\n    accountUpdate.authorization = {};\n    accountUpdate.lazyAuthorization = { kind: 'lazy-none' };\n  },\n};\n\nfunction addMissingSignatures(\n  zkappCommand: ZkappCommand,\n  privateKeys: PrivateKey[]\n): ZkappCommandSigned {\n  let additionalPublicKeys = privateKeys.map((sk) => sk.toPublicKey());\n  let { commitment, fullCommitment } = transactionCommitments(\n    {\n      ...Types.ZkappCommand.toValue(zkappCommand),\n      // TODO: represent memo in encoded form already?\n      memo: Memo.toBase58(Memo.fromString(zkappCommand.memo)),\n    },\n    activeInstance.getNetworkId()\n  );\n\n  function addFeePayerSignature(accountUpdate: FeePayerUnsigned): FeePayer {\n    let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);\n    if (lazyAuthorization === undefined) return { body, authorization };\n\n    let i = additionalPublicKeys.findIndex((pk) =>\n      pk.equals(accountUpdate.body.publicKey).toBoolean()\n    );\n    if (i === -1) {\n      // private key is missing, but we are not throwing an error here\n      // there is a change signature will be added by the wallet\n      // if not, error will be thrown by verifyAccountUpdate\n      // while .send() execution\n      return { body, authorization: dummySignature() };\n    }\n    let privateKey = privateKeys[i];\n\n    let signature = signFieldElement(\n      fullCommitment,\n      privateKey.toBigInt(),\n      activeInstance.getNetworkId()\n    );\n    return { body, authorization: Signature.toBase58(signature) };\n  }\n\n  function addSignature(accountUpdate: AccountUpdate) {\n    accountUpdate = AccountUpdate.clone(accountUpdate);\n    if (accountUpdate.lazyAuthorization?.kind !== 'lazy-signature') {\n      return accountUpdate as AccountUpdate & { lazyAuthorization?: LazyProof };\n    }\n    let i = additionalPublicKeys.findIndex((pk) =>\n      pk.equals(accountUpdate.body.publicKey).toBoolean()\n    );\n    if (i === -1) {\n      // private key is missing, but we are not throwing an error here\n      // there is a change signature will be added by the wallet\n      // if not, error will be thrown by verifyAccountUpdate\n      // while .send() execution\n      Authorization.setSignature(accountUpdate, dummySignature());\n      return accountUpdate as AccountUpdate & {\n        lazyAuthorization: undefined;\n      };\n    }\n    let privateKey = privateKeys[i];\n\n    let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean()\n      ? fullCommitment\n      : commitment;\n    let signature = signFieldElement(\n      transactionCommitment,\n      privateKey.toBigInt(),\n      activeInstance.getNetworkId()\n    );\n    Authorization.setSignature(accountUpdate, Signature.toBase58(signature));\n    return accountUpdate as AccountUpdate & { lazyAuthorization: undefined };\n  }\n  let { feePayer, accountUpdates, memo } = zkappCommand;\n  return {\n    feePayer: addFeePayerSignature(feePayer),\n    accountUpdates: accountUpdates.map(addSignature),\n    memo,\n  };\n}\n\nfunction dummySignature() {\n  return Signature.toBase58(Signature.dummy());\n}\n\n/**\n * The public input for zkApps consists of certain hashes of the proving\n * account update (and its child updates) which is constructed during method execution.\n *\n * For SmartContract proving, a method is run twice: First outside the proof, to\n * obtain the public input, and once in the prover, which takes the public input\n * as input. The current transaction is hashed again inside the prover, which\n * asserts that the result equals the input public input, as part of the snark\n * circuit. The block producer will also hash the transaction they receive and\n * pass it as a public input to the verifier. Thus, the transaction is fully\n * constrained by the proof - the proof couldn't be used to attest to a different\n * transaction.\n */\ntype ZkappPublicInput = {\n  accountUpdate: Field;\n  calls: Field;\n};\nlet ZkappPublicInput = provablePure({ accountUpdate: Field, calls: Field });\n\nasync function addMissingProofs(\n  zkappCommand: ZkappCommand,\n  { proofsEnabled = true }\n): Promise<{\n  zkappCommand: ZkappCommandProved;\n  proofs: (Proof<ZkappPublicInput, Empty> | undefined)[];\n}> {\n  let { feePayer, accountUpdates, memo } = zkappCommand;\n  // compute proofs serially. in parallel would clash with our global variable\n  // hacks\n  let accountUpdatesProved: AccountUpdateProved[] = [];\n  let proofs: (Proof<ZkappPublicInput, Empty> | undefined)[] = [];\n  for (let i = 0; i < accountUpdates.length; i++) {\n    let { accountUpdateProved, proof } = await addProof(zkappCommand, i, proofsEnabled);\n    accountUpdatesProved.push(accountUpdateProved);\n    proofs.push(proof);\n  }\n  return {\n    zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },\n    proofs,\n  };\n}\n\nasync function addProof(transaction: ZkappCommand, index: number, proofsEnabled: boolean) {\n  let accountUpdate = transaction.accountUpdates[index];\n  accountUpdate = AccountUpdate.clone(accountUpdate);\n\n  if (accountUpdate.lazyAuthorization?.kind !== 'lazy-proof') {\n    return {\n      accountUpdateProved: accountUpdate as AccountUpdateProved,\n      proof: undefined,\n    };\n  }\n  if (!proofsEnabled) {\n    Authorization.setProof(accountUpdate, await dummyBase64Proof());\n    return {\n      accountUpdateProved: accountUpdate as AccountUpdateProved,\n      proof: undefined,\n    };\n  }\n\n  let lazyProof: LazyProof = accountUpdate.lazyAuthorization;\n  let prover = getZkappProver(lazyProof);\n  let proverData = { transaction, accountUpdate, index };\n  let proof = await createZkappProof(prover, lazyProof, proverData);\n\n  let accountUpdateProved = Authorization.setProof(\n    accountUpdate,\n    Pickles.proofToBase64Transaction(proof.proof)\n  );\n  return { accountUpdateProved, proof };\n}\n\nasync function createZkappProof(\n  prover: Pickles.Prover,\n  { methodName, args, ZkappClass, memoized, blindingValue }: LazyProof,\n  { transaction, accountUpdate, index }: ZkappProverData\n): Promise<Proof<ZkappPublicInput, Empty>> {\n  let publicInput = accountUpdate.toPublicInput(transaction);\n  let publicInputFields = MlFieldConstArray.to(ZkappPublicInput.toFields(publicInput));\n\n  let [, , proof] = await zkAppProver.run(\n    [accountUpdate.publicKey, accountUpdate.tokenId, ...args],\n    { transaction, accountUpdate, index },\n    async () => {\n      let id = memoizationContext.enter({\n        memoized,\n        currentIndex: 0,\n        blindingValue,\n      });\n      try {\n        return await prover(publicInputFields);\n      } catch (err) {\n        console.error(`Error when proving ${ZkappClass.name}.${methodName}()`);\n        throw err;\n      } finally {\n        memoizationContext.leave(id);\n      }\n    }\n  );\n\n  let maxProofsVerified = await ZkappClass.getMaxProofsVerified();\n  const Proof = ZkappClass.Proof();\n  return new Proof({\n    publicInput,\n    publicOutput: undefined,\n    proof,\n    maxProofsVerified,\n  });\n}\n\nfunction getZkappProver({ methodName, ZkappClass }: LazyProof) {\n  if (ZkappClass._provers === undefined)\n    throw Error(\n      `Cannot prove execution of ${methodName}(), no prover found. ` +\n        `Try calling \\`await ${ZkappClass.name}.compile()\\` first, this will cache provers in the background.`\n    );\n  let provers = ZkappClass._provers;\n  let methodError =\n    `Error when computing proofs: Method ${methodName} not found. ` +\n    `Make sure your environment supports decorators, and annotate with \\`@method ${methodName}\\`.`;\n  if (ZkappClass._methods === undefined) throw Error(methodError);\n  let i = ZkappClass._methods.findIndex((m) => m.methodName === methodName);\n  if (i === -1) throw Error(methodError);\n  return provers[i];\n}\n", "import { Test } from '../../../bindings.js';\nimport { Field } from '../../provable/wrapped.js';\nimport { UInt64 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { TokenId, Authorization } from './account-update.js';\nimport * as Fetch from './fetch.js';\nimport { humanizeErrors, invalidTransactionError } from './errors.js';\nimport { Types } from '../../../bindings/mina-transaction/v1/types.js';\nimport { Account } from './account.js';\nimport { NetworkId } from '../../../mina-signer/src/types.js';\nimport { currentTransaction } from './transaction-context.js';\nimport {\n  type FeePayerSpec,\n  type ActionStates,\n  type NetworkConstants,\n  activeInstance,\n  setActiveInstance,\n  Mina,\n  defaultNetworkConstants,\n  currentSlot,\n  getAccount,\n  hasAccount,\n  getBalance,\n  getNetworkId,\n  getNetworkConstants,\n  getNetworkState,\n  fetchEvents,\n  fetchActions,\n  getActions,\n  getProofsEnabled,\n} from './mina-instance.js';\nimport { type EventActionFilterOptions } from './graphql.js';\nimport {\n  Transaction,\n  type PendingTransaction,\n  type IncludedTransaction,\n  type RejectedTransaction,\n  type PendingTransactionStatus,\n  type PendingTransactionPromise,\n  createTransaction,\n  toTransactionPromise,\n  transaction,\n  createRejectedTransaction,\n  createIncludedTransaction,\n  toPendingTransactionPromise,\n} from './transaction.js';\nimport {\n  reportGetAccountError,\n  verifyTransactionLimits,\n  defaultNetworkState,\n  filterGroups,\n} from './transaction-validation.js';\nimport { LocalBlockchain, TestPublicKey } from './local-blockchain.js';\n\nexport {\n  LocalBlockchain,\n  Network,\n  currentTransaction,\n  Transaction,\n  type PendingTransaction,\n  type IncludedTransaction,\n  type RejectedTransaction,\n  type PendingTransactionStatus,\n  type PendingTransactionPromise,\n  TestPublicKey,\n  activeInstance,\n  setActiveInstance,\n  transaction,\n  sender,\n  currentSlot,\n  getAccount,\n  hasAccount,\n  getBalance,\n  getNetworkId,\n  getNetworkConstants,\n  getNetworkState,\n  fetchEvents,\n  fetchActions,\n  getActions,\n  FeePayerSpec,\n  ActionStates,\n  faucet,\n  waitForFunding,\n  getProofsEnabled,\n  // for internal testing only\n  filterGroups,\n  type NetworkConstants,\n};\n\n// patch active instance so that we can still create basic transactions without giving Mina network details\nsetActiveInstance({\n  ...activeInstance,\n  transaction(sender: FeePayerSpec, f: () => Promise<void>) {\n    return toTransactionPromise(() => createTransaction(sender, f, 0));\n  },\n});\n\n/**\n * Represents the Mina blockchain running on a real network\n */\nfunction Network(graphqlEndpoint: string): Mina;\nfunction Network(options: {\n  networkId?: NetworkId;\n  mina: string | string[];\n  archive?: string | string[];\n  lightnetAccountManager?: string;\n  bypassTransactionLimits?: boolean;\n  minaDefaultHeaders?: HeadersInit;\n  archiveDefaultHeaders?: HeadersInit;\n}): Mina;\nfunction Network(\n  options:\n    | {\n        networkId?: NetworkId;\n        mina: string | string[];\n        archive?: string | string[];\n        lightnetAccountManager?: string;\n        bypassTransactionLimits?: boolean;\n        minaDefaultHeaders?: HeadersInit;\n        archiveDefaultHeaders?: HeadersInit;\n      }\n    | string\n): Mina {\n  let minaNetworkId: NetworkId = 'devnet';\n  let minaGraphqlEndpoint: string;\n  let archiveEndpoint: string;\n  let lightnetAccountManagerEndpoint: string;\n  let enforceTransactionLimits: boolean = true;\n\n  if (options && typeof options === 'string') {\n    minaGraphqlEndpoint = options;\n    Fetch.setGraphqlEndpoint(minaGraphqlEndpoint);\n  } else if (options && typeof options === 'object') {\n    if (options.networkId) {\n      minaNetworkId = options.networkId;\n    }\n    if (!options.mina)\n      throw new Error(\"Network: malformed input. Please provide an object with 'mina' endpoint.\");\n    if (Array.isArray(options.mina) && options.mina.length !== 0) {\n      minaGraphqlEndpoint = options.mina[0];\n      Fetch.setGraphqlEndpoint(minaGraphqlEndpoint, options.minaDefaultHeaders);\n      Fetch.setMinaGraphqlFallbackEndpoints(options.mina.slice(1));\n    } else if (typeof options.mina === 'string') {\n      minaGraphqlEndpoint = options.mina;\n      Fetch.setGraphqlEndpoint(minaGraphqlEndpoint, options.minaDefaultHeaders);\n    }\n\n    if (options.archive !== undefined) {\n      if (Array.isArray(options.archive) && options.archive.length !== 0) {\n        archiveEndpoint = options.archive[0];\n        Fetch.setArchiveGraphqlEndpoint(archiveEndpoint, options.archiveDefaultHeaders);\n        Fetch.setArchiveGraphqlFallbackEndpoints(options.archive.slice(1));\n      } else if (typeof options.archive === 'string') {\n        archiveEndpoint = options.archive;\n        Fetch.setArchiveGraphqlEndpoint(archiveEndpoint, options.archiveDefaultHeaders);\n      }\n    }\n\n    if (\n      options.lightnetAccountManager !== undefined &&\n      typeof options.lightnetAccountManager === 'string'\n    ) {\n      lightnetAccountManagerEndpoint = options.lightnetAccountManager;\n      Fetch.setLightnetAccountManagerEndpoint(lightnetAccountManagerEndpoint);\n    }\n\n    if (\n      options.bypassTransactionLimits !== undefined &&\n      typeof options.bypassTransactionLimits === 'boolean'\n    ) {\n      enforceTransactionLimits = !options.bypassTransactionLimits;\n    }\n  } else {\n    throw new Error(\n      \"Network: malformed input. Please provide a string or an object with 'mina' and 'archive' endpoints.\"\n    );\n  }\n\n  return {\n    getNetworkId: () => minaNetworkId,\n    getNetworkConstants() {\n      if (currentTransaction()?.fetchMode === 'test') {\n        Fetch.markNetworkToBeFetched(minaGraphqlEndpoint);\n        const genesisConstants = Fetch.getCachedGenesisConstants(minaGraphqlEndpoint);\n        return genesisConstants !== undefined\n          ? genesisToNetworkConstants(genesisConstants)\n          : defaultNetworkConstants;\n      }\n      if (!currentTransaction.has() || currentTransaction.get().fetchMode === 'cached') {\n        const genesisConstants = Fetch.getCachedGenesisConstants(minaGraphqlEndpoint);\n        if (genesisConstants !== undefined) return genesisToNetworkConstants(genesisConstants);\n      }\n      return defaultNetworkConstants;\n    },\n    currentSlot() {\n      throw Error('currentSlot() is not implemented yet for remote blockchains.');\n    },\n    hasAccount(publicKey: PublicKey, tokenId: Field = TokenId.default) {\n      if (!currentTransaction.has() || currentTransaction.get().fetchMode === 'cached') {\n        return !!Fetch.getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);\n      }\n      return false;\n    },\n    getAccount(publicKey: PublicKey, tokenId: Field = TokenId.default) {\n      if (currentTransaction()?.fetchMode === 'test') {\n        Fetch.markAccountToBeFetched(publicKey, tokenId, minaGraphqlEndpoint);\n        let account = Fetch.getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);\n        return account ?? dummyAccount(publicKey);\n      }\n      if (!currentTransaction.has() || currentTransaction.get().fetchMode === 'cached') {\n        let account = Fetch.getCachedAccount(publicKey, tokenId, minaGraphqlEndpoint);\n        if (account !== undefined) return account;\n      }\n      throw Error(\n        `${reportGetAccountError(\n          publicKey.toBase58(),\n          TokenId.toBase58(tokenId)\n        )}\\nGraphql endpoint: ${minaGraphqlEndpoint}`\n      );\n    },\n    getNetworkState() {\n      if (currentTransaction()?.fetchMode === 'test') {\n        Fetch.markNetworkToBeFetched(minaGraphqlEndpoint);\n        let network = Fetch.getCachedNetwork(minaGraphqlEndpoint);\n        return network ?? defaultNetworkState();\n      }\n      if (!currentTransaction.has() || currentTransaction.get().fetchMode === 'cached') {\n        let network = Fetch.getCachedNetwork(minaGraphqlEndpoint);\n        if (network !== undefined) return network;\n      }\n      throw Error(\n        `getNetworkState: Could not fetch network state from graphql endpoint ${minaGraphqlEndpoint} outside of a transaction.`\n      );\n    },\n    sendTransaction(txn) {\n      return toPendingTransactionPromise(async () => {\n        if (enforceTransactionLimits) verifyTransactionLimits(txn.transaction);\n\n        let [response, error] = await Fetch.sendZkapp(txn.toJSON());\n        let errors: string[] = [];\n        if (response === undefined && error !== undefined) {\n          errors = [JSON.stringify(error)];\n        } else if (response && response.errors && response.errors.length > 0) {\n          response?.errors.forEach((e: any) => errors.push(JSON.stringify(e)));\n        }\n        const updatedErrors = humanizeErrors(errors);\n\n        const status: PendingTransactionStatus = errors.length === 0 ? 'pending' : 'rejected';\n        let mlTest = await Test();\n        const hash = mlTest.transactionHash.hashZkAppCommand(txn.toJSON());\n        const pendingTransaction: Omit<PendingTransaction, 'wait' | 'safeWait'> = {\n          status,\n          data: response?.data,\n          errors: updatedErrors,\n          transaction: txn.transaction,\n          setFee: txn.setFee,\n          setFeePerSnarkCost: txn.setFeePerSnarkCost,\n          hash,\n          toJSON: txn.toJSON,\n          toPretty: txn.toPretty,\n        };\n\n        const pollTransactionStatus = async (\n          transactionHash: string,\n          maxAttempts: number,\n          interval: number,\n          attempts: number = 0\n        ): Promise<IncludedTransaction | RejectedTransaction> => {\n          let res: Awaited<ReturnType<typeof Fetch.checkZkappTransaction>>;\n          try {\n            res = await Fetch.checkZkappTransaction(transactionHash);\n            if (res.success) {\n              return createIncludedTransaction(pendingTransaction);\n            } else if (res.failureReason) {\n              const error = invalidTransactionError(txn.transaction, res.failureReason, {\n                accountCreationFee: defaultNetworkConstants.accountCreationFee.toString(),\n              });\n              return createRejectedTransaction(pendingTransaction, [error]);\n            }\n          } catch (error) {\n            return createRejectedTransaction(pendingTransaction, [(error as Error).message]);\n          }\n\n          if (maxAttempts && attempts >= maxAttempts) {\n            return createRejectedTransaction(pendingTransaction, [\n              `Exceeded max attempts.\\nTransactionId: ${transactionHash}\\nAttempts: ${attempts}\\nLast received status: ${res}`,\n            ]);\n          }\n\n          await new Promise((resolve) => setTimeout(resolve, interval));\n          return pollTransactionStatus(transactionHash, maxAttempts, interval, attempts + 1);\n        };\n\n        // default is 45 attempts * 20s each = 15min\n        // the block time on berkeley is currently longer than the average 3-4min, so its better to target a higher block time\n        // fetching an update every 20s is more than enough with a current block time of 3min\n        const poll = async (\n          maxAttempts: number = 45,\n          interval: number = 20000\n        ): Promise<IncludedTransaction | RejectedTransaction> => {\n          return pollTransactionStatus(hash, maxAttempts, interval);\n        };\n\n        const wait = async (options?: {\n          maxAttempts?: number;\n          interval?: number;\n        }): Promise<IncludedTransaction> => {\n          const pendingTransaction = await safeWait(options);\n          if (pendingTransaction.status === 'rejected') {\n            throw Error(`Transaction failed with errors:\\n${pendingTransaction.errors.join('\\n')}`);\n          }\n          return pendingTransaction;\n        };\n\n        const safeWait = async (options?: {\n          maxAttempts?: number;\n          interval?: number;\n        }): Promise<IncludedTransaction | RejectedTransaction> => {\n          if (status === 'rejected') {\n            return createRejectedTransaction(pendingTransaction, pendingTransaction.errors);\n          }\n          return await poll(options?.maxAttempts, options?.interval);\n        };\n\n        return {\n          ...pendingTransaction,\n          wait,\n          safeWait,\n        };\n      });\n    },\n    transaction(sender: FeePayerSpec, f: () => Promise<void>) {\n      return toTransactionPromise(async () => {\n        // TODO we run the transaction twice to be able to fetch data in between\n        let tx = await createTransaction(sender, f, 0, {\n          fetchMode: 'test',\n          isFinalRunOutsideCircuit: false,\n        });\n        await Fetch.fetchMissingData(minaGraphqlEndpoint, archiveEndpoint);\n        let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);\n        return await createTransaction(sender, f, 1, {\n          fetchMode: 'cached',\n          isFinalRunOutsideCircuit: !hasProofs,\n        });\n      });\n    },\n    async fetchEvents(\n      publicKey: PublicKey,\n      tokenId: Field = TokenId.default,\n      filterOptions: EventActionFilterOptions = {},\n      headers?: HeadersInit\n    ) {\n      const pubKey = publicKey.toBase58();\n      const token = TokenId.toBase58(tokenId);\n      const from = filterOptions.from ? Number(filterOptions.from.toString()) : undefined;\n      const to = filterOptions.to ? Number(filterOptions.to.toString()) : undefined;\n\n      return Fetch.fetchEvents(\n        { publicKey: pubKey, tokenId: token, from, to },\n        archiveEndpoint,\n        headers\n      );\n    },\n    async fetchActions(\n      publicKey: PublicKey,\n      actionStates?: ActionStates,\n      tokenId: Field = TokenId.default,\n      from?: number,\n      to?: number,\n      headers?: HeadersInit\n    ) {\n      const pubKey = publicKey.toBase58();\n      const token = TokenId.toBase58(tokenId);\n      const { fromActionState, endActionState } = actionStates ?? {};\n      const fromActionStateBase58 = fromActionState ? fromActionState.toString() : undefined;\n      const endActionStateBase58 = endActionState ? endActionState.toString() : undefined;\n\n      return Fetch.fetchActions(\n        {\n          publicKey: pubKey,\n          actionStates: {\n            fromActionState: fromActionStateBase58,\n            endActionState: endActionStateBase58,\n          },\n          from,\n          to,\n          tokenId: token,\n        },\n        archiveEndpoint,\n        headers\n      );\n    },\n    getActions(\n      publicKey: PublicKey,\n      actionStates?: ActionStates,\n      tokenId: Field = TokenId.default\n    ) {\n      if (currentTransaction()?.fetchMode === 'test') {\n        Fetch.markActionsToBeFetched(publicKey, tokenId, archiveEndpoint, actionStates);\n        let actions = Fetch.getCachedActions(publicKey, tokenId);\n        return actions ?? [];\n      }\n      if (!currentTransaction.has() || currentTransaction.get().fetchMode === 'cached') {\n        let actions = Fetch.getCachedActions(publicKey, tokenId);\n        if (actions !== undefined) return actions;\n      }\n      throw Error(`getActions: Could not find actions for the public key ${publicKey.toBase58()}`);\n    },\n    proofsEnabled: true,\n  };\n}\n\n/**\n * Returns the public key of the current transaction's sender account.\n *\n * Throws an error if not inside a transaction, or the sender wasn't passed in.\n */\nfunction sender() {\n  let tx = currentTransaction();\n  if (tx === undefined)\n    throw Error(\n      `The sender is not available outside a transaction. Make sure you only use it within \\`Mina.transaction\\` blocks or smart contract methods.`\n    );\n  let sender = currentTransaction()?.sender;\n  if (sender === undefined)\n    throw Error(\n      `The sender is not available, because the transaction block was created without the optional \\`sender\\` argument.\nHere's an example for how to pass in the sender and make it available:\n\nMina.transaction(sender, // <-- pass in sender's public key here\n() => {\n  // methods can use this.sender\n});\n`\n    );\n  return sender;\n}\n\nfunction dummyAccount(pubkey?: PublicKey): Account {\n  let dummy = Types.Account.empty();\n  if (pubkey) dummy.publicKey = pubkey;\n  return dummy;\n}\n\nasync function waitForFunding(address: string, headers?: HeadersInit): Promise<void> {\n  let attempts = 0;\n  let maxAttempts = 30;\n  let interval = 30000;\n  const executePoll = async (resolve: () => void, reject: (err: Error) => void | Error) => {\n    let { account } = await Fetch.fetchAccount({ publicKey: address }, undefined, { headers });\n    attempts++;\n    if (account) {\n      return resolve();\n    } else if (maxAttempts && attempts === maxAttempts) {\n      return reject(new Error(`Exceeded max attempts`));\n    } else {\n      setTimeout(executePoll, interval, resolve, reject);\n    }\n  };\n  return new Promise(executePoll);\n}\n\n/**\n * Requests the [testnet faucet](https://faucet.minaprotocol.com/api/v1/faucet) to fund a public key.\n */\nasync function faucet(pub: PublicKey, network: string = 'devnet', headers?: HeadersInit) {\n  let address = pub.toBase58();\n  let response = await fetch('https://faucet.minaprotocol.com/api/v1/faucet', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      network,\n      address: address,\n    }),\n  });\n  response = await response.json();\n  if (response.status.toString() !== 'success') {\n    throw new Error(\n      `Error funding account ${address}, got response status: ${response.status}, text: ${response.statusText}`\n    );\n  }\n  await waitForFunding(address, headers);\n}\n\nfunction genesisToNetworkConstants(genesisConstants: Fetch.GenesisConstants): NetworkConstants {\n  return {\n    genesisTimestamp: UInt64.from(Date.parse(genesisConstants.genesisTimestamp)),\n    slotTime: UInt64.from(genesisConstants.slotDuration),\n    accountCreationFee: UInt64.from(genesisConstants.accountCreationFee),\n  };\n}\n", "import { Types } from '../../../bindings/mina-transaction/v1/types.js';\nimport { Bool, Field } from '../../provable/wrapped.js';\nimport { Permissions } from './account-update.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { TokenId, ReceiptChainHash } from './base58-encodings.js';\nimport { genericLayoutFold } from '../../../bindings/lib/from-layout.js';\nimport { customTypes, TypeMap } from '../../../bindings/mina-transaction/gen/v1/transaction.js';\nimport { jsLayout } from '../../../bindings/mina-transaction/gen/v1/js-layout.js';\nimport { ProvableExtended } from '../../provable/types/struct.js';\nimport { FetchedAccount } from './graphql.js';\n\nexport { Account, PartialAccount };\nexport { newAccount, parseFetchedAccount, fillPartialAccount };\n\ntype Account = Types.Account;\nconst Account = Types.Account;\n\nfunction newAccount(accountId: { publicKey: PublicKey; tokenId?: Field }): Account {\n  let account = Account.empty();\n  account.publicKey = accountId.publicKey;\n  account.tokenId = accountId.tokenId ?? Types.TokenId.empty();\n  account.permissions = Permissions.initial();\n  return account;\n}\n\ntype PartialAccount = Omit<Partial<Account>, 'zkapp'> & {\n  zkapp?: Partial<Account['zkapp']>;\n};\n\n// convert FetchedAccount (from graphql) to Account (internal representation both here and in Mina)\nfunction parseFetchedAccount(account: FetchedAccount): Account {\n  const {\n    publicKey,\n    nonce,\n    zkappState,\n    balance,\n    permissions,\n    timing: { cliffAmount, cliffTime, initialMinimumBalance, vestingIncrement, vestingPeriod },\n    delegateAccount,\n    receiptChainHash,\n    actionState,\n    token,\n    tokenSymbol,\n    verificationKey,\n    provedState,\n    zkappUri,\n  } = account;\n\n  let hasZkapp =\n    zkappState !== null ||\n    verificationKey !== null ||\n    actionState !== null ||\n    zkappUri !== null ||\n    provedState;\n  let partialAccount: PartialAccount = {\n    publicKey: PublicKey.fromBase58(publicKey),\n    tokenId: TokenId.fromBase58(token),\n    tokenSymbol: tokenSymbol ?? undefined,\n    balance: balance && UInt64.from(balance.total),\n    nonce: UInt32.from(nonce),\n    receiptChainHash:\n      (receiptChainHash && ReceiptChainHash.fromBase58(receiptChainHash)) || undefined,\n    delegate: (delegateAccount && PublicKey.fromBase58(delegateAccount.publicKey)) ?? undefined,\n    votingFor: undefined, // TODO\n    timing:\n      (cliffAmount &&\n        cliffTime &&\n        initialMinimumBalance &&\n        vestingIncrement &&\n        vestingPeriod && {\n          isTimed: Bool(true),\n          cliffAmount: UInt64.from(cliffAmount),\n          cliffTime: UInt32.from(cliffTime),\n          initialMinimumBalance: UInt64.from(initialMinimumBalance),\n          vestingIncrement: UInt64.from(vestingIncrement),\n          vestingPeriod: UInt32.from(vestingPeriod),\n        }) ||\n      undefined,\n    permissions: (permissions && Permissions.fromJSON(permissions)) ?? Permissions.initial(),\n    zkapp: hasZkapp\n      ? {\n          appState: (zkappState && zkappState.map(Field)) ?? undefined,\n          verificationKey:\n            (verificationKey && {\n              data: verificationKey.verificationKey,\n              hash: Field(verificationKey.hash),\n            }) ??\n            undefined,\n          zkappVersion: undefined, // TODO\n          actionState: (actionState && actionState.map(Field)) ?? undefined,\n          lastActionSlot: undefined, // TODO\n          provedState: provedState !== null ? Bool(provedState) : undefined,\n          zkappUri: zkappUri !== null ? zkappUri : undefined,\n        }\n      : undefined,\n  };\n  return fillPartialAccount(partialAccount);\n}\n\nfunction fillPartialAccount(account: PartialAccount): Account {\n  return genericLayoutFold<ProvableExtended<any>>(\n    TypeMap,\n    customTypes,\n    {\n      map(type, value) {\n        // if value exists, use it; otherwise fall back to dummy value\n        if (value !== undefined) return value;\n        return type.empty();\n      },\n      reduceArray(array) {\n        return array;\n      },\n      reduceObject(_, record) {\n        return record;\n      },\n      reduceFlaggedOption() {\n        // doesn't occur for accounts\n        throw Error('not relevant');\n      },\n      reduceOrUndefined(value) {\n        // don't fill in value that's allowed to be undefined\n        return value;\n      },\n    },\n    jsLayout.Account as any,\n    account as unknown\n  );\n}\n", "import { UInt32 } from '../../provable/int.js';\nimport { TokenId, type ZkappCommand } from './account-update.js';\nimport type { ActionStatesStringified } from './fetch.js';\nimport { Types } from '../../../bindings/mina-transaction/v1/types.js';\n\nexport {\n  type EpochData,\n  type LastBlockQueryResponse,\n  type GenesisConstantsResponse,\n  type FailureReasonResponse,\n  type LastBlockQueryFailureCheckResponse,\n  type FetchedAction,\n  type FetchedBlock,\n  type TransactionStatus,\n  type TransactionStatusQueryResponse,\n  type EventsQueryInputs,\n  type EventQueryResponse,\n  type ActionsQueryInputs,\n  type ActionQueryResponse,\n  type EventActionFilterOptions,\n  type SendZkAppResponse,\n  type FetchedAccount,\n  type FetchedAccountResponse,\n  type CurrentSlotResponse,\n  getEventsQuery,\n  getActionsQuery,\n  sendZkappQuery,\n  transactionStatusQuery,\n  lastBlockQueryFailureCheck,\n  accountQuery,\n  currentSlotQuery,\n  genesisConstantsQuery,\n  lastBlockQuery,\n  removeJsonQuotes,\n};\n\n// removes the quotes on JSON keys\nfunction removeJsonQuotes(json: string) {\n  let cleaned = JSON.stringify(JSON.parse(json), null, 2);\n  return cleaned.replace(/\\\"(\\S+)\\\"\\s*:/gm, '$1:');\n}\n\ntype ActionsQueryInputs = {\n  /** Public key of the ZkApp to which actions have been emitted */\n  publicKey: string;\n  actionStates?: ActionStatesStringified;\n  tokenId?: string;\n  /** Block number to query from */\n  from?: number;\n  /** Block number to query to */\n  to?: number;\n};\n\ntype EventsQueryInputs = {\n  /** Public key of the ZkApp to which events have been emitted */\n  publicKey: string;\n  tokenId?: string;\n  /** Block number to query from */\n  from?: number;\n  /** Block number to query to */\n  to?: number;\n};\n\ntype AuthRequired = Types.Json.AuthRequired;\n// TODO auto-generate this type and the query\ntype FetchedAccount = {\n  publicKey: string;\n  token: string;\n  nonce: string;\n  balance: { total: string };\n  tokenSymbol: string | null;\n  receiptChainHash: string | null;\n  timing: {\n    initialMinimumBalance: string | null;\n    cliffTime: string | null;\n    cliffAmount: string | null;\n    vestingPeriod: string | null;\n    vestingIncrement: string | null;\n  };\n  permissions: {\n    editState: AuthRequired;\n    access: AuthRequired;\n    send: AuthRequired;\n    receive: AuthRequired;\n    setDelegate: AuthRequired;\n    setPermissions: AuthRequired;\n    setVerificationKey: {\n      auth: AuthRequired;\n      txnVersion: string;\n    };\n    setZkappUri: AuthRequired;\n    editActionState: AuthRequired;\n    setTokenSymbol: AuthRequired;\n    incrementNonce: AuthRequired;\n    setVotingFor: AuthRequired;\n    setTiming: AuthRequired;\n  } | null;\n  delegateAccount: { publicKey: string } | null;\n  votingFor: string | null;\n  zkappState: string[] | null;\n  verificationKey: { verificationKey: string; hash: string } | null;\n  actionState: string[] | null;\n  provedState: boolean | null;\n  zkappUri: string | null;\n};\ntype FetchedAccountResponse = {\n  account: FetchedAccount;\n};\n\ntype EpochData = {\n  ledger: {\n    hash: string;\n    totalCurrency: string;\n  };\n  seed: string;\n  startCheckpoint: string;\n  lockCheckpoint: string;\n  epochLength: string;\n};\n\ntype LastBlockQueryResponse = {\n  bestChain: {\n    protocolState: {\n      blockchainState: {\n        snarkedLedgerHash: string;\n        stagedLedgerHash: string;\n        date: string;\n        utcDate: string;\n        stagedLedgerProofEmitted: boolean;\n      };\n      previousStateHash: string;\n      consensusState: {\n        blockHeight: string;\n        slotSinceGenesis: string;\n        slot: string;\n        nextEpochData: EpochData;\n        stakingEpochData: EpochData;\n        epochCount: string;\n        minWindowDensity: string;\n        totalCurrency: string;\n        epoch: string;\n      };\n    };\n  }[];\n};\n\ntype FailureReasonResponse = {\n  failures: string[];\n  index: number;\n}[];\n\ntype LastBlockQueryFailureCheckResponse = {\n  bestChain: {\n    transactions: {\n      zkappCommands: {\n        hash: string;\n        failureReason: FailureReasonResponse;\n      }[];\n    };\n  }[];\n};\n\ntype FetchedBlock = {\n  protocolState: {\n    blockchainState: {\n      snarkedLedgerHash: string; // hash-like encoding\n      stagedLedgerHash: string; // hash-like encoding\n      date: string; // String(Date.now())\n      utcDate: string; // String(Date.now())\n      stagedLedgerProofEmitted: boolean; // bool\n    };\n    previousStateHash: string; // hash-like encoding\n    consensusState: {\n      blockHeight: string; // String(number)\n      slotSinceGenesis: string; // String(number)\n      slot: string; // String(number)\n      nextEpochData: {\n        ledger: {\n          hash: string; // hash-like encoding\n          totalCurrency: string; // String(number)\n        };\n        seed: string; // hash-like encoding\n        startCheckpoint: string; // hash-like encoding\n        lockCheckpoint: string; // hash-like encoding\n        epochLength: string; // String(number)\n      };\n      stakingEpochData: {\n        ledger: {\n          hash: string; // hash-like encoding\n          totalCurrency: string; // String(number)\n        };\n        seed: string; // hash-like encoding\n        startCheckpoint: string; // hash-like encoding\n        lockCheckpoint: string; // hash-like encoding\n        epochLength: string; // String(number)\n      };\n      epochCount: string; // String(number)\n      minWindowDensity: string; // String(number)\n      totalCurrency: string; // String(number)\n      epoch: string; // String(number)\n    };\n  };\n};\n\ntype GenesisConstantsResponse = {\n  genesisConstants: {\n    genesisTimestamp: string;\n    coinbase: string;\n    accountCreationFee: string;\n  };\n  daemonStatus: {\n    consensusConfiguration: {\n      epochDuration: string;\n      k: string;\n      slotDuration: string;\n      slotsPerEpoch: string;\n    };\n  };\n};\n\ntype CurrentSlotResponse = {\n  bestChain: Array<{\n    protocolState: {\n      consensusState: {\n        slot: number;\n      };\n    };\n  }>;\n};\n\n/**\n * INCLUDED: A transaction that is on the longest chain\n *\n * PENDING: A transaction either in the transition frontier or in transaction pool but is not on the longest chain\n *\n * UNKNOWN: The transaction has either been snarked, reached finality through consensus or has been dropped\n *\n */\ntype TransactionStatus = 'INCLUDED' | 'PENDING' | 'UNKNOWN';\n\ntype TransactionStatusQueryResponse = {\n  transactionStatus: TransactionStatus;\n};\n\ntype SendZkAppResponse = {\n  sendZkapp: {\n    zkapp: {\n      hash: string;\n      id: string;\n      zkappCommand: ZkappCommand;\n      failureReasons: FailureReasonResponse;\n    };\n  };\n};\n\ntype EventQueryResponse = {\n  events: {\n    blockInfo: {\n      distanceFromMaxBlockHeight: number;\n      globalSlotSinceGenesis: number;\n      height: number;\n      stateHash: string;\n      parentHash: string;\n      chainStatus: string;\n    };\n    eventData: {\n      transactionInfo: {\n        hash: string;\n        memo: string;\n        status: string;\n      };\n      data: string[];\n    }[];\n  }[];\n};\n\ntype FetchedAction = {\n  blockInfo: {\n    distanceFromMaxBlockHeight: number;\n  };\n  actionState: {\n    actionStateOne: string;\n    actionStateTwo: string;\n  };\n  actionData: {\n    accountUpdateId: string;\n    data: string[];\n    transactionInfo?: {\n      sequenceNumber: number;\n      zkappAccountUpdateIds: number[];\n    };\n  }[];\n};\n\ntype ActionQueryResponse = {\n  actions: FetchedAction[];\n};\n\ntype EventActionFilterOptions = {\n  to?: UInt32;\n  from?: UInt32;\n};\n\nconst transactionStatusQuery = (txId: string) => `query {\n    transactionStatus(zkappTransaction:\"${txId}\")\n  }`;\n\nconst getEventsQuery = (inputs: EventsQueryInputs) => {\n  inputs.tokenId ??= TokenId.toBase58(TokenId.default);\n  const { publicKey, tokenId, to, from } = inputs;\n  let input = `address: \"${publicKey}\", tokenId: \"${tokenId}\"`;\n  if (to !== undefined) {\n    input += `, to: ${to.toString()}`;\n  }\n  if (from !== undefined) {\n    input += `, from: ${from.toString()}`;\n  }\n  return `{\n  events(input: { ${input} }) {\n    blockInfo {\n      distanceFromMaxBlockHeight\n      height\n      globalSlotSinceGenesis\n      stateHash\n      parentHash\n      chainStatus\n    }\n    eventData {\n      transactionInfo {\n        hash\n        memo\n        status\n      }\n      data\n    }\n  }\n}`;\n};\n\nconst getActionsQuery = (inputs: ActionsQueryInputs) => {\n  inputs.tokenId ??= TokenId.toBase58(TokenId.default);\n  const { publicKey, tokenId, actionStates, from, to } = inputs;\n  const { fromActionState, endActionState } = actionStates ?? {};\n  let input = `address: \"${publicKey}\", tokenId: \"${tokenId}\"`;\n  if (fromActionState !== undefined) {\n    input += `, fromActionState: \"${fromActionState}\"`;\n  }\n  if (endActionState !== undefined) {\n    input += `, endActionState: \"${endActionState}\"`;\n  }\n  if (to !== undefined) {\n    input += `, to: ${to}`;\n  }\n  if (from !== undefined) {\n    input += `, from: ${from}`;\n  }\n  return `{\n    actions(input: { ${input} }) {\n      blockInfo {\n        distanceFromMaxBlockHeight\n      }\n      actionState {\n        actionStateOne\n        actionStateTwo\n      }\n      actionData {\n        accountUpdateId\n        data\n        transactionInfo { \n          sequenceNumber \n          zkappAccountUpdateIds \n        }\n      }\n    }\n  }`;\n};\n\nconst genesisConstantsQuery = `{\n    genesisConstants {\n      genesisTimestamp\n      coinbase\n      accountCreationFee\n    }\n    daemonStatus {\n      consensusConfiguration {\n        epochDuration\n        k\n        slotDuration\n        slotsPerEpoch\n      }\n    }\n  }`;\n\nconst lastBlockQuery = `{\n  bestChain(maxLength: 1) {\n    protocolState {\n      blockchainState {\n        snarkedLedgerHash\n        stagedLedgerHash\n        date\n        utcDate\n        stagedLedgerProofEmitted\n      }\n      previousStateHash\n      consensusState {\n        blockHeight\n        slotSinceGenesis\n        slot\n        nextEpochData {\n          ledger {hash totalCurrency}\n          seed\n          startCheckpoint\n          lockCheckpoint\n          epochLength\n        }\n        stakingEpochData {\n          ledger {hash totalCurrency}\n          seed\n          startCheckpoint\n          lockCheckpoint\n          epochLength\n        }\n        epochCount\n        minWindowDensity\n        totalCurrency\n        epoch\n      }\n    }\n  }\n}`;\n\nconst lastBlockQueryFailureCheck = (length: number) => `{\n  bestChain(maxLength: ${length}) {\n    transactions {\n      zkappCommands {\n        hash\n        failureReason {\n          failures\n          index\n        }\n      }\n    }\n    stateHash\n    protocolState {\n      consensusState {\n        blockHeight\n        epoch\n        slotSinceGenesis\n      }\n      previousStateHash\n    }\n  }\n}`;\n\n// TODO: Decide an appropriate response structure.\nfunction sendZkappQuery(json: string) {\n  return `mutation {\n  sendZkapp(input: {\n    zkappCommand: ${removeJsonQuotes(json)}\n  }) {\n    zkapp {\n      hash\n      id\n      failureReason {\n        failures\n        index\n      }\n      zkappCommand {\n        memo\n        feePayer {\n          body {\n            publicKey\n          }\n        }\n        accountUpdates {\n          body {\n            publicKey\n            useFullCommitment\n            incrementNonce\n          }\n        }\n      }\n    }\n  }\n}\n`;\n}\n\nconst accountQuery = (publicKey: string, tokenId: string) => `{\n  account(publicKey: \"${publicKey}\", token: \"${tokenId}\") {\n    publicKey\n    token\n    nonce\n    balance { total }\n    tokenSymbol\n    receiptChainHash\n    timing {\n      initialMinimumBalance\n      cliffTime\n      cliffAmount\n      vestingPeriod\n      vestingIncrement\n    }\n    permissions {\n      editState\n      access\n      send\n      receive\n      setDelegate\n      setPermissions\n      setVerificationKey {\n        auth\n        txnVersion\n      }\n      setZkappUri\n      editActionState\n      setTokenSymbol\n      incrementNonce\n      setVotingFor\n      setTiming\n    }\n    delegateAccount { publicKey }\n    votingFor\n    zkappState\n    verificationKey {\n      verificationKey\n      hash\n    }\n    actionState\n    provedState\n    zkappUri\n  }\n}\n`;\n\nconst currentSlotQuery = `{\n    bestChain(maxLength: 1) {\n      protocolState {\n        consensusState {\n          slot\n        }\n      }\n    }\n}`;\n", "import { Field } from '../../provable/wrapped.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport { Actions, TokenId } from './account-update.js';\nimport { PublicKey, PrivateKey } from '../../provable/crypto/signature.js';\nimport { NetworkValue } from './precondition.js';\nimport { Types } from '../../../bindings/mina-transaction/v1/types.js';\nimport { ActionStates } from './mina.js';\nimport { LedgerHash, EpochSeed, StateHash } from './base58-encodings.js';\nimport { Account, fillPartialAccount, parseFetchedAccount, PartialAccount } from './account.js';\nimport {\n  type LastBlockQueryResponse,\n  type GenesisConstantsResponse,\n  type LastBlockQueryFailureCheckResponse,\n  type FetchedAction,\n  type FetchedBlock,\n  type TransactionStatus,\n  type TransactionStatusQueryResponse,\n  type EventsQueryInputs,\n  type EventQueryResponse,\n  type ActionsQueryInputs,\n  type ActionQueryResponse,\n  type SendZkAppResponse,\n  type FetchedAccountResponse,\n  type CurrentSlotResponse,\n  sendZkappQuery,\n  lastBlockQuery,\n  lastBlockQueryFailureCheck,\n  transactionStatusQuery,\n  getEventsQuery,\n  getActionsQuery,\n  genesisConstantsQuery,\n  accountQuery,\n  currentSlotQuery,\n} from './graphql.js';\n\nexport {\n  fetchAccount,\n  fetchLastBlock,\n  fetchGenesisConstants,\n  fetchCurrentSlot,\n  checkZkappTransaction,\n  parseFetchedAccount,\n  markAccountToBeFetched,\n  markNetworkToBeFetched,\n  markActionsToBeFetched,\n  fetchMissingData,\n  fetchTransactionStatus,\n  getCachedAccount,\n  getCachedNetwork,\n  getCachedActions,\n  getCachedGenesisConstants,\n  addCachedAccount,\n  networkConfig,\n  setMinaDefaultHeaders,\n  setArchiveDefaultHeaders,\n  setGraphqlEndpoint,\n  setGraphqlEndpoints,\n  setMinaGraphqlFallbackEndpoints,\n  setArchiveGraphqlEndpoint,\n  setArchiveGraphqlFallbackEndpoints,\n  setLightnetAccountManagerEndpoint,\n  sendZkapp,\n  fetchEvents,\n  fetchActions,\n  makeGraphqlRequest,\n  Lightnet,\n  type GenesisConstants,\n  type ActionStatesStringified,\n};\n\ntype NetworkConfig = {\n  minaEndpoint: string;\n  minaFallbackEndpoints: string[];\n  archiveEndpoint: string;\n  archiveFallbackEndpoints: string[];\n  lightnetAccountManagerEndpoint: string;\n  minaDefaultHeaders: HeadersInit;\n  archiveDefaultHeaders: HeadersInit;\n};\n\nlet networkConfig = {\n  minaEndpoint: '',\n  minaFallbackEndpoints: [] as string[],\n  archiveEndpoint: '',\n  archiveFallbackEndpoints: [] as string[],\n  lightnetAccountManagerEndpoint: '',\n  minaDefaultHeaders: {},\n  archiveDefaultHeaders: {},\n} satisfies NetworkConfig;\n\nfunction checkForValidUrl(url: string) {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Sets up the default headers to be used for all Mina node GraphQL requests, example usage:\n * ```typescript\n * setMinaDefaultHeaders({ Authorization: 'Bearer example-token' });\n * ```\n *\n * It can be overridden by passing headers to the individual fetch functions, example usage:\n * ```typescript\n * setMinaDefaultHeaders({ Authorization: 'Bearer default-token' });\n * await fetchAccount({publicKey}, minaEndpoint, { headers: { Authorization: 'Bearer override-token' } });\n * ```\n * @param headers Arbitrary sized headers to be used for all Mina node GraphQL requests.\n */\nfunction setMinaDefaultHeaders(headers: HeadersInit) {\n  networkConfig.minaDefaultHeaders = headers;\n}\n\n/**\n * Sets up the default headers to be used for all Archive node GraphQL requests, example usage:\n * ```typescript\n * setArchiveDefaultHeaders({ Authorization: 'Bearer example-token' });\n * ```\n *\n * It can be overridden by passing headers to the individual fetch functions, example usage:\n * ```typescript\n * setArchiveDefaultHeaders({ Authorization: 'Bearer default-token' });\n * await fetchEvents({publicKey}, archiveEndpoint, { headers: { Authorization: 'Bearer override-token' } });\n * ```\n * @param headers Arbitrary sized headers to be used for all Mina Archive node GraphQL requests.\n */\nfunction setArchiveDefaultHeaders(headers: HeadersInit) {\n  networkConfig.archiveDefaultHeaders = headers;\n}\n\nfunction setGraphqlEndpoints([graphqlEndpoint, ...fallbackEndpoints]: string[]) {\n  setGraphqlEndpoint(graphqlEndpoint);\n  setMinaGraphqlFallbackEndpoints(fallbackEndpoints);\n}\nfunction setGraphqlEndpoint(graphqlEndpoint: string, minaDefaultHeaders?: HeadersInit) {\n  if (!checkForValidUrl(graphqlEndpoint)) {\n    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoint}. Please specify a valid URL.`);\n  }\n  networkConfig.minaEndpoint = graphqlEndpoint;\n  if (minaDefaultHeaders) setMinaDefaultHeaders(minaDefaultHeaders);\n}\nfunction setMinaGraphqlFallbackEndpoints(graphqlEndpoints: string[]) {\n  if (graphqlEndpoints.some((endpoint) => !checkForValidUrl(endpoint))) {\n    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoints}. Please specify a valid URL.`);\n  }\n  networkConfig.minaFallbackEndpoints = graphqlEndpoints;\n}\n\n/**\n * Sets up a GraphQL endpoint to be used for fetching information from an Archive Node.\n *\n */\nfunction setArchiveGraphqlEndpoint(graphqlEndpoint: string, archiveDefaultHeaders?: HeadersInit) {\n  if (!checkForValidUrl(graphqlEndpoint)) {\n    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoint}. Please specify a valid URL.`);\n  }\n  networkConfig.archiveEndpoint = graphqlEndpoint;\n  if (archiveDefaultHeaders) setArchiveDefaultHeaders(archiveDefaultHeaders);\n}\nfunction setArchiveGraphqlFallbackEndpoints(graphqlEndpoints: string[]) {\n  if (graphqlEndpoints.some((endpoint) => !checkForValidUrl(endpoint))) {\n    throw new Error(`Invalid GraphQL endpoint: ${graphqlEndpoints}. Please specify a valid URL.`);\n  }\n  networkConfig.archiveFallbackEndpoints = graphqlEndpoints;\n}\n\n/**\n * Sets up the lightnet account manager endpoint to be used for accounts acquisition and releasing.\n *\n * @param endpoint Account manager endpoint.\n */\nfunction setLightnetAccountManagerEndpoint(endpoint: string) {\n  if (!checkForValidUrl(endpoint)) {\n    throw new Error(`Invalid account manager endpoint: ${endpoint}. Please specify a valid URL.`);\n  }\n  networkConfig.lightnetAccountManagerEndpoint = endpoint;\n}\n\n/**\n * Gets account information on the specified publicKey by performing a GraphQL query\n * to the specified endpoint. This will call the 'GetAccountInfo' query which fetches\n * zkapp related account information.\n *\n * If an error is returned by the specified endpoint, an error is thrown. Otherwise,\n * the data is returned.\n *\n * @param accountInfo The public key and token id of the account to fetch\n * @param accountInfo.publicKey The specified publicKey to get account information on\n * @param accountInfo.tokenId The specified tokenId to get account information on\n * @param graphqlEndpoint The graphql endpoint to fetch from\n * @param config An object that exposes an additional timeout and header options\n * @returns zkapp information on the specified account or an error is thrown\n */\nasync function fetchAccount(\n  accountInfo: { publicKey: string | PublicKey; tokenId?: string | Field },\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  { timeout = defaultTimeout, headers }: FetchConfig = {}\n): Promise<\n  { account: Types.Account; error: undefined } | { account: undefined; error: FetchError }\n> {\n  let publicKeyBase58 =\n    accountInfo.publicKey instanceof PublicKey\n      ? accountInfo.publicKey.toBase58()\n      : accountInfo.publicKey;\n  let tokenIdBase58 =\n    typeof accountInfo.tokenId === 'string' || !accountInfo.tokenId\n      ? accountInfo.tokenId\n      : TokenId.toBase58(accountInfo.tokenId);\n\n  return await fetchAccountInternal(\n    { publicKey: publicKeyBase58, tokenId: tokenIdBase58 },\n    graphqlEndpoint,\n    {\n      timeout,\n      headers: { ...networkConfig.minaDefaultHeaders, ...headers },\n    }\n  );\n}\n\n// internal version of fetchAccount which does the same, but returns the original JSON version\n// of the account, to save some back-and-forth conversions when caching accounts\nasync function fetchAccountInternal(\n  accountInfo: { publicKey: string; tokenId?: string },\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  config?: FetchConfig\n) {\n  const { publicKey, tokenId } = accountInfo;\n  let [response, error] = await makeGraphqlRequest<FetchedAccountResponse>(\n    accountQuery(publicKey, tokenId ?? TokenId.toBase58(TokenId.default)),\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    config\n  );\n  if (error !== undefined) return { account: undefined, error };\n  let fetchedAccount = response?.data?.account;\n  if (!fetchedAccount) {\n    return {\n      account: undefined,\n      error: {\n        statusCode: 404,\n        statusText: `fetchAccount: Account with public key ${publicKey} does not exist.`,\n      },\n    };\n  }\n  let account = parseFetchedAccount(fetchedAccount);\n  // account successfully fetched - add to cache before returning\n  addCachedAccountInternal(account, graphqlEndpoint);\n  return {\n    account,\n    error: undefined,\n  };\n}\n\ntype FetchConfig = { timeout?: number; headers?: HeadersInit };\ntype FetchResponse<TDataResponse = any> = { data: TDataResponse; errors?: any };\ntype FetchError = {\n  statusCode: number;\n  statusText: string;\n};\ntype ActionStatesStringified = {\n  [K in keyof ActionStates]: string;\n};\n// Specify 5min as the default timeout\nconst defaultTimeout = 5 * 60 * 1000;\n\nlet accountCache = {} as Record<\n  string,\n  {\n    account: Account;\n    graphqlEndpoint: string;\n    timestamp: number;\n  }\n>;\nlet networkCache = {} as Record<\n  string,\n  {\n    network: NetworkValue;\n    graphqlEndpoint: string;\n    timestamp: number;\n  }\n>;\nlet actionsCache = {} as Record<\n  string,\n  {\n    actions: { hash: string; actions: string[][] }[];\n    graphqlEndpoint: string;\n    timestamp: number;\n  }\n>;\nlet accountsToFetch = {} as Record<\n  string,\n  { publicKey: string; tokenId: string; graphqlEndpoint: string }\n>;\nlet networksToFetch = {} as Record<string, { graphqlEndpoint: string }>;\nlet actionsToFetch = {} as Record<\n  string,\n  {\n    publicKey: string;\n    tokenId: string;\n    actionStates: ActionStatesStringified;\n    graphqlEndpoint: string;\n  }\n>;\ntype GenesisConstants = {\n  genesisTimestamp: string;\n  coinbase: number;\n  accountCreationFee: number;\n  epochDuration: number;\n  k: number;\n  slotDuration: number;\n  slotsPerEpoch: number;\n};\nlet genesisConstantsCache = {} as Record<string, GenesisConstants>;\n\nconst emptyKey = PublicKey.empty().toBase58();\n\nfunction markAccountToBeFetched(publicKey: PublicKey, tokenId: Field, graphqlEndpoint: string) {\n  let publicKeyBase58 = publicKey.toBase58();\n  if (publicKeyBase58 === emptyKey) return;\n  let tokenBase58 = TokenId.toBase58(tokenId);\n  accountsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {\n    publicKey: publicKeyBase58,\n    tokenId: tokenBase58,\n    graphqlEndpoint,\n  };\n}\nfunction markNetworkToBeFetched(graphqlEndpoint: string) {\n  networksToFetch[graphqlEndpoint] = { graphqlEndpoint };\n}\nfunction markActionsToBeFetched(\n  publicKey: PublicKey,\n  tokenId: Field,\n  graphqlEndpoint: string,\n  actionStates: ActionStates = {}\n) {\n  let publicKeyBase58 = publicKey.toBase58();\n  let tokenBase58 = TokenId.toBase58(tokenId);\n  let { fromActionState, endActionState } = actionStates;\n  let fromActionStateBase58 = fromActionState ? fromActionState.toString() : undefined;\n  let endActionStateBase58 = endActionState ? endActionState.toString() : undefined;\n\n  actionsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {\n    publicKey: publicKeyBase58,\n    tokenId: tokenBase58,\n    actionStates: {\n      fromActionState: fromActionStateBase58,\n      endActionState: endActionStateBase58,\n    },\n    graphqlEndpoint,\n  };\n}\n\nasync function fetchMissingData(graphqlEndpoint: string, archiveEndpoint?: string) {\n  let promises = Object.entries(accountsToFetch).map(async ([key, { publicKey, tokenId }]) => {\n    let response = await fetchAccountInternal({ publicKey, tokenId }, graphqlEndpoint);\n    if (response.error === undefined) delete accountsToFetch[key];\n  });\n  let actionPromises = Object.entries(actionsToFetch).map(\n    async ([key, { publicKey, actionStates, tokenId }]) => {\n      let response = await fetchActions({ publicKey, actionStates, tokenId }, archiveEndpoint);\n      if (!('error' in response) || response.error === undefined) delete actionsToFetch[key];\n    }\n  );\n  promises.push(...actionPromises);\n  let network = Object.entries(networksToFetch).find(([, network]) => {\n    return network.graphqlEndpoint === graphqlEndpoint;\n  });\n  if (network !== undefined) {\n    promises.push(\n      (async () => {\n        const [lastBlockOk, constantsOk] = await Promise.all([\n          fetchLastBlock(graphqlEndpoint)\n            .then(() => true)\n            .catch(() => false),\n          fetchGenesisConstants(graphqlEndpoint)\n            .then(() => true)\n            .catch(() => false),\n        ]);\n\n        if (lastBlockOk && constantsOk) {\n          delete networksToFetch[network[0]];\n        }\n      })()\n    );\n  }\n  await Promise.all(promises);\n}\n\nfunction getCachedAccount(\n  publicKey: PublicKey,\n  tokenId: Field,\n  graphqlEndpoint = networkConfig.minaEndpoint\n): Account | undefined {\n  return accountCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.account;\n}\n\nfunction getCachedNetwork(graphqlEndpoint = networkConfig.minaEndpoint) {\n  return networkCache[graphqlEndpoint]?.network;\n}\n\nfunction getCachedActions(\n  publicKey: PublicKey,\n  tokenId: Field,\n  graphqlEndpoint = networkConfig.archiveEndpoint\n) {\n  return actionsCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.actions;\n}\n\nfunction getCachedGenesisConstants(graphqlEndpoint = networkConfig.minaEndpoint): GenesisConstants {\n  return genesisConstantsCache[graphqlEndpoint];\n}\n\n/**\n * Adds an account to the local cache, indexed by a GraphQL endpoint.\n */\nfunction addCachedAccount(\n  partialAccount: PartialAccount,\n  graphqlEndpoint = networkConfig.minaEndpoint\n) {\n  let account = fillPartialAccount(partialAccount);\n  addCachedAccountInternal(account, graphqlEndpoint);\n}\n\nfunction addCachedAccountInternal(account: Account, graphqlEndpoint: string) {\n  accountCache[accountCacheKey(account.publicKey, account.tokenId, graphqlEndpoint)] = {\n    account,\n    graphqlEndpoint,\n    timestamp: Date.now(),\n  };\n}\n\nfunction addCachedActions(\n  { publicKey, tokenId }: { publicKey: string; tokenId: string },\n  actions: { hash: string; actions: string[][] }[],\n  graphqlEndpoint: string\n) {\n  actionsCache[`${publicKey};${tokenId};${graphqlEndpoint}`] = {\n    actions,\n    graphqlEndpoint,\n    timestamp: Date.now(),\n  };\n}\n\nfunction accountCacheKey(publicKey: PublicKey, tokenId: Field, graphqlEndpoint: string) {\n  return `${publicKey.toBase58()};${TokenId.toBase58(tokenId)};${graphqlEndpoint}`;\n}\n\n/**\n * Fetches the last block on the Mina network.\n */\nasync function fetchLastBlock(graphqlEndpoint = networkConfig.minaEndpoint, headers?: HeadersInit) {\n  let [resp, error] = await makeGraphqlRequest<LastBlockQueryResponse>(\n    lastBlockQuery,\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    { headers: { ...networkConfig.minaDefaultHeaders, ...headers } }\n  );\n  if (error) throw Error(error.statusText);\n  let lastBlock = resp?.data?.bestChain?.[0];\n  if (lastBlock === undefined) {\n    throw Error('Failed to fetch latest network state.');\n  }\n  let network = parseFetchedBlock(lastBlock);\n  networkCache[graphqlEndpoint] = {\n    network,\n    graphqlEndpoint,\n    timestamp: Date.now(),\n  };\n  return network;\n}\n\n/**\n * Fetches the current slot number of the Mina network.\n * @param graphqlEndpoint GraphQL endpoint to fetch from\n * @param headers optional headers to pass to the fetch request\n * @returns The current slot number\n */\nasync function fetchCurrentSlot(\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  headers?: HeadersInit\n) {\n  let [resp, error] = await makeGraphqlRequest<CurrentSlotResponse>(\n    currentSlotQuery,\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    { headers: { ...networkConfig.minaDefaultHeaders, ...headers } }\n  );\n  if (error) throw Error(`Error making GraphQL request: ${error.statusText}`);\n  let bestChain = resp?.data?.bestChain;\n  if (!bestChain || bestChain.length === 0) {\n    throw Error('Failed to fetch the current slot. The response data is undefined.');\n  }\n  return bestChain[0].protocolState.consensusState.slot;\n}\n\nasync function fetchLatestBlockZkappStatus(\n  blockLength: number,\n  graphqlEndpoint = networkConfig.minaEndpoint\n) {\n  let [resp, error] = await makeGraphqlRequest<LastBlockQueryFailureCheckResponse>(\n    lastBlockQueryFailureCheck(blockLength),\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    { headers: networkConfig.minaDefaultHeaders }\n  );\n  if (error) throw Error(`Error making GraphQL request: ${error.statusText}`);\n  let bestChain = resp?.data;\n  if (bestChain === undefined) {\n    throw Error(\n      'Failed to fetch the latest zkApp transaction status. The response data is undefined.'\n    );\n  }\n  return bestChain;\n}\n\nasync function checkZkappTransaction(transactionHash: string, blockLength = 20) {\n  let bestChainBlocks = await fetchLatestBlockZkappStatus(blockLength);\n  for (let block of bestChainBlocks.bestChain) {\n    for (let zkappCommand of block.transactions.zkappCommands) {\n      if (zkappCommand.hash === transactionHash) {\n        if (zkappCommand.failureReason !== null) {\n          let failureReason = zkappCommand.failureReason.reverse().map((failure) => {\n            return [failure.failures.map((failureItem) => failureItem)];\n          });\n          return {\n            success: false,\n            failureReason,\n          };\n        } else {\n          return {\n            success: true,\n            failureReason: null,\n          };\n        }\n      }\n    }\n  }\n  return {\n    success: false,\n    failureReason: null,\n  };\n}\n\nfunction parseFetchedBlock({\n  protocolState: {\n    blockchainState: { snarkedLedgerHash },\n    consensusState: {\n      blockHeight,\n      minWindowDensity,\n      totalCurrency,\n      slotSinceGenesis,\n      nextEpochData,\n      stakingEpochData,\n    },\n  },\n}: FetchedBlock): NetworkValue {\n  return {\n    snarkedLedgerHash: LedgerHash.fromBase58(snarkedLedgerHash),\n    // TODO: use date or utcDate?\n    blockchainLength: UInt32.from(blockHeight),\n    minWindowDensity: UInt32.from(minWindowDensity),\n    totalCurrency: UInt64.from(totalCurrency),\n    globalSlotSinceGenesis: UInt32.from(slotSinceGenesis),\n    nextEpochData: parseEpochData(nextEpochData),\n    stakingEpochData: parseEpochData(stakingEpochData),\n  };\n}\n\nfunction parseEpochData({\n  ledger: { hash, totalCurrency },\n  seed,\n  startCheckpoint,\n  lockCheckpoint,\n  epochLength,\n}: FetchedBlock['protocolState']['consensusState']['nextEpochData']): NetworkValue['nextEpochData'] {\n  return {\n    ledger: {\n      hash: LedgerHash.fromBase58(hash),\n      totalCurrency: UInt64.from(totalCurrency),\n    },\n    seed: EpochSeed.fromBase58(seed),\n    startCheckpoint: StateHash.fromBase58(startCheckpoint),\n    lockCheckpoint: StateHash.fromBase58(lockCheckpoint),\n    epochLength: UInt32.from(epochLength),\n  };\n}\n\n/**\n * Fetches the status of a transaction.\n */\nasync function fetchTransactionStatus(\n  txId: string,\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  headers?: HeadersInit\n): Promise<TransactionStatus> {\n  let [resp, error] = await makeGraphqlRequest<TransactionStatusQueryResponse>(\n    transactionStatusQuery(txId),\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    { headers: { ...networkConfig.minaDefaultHeaders, ...headers } }\n  );\n  if (error) throw Error(error.statusText);\n  let txStatus = resp?.data?.transactionStatus;\n  if (txStatus === undefined || txStatus === null) {\n    throw Error(`Failed to fetch transaction status. TransactionId: ${txId}`);\n  }\n  return txStatus as TransactionStatus;\n}\n\n/**\n * Sends a zkApp command (transaction) to the specified GraphQL endpoint.\n */\nfunction sendZkapp(\n  json: string,\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  { timeout = defaultTimeout, headers }: FetchConfig = {}\n) {\n  return makeGraphqlRequest<SendZkAppResponse>(\n    sendZkappQuery(json),\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    {\n      timeout,\n      headers: { ...networkConfig.minaDefaultHeaders, ...headers },\n    }\n  );\n}\n\n/**\n * Asynchronously fetches event data for an account from the Mina Archive Node GraphQL API.\n * @param accountInfo - The account information object.\n * @param accountInfo.publicKey - The account public key.\n * @param [accountInfo.tokenId] - The optional token ID for the account.\n * @param [graphqlEndpoint=networkConfig.archiveEndpoint] - The GraphQL endpoint to query. Defaults to the Archive Node GraphQL API.\n * @param [filterOptions={}] - The optional filter options object.\n * @param headers - Optional headers to pass to the fetch request\n * @returns A promise that resolves to an array of objects containing event data, block information and transaction information for the account.\n * @throws If the GraphQL request fails or the response is invalid.\n * @example\n * ```ts\n * const accountInfo = { publicKey: 'B62qiwmXrWn7Cok5VhhB3KvCwyZ7NHHstFGbiU5n7m8s2RqqNW1p1wF' };\n * const events = await fetchEvents(accountInfo);\n * console.log(events);\n * ```\n */\nasync function fetchEvents(\n  queryInputs: EventsQueryInputs,\n  graphqlEndpoint = networkConfig.archiveEndpoint,\n  headers?: HeadersInit\n) {\n  if (!graphqlEndpoint)\n    throw Error(\n      'fetchEvents: Specified GraphQL endpoint is undefined. When using events, you must set the archive node endpoint in Mina.Network(). Please ensure your Mina.Network() configuration includes an archive node endpoint.'\n    );\n  let [response, error] = await makeGraphqlRequest<EventQueryResponse>(\n    getEventsQuery(queryInputs),\n    graphqlEndpoint,\n    networkConfig.archiveFallbackEndpoints,\n    { headers: { ...networkConfig.archiveDefaultHeaders, ...headers } }\n  );\n  if (error) throw Error(error.statusText);\n  let fetchedEvents = response?.data.events;\n  if (fetchedEvents === undefined) {\n    throw Error(\n      `Failed to fetch events data. Account: ${queryInputs.publicKey} Token: ${queryInputs.tokenId}`\n    );\n  }\n\n  return fetchedEvents.map((event) => {\n    let events = event.eventData.map(({ data, transactionInfo }) => {\n      return {\n        data,\n        transactionInfo,\n      };\n    });\n\n    return {\n      events,\n      blockHeight: UInt32.from(event.blockInfo.height),\n      blockHash: event.blockInfo.stateHash,\n      parentBlockHash: event.blockInfo.parentHash,\n      globalSlot: UInt32.from(event.blockInfo.globalSlotSinceGenesis),\n      chainStatus: event.blockInfo.chainStatus,\n    };\n  });\n}\n\n/**\n * Fetches account actions for a specified public key and token ID by performing a GraphQL query.\n *\n * @param accountInfo - An {@link ActionsQueryInputs} containing the public key, and optional query parameters for the actions query\n * @param graphqlEndpoint - The GraphQL endpoint to fetch from. Defaults to the configured Mina endpoint.\n * @param headers - Optional headers to pass to the fetch request\n *\n * @returns A promise that resolves to an object containing the final actions hash for the account, and a list of actions\n * @throws Will throw an error if the GraphQL endpoint is invalid or if the fetch request fails.\n *\n * @example\n * ```ts\n * const accountInfo = { publicKey: 'B62qiwmXrWn7Cok5VhhB3KvCwyZ7NHHstFGbiU5n7m8s2RqqNW1p1wF' };\n * const actionsList = await fetchAccount(accountInfo);\n * console.log(actionsList);\n * ```\n */\nasync function fetchActions(\n  queryInputs: ActionsQueryInputs,\n  graphqlEndpoint = networkConfig.archiveEndpoint,\n  headers?: HeadersInit\n): Promise<\n  | {\n      actions: string[][];\n      hash: string;\n    }[]\n  | { error: FetchError }\n> {\n  if (!graphqlEndpoint)\n    throw Error(\n      'fetchActions: Specified GraphQL endpoint is undefined. When using actions, you must set the archive node endpoint in Mina.Network(). Please ensure your Mina.Network() configuration includes an archive node endpoint.'\n    );\n\n  queryInputs.tokenId = queryInputs.tokenId ?? TokenId.toBase58(TokenId.default);\n\n  let [response, _error] = await makeGraphqlRequest<ActionQueryResponse>(\n    getActionsQuery(queryInputs),\n    graphqlEndpoint,\n    networkConfig.archiveFallbackEndpoints,\n    { headers: { ...networkConfig.archiveDefaultHeaders, ...headers } }\n  );\n  let fetchedActions = response?.data.actions;\n  if (fetchedActions === undefined) {\n    return {\n      error: {\n        statusCode: 404,\n        statusText: `fetchActions: Account with public key ${queryInputs.publicKey} with tokenId ${queryInputs.tokenId} does not exist.`,\n      },\n    };\n  }\n\n  const actionsList = createActionsList(\n    {\n      publicKey: queryInputs.publicKey,\n      actionStates: {\n        fromActionState: queryInputs.actionStates?.fromActionState,\n        endActionState: queryInputs.actionStates?.endActionState,\n      },\n    },\n    fetchedActions\n  );\n  addCachedActions(\n    { publicKey: queryInputs.publicKey, tokenId: queryInputs.tokenId },\n    actionsList,\n    graphqlEndpoint\n  );\n\n  return actionsList;\n}\n\n/**\n * Given a graphQL response from #getActionsQuery, process the actions into a canonical actions list\n */\nexport function createActionsList(\n  accountInfo: {\n    publicKey: string;\n    actionStates: ActionStatesStringified;\n  },\n  fetchedActions: FetchedAction[]\n) {\n  const { publicKey, actionStates } = accountInfo;\n\n  let actionsList: { actions: string[][]; hash: string }[] = [];\n  // correct for archive node sending one block too many\n  if (\n    fetchedActions.length !== 0 &&\n    fetchedActions[0].actionState.actionStateOne === actionStates.fromActionState\n  ) {\n    fetchedActions = fetchedActions.slice(1);\n  }\n\n  fetchedActions.forEach((actionBlock) => {\n    let { actionData } = actionBlock;\n    let latestActionState = Field(actionBlock.actionState.actionStateTwo);\n    let actionState = actionBlock.actionState.actionStateOne;\n\n    if (actionData.length === 0)\n      throw Error(\n        `No action data was found for the account ${publicKey} with the latest action state ${actionState}`\n      );\n\n    // DEPRECATED: In case the archive node is running an out-of-date version, best guess is to sort by the account update id\n    // As of 2025-01-07, minascan is running a version of the node which supports `sequenceNumber` and `zkappAccountUpdateIds` fields\n    // We could consider removing this fallback since no other nodes are widely used\n    if (!actionData[0].transactionInfo) {\n      actionData = actionData.sort((a1, a2) => {\n        return Number(a1.accountUpdateId) - Number(a2.accountUpdateId);\n      });\n    } else {\n      // sort actions within one block by transaction sequence number and account update sequence\n      actionData = actionData.sort((a1, a2) => {\n        const a1TxSequence = a1.transactionInfo!.sequenceNumber;\n        const a2TxSequence = a2.transactionInfo!.sequenceNumber;\n        if (a1TxSequence === a2TxSequence) {\n          const a1AuSequence = a1.transactionInfo!.zkappAccountUpdateIds.indexOf(\n            Number(a1.accountUpdateId)\n          );\n          const a2AuSequence = a2.transactionInfo!.zkappAccountUpdateIds.indexOf(\n            Number(a2.accountUpdateId)\n          );\n          return a1AuSequence - a2AuSequence;\n        } else {\n          return a1TxSequence - a2TxSequence;\n        }\n      });\n    }\n\n    // split actions by account update\n    let actionsByAccountUpdate: string[][][] = [];\n    let currentAccountUpdateId = 'none';\n    let currentActions: string[][];\n    actionData.forEach(({ accountUpdateId, data }) => {\n      if (accountUpdateId === currentAccountUpdateId) {\n        currentActions.push(data);\n      } else {\n        currentAccountUpdateId = accountUpdateId;\n        currentActions = [data];\n        actionsByAccountUpdate.push(currentActions);\n      }\n    });\n\n    // re-hash actions\n    for (let actions of actionsByAccountUpdate) {\n      latestActionState = updateActionState(actions, latestActionState);\n      actionsList.push({ actions, hash: latestActionState.toString() });\n    }\n\n    const finalActionState = latestActionState.toString();\n    const expectedActionState = actionState;\n\n    if (finalActionState !== expectedActionState) {\n      throw new Error(\n        `Failed to derive correct actions hash for ${publicKey}.\n        Derived hash: ${finalActionState}, expected hash: ${expectedActionState}).\n        All action hashes derived: ${JSON.stringify(actionsList, null, 2)}\n        Please try a different Archive Node API endpoint.\n        `\n      );\n    }\n  });\n  return actionsList;\n}\n\n/**\n * Fetches genesis constants.\n */\nasync function fetchGenesisConstants(\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  headers?: HeadersInit\n): Promise<GenesisConstants> {\n  let [resp, error] = await makeGraphqlRequest<GenesisConstantsResponse>(\n    genesisConstantsQuery,\n    graphqlEndpoint,\n    networkConfig.minaFallbackEndpoints,\n    { headers: { ...networkConfig.minaDefaultHeaders, ...headers } }\n  );\n  if (error) throw Error(error.statusText);\n  const genesisConstants = resp?.data?.genesisConstants;\n  const consensusConfiguration = resp?.data?.daemonStatus?.consensusConfiguration;\n  if (genesisConstants === undefined || consensusConfiguration === undefined) {\n    throw Error('Failed to fetch genesis constants.');\n  }\n  const data = {\n    genesisTimestamp: genesisConstants.genesisTimestamp,\n    coinbase: Number(genesisConstants.coinbase),\n    accountCreationFee: Number(genesisConstants.accountCreationFee),\n    epochDuration: Number(consensusConfiguration.epochDuration),\n    k: Number(consensusConfiguration.k),\n    slotDuration: Number(consensusConfiguration.slotDuration),\n    slotsPerEpoch: Number(consensusConfiguration.slotsPerEpoch),\n  };\n  genesisConstantsCache[graphqlEndpoint] = data;\n  return data as GenesisConstants;\n}\n\nnamespace Lightnet {\n  /**\n   * Gets random key pair (public and private keys) from account manager\n   * that operates with accounts configured in target network Genesis Ledger.\n   *\n   * If an error is returned by the specified endpoint, an error is thrown. Otherwise,\n   * the data is returned.\n   *\n   * @param options.isRegularAccount Whether to acquire key pair of regular or zkApp account (one with already configured verification key)\n   * @param options.lightnetAccountManagerEndpoint Account manager endpoint to fetch from\n   * @returns Key pair\n   */\n  export async function acquireKeyPair(\n    options: {\n      isRegularAccount?: boolean;\n      lightnetAccountManagerEndpoint?: string;\n    } = {}\n  ): Promise<{\n    publicKey: PublicKey;\n    privateKey: PrivateKey;\n  }> {\n    const {\n      isRegularAccount = true,\n      lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint,\n    } = options;\n    const response = await fetch(\n      `${lightnetAccountManagerEndpoint}/acquire-account?isRegularAccount=${isRegularAccount}`,\n      {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n\n    if (response.ok) {\n      const data = await response.json();\n      if (data) {\n        return {\n          publicKey: PublicKey.fromBase58(data.pk),\n          privateKey: PrivateKey.fromBase58(data.sk),\n        };\n      }\n    }\n\n    throw new Error('Failed to acquire the key pair');\n  }\n\n  /**\n   * Releases previously acquired key pair by public key.\n   *\n   * @param options.publicKey Public key of previously acquired key pair to release\n   * @param options.lightnetAccountManagerEndpoint Account manager endpoint to fetch from\n   * @returns Response message from the account manager as string or null if the request failed\n   */\n  export async function releaseKeyPair(options: {\n    publicKey: string;\n    lightnetAccountManagerEndpoint?: string;\n  }): Promise<string | null> {\n    const {\n      publicKey,\n      lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint,\n    } = options;\n    const response = await fetch(`${lightnetAccountManagerEndpoint}/release-account`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        pk: publicKey,\n      }),\n    });\n\n    if (response.ok) {\n      const data = await response.json();\n      if (data) {\n        return data.message as string;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets previously acquired key pairs list.\n   *\n   * @param options.lightnetAccountManagerEndpoint Account manager endpoint to fetch from\n   * @returns Key pairs list or null if the request failed\n   */\n  export async function listAcquiredKeyPairs(options: {\n    lightnetAccountManagerEndpoint?: string;\n  }): Promise<Array<{\n    publicKey: PublicKey;\n    privateKey: PrivateKey;\n  }> | null> {\n    const { lightnetAccountManagerEndpoint = networkConfig.lightnetAccountManagerEndpoint } =\n      options;\n    const response = await fetch(`${lightnetAccountManagerEndpoint}/list-acquired-accounts`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (response.ok) {\n      const data = await response.json();\n      if (data) {\n        return data.map((account: any) => ({\n          publicKey: PublicKey.fromBase58(account.pk),\n          privateKey: PrivateKey.fromBase58(account.sk),\n        }));\n      }\n    }\n\n    return null;\n  }\n}\n\nfunction updateActionState(actions: string[][], actionState: Field) {\n  let actionHash = Actions.fromJSON(actions).hash;\n  return Actions.updateSequenceState(actionState, actionHash);\n}\n\n// TODO it seems we're not actually catching most errors here\nasync function makeGraphqlRequest<TDataResponse = any>(\n  query: string,\n  graphqlEndpoint = networkConfig.minaEndpoint,\n  fallbackEndpoints: string[],\n  { timeout = defaultTimeout, headers } = {} as FetchConfig\n) {\n  if (graphqlEndpoint === 'none')\n    throw Error(\n      \"Should have made a graphql request, but don't know to which endpoint. Try calling `setGraphqlEndpoint` first.\"\n    );\n  let timeouts: NodeJS.Timeout[] = [];\n  const clearTimeouts = () => {\n    timeouts.forEach((t) => clearTimeout(t));\n    timeouts = [];\n  };\n\n  const makeRequest = async (url: string) => {\n    const controller = new AbortController();\n    const timer = setTimeout(() => controller.abort(), timeout);\n    timeouts.push(timer);\n    let body = JSON.stringify({ operationName: null, query, variables: {} });\n    try {\n      let response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        body,\n        signal: controller.signal,\n      });\n      return checkResponseStatus<TDataResponse>(response);\n    } finally {\n      clearTimeouts();\n    }\n  };\n  // try to fetch from endpoints in pairs\n  let timeoutErrors: { url1: string; url2: string; error: any }[] = [];\n  let urls = [graphqlEndpoint, ...fallbackEndpoints];\n  for (let i = 0; i < urls.length; i += 2) {\n    let url1 = urls[i];\n    let url2 = urls[i + 1];\n    if (url2 === undefined) {\n      try {\n        return await makeRequest(url1);\n      } catch (error) {\n        return [undefined, inferError(error)] as [undefined, FetchError];\n      }\n    }\n    try {\n      return await Promise.race([makeRequest(url1), makeRequest(url2)]);\n    } catch (unknownError) {\n      let error = inferError(unknownError);\n      if (error.statusCode === 408) {\n        // If the request timed out, try the next 2 endpoints\n        timeoutErrors.push({ url1, url2, error });\n      } else {\n        // If the request failed for some other reason (e.g. o1js error), return the error\n        return [undefined, error] as [undefined, FetchError];\n      }\n    }\n  }\n  const statusText = timeoutErrors\n    .map(({ url1, url2, error }) => `Request to ${url1} and ${url2} timed out. Error: ${error}`)\n    .join('\\n');\n  return [undefined, { statusCode: 408, statusText }] as [undefined, FetchError];\n}\n\nasync function checkResponseStatus<TDataResponse>(\n  response: Response\n): Promise<[FetchResponse<TDataResponse>, undefined] | [undefined, FetchError]> {\n  if (response.ok) {\n    let jsonResponse = await response.json();\n    if (jsonResponse.errors && jsonResponse.errors.length > 0) {\n      return [\n        undefined,\n        {\n          statusCode: response.status,\n          statusText: jsonResponse.errors.map((error: any) => error.message).join('\\n'),\n        } as FetchError,\n      ];\n    } else if (jsonResponse.data === undefined) {\n      return [\n        undefined,\n        {\n          statusCode: response.status,\n          statusText: `GraphQL response data is undefined`,\n        } as FetchError,\n      ];\n    }\n    return [jsonResponse as FetchResponse<TDataResponse>, undefined];\n  } else {\n    return [\n      undefined,\n      {\n        statusCode: response.status,\n        statusText: response.statusText,\n      } as FetchError,\n    ];\n  }\n}\n\nfunction inferError(error: unknown): FetchError {\n  let errorMessage = JSON.stringify(error);\n  if (error instanceof AbortSignal) {\n    return { statusCode: 408, statusText: `Request Timeout: ${errorMessage}` };\n  } else {\n    return {\n      statusCode: 500,\n      statusText: `Unknown Error: ${errorMessage}`,\n    };\n  }\n}\n", "import { Types } from '../../../bindings/mina-transaction/v1/types.js';\nimport { TokenId } from './account-update.js';\n\nexport { humanizeErrors, invalidTransactionError };\n\nconst ErrorHandlers = {\n  Invalid_fee_excess({\n    transaction: { accountUpdates },\n    isFeePayer,\n    accountCreationFee,\n  }: ErrorHandlerArgs) {\n    // TODO: handle fee payer for Invalid_fee_excess?\n    if (isFeePayer) return;\n\n    let balances = accountUpdates.map(({ body }) => {\n      if (body.tokenId.equals(TokenId.default).toBoolean()) {\n        return Number(body.balanceChange.toString()) * 1e-9;\n      }\n    });\n    let sum = balances.reduce((a = 0, b = 0) => a + b) ?? 0;\n    return `Invalid fee excess.\nThis means that balance changes in your transaction do not sum up to the amount of fees needed.\nHere's the list of balance changes:\n\n${balances\n  .map((balance, i) => {\n    return `Account update #${i + 1}) ${\n      balance === undefined ? 'not a MINA account' : `${balance.toFixed(2)} MINA`\n    }`;\n  })\n  .join(`\\n`)}\n\nTotal change: ${sum.toFixed(2)} MINA\n\nIf there are no new accounts created in your transaction, then this sum should be equal to 0.00 MINA.\nIf you are creating new accounts -- by updating accounts that didn't exist yet --\nthen keep in mind the ${(Number(accountCreationFee) * 1e-9).toFixed(\n      2\n    )} MINA account creation fee, and make sure that the sum equals\n${(-Number(accountCreationFee) * 1e-9).toFixed(2)} times the number of newly created accounts.`;\n  },\n};\nconst defaultErrorReplacementRules: ErrorReplacementRule[] = [\n  {\n    pattern: /\\(invalid \\(Invalid_proof \\\\\"In progress\\\\\"\\)\\)/g,\n    replacement:\n      'Stale verification key detected. Please make sure that deployed verification key reflects latest zkApp changes.',\n  },\n];\n\ntype ErrorHandlerArgs = {\n  transaction: Types.ZkappCommand;\n  accountUpdateIndex: number;\n  isFeePayer: boolean;\n  accountCreationFee: string | number;\n};\n\ntype ErrorReplacementRule = {\n  pattern: RegExp;\n  replacement: string;\n};\n\nfunction invalidTransactionError(\n  transaction: Types.ZkappCommand,\n  errors: string[][][],\n  additionalContext: { accountCreationFee: string | number }\n): string {\n  let errorMessages = [];\n  let rawErrors = JSON.stringify(errors);\n  let n = transaction.accountUpdates.length;\n\n  // Check if the number of errors match the number of account updates. If there are more, then the fee payer has an error.\n  // We do this check because the fee payer error is not included in network transaction errors and is always present (even if empty) in the local transaction errors.\n  if (errors.length > n) {\n    let errorsForFeePayer = errors.shift() ?? [];\n    for (let [error] of errorsForFeePayer) {\n      let message = ErrorHandlers[error as keyof typeof ErrorHandlers]?.({\n        transaction,\n        accountUpdateIndex: NaN,\n        isFeePayer: true,\n        ...additionalContext,\n      });\n      if (message) errorMessages.push(message);\n    }\n  }\n\n  for (let i = 0; i < errors.length; i++) {\n    let errorsForUpdate = errors[i];\n    for (let [error] of errorsForUpdate) {\n      let message = ErrorHandlers[error as keyof typeof ErrorHandlers]?.({\n        transaction,\n        accountUpdateIndex: i,\n        isFeePayer: false,\n        ...additionalContext,\n      });\n      if (message) errorMessages.push(message);\n    }\n  }\n\n  if (errorMessages.length > 1) {\n    return [\n      'There were multiple errors when applying your transaction:',\n      ...errorMessages.map((msg, i) => `${i + 1}.) ${msg}`),\n      `Raw list of errors: ${rawErrors}`,\n    ].join('\\n\\n');\n  }\n  if (errorMessages.length === 1) {\n    return `${errorMessages[0]}\\n\\nRaw list of errors: ${rawErrors}`;\n  }\n  // fallback if we don't have a good error message yet\n  return rawErrors;\n}\n\nfunction humanizeErrors(\n  errors: string[],\n  replacements: ErrorReplacementRule[] = defaultErrorReplacementRules\n): string[] {\n  return errors.map((error) => {\n    let modifiedError = error;\n    replacements.forEach(({ pattern, replacement }) => {\n      modifiedError = modifiedError.replace(pattern, replacement);\n    });\n    return modifiedError;\n  });\n}\n", "/**\n * This file contains constants used in the Mina protocol.\n * Originally defined in the mina_compile_config file in the mina repo:\n * https://github.com/MinaProtocol/mina/blob/develop/src/lib/mina_compile_config/mina_compile_config.ml\n */\n\n// Constants used to calculate cost of a transaction\nexport namespace TransactionCost {\n  // Defined in https://github.com/MinaProtocol/mina/blob/e8c743488cf0c8f0b7925b7a48a914ca73ed13a1/src/lib/mina_compile_config/mina_compile_config.ml#L67\n  export const PROOF_COST = 10.26 as const;\n\n  // Defined in https://github.com/MinaProtocol/mina/blob/e8c743488cf0c8f0b7925b7a48a914ca73ed13a1/src/lib/mina_compile_config/mina_compile_config.ml#L69\n  export const SIGNED_PAIR_COST = 10.08 as const;\n\n  // Defined in https://github.com/MinaProtocol/mina/blob/e39abf79b7fdf96717eb8a8ee88ec42ba1e2663d/src/lib/mina_compile_config/mina_compile_config.ml#L71\n  export const SIGNED_SINGLE_COST = 9.14 as const;\n\n  // Defined in https://github.com/MinaProtocol/mina/blob/e39abf79b7fdf96717eb8a8ee88ec42ba1e2663d/src/lib/mina_compile_config/mina_compile_config.ml#L73\n  export const COST_LIMIT = 69.45 as const;\n}\n\n// Constants to define the maximum number of events and actions in a transaction\nexport namespace TransactionLimits {\n  // Defined in https://github.com/MinaProtocol/mina/blob/e39abf79b7fdf96717eb8a8ee88ec42ba1e2663d/src/lib/mina_compile_config/mina_compile_config.ml#L75\n  export const MAX_ACTION_ELEMENTS = 100 as const;\n  // Defined in https://github.com/MinaProtocol/mina/blob/e39abf79b7fdf96717eb8a8ee88ec42ba1e2663d/src/lib/mina_compile_config/mina_compile_config.ml#L77\n  export const MAX_EVENT_ELEMENTS = 100 as const;\n}\n\nexport namespace ZkappConstants {\n  export const MAX_ZKAPP_STATE_FIELDS = 8 as const;\n  export const ACCOUNT_ACTION_STATE_BUFFER_SIZE = 5 as const;\n  export const ACCOUNT_CREATION_FEE = 1000000000n as const;\n}\n", "/**\n * This module holds the global Mina instance and its interface.\n */\nimport {\n  ZkappCommand,\n  TokenId,\n  Events,\n  ZkappPublicInput,\n  AccountUpdate,\n  dummySignature,\n} from './account-update.js';\nimport { Field } from '../../provable/wrapped.js';\nimport { UInt64, UInt32 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { JsonProof, verify } from '../../proof-system/zkprogram.js';\nimport { verifyAccountUpdateSignature } from '../../../mina-signer/src/sign-zkapp-command.js';\nimport { TransactionCost, TransactionLimits } from './constants.js';\nimport { cloneCircuitValue } from '../../provable/types/struct.js';\nimport { assert } from '../../provable/gadgets/common.js';\nimport { Types, TypesBigint } from '../../../bindings/mina-transaction/v1/types.js';\nimport type { NetworkId } from '../../../mina-signer/src/types.js';\nimport type { Account } from './account.js';\nimport type { NetworkValue } from './precondition.js';\nimport { VerificationKey } from '../../proof-system/verification-key.js';\n\nexport {\n  reportGetAccountError,\n  defaultNetworkState,\n  verifyTransactionLimits,\n  getTotalTimeRequired,\n  verifyAccountUpdate,\n  filterGroups,\n};\n\nfunction reportGetAccountError(publicKey: string, tokenId: string) {\n  if (tokenId === TokenId.toBase58(TokenId.default)) {\n    return `getAccount: Could not find account for public key ${publicKey}`;\n  } else {\n    return `getAccount: Could not find account for public key ${publicKey} with the tokenId ${tokenId}`;\n  }\n}\n\nfunction defaultNetworkState(): NetworkValue {\n  let epochData: NetworkValue['stakingEpochData'] = {\n    ledger: { hash: Field(0), totalCurrency: UInt64.zero },\n    seed: Field(0),\n    startCheckpoint: Field(0),\n    lockCheckpoint: Field(0),\n    epochLength: UInt32.zero,\n  };\n  return {\n    snarkedLedgerHash: Field(0),\n    blockchainLength: UInt32.zero,\n    minWindowDensity: UInt32.zero,\n    totalCurrency: UInt64.zero,\n    globalSlotSinceGenesis: UInt32.zero,\n    stakingEpochData: epochData,\n    nextEpochData: cloneCircuitValue(epochData),\n  };\n}\n\nfunction verifyTransactionLimits({ accountUpdates }: ZkappCommand) {\n  let { totalTimeRequired, eventElements, authTypes } = getTotalTimeRequired(accountUpdates);\n\n  let isWithinCostLimit = totalTimeRequired < TransactionCost.COST_LIMIT;\n\n  let isWithinEventsLimit = eventElements.events <= TransactionLimits.MAX_EVENT_ELEMENTS;\n  let isWithinActionsLimit = eventElements.actions <= TransactionLimits.MAX_ACTION_ELEMENTS;\n\n  let error = '';\n\n  if (!isWithinCostLimit) {\n    // TODO: we should add a link to the docs explaining the reasoning behind it once we have such an explainer\n    error += `Error: The transaction is too expensive, try reducing the number of AccountUpdates that are attached to the transaction.\nEach transaction needs to be processed by the snark workers on the network.\nCertain layouts of AccountUpdates require more proving time than others, and therefore are too expensive.\n\n${JSON.stringify(authTypes)}\n\\n\\n`;\n  }\n\n  if (!isWithinEventsLimit) {\n    error += `Error: The account updates in your transaction are trying to emit too much event data. The maximum allowed number of field elements in events is ${TransactionLimits.MAX_EVENT_ELEMENTS}, but you tried to emit ${eventElements.events}.\\n\\n`;\n  }\n\n  if (!isWithinActionsLimit) {\n    error += `Error: The account updates in your transaction are trying to emit too much action data. The maximum allowed number of field elements in actions is ${TransactionLimits.MAX_ACTION_ELEMENTS}, but you tried to emit ${eventElements.actions}.\\n\\n`;\n  }\n\n  if (error) throw Error('Error during transaction sending:\\n\\n' + error);\n}\n\nfunction getTotalTimeRequired(accountUpdates: AccountUpdate[]) {\n  let eventElements = { events: 0, actions: 0 };\n\n  let authKinds = accountUpdates.map((update) => {\n    eventElements.events += countEventElements(update.body.events);\n    eventElements.actions += countEventElements(update.body.actions);\n    let { isSigned, isProved, verificationKeyHash } = update.body.authorizationKind;\n    return {\n      isSigned: isSigned.toBoolean(),\n      isProved: isProved.toBoolean(),\n      verificationKeyHash: verificationKeyHash.toString(),\n    };\n  });\n  // insert entry for the fee payer\n  authKinds.unshift({\n    isSigned: true,\n    isProved: false,\n    verificationKeyHash: '',\n  });\n  let authTypes = filterGroups(authKinds);\n\n  /*\n  np := proof\n  n2 := signedPair\n  n1 := signedSingle\n\n  formula used to calculate how expensive a zkapp transaction is\n\n  10.26*np + 10.08*n2 + 9.14*n1 < 69.45\n  */\n  let totalTimeRequired =\n    TransactionCost.PROOF_COST * authTypes.proof +\n    TransactionCost.SIGNED_PAIR_COST * authTypes.signedPair +\n    TransactionCost.SIGNED_SINGLE_COST * authTypes.signedSingle;\n  // returns totalTimeRequired and additional data used by verifyTransactionLimits\n  return { totalTimeRequired, eventElements, authTypes };\n}\n\nfunction countEventElements({ data }: Events) {\n  return data.reduce((acc, ev) => acc + ev.length, 0);\n}\n\nfunction filterGroups(xs: AuthorizationKind[]) {\n  let pairs = filterPairs(xs);\n  xs = pairs.xs;\n\n  let singleCount = 0;\n  let proofCount = 0;\n\n  xs.forEach((t) => {\n    if (t.isProved) proofCount++;\n    else singleCount++;\n  });\n\n  return {\n    signedPair: pairs.pairs,\n    signedSingle: singleCount,\n    proof: proofCount,\n  };\n}\n\nasync function verifyAccountUpdate(\n  account: Account,\n  accountUpdate: AccountUpdate,\n  publicInput: ZkappPublicInput,\n  transactionCommitments: { commitment: bigint; fullCommitment: bigint },\n  proofsEnabled: boolean,\n  networkId: NetworkId\n): Promise<void> {\n  // check that that top-level updates have mayUseToken = No\n  // (equivalent check exists in the Mina node)\n  if (\n    accountUpdate.body.callDepth === 0 &&\n    !AccountUpdate.MayUseToken.isNo(accountUpdate).toBoolean()\n  ) {\n    throw Error(\n      'Top-level account update can not use or pass on token permissions. Make sure that\\n' +\n        'accountUpdate.body.mayUseToken = AccountUpdate.MayUseToken.No;'\n    );\n  }\n\n  let perm = account.permissions;\n\n  // check if addMissingSignatures failed to include a signature\n  // due to a missing private key\n  if (accountUpdate.authorization === dummySignature()) {\n    let pk = PublicKey.toBase58(accountUpdate.body.publicKey);\n    throw Error(\n      `verifyAccountUpdate: Detected a missing signature for (${pk}), private key was missing.`\n    );\n  }\n  // we are essentially only checking if the update is empty or an actual update\n  function includesChange<T extends {}>(val: T | string | null | (string | null)[]): boolean {\n    if (Array.isArray(val)) {\n      return !val.every((v) => v === null);\n    } else {\n      return val !== null;\n    }\n  }\n\n  function permissionForUpdate(key: string): Types.AuthRequired {\n    switch (key) {\n      case 'appState':\n        return perm.editState;\n      case 'delegate':\n        return perm.setDelegate;\n      case 'verificationKey':\n        return perm.setVerificationKey.auth;\n      case 'permissions':\n        return perm.setPermissions;\n      case 'zkappUri':\n        return perm.setZkappUri;\n      case 'tokenSymbol':\n        return perm.setTokenSymbol;\n      case 'timing':\n        return perm.setTiming;\n      case 'votingFor':\n        return perm.setVotingFor;\n      case 'actions':\n        return perm.editActionState;\n      case 'incrementNonce':\n        return perm.incrementNonce;\n      case 'send':\n        return perm.send;\n      case 'receive':\n        return perm.receive;\n      default:\n        throw Error(`Invalid permission for field ${key}: does not exist.`);\n    }\n  }\n\n  let accountUpdateJson = accountUpdate.toJSON();\n  const update = accountUpdateJson.body.update;\n\n  let errorTrace = '';\n\n  let isValidProof = false;\n  let isValidSignature = false;\n\n  // we don't check if proofs aren't enabled\n  if (!proofsEnabled) isValidProof = true;\n\n  if (accountUpdate.authorization.proof && proofsEnabled) {\n    try {\n      let publicInputFields = ZkappPublicInput.toFields(publicInput);\n\n      let proof: JsonProof = {\n        maxProofsVerified: 2,\n        proof: accountUpdate.authorization.proof!,\n        publicInput: publicInputFields.map((f) => f.toString()),\n        publicOutput: [],\n      };\n\n      let verificationKeyRaw = account.zkapp?.verificationKey;\n      assert(verificationKeyRaw !== undefined, 'Account does not have a verification key');\n      let verificationKey = verificationKeyRaw.data;\n\n      const isVkValid = await VerificationKey.checkValidity(verificationKeyRaw);\n      if (!isVkValid)\n        throw Error(`The verification key hash is not consistent with the provided data`);\n\n      isValidProof = await verify(proof, verificationKey);\n      if (!isValidProof) {\n        throw Error(`Invalid proof for account update\\n${JSON.stringify(update)}`);\n      }\n    } catch (error) {\n      errorTrace += '\\n\\n' + (error as Error).stack;\n      isValidProof = false;\n    }\n  }\n\n  if (accountUpdate.authorization.signature) {\n    // checking permissions and authorization for each account update individually\n    try {\n      isValidSignature = verifyAccountUpdateSignature(\n        TypesBigint.AccountUpdate.fromJSON(accountUpdateJson),\n        transactionCommitments,\n        networkId\n      );\n    } catch (error) {\n      errorTrace += '\\n\\n' + (error as Error).stack;\n      isValidSignature = false;\n    }\n  }\n\n  let verified = false;\n\n  function checkPermission(p0: Types.AuthRequired, field: string) {\n    let p = Types.AuthRequired.toJSON(p0);\n    if (p === 'None') return;\n\n    if (p === 'Impossible') {\n      throw Error(\n        `Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p}'`\n      );\n    }\n\n    if (p === 'Signature' || p === 'Either') {\n      verified ||= isValidSignature;\n    }\n\n    if (p === 'Proof' || p === 'Either') {\n      verified ||= isValidProof;\n    }\n\n    if (!verified) {\n      throw Error(\n        `Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p}', but the required authorization was not provided or is invalid.\n        ${errorTrace !== '' ? 'Error trace: ' + errorTrace : ''}\\n\\n`\n      );\n    }\n  }\n\n  // goes through the update field on a transaction\n  Object.entries(update).forEach(([key, value]) => {\n    if (includesChange(value)) {\n      let p = permissionForUpdate(key);\n      checkPermission(p, key);\n    }\n  });\n\n  if (accountUpdate.update.verificationKey.isSome.toBoolean()) {\n    const isVkValid = await VerificationKey.checkValidity(\n      accountUpdate.update.verificationKey.value\n    );\n    if (!isVkValid)\n      throw Error(`The verification key hash is not consistent with the provided data`);\n  }\n  // checks the sequence events (which result in an updated sequence state)\n  if (accountUpdate.body.actions.data.length > 0) {\n    let p = permissionForUpdate('actions');\n    checkPermission(p, 'actions');\n  }\n\n  if (accountUpdate.body.incrementNonce.toBoolean()) {\n    let p = permissionForUpdate('incrementNonce');\n    checkPermission(p, 'incrementNonce');\n  }\n\n  // this checks for an edge case where an account update can be approved using proofs but\n  // a) the proof is invalid (bad verification key)\n  // and b) there are no state changes initiate so no permissions will be checked\n  // however, if the verification key changes, the proof should still be invalid\n  if (errorTrace && !verified) {\n    throw Error(\n      `One or more proofs were invalid and no other form of authorization was provided.\\n${errorTrace}`\n    );\n  }\n}\n\ntype AuthorizationKind = { isProved: boolean; isSigned: boolean };\n\nconst isPair = (a: AuthorizationKind, b: AuthorizationKind) => !a.isProved && !b.isProved;\n\nfunction filterPairs(xs: AuthorizationKind[]): {\n  xs: { isProved: boolean; isSigned: boolean }[];\n  pairs: number;\n} {\n  if (xs.length <= 1) return { xs, pairs: 0 };\n  if (isPair(xs[0], xs[1])) {\n    let rec = filterPairs(xs.slice(2));\n    return { xs: rec.xs, pairs: rec.pairs + 1 };\n  } else {\n    let rec = filterPairs(xs.slice(1));\n    return { xs: [xs[0]].concat(rec.xs), pairs: rec.pairs };\n  }\n}\n", "import {\n  ZkappCommand,\n  AccountUpdate,\n  ZkappPublicInput,\n  AccountUpdateLayout,\n  FeePayerUnsigned,\n  addMissingSignatures,\n  TokenId,\n  addMissingProofs,\n} from './account-update.js';\nimport { Field } from '../../provable/wrapped.js';\nimport { PrivateKey, PublicKey } from '../../provable/crypto/signature.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport { Empty } from '../../proof-system/zkprogram.js';\nimport { Proof } from '../../proof-system/proof.js';\nimport { currentTransaction } from './transaction-context.js';\nimport { Provable } from '../../provable/provable.js';\nimport { assertPreconditionInvariants } from './precondition.js';\nimport { Account } from './account.js';\nimport { type FeePayerSpec, activeInstance } from './mina-instance.js';\nimport * as Fetch from './fetch.js';\nimport { type SendZkAppResponse, sendZkappQuery } from './graphql.js';\nimport { type FetchMode } from './transaction-context.js';\nimport { assertPromise } from '../../util/assert.js';\nimport { Types } from '../../../bindings/mina-transaction/v1/types.js';\nimport { getTotalTimeRequired } from './transaction-validation.js';\n\nexport {\n  Transaction,\n  type TransactionPromise,\n  type PendingTransaction,\n  type IncludedTransaction,\n  type RejectedTransaction,\n  type PendingTransactionPromise,\n  type PendingTransactionStatus,\n  createTransaction,\n  toTransactionPromise,\n  toPendingTransactionPromise,\n  sendTransaction,\n  newTransaction,\n  getAccount,\n  transaction,\n  createRejectedTransaction,\n  createIncludedTransaction,\n};\n\ntype TransactionCommon = {\n  /**\n   * Transaction structure used to describe a state transition on the Mina blockchain.\n   */\n  transaction: ZkappCommand;\n  /**\n   * Serializes the transaction to a JSON string.\n   * @returns A string representation of the {@link Transaction}.\n   */\n  toJSON(): string;\n  /**\n   * Produces a pretty-printed JSON representation of the {@link Transaction}.\n   * @returns A formatted string representing the transaction in JSON.\n   */\n  toPretty(): any;\n  /**\n   * Constructs the GraphQL query string used for submitting the transaction to a Mina daemon.\n   * @returns The GraphQL query string for the {@link Transaction}.\n   */\n  toGraphqlQuery(): string;\n  /**\n   * Submits the {@link Transaction} to the network. This method asynchronously sends the transaction\n   * for processing. If successful, it returns a {@link PendingTransaction} instance, which can be used to monitor the transaction's progress.\n   * If the transaction submission fails, this method throws an error that should be caught and handled appropriately.\n   * @returns A {@link PendingTransactionPromise}, which resolves to a {@link PendingTransaction} instance representing the submitted transaction if the submission is successful.\n   * @throws An error if the transaction cannot be sent or processed by the network, containing details about the failure.\n   * @example\n   * ```ts\n   * try {\n   *   const pendingTransaction = await transaction.send();\n   *   console.log('Transaction sent successfully to the Mina daemon.');\n   * } catch (error) {\n   *   console.error('Failed to send transaction to the Mina daemon:', error);\n   * }\n   * ```\n   */\n};\n\nnamespace Transaction {\n  /**\n   * Deserializes a transaction from a JSON object or JSON string representation.\n   * This method accepts both parsed JSON objects and JSON strings, making it flexible for different use cases.\n   *\n   * @param json A JSON object representation of a transaction (Types.Json.ZkappCommand) or a JSON string\n   * @returns A new Transaction instance reconstructed from the JSON input\n   *\n   * @example\n   * ```ts\n   * const originalTx = await Mina.transaction(sender, () => {\n   *   zkapp.someMethod();\n   * });\n   * const serialized = originalTx.toJSON();\n   * const deserializedTx = Transaction.fromJSON(serialized);\n   * ```\n   */\n  export function fromJSON(json: Types.Json.ZkappCommand | string): Transaction<false, false> {\n    let transaction = ZkappCommand.fromJSON(json);\n    return newTransaction(transaction, activeInstance.proofsEnabled);\n  }\n}\n\n/**\n * Defines the structure and operations associated with a transaction.\n * This type encompasses methods for serializing the transaction, signing it, generating proofs,\n * and submitting it to the network.\n */\ntype Transaction<Proven extends boolean, Signed extends boolean> = TransactionCommon & {\n  send(): PendingTransactionPromise;\n  /**\n   * Sends the {@link Transaction} to the network. Unlike the standard {@link Transaction.send}, this function does not throw an error if internal errors are detected. Instead, it returns a {@link PendingTransaction} if the transaction is successfully sent for processing or a {@link RejectedTransaction} if it encounters errors during processing or is outright rejected by the Mina daemon.\n   * @returns {Promise<PendingTransaction | RejectedTransaction>} A promise that resolves to a {@link PendingTransaction} if the transaction is accepted for processing, or a {@link RejectedTransaction} if the transaction fails or is rejected.\n   * @example\n   * ```ts\n   * const result = await transaction.safeSend();\n   * if (result.status === 'pending') {\n   *   console.log('Transaction sent successfully to the Mina daemon.');\n   * } else if (result.status === 'rejected') {\n   *   console.error('Transaction failed with errors:', result.errors);\n   * }\n   * ```\n   */\n  safeSend(): Promise<PendingTransaction | RejectedTransaction>;\n\n  /**\n   * Modifies a transaction to set the fee to the new fee provided. Because this change invalidates proofs and signatures both are removed. The nonce is not increased so sending both transitions will not risk both being accepted.\n   * @returns {TransactionPromise<false,false>} The same transaction with the new fee and the proofs and signatures removed.\n   * @example\n   * ```ts\n   * tx.send();\n   * // Waits for some time and decide to resend with a higher fee\n   *\n   * tx.setFee(newFee);\n   * await tx.sign([feePayerKey]));\n   * await tx.send();\n   * ```\n   */\n  setFee(newFee: UInt64): TransactionPromise<Proven, false>;\n  /**\n   * setFeePerSnarkCost behaves identically to {@link Transaction.setFee} but the fee is given per estimated cost of snarking the transition as given by {@link getTotalTimeRequired}. This is useful because it should reflect what snark workers would charge in times of network contention.\n   */\n  setFeePerSnarkCost(newFeePerSnarkCost: number): TransactionPromise<Proven, false>;\n} & (Proven extends false\n    ? {\n        /**\n         * Initiates the proof generation process for the {@link Transaction}. This asynchronous operation is\n         * crucial for zero-knowledge-based transactions, where proofs are required to validate state transitions.\n         * This can take some time.\n         * @example\n         * ```ts\n         * await transaction.prove();\n         * ```\n         */\n        prove(): Promise<Transaction<true, Signed>>;\n      }\n    : {\n        /** The proofs generated as the result of calling `prove`. */\n        proofs: (Proof<ZkappPublicInput, Empty> | undefined)[];\n      }) &\n  (Signed extends false\n    ? {\n        /**\n         * Signs all {@link AccountUpdate}s included in the {@link Transaction} that require a signature.\n         * {@link AccountUpdate}s that require a signature can be specified with `{AccountUpdate|SmartContract}.requireSignature()`.\n         * @param privateKeys The list of keys that should be used to sign the {@link Transaction}\n         * @returns The {@link Transaction} instance with all required signatures applied.\n         * @example\n         * ```ts\n         * const signedTx = transaction.sign([userPrivateKey]);\n         * console.log('Transaction signed successfully.');\n         * ```\n         */\n        sign(privateKeys: PrivateKey[]): Transaction<Proven, true>;\n      }\n    : {});\n\ntype PendingTransactionStatus = 'pending' | 'rejected';\n/**\n * Represents a transaction that has been submitted to the blockchain but has not yet reached a final state.\n * The {@link PendingTransaction} type extends certain functionalities from the base {@link Transaction} type,\n * adding methods to monitor the transaction's progress towards being finalized (either included in a block or rejected).\n */\ntype PendingTransaction = Pick<TransactionCommon, 'transaction' | 'toJSON' | 'toPretty'> & {\n  /**\n   * @property {PendingTransactionStatus} status The status of the transaction after being sent to the Mina daemon.\n   * This property indicates the transaction's initial processing status but does not guarantee its eventual inclusion in a block.\n   * A status of `pending` suggests the transaction was accepted by the Mina daemon for processing,\n   * whereas a status of `rejected` indicates that the transaction was not accepted.\n   * Use the {@link PendingTransaction.wait()} or {@link PendingTransaction.safeWait()} methods to track the transaction's progress towards finalization and to determine whether it's included in a block.\n   * @example\n   * ```ts\n   * if (pendingTransaction.status === 'pending') {\n   *   console.log('Transaction accepted for processing by the Mina daemon.');\n   *   try {\n   *     await pendingTransaction.wait();\n   *     console.log('Transaction successfully included in a block.');\n   *   } catch (error) {\n   *     console.error('Transaction was rejected or failed to be included in a block:', error);\n   *   }\n   * } else {\n   *   console.error('Transaction was not accepted for processing by the Mina daemon.');\n   * }\n   * ```\n   */\n  status: PendingTransactionStatus;\n\n  /**\n   * Waits for the transaction to be included in a block. This method polls the Mina daemon to check the transaction's status, and throws an error if the transaction is rejected.\n   * @param {Object} [options] Configuration options for polling behavior.\n   * @param {number} [options.maxAttempts] The maximum number of attempts to check the transaction status.\n   * @param {number} [options.interval] The interval, in milliseconds, between status checks.\n   * @returns {Promise<IncludedTransaction>} A promise that resolves to the transaction's final state or throws an error.\n   * @throws {Error} If the transaction is rejected or fails to finalize within the given attempts.\n   * @example\n   * ```ts\n   * try {\n   *   const transaction = await pendingTransaction.wait({ maxAttempts: 10, interval: 2000 });\n   *   console.log('Transaction included in a block.');\n   * } catch (error) {\n   *   console.error('Transaction rejected or failed to finalize:', error);\n   * }\n   * ```\n   */\n  wait(options?: { maxAttempts?: number; interval?: number }): Promise<IncludedTransaction>;\n\n  /**\n   * Waits for the transaction to be included in a block. This method polls the Mina daemon to check the transaction's status\n   * @param {Object} [options] Configuration options for polling behavior.\n   * @param {number} [options.maxAttempts] The maximum number of polling attempts.\n   * @param {number} [options.interval] The time interval, in milliseconds, between each polling attempt.\n   * @returns {Promise<IncludedTransaction | RejectedTransaction>} A promise that resolves to the transaction's final state.\n   * @example\n   * ```ts\n   * const transaction = await pendingTransaction.wait({ maxAttempts: 5, interval: 1000 });\n   * console.log(transaction.status); // 'included' or 'rejected'\n   * ```\n   */\n  safeWait(options?: {\n    maxAttempts?: number;\n    interval?: number;\n  }): Promise<IncludedTransaction | RejectedTransaction>;\n\n  /**\n   * Returns the transaction hash as a string identifier.\n   * @property {string} The hash of the transaction.\n   * @example\n   * ```ts\n   * const txHash = pendingTransaction.hash;\n   * console.log(`Transaction hash: ${txHash}`);\n   * ```\n   */\n  hash: string;\n\n  /**\n   * Optional. Contains response data from a ZkApp transaction submission.\n   *\n   * @property {SendZkAppResponse} [data] The response data from the transaction submission.\n   */\n  data?: SendZkAppResponse;\n\n  /**\n   * An array of error messages related to the transaction processing.\n   *\n   * @property {string[]} errors Descriptive error messages if the transaction encountered issues during processing.\n   * @example\n   * ```ts\n   * if (!pendingTransaction.status === 'rejected') {\n   *   console.error(`Transaction errors: ${pendingTransaction.errors.join(', ')}`);\n   * }\n   * ```\n   */\n  errors: string[];\n\n  /**\n   * setFee is the same as {@link Transaction.setFee(newFee)} but for a {@link PendingTransaction}.\n   */\n  setFee(newFee: UInt64): TransactionPromise<boolean, false>;\n  /**\n   * setFeePerSnarkCost is the same as {@link Transaction.setFeePerSnarkCost(newFeePerSnarkCost)} but for a {@link PendingTransaction}.\n   */\n  setFeePerSnarkCost(newFeePerSnarkCost: number): TransactionPromise<boolean, false>;\n};\n\n/**\n * Represents a transaction that has been successfully included in a block.\n */\ntype IncludedTransaction = Pick<\n  PendingTransaction,\n  'transaction' | 'toJSON' | 'toPretty' | 'hash' | 'data'\n> & {\n  /**\n   * @property {string} status The final status of the transaction, indicating successful inclusion in a block.\n   * @example\n   * ```ts\n   * try {\n   *   const includedTx: IncludedTransaction = await pendingTransaction.wait();\n   *   // If wait() resolves, it means the transaction was successfully included.\n   *   console.log(`Transaction ${includedTx.hash} included in a block.`);\n   * } catch (error) {\n   *   // If wait() throws, the transaction was not included in a block.\n   *   console.error('Transaction failed to be included in a block:', error);\n   * }\n   * ```\n   */\n  status: 'included';\n};\n\n/**\n * Represents a transaction that has been rejected and not included in a blockchain block.\n */\ntype RejectedTransaction = Pick<\n  PendingTransaction,\n  'transaction' | 'toJSON' | 'toPretty' | 'hash' | 'data'\n> & {\n  /**\n   * @property {string} status The final status of the transaction, specifically indicating that it has been rejected.\n   * @example\n   * ```ts\n   * try {\n   *   const txResult = await pendingTransaction.wait();\n   *   // This line will not execute if the transaction is rejected, as `.wait()` will throw an error instead.\n   *   console.log(`Transaction ${txResult.hash} was successfully included in a block.`);\n   * } catch (error) {\n   *   console.error(`Transaction ${error.transaction.hash} was rejected.`);\n   *   error.errors.forEach((error, i) => {\n   *    console.error(`Error ${i + 1}: ${error}`);\n   *   });\n   * }\n   * ```\n   */\n  status: 'rejected';\n\n  /**\n   * @property {string[]} errors An array of error messages detailing the reasons for the transaction's rejection.\n   */\n  errors: string[];\n};\n\n/**\n * A `Promise<Transaction>` with some additional methods for making chained method calls\n * into the pending value upon its resolution.\n */\ntype TransactionPromise<Proven extends boolean, Signed extends boolean> = Promise<\n  Transaction<Proven, Signed>\n> & {\n  /** Equivalent to calling the resolved `Transaction`'s `send` method. */\n  send(): PendingTransactionPromise;\n} & (Proven extends false\n    ? {\n        /**\n         * Calls `prove` upon resolution of the `Transaction`. Returns a\n         * new `TransactionPromise` with the field `proofPromise` containing\n         * a promise which resolves to the proof array.\n         */\n        prove(): TransactionPromise<true, Signed>;\n      }\n    : {\n        /**\n         * If the chain of method calls that produced the current `TransactionPromise`\n         * contains a `prove` call, then this field contains a promise resolving to the\n         * proof array which was output from the underlying `prove` call.\n         */\n        proofs(): Promise<Transaction<true, Signed>['proofs']>;\n      }) &\n  (Signed extends false\n    ? {\n        /** Equivalent to calling the resolved `Transaction`'s `sign` method. */\n        sign(\n          ...args: Parameters<Transaction<Proven, Signed>['sign']>\n        ): TransactionPromise<Proven, true>;\n      }\n    : {});\n\nfunction toTransactionPromise<Proven extends boolean, Signed extends boolean>(\n  getPromise: () => Promise<Transaction<Proven, Signed>>\n): TransactionPromise<Proven, Signed> {\n  const pending = getPromise().then();\n  return Object.assign(pending, {\n    sign(...args: Parameters<Transaction<boolean, false>['sign']>) {\n      return toTransactionPromise(() =>\n        pending.then((v) => (v as Transaction<Proven, false>).sign(...args))\n      );\n    },\n    send() {\n      return toPendingTransactionPromise(() => pending.then((v) => v.send()));\n    },\n    prove() {\n      return toTransactionPromise(() =>\n        pending.then((v) => (v as never as Transaction<false, Signed>).prove())\n      );\n    },\n    proofs() {\n      return pending.then((v) => (v as never as Transaction<true, Proven>).proofs);\n    },\n  }) as never as TransactionPromise<Proven, Signed>;\n}\n\n/**\n * A `Promise<PendingTransaction>` with an additional `wait` method, which calls\n * into the inner `TransactionStatus`'s `wait` method upon its resolution.\n */\ntype PendingTransactionPromise = Promise<PendingTransaction> & {\n  /** Equivalent to calling the resolved `PendingTransaction`'s `wait` method. */\n  wait: PendingTransaction['wait'];\n};\n\nfunction toPendingTransactionPromise(\n  getPromise: () => Promise<PendingTransaction>\n): PendingTransactionPromise {\n  const pending = getPromise().then();\n  return Object.assign(pending, {\n    wait(...args: Parameters<PendingTransaction['wait']>) {\n      return pending.then((v) => v.wait(...args));\n    },\n  });\n}\n\nasync function createTransaction(\n  feePayer: FeePayerSpec,\n  f: () => Promise<unknown>,\n  numberOfRuns: 0 | 1 | undefined,\n  { fetchMode = 'cached' as FetchMode, isFinalRunOutsideCircuit = true, proofsEnabled = true } = {}\n): Promise<Transaction<false, false>> {\n  if (currentTransaction.has()) {\n    throw new Error('Cannot start new transaction within another transaction');\n  }\n  let feePayerSpec: {\n    sender?: PublicKey;\n    fee?: number | string | UInt64;\n    memo?: string;\n    nonce?: number;\n  };\n  if (feePayer === undefined) {\n    feePayerSpec = {};\n  } else if (feePayer instanceof PublicKey) {\n    feePayerSpec = { sender: feePayer };\n  } else {\n    feePayerSpec = feePayer;\n  }\n  let { sender, fee, memo = '', nonce } = feePayerSpec;\n\n  let transactionId = currentTransaction.enter({\n    sender,\n    layout: new AccountUpdateLayout(),\n    fetchMode,\n    isFinalRunOutsideCircuit,\n    numberOfRuns,\n  });\n\n  // run circuit\n  try {\n    if (fetchMode === 'test') {\n      await Provable.runUnchecked(async () => {\n        await assertPromise(f());\n        Provable.asProver(() => {\n          let tx = currentTransaction.get();\n          tx.layout.toConstantInPlace();\n        });\n      });\n    } else {\n      await assertPromise(f());\n    }\n  } catch (err) {\n    currentTransaction.leave(transactionId);\n    throw err;\n  }\n\n  let accountUpdates = currentTransaction.get().layout.toFlatList({ mutate: true });\n\n  try {\n    // check that on-chain values weren't used without setting a precondition\n    for (let accountUpdate of accountUpdates) {\n      assertPreconditionInvariants(accountUpdate);\n    }\n  } catch (err) {\n    currentTransaction.leave(transactionId);\n    throw err;\n  }\n\n  let feePayerAccountUpdate: FeePayerUnsigned;\n  if (sender !== undefined) {\n    // if senderKey is provided, fetch account to get nonce and mark to be signed\n    let nonce_;\n    let senderAccount = getAccount(sender, TokenId.default);\n\n    if (nonce === undefined) {\n      nonce_ = senderAccount.nonce;\n    } else {\n      nonce_ = UInt32.from(nonce);\n      senderAccount.nonce = nonce_;\n      Fetch.addCachedAccount(senderAccount);\n    }\n    feePayerAccountUpdate = AccountUpdate.defaultFeePayer(sender, nonce_);\n    if (fee !== undefined) {\n      feePayerAccountUpdate.body.fee = fee instanceof UInt64 ? fee : UInt64.from(String(fee));\n    }\n  } else {\n    // otherwise use a dummy fee payer that has to be filled in later\n    feePayerAccountUpdate = AccountUpdate.dummyFeePayer();\n  }\n\n  let transaction: ZkappCommand = {\n    accountUpdates,\n    feePayer: feePayerAccountUpdate,\n    memo,\n  };\n\n  currentTransaction.leave(transactionId);\n  return newTransaction(transaction, proofsEnabled);\n}\n\nfunction newTransaction(transaction: ZkappCommand, proofsEnabled?: boolean) {\n  let self: Transaction<false, false> = {\n    transaction,\n    sign(privateKeys: PrivateKey[]) {\n      self.transaction = addMissingSignatures(self.transaction, privateKeys);\n      return self;\n    },\n    prove() {\n      return toTransactionPromise(async () => {\n        let { zkappCommand, proofs } = await addMissingProofs(self.transaction, {\n          proofsEnabled,\n        });\n        self.transaction = zkappCommand;\n        return Object.assign(self as never as Transaction<true, false>, {\n          proofs,\n        });\n      });\n    },\n    toJSON() {\n      let json = ZkappCommand.toJSON(self.transaction);\n      return JSON.stringify(json);\n    },\n    toPretty() {\n      return ZkappCommand.toPretty(self.transaction);\n    },\n    toGraphqlQuery() {\n      return sendZkappQuery(self.toJSON());\n    },\n    send() {\n      return toPendingTransactionPromise(async () => {\n        const pendingTransaction = await sendTransaction(self);\n        if (pendingTransaction.errors.length > 0) {\n          throw Error(\n            `Transaction failed with errors:\\n- ${pendingTransaction.errors.join('\\n- ')}`\n          );\n        }\n        return pendingTransaction;\n      });\n    },\n    async safeSend() {\n      const pendingTransaction = await sendTransaction(self);\n      if (pendingTransaction.errors.length > 0) {\n        return createRejectedTransaction(pendingTransaction, pendingTransaction.errors);\n      }\n      return pendingTransaction;\n    },\n    setFeePerSnarkCost(newFeePerSnarkCost: number) {\n      let { totalTimeRequired } = getTotalTimeRequired(transaction.accountUpdates);\n      return this.setFee(new UInt64(Math.round(totalTimeRequired * newFeePerSnarkCost)));\n    },\n    setFee(newFee: UInt64) {\n      return toTransactionPromise(async () => {\n        self = self as Transaction<false, false>;\n        self.transaction.accountUpdates.forEach((au) => {\n          if (au.body.useFullCommitment.toBoolean()) {\n            au.authorization.signature = undefined;\n            au.lazyAuthorization = { kind: 'lazy-signature' };\n          }\n        });\n        self.transaction.feePayer.body.fee = newFee;\n        self.transaction.feePayer.lazyAuthorization = { kind: 'lazy-signature' };\n        return self;\n      });\n    },\n  };\n  return self;\n}\n\n/**\n * Construct a smart contract transaction. Within the callback passed to this function,\n * you can call into the methods of smart contracts.\n *\n * ```\n * let tx = await Mina.transaction(sender, async () => {\n *   await myZkapp.update();\n *   await someOtherZkapp.someOtherMethod();\n * });\n * ```\n *\n * @return A transaction that can subsequently be submitted to the chain.\n */\nfunction transaction(\n  sender: FeePayerSpec,\n  f: () => Promise<void>\n): TransactionPromise<false, false>;\nfunction transaction(f: () => Promise<void>): TransactionPromise<false, false>;\nfunction transaction(\n  senderOrF: FeePayerSpec | (() => Promise<void>),\n  fOrUndefined?: () => Promise<void>\n): TransactionPromise<false, false> {\n  let sender: FeePayerSpec;\n  let f: () => Promise<void>;\n  if (fOrUndefined !== undefined) {\n    sender = senderOrF as FeePayerSpec;\n    f = fOrUndefined;\n  } else {\n    sender = undefined;\n    f = senderOrF as () => Promise<void>;\n  }\n  return activeInstance.transaction(sender, f);\n}\n\n// TODO: should we instead constrain to `Transaction<true, true>`?\nasync function sendTransaction(txn: Transaction<boolean, boolean>) {\n  return await activeInstance.sendTransaction(txn);\n}\n\n/**\n * @return The account data associated to the given public key.\n */\nfunction getAccount(publicKey: PublicKey, tokenId?: Field): Account {\n  return activeInstance.getAccount(publicKey, tokenId);\n}\n\nfunction createRejectedTransaction(\n  { transaction, data, toJSON, toPretty, hash }: Omit<PendingTransaction, 'wait' | 'safeWait'>,\n  errors: string[]\n): RejectedTransaction {\n  return {\n    status: 'rejected',\n    errors,\n    transaction,\n    toJSON,\n    toPretty,\n    hash,\n    data,\n  };\n}\n\nfunction createIncludedTransaction({\n  transaction,\n  data,\n  toJSON,\n  toPretty,\n  hash,\n}: Omit<PendingTransaction, 'wait' | 'safeWait'>): IncludedTransaction {\n  return {\n    status: 'included',\n    transaction,\n    toJSON,\n    toPretty,\n    hash,\n    data,\n  };\n}\n", "/**\n * this file contains conversion functions between JS and OCaml\n */\n\nimport type { MlPublicKey, MlPublicKeyVar } from '../../bindings.js';\nimport { HashInput } from '../provable/types/struct.js';\nimport { Bool, Field } from '../provable/wrapped.js';\nimport { FieldVar, FieldConst } from '../provable/core/fieldvar.js';\nimport { Scalar, ScalarConst } from '../provable/scalar.js';\nimport { PrivateKey, PublicKey } from '../provable/crypto/signature.js';\nimport { MlPair, MlBool, MlArray } from './base.js';\nimport { MlFieldConstArray } from './fields.js';\n\nexport { Ml, MlHashInput };\n\nconst Ml = {\n  constFromField,\n  constToField,\n  varFromField,\n  varToField,\n\n  fromScalar,\n  toScalar,\n\n  fromPrivateKey,\n  toPrivateKey,\n\n  fromPublicKey,\n  toPublicKey,\n\n  fromPublicKeyVar,\n  toPublicKeyVar,\n};\n\ntype MlHashInput = [\n  flag: 0,\n  field_elements: MlArray<FieldConst>,\n  packed: MlArray<MlPair<FieldConst, number>>,\n];\n\nconst MlHashInput = {\n  to({ fields = [], packed = [] }: HashInput): MlHashInput {\n    return [\n      0,\n      MlFieldConstArray.to(fields),\n      MlArray.to(packed.map(([field, size]) => [0, Ml.constFromField(field), size])),\n    ];\n  },\n  from([, fields, packed]: MlHashInput): HashInput {\n    return {\n      fields: MlFieldConstArray.from(fields),\n      packed: MlArray.from(packed).map(\n        ([, field, size]) => [Field(field), size] as [Field, number]\n      ),\n    };\n  },\n};\n\nfunction constFromField(x: Field): FieldConst {\n  return x.toConstant().value[1];\n}\nfunction constToField(x: FieldConst): Field {\n  return Field(x);\n}\nfunction varFromField(x: Field): FieldVar {\n  return x.value;\n}\nfunction varToField(x: FieldVar): Field {\n  return Field(x);\n}\n\nfunction fromScalar(s: Scalar): ScalarConst {\n  return [0, s.toBigInt()];\n}\nfunction toScalar(s: ScalarConst) {\n  return Scalar.from(s[1]);\n}\n\nfunction fromPrivateKey(sk: PrivateKey) {\n  return fromScalar(sk.s);\n}\nfunction toPrivateKey(sk: ScalarConst) {\n  return new PrivateKey(Scalar.from(sk[1]));\n}\n\nfunction fromPublicKey(pk: PublicKey): MlPublicKey {\n  return MlPair(pk.x.toConstant().value[1], MlBool(pk.isOdd.toBoolean()));\n}\nfunction toPublicKey([, x, isOdd]: MlPublicKey): PublicKey {\n  return PublicKey.from({\n    x: Field(x),\n    isOdd: Bool(MlBool.from(isOdd)),\n  });\n}\n\nfunction fromPublicKeyVar(pk: PublicKey): MlPublicKeyVar {\n  return MlPair(pk.x.value, pk.isOdd.toField().value);\n}\nfunction toPublicKeyVar([, x, isOdd]: MlPublicKeyVar): PublicKey {\n  return PublicKey.from({ x: Field(x), isOdd: Bool(isOdd) });\n}\n", "/**\n * Apply transactions to a ledger of accounts.\n */\nimport { type AccountUpdate } from '../account-update.js';\nimport { Account } from '../account.js';\n\nexport { applyAccountUpdate };\n\n/**\n * Apply a single account update to update an account.\n *\n * TODO:\n * - This must receive and return some context global to the transaction, to check validity\n * - Should operate on the value / bigint type, not the provable type\n */\nfunction applyAccountUpdate(account: Account, update: AccountUpdate): Account {\n  account.publicKey.assertEquals(update.publicKey);\n  account.tokenId.assertEquals(update.tokenId, 'token id mismatch');\n\n  // clone account (TODO: do this efficiently)\n  let json = Account.toJSON(account);\n  account = Account.fromJSON(json);\n\n  // update permissions\n  if (update.update.permissions.isSome.toBoolean()) {\n    account.permissions = update.update.permissions.value;\n  }\n\n  return account;\n}\n", "/**\n * A ledger of accounts - simple model of a local blockchain.\n */\nimport { PublicKey } from '../../../provable/crypto/signature.js';\nimport type { AccountUpdate } from '../account-update.js';\nimport { Account, newAccount } from '../account.js';\nimport { Field } from '../../../provable/field.js';\nimport { applyAccountUpdate } from './apply.js';\nimport { Types } from '../../../../bindings/mina-transaction/v1/types.js';\n\nexport { SimpleLedger };\n\nclass SimpleLedger {\n  accounts: Map<bigint, Account>;\n\n  constructor() {\n    this.accounts = new Map();\n  }\n\n  static create(): SimpleLedger {\n    return new SimpleLedger();\n  }\n\n  exists({ publicKey, tokenId = Types.TokenId.empty() }: InputAccountId): boolean {\n    return this.accounts.has(accountId({ publicKey, tokenId }));\n  }\n\n  store(account: Account): void {\n    this.accounts.set(accountId(account), account);\n  }\n\n  load({ publicKey, tokenId = Types.TokenId.empty() }: InputAccountId): Account | undefined {\n    let id = accountId({ publicKey, tokenId });\n    let account = this.accounts.get(id);\n    return account;\n  }\n\n  apply(update: AccountUpdate): void {\n    let id = accountId(update.body);\n    let account = this.accounts.get(id);\n    account ??= newAccount(update.body);\n\n    let updated = applyAccountUpdate(account, update);\n    this.accounts.set(id, updated);\n  }\n}\n\ntype AccountId = { publicKey: PublicKey; tokenId: Field };\ntype InputAccountId = { publicKey: PublicKey; tokenId?: Field };\n\nfunction accountId(account: AccountId): bigint {\n  let id = account.publicKey.x.toBigInt();\n  id <<= 1n;\n  id |= BigInt(account.publicKey.isOdd.toBoolean());\n  id <<= BigInt(Field.sizeInBits);\n  id |= account.tokenId.toBigInt();\n  return id;\n}\n", "import { Ledger, Test, initializeBindings } from '../../../bindings.js';\nimport { Types, TypesBigint } from '../../../bindings/mina-transaction/v1/types.js';\nimport { transactionCommitments } from '../../../mina-signer/src/sign-zkapp-command.js';\nimport { NetworkId } from '../../../mina-signer/src/types.js';\nimport { Ml } from '../../ml/conversion.js';\nimport { PrivateKey, PublicKey } from '../../provable/crypto/signature.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport { Field } from '../../provable/wrapped.js';\nimport { prettifyStacktrace } from '../../util/errors.js';\nimport { TupleN } from '../../util/types.js';\nimport { Actions, Authorization, TokenId, ZkappCommand } from './account-update.js';\nimport { Account } from './account.js';\nimport { invalidTransactionError } from './errors.js';\nimport {\n  Mina,\n  defaultNetworkConstants,\n  type ActionStates,\n  type FeePayerSpec,\n} from './mina-instance.js';\nimport { SimpleLedger } from './transaction-logic/ledger.js';\nimport {\n  defaultNetworkState,\n  reportGetAccountError,\n  verifyAccountUpdate,\n  verifyTransactionLimits,\n} from './transaction-validation.js';\nimport {\n  IncludedTransaction,\n  PendingTransaction,\n  PendingTransactionPromise,\n  PendingTransactionStatus,\n  RejectedTransaction,\n  Transaction,\n  createIncludedTransaction,\n  createRejectedTransaction,\n  createTransaction,\n  toPendingTransactionPromise,\n  toTransactionPromise,\n} from './transaction.js';\n\nexport { LocalBlockchain, TestPublicKey };\n\ntype TestPublicKey = PublicKey & {\n  key: PrivateKey;\n};\nfunction TestPublicKey(key: PrivateKey): TestPublicKey {\n  return Object.assign(PublicKey.fromPrivateKey(key), { key });\n}\nnamespace TestPublicKey {\n  export function random<N extends number = 1>(\n    count: N = 1 as never\n  ): N extends 1 ? TestPublicKey : TupleN<TestPublicKey, N> {\n    if (count === 1) return TestPublicKey(PrivateKey.random()) as never;\n    return Array.from({ length: count as number }, () =>\n      TestPublicKey(PrivateKey.random())\n    ) as never;\n  }\n\n  export function fromBase58(base58: string): TestPublicKey {\n    return TestPublicKey(PrivateKey.fromBase58(base58));\n  }\n}\n\nexport type LocalBlockchain = Awaited<ReturnType<typeof LocalBlockchain>>;\n\n/**\n * A mock Mina blockchain running locally and useful for testing.\n */\nasync function LocalBlockchain({ proofsEnabled = true, enforceTransactionLimits = true } = {}) {\n  await initializeBindings();\n  const slotTime = 3 * 60 * 1000;\n  const startTime = Date.now();\n  const genesisTimestamp = UInt64.from(startTime);\n  const ledger = Ledger.create();\n  let networkState = defaultNetworkState();\n\n  function addAccount(publicKey: PublicKey, balance: string) {\n    try {\n      ledger.addAccount(Ml.fromPublicKey(publicKey), balance);\n    } catch (error) {\n      throw prettifyStacktrace(error);\n    }\n  }\n\n  let testAccounts = [] as never as TupleN<TestPublicKey, 10>;\n\n  for (let i = 0; i < 10; ++i) {\n    let MINA = 10n ** 9n;\n    const largeValue = 1000n * MINA;\n    const testAccount = TestPublicKey.random();\n    addAccount(testAccount, largeValue.toString());\n    testAccounts.push(testAccount);\n  }\n\n  const events: Record<string, any> = {};\n  const actions: Record<string, Record<string, { actions: string[][]; hash: string }[]>> = {};\n  const originalProofsEnabled = proofsEnabled;\n\n  return {\n    getNetworkId: () => 'devnet' as NetworkId,\n    proofsEnabled,\n    getNetworkConstants() {\n      return {\n        ...defaultNetworkConstants,\n        genesisTimestamp,\n      };\n    },\n    currentSlot() {\n      return UInt32.from(Math.ceil((new Date().valueOf() - startTime) / slotTime));\n    },\n    hasAccount(publicKey: PublicKey, tokenId: Field = TokenId.default) {\n      return !!ledger.getAccount(Ml.fromPublicKey(publicKey), Ml.constFromField(tokenId));\n    },\n    getAccount(publicKey: PublicKey, tokenId: Field = TokenId.default): Account {\n      let accountJson = ledger.getAccount(Ml.fromPublicKey(publicKey), Ml.constFromField(tokenId));\n      if (accountJson === undefined) {\n        throw new Error(reportGetAccountError(publicKey.toBase58(), TokenId.toBase58(tokenId)));\n      }\n      return Types.Account.fromJSON(accountJson);\n    },\n    getNetworkState() {\n      return networkState;\n    },\n    sendTransaction(txn: Transaction<boolean, boolean>): PendingTransactionPromise {\n      return toPendingTransactionPromise(async () => {\n        let zkappCommandJson = ZkappCommand.toJSON(txn.transaction);\n        let commitments = transactionCommitments(\n          TypesBigint.ZkappCommand.fromJSON(zkappCommandJson),\n          this.getNetworkId()\n        );\n\n        if (enforceTransactionLimits) verifyTransactionLimits(txn.transaction);\n\n        // create an ad-hoc ledger to record changes to accounts within the transaction\n        let simpleLedger = SimpleLedger.create();\n\n        for (const update of txn.transaction.accountUpdates) {\n          let authIsProof = !!update.authorization.proof;\n          let kindIsProof = update.body.authorizationKind.isProved.toBoolean();\n          // checks and edge case where a proof is expected, but the developer forgot to invoke await tx.prove()\n          // this resulted in an assertion OCaml error, which didn't contain any useful information\n          if (kindIsProof && !authIsProof) {\n            throw Error(\n              `The actual authorization does not match the expected authorization kind. Did you forget to invoke \\`await tx.prove();\\`?`\n            );\n          }\n\n          let account = simpleLedger.load(update.body);\n\n          // the first time we encounter an account, use it from the persistent ledger\n          if (account === undefined) {\n            let accountJson = ledger.getAccount(\n              Ml.fromPublicKey(update.body.publicKey),\n              Ml.constFromField(update.body.tokenId)\n            );\n            if (accountJson !== undefined) {\n              let storedAccount = Account.fromJSON(accountJson);\n              simpleLedger.store(storedAccount);\n              account = storedAccount;\n            }\n          }\n\n          // TODO: verify account update even if the account doesn't exist yet, using a default initial account\n          if (account !== undefined) {\n            let publicInput = update.toPublicInput(txn.transaction);\n            await verifyAccountUpdate(\n              account,\n              update,\n              publicInput,\n              commitments,\n              this.proofsEnabled,\n              this.getNetworkId()\n            );\n            simpleLedger.apply(update);\n          }\n        }\n\n        let status: PendingTransactionStatus = 'pending';\n        const errors: string[] = [];\n        try {\n          ledger.applyJsonTransaction(\n            JSON.stringify(zkappCommandJson),\n            defaultNetworkConstants.accountCreationFee.toString(),\n            JSON.stringify(networkState)\n          );\n        } catch (err: any) {\n          status = 'rejected';\n          try {\n            const errorMessages = JSON.parse(err.message);\n            const formattedError = invalidTransactionError(txn.transaction, errorMessages, {\n              accountCreationFee: defaultNetworkConstants.accountCreationFee.toString(),\n            });\n            errors.push(formattedError);\n          } catch (parseError: any) {\n            const fallbackErrorMessage =\n              err.message || parseError.message || 'Unknown error occurred';\n            errors.push(fallbackErrorMessage);\n          }\n        }\n\n        // fetches all events from the transaction and stores them\n        // events are identified and associated with a publicKey and tokenId\n        txn.transaction.accountUpdates.forEach((p, i) => {\n          let pJson = zkappCommandJson.accountUpdates[i];\n          let addr = pJson.body.publicKey;\n          let tokenId = pJson.body.tokenId;\n          events[addr] ??= {};\n          if (p.body.events.data.length > 0) {\n            events[addr][tokenId] ??= [];\n            let updatedEvents = p.body.events.data.map((data: Field[]) => {\n              return {\n                data: data.map((e) => e.toString()),\n                transactionInfo: {\n                  transactionHash: '',\n                  transactionStatus: '',\n                  transactionMemo: '',\n                },\n              };\n            });\n            events[addr][tokenId].push({\n              events: updatedEvents,\n              blockHeight: networkState.blockchainLength,\n              globalSlot: networkState.globalSlotSinceGenesis,\n              // The following fields are fetched from the Mina network. For now, we mock these values out\n              // since networkState does not contain these fields.\n              blockHash: '',\n              parentBlockHash: '',\n              chainStatus: '',\n            });\n          }\n\n          // actions/sequencing events\n\n          // most recent action state\n          let storedActions = actions[addr]?.[tokenId];\n          let latestActionState_ = storedActions?.[storedActions.length - 1]?.hash;\n          // if there exists no hash, this means we initialize our latest hash with the empty state\n          let latestActionState =\n            latestActionState_ !== undefined\n              ? Field(latestActionState_)\n              : Actions.emptyActionState();\n\n          actions[addr] ??= {};\n          if (p.body.actions.data.length > 0) {\n            let newActionState = Actions.updateSequenceState(\n              latestActionState,\n              p.body.actions.hash\n            );\n            actions[addr][tokenId] ??= [];\n            actions[addr][tokenId].push({\n              actions: pJson.body.actions,\n              hash: newActionState.toString(),\n            });\n          }\n        });\n\n        let test = await Test();\n        const hash = test.transactionHash.hashZkAppCommand(txn.toJSON());\n        const pendingTransaction: Omit<PendingTransaction, 'wait' | 'safeWait'> = {\n          status,\n          errors,\n          transaction: txn.transaction,\n          setFee: txn.setFee,\n          setFeePerSnarkCost: txn.setFeePerSnarkCost,\n          hash,\n          toJSON: txn.toJSON,\n          toPretty: txn.toPretty,\n        };\n\n        const wait = async (_options?: {\n          maxAttempts?: number;\n          interval?: number;\n        }): Promise<IncludedTransaction> => {\n          const pendingTransaction = await safeWait(_options);\n          if (pendingTransaction.status === 'rejected') {\n            throw Error(`Transaction failed with errors:\\n${pendingTransaction.errors.join('\\n')}`);\n          }\n          return pendingTransaction;\n        };\n\n        const safeWait = async (_options?: {\n          maxAttempts?: number;\n          interval?: number;\n        }): Promise<IncludedTransaction | RejectedTransaction> => {\n          if (status === 'rejected') {\n            return createRejectedTransaction(pendingTransaction, pendingTransaction.errors);\n          }\n          return createIncludedTransaction(pendingTransaction);\n        };\n\n        return {\n          ...pendingTransaction,\n          wait,\n          safeWait,\n        };\n      });\n    },\n    transaction(sender: FeePayerSpec, f: () => Promise<void>) {\n      return toTransactionPromise(async () => {\n        // TODO we run the transaction twice to match the behavior of `Network.transaction`\n        let tx = await createTransaction(sender, f, 0, {\n          isFinalRunOutsideCircuit: false,\n          proofsEnabled: this.proofsEnabled,\n          fetchMode: 'test',\n        });\n        let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);\n        return await createTransaction(sender, f, 1, {\n          isFinalRunOutsideCircuit: !hasProofs,\n          proofsEnabled: this.proofsEnabled,\n        });\n      });\n    },\n    applyJsonTransaction(json: string) {\n      return ledger.applyJsonTransaction(\n        json,\n        defaultNetworkConstants.accountCreationFee.toString(),\n        JSON.stringify(networkState)\n      );\n    },\n    async fetchEvents(publicKey: PublicKey, tokenId: Field = TokenId.default) {\n      // Return events in reverse chronological order (latest events at the beginning)\n      const reversedEvents = (\n        events?.[publicKey.toBase58()]?.[TokenId.toBase58(tokenId)] ?? []\n      ).reverse();\n      return reversedEvents;\n    },\n    async fetchActions(\n      publicKey: PublicKey,\n      actionStates?: ActionStates,\n      tokenId: Field = TokenId.default,\n      _from?: number,\n      _to?: number\n    ) {\n      return this.getActions(publicKey, actionStates, tokenId);\n    },\n    getActions(\n      publicKey: PublicKey,\n      actionStates?: ActionStates,\n      tokenId: Field = TokenId.default\n    ): { hash: string; actions: string[][] }[] {\n      let currentActions = actions?.[publicKey.toBase58()]?.[TokenId.toBase58(tokenId)] ?? [];\n      let { fromActionState, endActionState } = actionStates ?? {};\n\n      let emptyState = Actions.emptyActionState();\n      if (endActionState?.equals(emptyState).toBoolean()) return [];\n\n      let start = fromActionState?.equals(emptyState).toBoolean()\n        ? undefined\n        : fromActionState?.toString();\n      let end = endActionState?.toString();\n\n      let startIndex = 0;\n      if (start) {\n        let i = currentActions.findIndex((e) => e.hash === start);\n        if (i === -1) throw Error(`getActions: fromActionState not found.`);\n        startIndex = i + 1;\n      }\n      let endIndex: number | undefined;\n      if (end) {\n        let i = currentActions.findIndex((e) => e.hash === end);\n        if (i === -1) throw Error(`getActions: endActionState not found.`);\n        endIndex = i + 1;\n      }\n      return currentActions.slice(startIndex, endIndex);\n    },\n    addAccount,\n    /**\n     * An array of 10 test accounts that have been pre-filled with\n     * 30000000000 units of currency.\n     */\n    testAccounts,\n    setGlobalSlot(slot: UInt32 | number) {\n      networkState.globalSlotSinceGenesis = UInt32.from(slot);\n    },\n    incrementGlobalSlot(increment: UInt32 | number) {\n      networkState.globalSlotSinceGenesis = networkState.globalSlotSinceGenesis.add(increment);\n    },\n    setBlockchainLength(height: UInt32) {\n      networkState.blockchainLength = height;\n    },\n    setTotalCurrency(currency: UInt64) {\n      networkState.totalCurrency = currency;\n    },\n    setProofsEnabled(newProofsEnabled: boolean) {\n      this.proofsEnabled = newProofsEnabled;\n    },\n    resetProofsEnabled() {\n      this.proofsEnabled = originalProofsEnabled;\n    },\n  };\n}\n// assert type compatibility without preventing LocalBlockchain to return additional properties / methods\nLocalBlockchain satisfies (...args: any) => Promise<Mina>;\n", "import { Field } from '../../../provable/wrapped.js';\nimport { Actions } from '../account-update.js';\nimport { FlexibleProvablePure, InferProvable } from '../../../provable/types/struct.js';\nimport { provable } from '../../../provable/types/provable-derivers.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { ProvableHashable } from '../../../provable/crypto/poseidon.js';\nimport * as Mina from '../mina.js';\nimport { ProvablePure } from '../../../provable/types/provable-intf.js';\nimport { MerkleList } from '../../../provable/merkle-list.js';\nimport type { SmartContract } from '../zkapp.js';\n\nexport { Reducer, getReducer };\n\nconst Reducer: (<\n  T extends FlexibleProvablePure<any>,\n  A extends InferProvable<T> = InferProvable<T>,\n>(reducer: {\n  actionType: T;\n}) => ReducerReturn<A>) & {\n  initialActionState: Field;\n} = Object.defineProperty(\n  function (reducer: any) {\n    // we lie about the return value here, and instead overwrite this.reducer with\n    // a getter, so we can get access to `this` inside functions on this.reducer (see constructor)\n    return reducer;\n  },\n  'initialActionState',\n  { get: Actions.emptyActionState }\n) as any;\n\ntype Reducer<Action> = {\n  actionType: FlexibleProvablePure<Action>;\n};\n\ntype ReducerReturn<Action> = {\n  /**\n   * Dispatches an {@link Action}. Similar to normal {@link Event}s,\n   * {@link Action}s can be stored by archive nodes and later reduced within a {@link SmartContract} method\n   * to change the state of the contract accordingly\n   *\n   * ```ts\n   * this.reducer.dispatch(Field(1)); // emits one action\n   * ```\n   *\n   * */\n  dispatch(action: Action): void;\n  /**\n   * Reduces a list of {@link Action}s, similar to `Array.reduce()`.\n   *\n   * ```ts\n   *  let pendingActions = this.reducer.getActions({\n   *    fromActionState: actionState,\n   *  });\n   *\n   *  let newState = this.reducer.reduce(\n   *    pendingActions,\n   *    Field, // the state type\n   *    (state: Field, _action: Field) => {\n   *      return state.add(1);\n   *    },\n   *    initialState // initial state\n   * );\n   * ```\n   *\n   * Warning: The reducer API in o1js is currently not safe to use in production applications. The `reduce()`\n   * method breaks if more than the hard-coded number (default: 32) of actions are pending. Work is actively\n   * in progress to mitigate this limitation.\n   */\n  reduce<State>(\n    actions: MerkleList<MerkleList<Action>>,\n    stateType: Provable<State>,\n    reduce: (state: State, action: Action) => State,\n    initial: State,\n    options?: {\n      maxUpdatesWithActions?: number;\n      maxActionsPerUpdate?: number;\n      skipActionStatePrecondition?: boolean;\n    }\n  ): State;\n  /**\n   * Perform circuit logic for every {@link Action} in the list.\n   *\n   * This is a wrapper around {@link reduce} for when you don't need `state`.\n   */\n  forEach(\n    actions: MerkleList<MerkleList<Action>>,\n    reduce: (action: Action) => void,\n    options?: {\n      maxUpdatesWithActions?: number;\n      maxActionsPerUpdate?: number;\n      skipActionStatePrecondition?: boolean;\n    }\n  ): void;\n  /**\n   * Fetches the list of previously emitted {@link Action}s by this {@link SmartContract}.\n   * ```ts\n   * let pendingActions = this.reducer.getActions({\n   *    fromActionState: actionState,\n   * });\n   * ```\n   *\n   * The final action state can be accessed on `pendingActions.hash`.\n   * ```ts\n   * let endActionState = pendingActions.hash;\n   * ```\n   *\n   * If the optional `endActionState` is provided, the list of actions will be fetched up to that state.\n   * In that case, `pendingActions.hash` is guaranteed to equal `endActionState`.\n   */\n  getActions({\n    fromActionState,\n    endActionState,\n  }?: {\n    fromActionState?: Field;\n    endActionState?: Field;\n  }): MerkleList<MerkleList<Action>>;\n  /**\n   * Fetches the list of previously emitted {@link Action}s by zkapp {@link SmartContract}.\n   * ```ts\n   * let pendingActions = await zkapp.reducer.fetchActions({\n   *    fromActionState: actionState,\n   * });\n   * ```\n   */\n  fetchActions({\n    fromActionState,\n    endActionState,\n  }?: {\n    fromActionState?: Field;\n    endActionState?: Field;\n  }): Promise<Action[][]>;\n};\n\nfunction getReducer<A>(contract: SmartContract): ReducerReturn<A> {\n  let reducer: Reducer<A> = ((contract as any)._ ??= {}).reducer;\n  if (reducer === undefined)\n    throw Error(\n      'You are trying to use a reducer without having declared its type.\\n' +\n        `Make sure to add a property \\`reducer\\` on ${contract.constructor.name}, for example:\nclass ${contract.constructor.name} extends SmartContract {\n  reducer = Reducer({ actionType: Field });\n}`\n    );\n  return {\n    dispatch(action: A) {\n      let accountUpdate = contract.self;\n      let canonical = Provable.toCanonical(reducer.actionType as Provable<A>, action);\n      let eventFields = reducer.actionType.toFields(canonical);\n      accountUpdate.body.actions = Actions.pushEvent(accountUpdate.body.actions, eventFields);\n    },\n\n    reduce<S>(\n      actionLists: MerkleList<MerkleList<A>>,\n      stateType: Provable<S>,\n      reduce: (state: S, action: A) => S,\n      state: S,\n      {\n        maxUpdatesWithActions = 32,\n        maxActionsPerUpdate = 1,\n        skipActionStatePrecondition = false,\n      } = {}\n    ): S {\n      Provable.asProver(() => {\n        if (actionLists.data.get().length > maxUpdatesWithActions) {\n          throw Error(\n            `reducer.reduce: Exceeded the maximum number of lists of actions, ${maxUpdatesWithActions}.\n  Use the optional \\`maxUpdatesWithActions\\` argument to increase this number.`\n          );\n        }\n      });\n\n      if (!skipActionStatePrecondition) {\n        // the actionList.hash is the hash of all actions in that list, appended to the previous hash (the previous list of historical actions)\n        // this must equal one of the action states as preconditions to build a chain to that we only use actions that were dispatched between the current on chain action state and the initialActionState\n        contract.account.actionState.requireEquals(actionLists.hash);\n      }\n\n      const listIter = actionLists.startIterating();\n\n      for (let i = 0; i < maxUpdatesWithActions; i++) {\n        let { element: merkleActions, isDummy } = listIter.Unsafe.next();\n        let actionIter = merkleActions.startIterating();\n        let newState = state;\n\n        if (maxActionsPerUpdate === 1) {\n          // special case with less work, because the only action is a dummy iff merkleActions is a dummy\n          let action = Provable.witness(\n            reducer.actionType,\n            () => actionIter.data.get()[0]?.element ?? actionIter.innerProvable.empty()\n          );\n          let emptyHash = actionIter.Constructor.emptyHash;\n          let finalHash = actionIter.nextHash(emptyHash, action);\n          finalHash = Provable.if(isDummy, emptyHash, finalHash);\n\n          // note: this asserts nothing in the isDummy case, because `actionIter.hash` is not well-defined\n          // but it doesn't matter because we're also skipping all state and action state updates in that case\n          actionIter.hash.assertEquals(finalHash);\n\n          newState = reduce(newState, action);\n        } else {\n          for (let j = 0; j < maxActionsPerUpdate; j++) {\n            let { element: action, isDummy } = actionIter.Unsafe.next();\n            newState = Provable.if(isDummy, stateType, newState, reduce(newState, action));\n          }\n          // note: this asserts nothing about the iterated actions if `MerkleActions` is a dummy\n          // which doesn't matter because we're also skipping all state and action state updates in that case\n          actionIter.assertAtEnd();\n        }\n\n        state = Provable.if(isDummy, stateType, state, newState);\n      }\n\n      // important: we check that by iterating, we actually reached the claimed final action state\n      listIter.assertAtEnd();\n\n      return state;\n    },\n\n    forEach(actionLists: MerkleList<MerkleList<A>>, callback: (action: A) => void, config) {\n      const stateType = provable(null);\n      this.reduce(\n        actionLists,\n        stateType,\n        (_, action) => {\n          callback(action);\n          return null;\n        },\n        null,\n        config\n      );\n    },\n\n    getActions(config?: {\n      fromActionState?: Field;\n      endActionState?: Field;\n    }): MerkleList<MerkleList<A>> {\n      const Action = reducer.actionType;\n      const emptyHash = Actions.empty().hash;\n      const nextHash = (hash: Field, action: A) =>\n        Actions.pushEvent({ hash, data: [] }, Action.toFields(action)).hash;\n\n      class ActionList extends MerkleList.create(\n        Action as unknown as ProvableHashable<A>,\n        nextHash,\n        emptyHash\n      ) {}\n\n      class MerkleActions extends MerkleList.create(\n        ActionList,\n        (hash: Field, actions: ActionList) => Actions.updateSequenceState(hash, actions.hash),\n        // if no \"start\" action hash was specified, this means we are fetching the entire history of actions, which started from the empty action state hash\n        // otherwise we are only fetching a part of the history, which starts at `fromActionState`\n        // TODO does this show that `emptyHash` should be part of the instance, not the class? that would make the provable representation bigger though\n        config?.fromActionState ?? Actions.emptyActionState()\n      ) {}\n\n      let actions = Provable.witness(MerkleActions, () => {\n        let actionFields = Mina.getActions(contract.address, config, contract.tokenId);\n        // convert string-Fields back into the original action type\n        let actions = actionFields.map((event) =>\n          event.actions.map((action) =>\n            (reducer.actionType as ProvablePure<A>).fromFields(action.map(Field))\n          )\n        );\n        return MerkleActions.from(actions.map((a) => ActionList.fromReverse(a)));\n      });\n      // note that we don't have to assert anything about the initial action state here,\n      // because it is taken directly and not witnessed\n      if (config?.endActionState !== undefined) {\n        actions.hash.assertEquals(config.endActionState);\n      }\n      return actions;\n    },\n\n    async fetchActions(config?: {\n      fromActionState?: Field;\n      endActionState?: Field;\n    }): Promise<A[][]> {\n      let result = await Mina.fetchActions(contract.address, config, contract.tokenId);\n      if ('error' in result) {\n        throw Error(JSON.stringify(result));\n      }\n      return result.map((event) =>\n        // putting our string-Fields back into the original action type\n        event.actions.map((action) =>\n          (reducer.actionType as ProvablePure<A>).fromFields(action.map(Field))\n        )\n      );\n    },\n  };\n}\n", "import { FlexibleProvablePure } from '../../provable/types/struct.js';\nimport { AccountUpdate, TokenId } from './account-update.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport * as Mina from './mina.js';\nimport { fetchAccount, networkConfig } from './fetch.js';\nimport { SmartContract } from './zkapp.js';\nimport { Account } from './account.js';\nimport { Provable } from '../../provable/provable.js';\nimport { Field } from '../../provable/wrapped.js';\nimport {\n  ProvablePure,\n  ProvableType,\n  ProvableTypePure,\n} from '../../provable/types/provable-intf.js';\nimport { ensureConsistentPrecondition } from './precondition.js';\nimport { Bool } from '../../provable/wrapped.js';\n\n// external API\nexport { State, state, declareState };\n// internal API\nexport { assertStatePrecondition, cleanStatePrecondition, getLayout, InternalStateType };\n\n/**\n * Gettable and settable state that can be checked for equality.\n */\ntype State<A> = {\n  /**\n   * Get the current on-chain state.\n   *\n   * Caution: If you use this method alone inside a smart contract, it does not prove that your contract uses the current on-chain state.\n   * To successfully prove that your contract uses the current on-chain state, you must add an additional `.requireEquals()` statement or use `.getAndRequireEquals()`:\n   *\n   * ```ts\n   * let x = this.x.get();\n   * this.x.requireEquals(x);\n   * ```\n   *\n   * OR\n   *\n   * ```ts\n   * let x = this.x.getAndRequireEquals();\n   * ```\n   */\n  get(): A;\n  /**\n   * Get the current on-chain state and prove it really has to equal the on-chain state,\n   * by adding a precondition which the verifying Mina node will check before accepting this transaction.\n   */\n  getAndRequireEquals(): A;\n  /**\n   * Set the on-chain state to a new value.\n   */\n  set(a: A): void;\n  /**\n   * Asynchronously fetch the on-chain state. This is intended for getting the state outside a smart contract.\n   */\n  fetch(): Promise<A | undefined>;\n  /**\n   * Prove that the on-chain state has to equal the given state,\n   * by adding a precondition which the verifying Mina node will check before accepting this transaction.\n   */\n  requireEquals(a: A): void;\n  /**\n   * Require that the on-chain state has to equal the given state if the provided condition is true.\n   *\n   * If the condition is false, this is a no-op.\n   * If the condition is true, this adds a precondition that the verifying Mina node will check before accepting this transaction.\n   */\n  requireEqualsIf(condition: Bool, a: A): void;\n  /**\n   * **DANGER ZONE**: Override the error message that warns you when you use `.get()` without adding a precondition.\n   */\n  requireNothing(): void;\n  /**\n   * Get the state from the raw list of field elements on a zkApp account, for example:\n   *\n   * ```ts\n   * let myContract = new MyContract(address);\n   * let account = Mina.getAccount(address);\n   *\n   * let x = myContract.x.fromAppState(account.zkapp!.appState);\n   * ```\n   */\n  fromAppState(appState: Field[]): A;\n};\nfunction State<A>(defaultValue?: A): State<A> {\n  return createState<A>(defaultValue);\n}\n\n/**\n * A decorator to use within a zkapp to indicate what will be stored on-chain.\n * For example, if you want to store a field element `some_state` in a zkapp,\n * you can use the following in the declaration of your zkapp:\n *\n * ```\n * @state(Field) some_state = State<Field>();\n * ```\n *\n */\nfunction state<A>(type: ProvableTypePure<A> | FlexibleProvablePure<A>) {\n  let stateType = ProvableType.get(type);\n\n  return function (\n    target: SmartContract & { constructor: any },\n    key: string,\n    _descriptor?: PropertyDescriptor\n  ) {\n    const ZkappClass = target.constructor;\n    if (reservedPropNames.has(key)) {\n      throw Error(`Property name ${key} is reserved.`);\n    }\n    let sc = smartContracts.get(ZkappClass);\n    if (sc === undefined) {\n      sc = { states: [], layout: undefined };\n      smartContracts.set(ZkappClass, sc);\n    }\n    sc.states.push([key, stateType]);\n\n    Object.defineProperty(target, key, {\n      get(this) {\n        return this._?.[key];\n      },\n      set(this, v: InternalStateType<A>) {\n        if (v._contract !== undefined)\n          throw Error('A State should only be assigned once to a SmartContract');\n        if (this._?.[key]) throw Error('A @state should only be assigned once');\n        v._contract = {\n          key,\n          stateType: stateType as ProvablePure<A>,\n          instance: this,\n          class: ZkappClass,\n          wasConstrained: false,\n          wasRead: false,\n          cachedVariable: undefined,\n        };\n        (this._ ??= {})[key] = v;\n      },\n    });\n  };\n}\n\n/**\n * `declareState` can be used in place of the `@state` decorator to declare on-chain state on a SmartContract.\n * It should be placed _after_ the class declaration.\n * Here is an example of declaring a state property `x` of type `Field`.\n * ```ts\n * class MyContract extends SmartContract {\n *   x = State<Field>();\n *   // ...\n * }\n * declareState(MyContract, { x: Field });\n * ```\n *\n * If you're using pure JS, it's _not_ possible to use the built-in class field syntax,\n * i.e. the following will _not_ work:\n *\n * ```js\n * // THIS IS WRONG IN JS!\n * class MyContract extends SmartContract {\n *   x = State();\n * }\n * declareState(MyContract, { x: Field });\n * ```\n *\n * Instead, add a constructor where you assign the property:\n * ```js\n * class MyContract extends SmartContract {\n *   constructor(x) {\n *     super();\n *     this.x = State();\n *   }\n * }\n * declareState(MyContract, { x: Field });\n * ```\n */\nfunction declareState<T extends typeof SmartContract>(\n  SmartContract: T,\n  states: Record<string, FlexibleProvablePure<any>>\n) {\n  for (let key in states) {\n    let CircuitValue = states[key];\n    state(CircuitValue)(SmartContract.prototype, key);\n  }\n}\n\n// metadata defined by @state, which link state to a particular SmartContract\ntype StateAttachedContract<A> = {\n  key: string;\n  stateType: ProvablePure<A>;\n  instance: SmartContract;\n  class: typeof SmartContract;\n  wasRead: boolean;\n  wasConstrained: boolean;\n  cachedVariable?: A;\n};\n\ntype InternalStateType<A> = State<A> & {\n  _contract?: StateAttachedContract<A>;\n  defaultValue?: A;\n};\n\nfunction createState<T>(defaultValue?: T): InternalStateType<T> {\n  return {\n    _contract: undefined as StateAttachedContract<T> | undefined,\n    defaultValue,\n\n    set(state: T) {\n      if (this._contract === undefined)\n        throw Error('set can only be called when the State is assigned to a SmartContract @state.');\n      let layout = getLayoutPosition(this._contract);\n      let stateAsFields = this._contract.stateType.toFields(state);\n      let accountUpdate = this._contract.instance.self;\n      stateAsFields.forEach((x, i) => {\n        let appStateSlot = accountUpdate.body.update.appState[layout.offset + i];\n        AccountUpdate.setValue(appStateSlot, x);\n      });\n    },\n\n    requireEquals(state: T) {\n      if (this._contract === undefined)\n        throw Error(\n          'requireEquals can only be called when the State is assigned to a SmartContract @state.'\n        );\n      let layout = getLayoutPosition(this._contract);\n      let stateAsFields = this._contract.stateType.toFields(state);\n      let accountUpdate = this._contract.instance.self;\n      stateAsFields.forEach((x, i) => {\n        let precondition = accountUpdate.body.preconditions.account.state[layout.offset + i];\n        ensureConsistentPrecondition(precondition, Bool(true), x, this._contract?.key);\n        AccountUpdate.assertEquals(precondition, x);\n      });\n      this._contract.wasConstrained = true;\n    },\n\n    requireEqualsIf(condition: Bool, state: T) {\n      if (this._contract === undefined)\n        throw Error(\n          'requireEqualsIf can only be called when the State is assigned to a SmartContract @state.'\n        );\n      let layout = getLayoutPosition(this._contract);\n      let stateAsFields = this._contract.stateType.toFields(state);\n      let accountUpdate = this._contract.instance.self;\n      stateAsFields.forEach((stateField, i) => {\n        let value = Provable.if(condition, stateField, Field(0));\n        ensureConsistentPrecondition(\n          accountUpdate.body.preconditions.account.state[layout.offset + i],\n          condition,\n          value,\n          this._contract?.key\n        );\n        let state = accountUpdate.body.preconditions.account.state[layout.offset + i];\n        state.isSome = condition;\n        state.value = value;\n      });\n      this._contract.wasConstrained = true;\n    },\n\n    requireNothing() {\n      if (this._contract === undefined)\n        throw Error(\n          'requireNothing can only be called when the State is assigned to a SmartContract @state.'\n        );\n      // TODO: this should ideally reset any previous precondition,\n      // by setting each relevant state field to { isSome: false, value: Field(0) }\n      this._contract.wasConstrained = true;\n    },\n\n    get() {\n      if (this._contract === undefined)\n        throw Error('get can only be called when the State is assigned to a SmartContract @state.');\n      // inside the circuit, we have to cache variables, so there's only one unique variable per on-chain state.\n      // if we'd return a fresh variable every time, developers could easily end up linking just *one* of them to the precondition,\n      // while using an unconstrained variable elsewhere, which would create a loophole in the proof.\n      if (\n        this._contract.cachedVariable !== undefined &&\n        // `inCheckedComputation() === true` here always implies being inside a wrapped smart contract method,\n        // which will ensure that the cache is cleaned up before & after each method run.\n        Provable.inCheckedComputation()\n      ) {\n        this._contract.wasRead = true;\n        return this._contract.cachedVariable;\n      }\n      let layout = getLayoutPosition(this._contract);\n      let contract = this._contract;\n      let inProver_ = Provable.inProver();\n      let stateFieldsType = Provable.Array(Field, layout.length);\n      let stateAsFields = Provable.witness(stateFieldsType, () => {\n        let account: Account;\n        try {\n          account = Mina.getAccount(contract.instance.address, contract.instance.self.body.tokenId);\n        } catch (err: any) {\n          // TODO: there should also be a reasonable error here\n          if (inProver_) {\n            throw err;\n          }\n          let message =\n            `${contract.key}.get() failed, either:\\n` +\n            `1. We can't find this zkapp account in the ledger\\n` +\n            `2. Because the zkapp account was not found in the cache. ` +\n            `Try calling \\`await fetchAccount(zkappAddress)\\` first.\\n` +\n            `If none of these are the case, then please reach out on Discord at #zkapp-developers and/or open an issue to tell us!`;\n          if (err.message) {\n            err.message = message + `\\n\\n${err.message}`;\n            throw err;\n          } else {\n            throw Error(message);\n          }\n        }\n        if (account.zkapp?.appState === undefined) {\n          // if the account is not a zkapp account, let the default state be all zeroes\n          return Array(layout.length).fill(Field(0));\n        } else {\n          let stateAsFields: Field[] = [];\n          for (let i = 0; i < layout.length; ++i) {\n            stateAsFields.push(account.zkapp.appState[layout.offset + i]);\n          }\n          return stateAsFields;\n        }\n      });\n\n      let state = this._contract.stateType.fromFields(stateAsFields);\n      if (Provable.inCheckedComputation()) this._contract.stateType.check?.(state);\n      this._contract.wasRead = true;\n      this._contract.cachedVariable = state;\n      return state;\n    },\n\n    getAndRequireEquals() {\n      let state = this.get();\n      this.requireEquals(state);\n      return state;\n    },\n\n    async fetch() {\n      if (this._contract === undefined)\n        throw Error(\n          'fetch can only be called when the State is assigned to a SmartContract @state.'\n        );\n\n      let layout = getLayoutPosition(this._contract);\n      let address: PublicKey = this._contract.instance.address;\n      let tokenId: Field = this._contract.instance.tokenId;\n      let account: Account | undefined;\n      if (networkConfig.minaEndpoint === '') {\n        account = Mina.getAccount(address, tokenId);\n      } else {\n        ({ account } = await fetchAccount({\n          publicKey: address,\n          tokenId: TokenId.toBase58(tokenId),\n        }));\n      }\n      if (account === undefined) return undefined;\n\n      let stateAsFields: Field[];\n      if (account.zkapp?.appState === undefined) {\n        stateAsFields = Array(layout.length).fill(Field(0));\n      } else {\n        stateAsFields = [];\n        for (let i = 0; i < layout.length; i++) {\n          stateAsFields.push(account.zkapp.appState[layout.offset + i]);\n        }\n      }\n      return this._contract.stateType.fromFields(stateAsFields);\n    },\n\n    fromAppState(appState: Field[]) {\n      if (this._contract === undefined)\n        throw Error(\n          'fromAppState() can only be called when the State is assigned to a SmartContract @state.'\n        );\n      let layout = getLayoutPosition(this._contract);\n      let stateAsFields: Field[] = [];\n      for (let i = 0; i < layout.length; ++i) {\n        stateAsFields.push(appState[layout.offset + i]);\n      }\n      return this._contract.stateType.fromFields(stateAsFields);\n    },\n  };\n}\n\nfunction getLayoutPosition<A>({ key, class: contractClass }: StateAttachedContract<A>) {\n  let layout = getLayout(contractClass);\n  let stateLayout = layout.get(key);\n  if (stateLayout === undefined) {\n    throw new Error(`state ${key} not found`);\n  }\n  return stateLayout;\n}\n\nfunction getLayout(scClass: typeof SmartContract) {\n  let sc = smartContracts.get(scClass);\n  if (sc === undefined) return new Map();\n  if (sc.layout === undefined) {\n    let layout = new Map();\n    sc.layout = layout;\n    let offset = 0;\n    sc.states.forEach(([key, stateType]) => {\n      let length = stateType.sizeInFields();\n      layout.set(key, { offset, length });\n      offset += length;\n    });\n    if (offset > 8) {\n      throw Error(\n        `Found ${offset} on-chain state field elements on ${scClass.name}. Currently, only a total of 8 field elements of state are supported.`\n      );\n    }\n  }\n  return sc.layout;\n}\n\n// per-smart contract class context for keeping track of state layout\nconst smartContracts = new WeakMap<\n  typeof SmartContract,\n  {\n    states: [string, ProvablePure<any>][];\n    layout: Map<string, { offset: number; length: number }> | undefined;\n  }\n>();\n\nconst reservedPropNames = new Set(['_methods', '_']);\n\nfunction assertStatePrecondition(sc: SmartContract) {\n  try {\n    for (let [key, context] of getStateContexts(sc)) {\n      // check if every state that was read was also constrained\n      if (!context?.wasRead || context.wasConstrained) continue;\n      // we accessed a precondition field but not constrained it explicitly - throw an error\n      let errorMessage = `You used \\`this.${key}.get()\\` without adding a precondition that links it to the actual on-chain state.\nConsider adding this line to your code:\nthis.${key}.requireEquals(this.${key}.get());`;\n      throw Error(errorMessage);\n    }\n  } finally {\n    cleanStatePrecondition(sc);\n  }\n}\n\nfunction cleanStatePrecondition(sc: SmartContract) {\n  for (let [, context] of getStateContexts(sc)) {\n    if (context === undefined) continue;\n    context.wasRead = false;\n    context.wasConstrained = false;\n    context.cachedVariable = undefined;\n  }\n}\n\nfunction getStateContexts(\n  sc: SmartContract\n): [string, StateAttachedContract<unknown> | undefined][] {\n  let scClass = sc.constructor as typeof SmartContract;\n  let scInfo = smartContracts.get(scClass);\n  if (scInfo === undefined) return [];\n  return scInfo.states.map(([key]) => [key, (sc as any)[key]?._contract]);\n}\n", "import 'reflect-metadata';\nimport { Gate, Pickles } from '../../../bindings.js';\nimport { Field, Bool } from '../../provable/wrapped.js';\nimport {\n  AccountUpdate,\n  Authorization,\n  Body,\n  Events,\n  Permissions,\n  TokenId,\n  ZkappCommand,\n  zkAppProver,\n  ZkappPublicInput,\n  LazyProof,\n  AccountUpdateForest,\n  AccountUpdateLayout,\n  AccountUpdateTree,\n} from './account-update.js';\nimport type { EventActionFilterOptions } from './graphql.js';\nimport {\n  cloneCircuitValue,\n  FlexibleProvablePure,\n  InferProvable,\n} from '../../provable/types/struct.js';\nimport { Provable, getBlindingValue, memoizationContext } from '../../provable/provable.js';\nimport * as Encoding from '../../../bindings/lib/encoding.js';\nimport {\n  HashInput,\n  Poseidon,\n  hashConstant,\n  isHashable,\n  packToFields,\n} from '../../provable/crypto/poseidon.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport * as Mina from './mina.js';\nimport { assertPreconditionInvariants, cleanPreconditionsCache } from './precondition.js';\nimport {\n  analyzeMethod,\n  compileProgram,\n  computeMaxProofsVerified,\n  Empty,\n  MethodInterface,\n  sortMethodArguments,\n} from '../../proof-system/zkprogram.js';\nimport { VerificationKey } from '../../proof-system/verification-key.js';\nimport { Proof, ProofClass } from '../../proof-system/proof.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport {\n  InternalStateType,\n  assertStatePrecondition,\n  cleanStatePrecondition,\n  getLayout,\n} from './state.js';\nimport {\n  inAnalyze,\n  inCheckedComputation,\n  inCompile,\n  inProver,\n} from '../../provable/core/provable-context.js';\nimport { Cache } from '../../proof-system/cache.js';\nimport { assert } from '../../provable/gadgets/common.js';\nimport { SmartContractBase } from './smart-contract-base.js';\nimport { ZkappStateLength } from './mina-instance.js';\nimport {\n  SmartContractContext,\n  accountUpdateLayout,\n  smartContractContext,\n} from './smart-contract-context.js';\nimport { assertPromise } from '../../util/assert.js';\nimport { ProvablePure, ProvableType } from '../../provable/types/provable-intf.js';\nimport { getReducer, Reducer } from './actions/reducer.js';\nimport { provable } from '../../provable/types/provable-derivers.js';\n\n// external API\nexport { SmartContract, method, DeployArgs, declareMethods };\n\nconst reservedPropNames = new Set(['_methods', '_']);\ntype AsyncFunction = (...args: any) => Promise<any>;\n\n/**\n * A decorator to use in a zkApp to mark a method as provable.\n * You can use inside your zkApp class as:\n *\n * ```\n * \\@method async myMethod(someArg: Field) {\n *   // your code here\n * }\n * ```\n *\n * To return a value from the method, you have to explicitly declare the return type using the {@link method.returns} decorator:\n * ```\n * \\@method.returns(Field)\n * async myMethod(someArg: Field): Promise<Field> {\n *   // your code here\n * }\n * ```\n */\nfunction method<K extends string, T extends SmartContract>(\n  target: T & {\n    [k in K]: (...args: any) => Promise<void>;\n  },\n  methodName: K & string & keyof T,\n  descriptor: PropertyDescriptor,\n  returnType?: Provable<any>\n) {\n  const ZkappClass = target.constructor as typeof SmartContract;\n  if (reservedPropNames.has(methodName)) {\n    throw Error(`Property name ${methodName} is reserved.`);\n  }\n  if (typeof target[methodName] !== 'function') {\n    throw Error(`@method decorator was applied to \\`${methodName}\\`, which is not a function.`);\n  }\n  let paramTypes: Provable<any>[] = Reflect.getMetadata('design:paramtypes', target, methodName);\n\n  class SelfProof extends Proof<ZkappPublicInput, Empty> {\n    static publicInputType = ZkappPublicInput;\n    static publicOutputType = Empty;\n    static tag = () => ZkappClass;\n  }\n  let internalMethodEntry = sortMethodArguments(\n    ZkappClass.name,\n    methodName,\n    paramTypes,\n    undefined,\n    SelfProof\n  );\n  // add witness arguments for the publicKey (address) and tokenId\n  let methodEntry = sortMethodArguments(\n    ZkappClass.name,\n    methodName,\n    [PublicKey, Field, ...paramTypes],\n    undefined,\n    SelfProof\n  );\n\n  if (returnType !== undefined) {\n    internalMethodEntry.returnType = returnType;\n    methodEntry.returnType = returnType;\n  }\n  ZkappClass._methods ??= [];\n  // FIXME: overriding a method implies pushing a separate method entry here, yielding two entries with the same name\n  // this should only be changed once we no longer share the _methods array with the parent class (otherwise a subclass declaration messes up the parent class)\n  ZkappClass._methods.push(methodEntry);\n  let func = descriptor.value as AsyncFunction;\n  descriptor.value = wrapMethod(func, ZkappClass, internalMethodEntry);\n}\n\n/**\n * A decorator to mark a zkApp method as provable, and declare its return type.\n *\n * ```\n * \\@method.returns(Field)\n * async myMethod(someArg: Field): Promise<Field> {\n *   // your code here\n * }\n * ```\n */\nmethod.returns = function <K extends string, T extends SmartContract, R extends ProvableType>(\n  returnType: R\n) {\n  return function decorateMethod(\n    target: T & {\n      [k in K]: (...args: any) => Promise<InferProvable<R>>;\n    },\n    methodName: K & string & keyof T,\n    descriptor: PropertyDescriptor\n  ) {\n    return method(target as any, methodName, descriptor, ProvableType.get(returnType));\n  };\n};\n\n// do different things when calling a method, depending on the circumstance\nfunction wrapMethod(\n  method: AsyncFunction,\n  ZkappClass: typeof SmartContract,\n  methodIntf: MethodInterface\n) {\n  let methodName = methodIntf.methodName;\n  let noPromiseError = `Expected \\`${ZkappClass.name}.${methodName}()\\` to return a promise.`;\n  return async function wrappedMethod(this: SmartContract, ...actualArgs: any[]) {\n    cleanStatePrecondition(this);\n    // special case: any AccountUpdate that is passed as an argument to a method\n    // is unlinked from its current location, to allow the method to link it to itself\n    actualArgs.forEach((arg) => {\n      if (arg instanceof AccountUpdate) {\n        AccountUpdate.unlink(arg);\n      }\n    });\n\n    let insideContract = smartContractContext.get();\n    if (!insideContract) {\n      const { id, context } = SmartContractContext.enter(this, selfAccountUpdate(this, methodName));\n      try {\n        if (inCompile() || inProver() || inAnalyze()) {\n          // important to run this with a fresh accountUpdate every time, otherwise compile messes up our circuits\n          // because it runs this multiple times\n          let proverData = inProver() ? zkAppProver.getData() : undefined;\n          let txId = Mina.currentTransaction.enter({\n            sender: proverData?.transaction.feePayer.body.publicKey,\n            // TODO could pass an update with the fee payer's content here? probably not bc it's not accessed\n            layout: new AccountUpdateLayout(),\n            fetchMode: inProver() ? 'cached' : 'test',\n            isFinalRunOutsideCircuit: false,\n            numberOfRuns: undefined,\n          });\n          try {\n            // inside prover / compile, the method is always called with the public input as first argument\n            // -- so we can add assertions about it\n            let publicInput = actualArgs.shift();\n            let accountUpdate = this.self;\n\n            // the blinding value is important because otherwise, putting callData on the transaction would leak information about the private inputs\n            let blindingValue = Provable.witness(Field, getBlindingValue);\n            // it's also good if we prove that we use the same blinding value across the method\n            // that's why we pass the variable (not the constant) into a new context\n            let memoCtx = memoizationContext() ?? {\n              memoized: [],\n              currentIndex: 0,\n            };\n            let id = memoizationContext.enter({ ...memoCtx, blindingValue });\n            let result: unknown;\n            try {\n              let clonedArgs = actualArgs.map(cloneCircuitValue);\n              result = await assertPromise(method.apply(this, clonedArgs), noPromiseError);\n            } finally {\n              memoizationContext.leave(id);\n            }\n\n            // connects our input + result with callData, so this method can be called\n            let callDataFields = computeCallData(methodIntf, actualArgs, result, blindingValue);\n            accountUpdate.body.callData = Poseidon.hash(callDataFields);\n            ProofAuthorization.setKind(accountUpdate);\n\n            debugPublicInput(accountUpdate);\n            let calls = context.selfLayout.finalizeChildren();\n            checkPublicInput(publicInput, accountUpdate, calls);\n\n            // check the self accountUpdate right after calling the method\n            // TODO: this needs to be done in a unified way for all account updates that are created\n            assertPreconditionInvariants(accountUpdate);\n            cleanPreconditionsCache(accountUpdate);\n            assertStatePrecondition(this);\n            return result;\n          } finally {\n            Mina.currentTransaction.leave(txId);\n          }\n        } else if (!Mina.currentTransaction.has()) {\n          // outside a transaction, just call the method, but check precondition invariants\n          let result = await assertPromise(method.apply(this, actualArgs), noPromiseError);\n          // check the self accountUpdate right after calling the method\n          // TODO: this needs to be done in a unified way for all account updates that are created\n          assertPreconditionInvariants(this.self);\n          cleanPreconditionsCache(this.self);\n          assertStatePrecondition(this);\n          return result;\n        } else {\n          // called smart contract at the top level, in a transaction!\n          // => attach ours to the current list of account updates\n          let accountUpdate = context.selfUpdate;\n\n          // first, clone to protect against the method modifying arguments!\n          // TODO: double-check that this works on all possible inputs, e.g. CircuitValue, o1js primitives\n          let clonedArgs = cloneCircuitValue(actualArgs);\n\n          // we run this in a \"memoization context\" so that we can remember witnesses for reuse when proving\n          let blindingValue = getBlindingValue();\n          let memoContext = { memoized: [], currentIndex: 0, blindingValue };\n          let memoId = memoizationContext.enter(memoContext);\n          let result: any;\n          try {\n            result = await assertPromise(\n              method.apply(\n                this,\n                actualArgs.map((a, i) => {\n                  return Provable.witness(methodIntf.args[i], () => a);\n                })\n              ),\n              noPromiseError\n            );\n          } finally {\n            memoizationContext.leave(memoId);\n          }\n          let { memoized } = memoContext;\n\n          assertStatePrecondition(this);\n\n          // connect our input + result with callData, so this method can be called\n          let callDataFields = computeCallData(methodIntf, clonedArgs, result, blindingValue);\n          accountUpdate.body.callData = Poseidon.hash(callDataFields);\n\n          if (!Authorization.hasAny(accountUpdate)) {\n            ProofAuthorization.setLazyProof(\n              accountUpdate,\n              {\n                methodName: methodIntf.methodName,\n                args: clonedArgs,\n                ZkappClass,\n                memoized,\n                blindingValue,\n              },\n              Mina.currentTransaction.get().layout\n            );\n          }\n\n          // transfer layout from the smart contract context to the transaction\n          if (inCheckedComputation()) {\n            Provable.asProver(() => {\n              accountUpdate = Provable.toConstant(AccountUpdate, accountUpdate);\n              context.selfLayout.toConstantInPlace();\n            });\n          }\n          let txLayout = Mina.currentTransaction.get().layout;\n          txLayout.pushTopLevel(accountUpdate);\n          txLayout.setChildren(accountUpdate, context.selfLayout.finalizeChildren());\n\n          return result;\n        }\n      } finally {\n        smartContractContext.leave(id);\n      }\n    }\n\n    // if we're here, this method was called inside _another_ smart contract method\n    let parentAccountUpdate = insideContract.this.self;\n\n    let { id, context: innerContext } = SmartContractContext.enter(\n      this,\n      selfAccountUpdate(this, methodName)\n    );\n    try {\n      // we just reuse the blinding value of the caller for the callee\n      let blindingValue = getBlindingValue();\n\n      let runCalledContract = async () => {\n        let constantArgs = methodIntf.args.map((type, i) =>\n          Provable.toConstant(type, actualArgs[i])\n        );\n        let constantBlindingValue = blindingValue.toConstant();\n        let accountUpdate = this.self;\n        accountUpdate.body.callDepth = parentAccountUpdate.body.callDepth + 1;\n\n        let memoContext = {\n          memoized: [],\n          currentIndex: 0,\n          blindingValue: constantBlindingValue,\n        };\n        let memoId = memoizationContext.enter(memoContext);\n        let result: any;\n        try {\n          result = await assertPromise(\n            method.apply(this, constantArgs.map(cloneCircuitValue)),\n            noPromiseError\n          );\n        } finally {\n          memoizationContext.leave(memoId);\n        }\n        let { memoized } = memoContext;\n        assertStatePrecondition(this);\n\n        if (result !== undefined) {\n          let { returnType } = methodIntf;\n          assert(\n            returnType !== undefined,\n            \"Bug: returnType is undefined but the method result isn't.\"\n          );\n          result = Provable.toConstant(returnType, result);\n        }\n\n        // store inputs + result in callData\n        let callDataFields = computeCallData(\n          methodIntf,\n          constantArgs,\n          result,\n          constantBlindingValue\n        );\n        accountUpdate.body.callData = hashConstant(callDataFields);\n\n        if (!Authorization.hasAny(accountUpdate)) {\n          ProofAuthorization.setLazyProof(\n            accountUpdate,\n            {\n              methodName: methodIntf.methodName,\n              args: constantArgs,\n              ZkappClass,\n              memoized,\n              blindingValue: constantBlindingValue,\n            },\n            Mina.currentTransaction()?.layout ?? new AccountUpdateLayout()\n          );\n        }\n        // extract callee's account update layout\n        let children = innerContext.selfLayout.finalizeChildren();\n\n        return {\n          accountUpdate,\n          result: { result: result ?? null, children },\n        };\n      };\n\n      // we have to run the called contract inside a witness block, to not affect the caller's circuit\n      let {\n        accountUpdate,\n        result: { result, children },\n      } = await AccountUpdate.witness<{\n        result: any;\n        children: AccountUpdateForest;\n      }>(\n        provable({\n          result: methodIntf.returnType ?? provable(null),\n          children: AccountUpdateForest,\n        }),\n        runCalledContract,\n        { skipCheck: true }\n      );\n\n      // we're back in the _caller's_ circuit now, where we assert stuff about the method call\n\n      // overwrite this.self with the witnessed update, so it's this one we access later in the caller method\n      innerContext.selfUpdate = accountUpdate;\n\n      // connect accountUpdate to our own. outside Provable.witness so compile knows the right structure when hashing children\n      accountUpdate.body.callDepth = parentAccountUpdate.body.callDepth + 1;\n\n      insideContract.selfLayout.pushTopLevel(accountUpdate);\n      insideContract.selfLayout.setChildren(accountUpdate, children);\n\n      // assert that we really called the right zkapp\n      accountUpdate.body.publicKey.assertEquals(this.address);\n      accountUpdate.body.tokenId.assertEquals(this.self.body.tokenId);\n\n      // assert that the callee account update has proof authorization. everything else would have much worse security trade-offs,\n      // because a one-time change of the callee semantics by using a signature could go unnoticed even if we monitor the callee's\n      // onchain verification key\n      assert(accountUpdate.body.authorizationKind.isProved, 'callee is proved');\n\n      // assert that the inputs & outputs we have match what the callee put on its callData\n      let callDataFields = computeCallData(methodIntf, actualArgs, result, blindingValue);\n      let callData = Poseidon.hash(callDataFields);\n      accountUpdate.body.callData.assertEquals(callData);\n      return result;\n    } finally {\n      smartContractContext.leave(id);\n    }\n  };\n}\n\nfunction checkPublicInput(\n  { accountUpdate, calls }: ZkappPublicInput,\n  self: AccountUpdate,\n  selfCalls: AccountUpdateForest\n) {\n  accountUpdate.assertEquals(self.hash());\n  calls.assertEquals(selfCalls.hash);\n}\n\n/**\n * compute fields to be hashed as callData, in a way that the hash & circuit changes whenever\n * the method signature changes, i.e., the argument / return types represented as lists of field elements and the methodName.\n * see https://github.com/o1-labs/o1js/issues/303#issuecomment-1196441140\n */\nfunction computeCallData(\n  methodIntf: MethodInterface,\n  argumentValues: any[],\n  returnValue: any,\n  blindingValue: Field\n) {\n  let { returnType, methodName } = methodIntf;\n  let args = methodIntf.args.map((type, i) => {\n    return { type: ProvableType.get(type), value: argumentValues[i] };\n  });\n\n  let input: HashInput = { fields: [], packed: [] };\n  for (let { type, value } of args) {\n    if (isHashable(type)) {\n      input = HashInput.append(input, type.toInput(value));\n    } else {\n      input.fields!.push(Field(type.sizeInFields()), ...type.toFields(value));\n    }\n  }\n  const totalArgFields = packToFields(input);\n  let totalArgSize = Field(args.map(({ type }) => type.sizeInFields()).reduce((s, t) => s + t, 0));\n\n  let returnSize = Field(returnType?.sizeInFields() ?? 0);\n  input = { fields: [], packed: [] };\n  if (isHashable(returnType)) {\n    input = HashInput.append(input, returnType.toInput(returnValue));\n  } else {\n    input.fields!.push(...(returnType?.toFields(returnValue) ?? []));\n  }\n  let returnFields = packToFields(input);\n  let methodNameFields = Encoding.stringToFields(methodName);\n  return [\n    // we have to encode the sizes of arguments / return value, so that fields can't accidentally shift\n    // from one argument to another, or from arguments to the return value, or from the return value to the method name\n    totalArgSize,\n    ...totalArgFields,\n    returnSize,\n    ...returnFields,\n    // we don't have to encode the method name size because the blinding value is fixed to one field element,\n    // so method name fields can't accidentally become the blinding value and vice versa\n    ...methodNameFields,\n    blindingValue,\n  ];\n}\n\n/**\n * The main zkapp class. To write a zkapp, extend this class as such:\n *\n * ```\n * class YourSmartContract extends SmartContract {\n *   // your smart contract code here\n * }\n * ```\n *\n */\nclass SmartContract extends SmartContractBase {\n  address: PublicKey;\n  tokenId: Field;\n\n  #executionState: ExecutionState | undefined;\n\n  // here we store various metadata associated with a SmartContract subclass.\n  // by initializing all of these to `undefined`, we ensure that\n  // subclasses aren't sharing the same property with the base class and each other\n  // FIXME: these are still shared between a subclass and its own subclasses, which means extending SmartContracts is broken\n  static _methods?: MethodInterface[];\n  static _methodMetadata?: Record<\n    string,\n    {\n      actions: number;\n      rows: number;\n      digest: string;\n      gates: Gate[];\n      proofs: ProofClass[];\n    }\n  >; // keyed by method name\n  static _provers?: Pickles.Prover[];\n  static _verificationKey?: { data: string; hash: Field };\n\n  /**\n   * Returns a Proof type that belongs to this {@link SmartContract}.\n   */\n  static Proof() {\n    let Contract = this;\n    return class extends Proof<ZkappPublicInput, Empty> {\n      static publicInputType = ZkappPublicInput;\n      static publicOutputType = Empty;\n      static tag = () => Contract;\n    };\n  }\n\n  constructor(address: PublicKey, tokenId?: Field) {\n    super();\n    this.address = address;\n    this.tokenId = tokenId ?? TokenId.default;\n    Object.defineProperty(this, 'reducer', {\n      set(this, reducer: Reducer<any>) {\n        ((this as any)._ ??= {}).reducer = reducer;\n      },\n      get(this) {\n        return getReducer(this);\n      },\n    });\n  }\n\n  /**\n   * Compile your smart contract.\n   *\n   * This generates both the prover functions, needed to create proofs for running `@method`s,\n   * and the verification key, needed to deploy your zkApp.\n   *\n   * Although provers and verification key are returned by this method, they are also cached internally and used when needed,\n   * so you don't actually have to use the return value of this function.\n   *\n   * Under the hood, \"compiling\" means calling into the lower-level [Pickles and Kimchi libraries](https://o1-labs.github.io/proof-systems/kimchi/overview.html) to\n   * create multiple prover & verifier indices (one for each smart contract method as part of a \"step circuit\" and one for the \"wrap circuit\" which recursively wraps\n   * it so that proofs end up in the original finite field). These are fairly expensive operations, so **expect compiling to take at least 20 seconds**,\n   * up to several minutes if your circuit is large or your hardware is not optimal for these operations.\n   */\n  static async compile({ cache = Cache.FileSystemDefault, forceRecompile = false } = {}) {\n    let methodIntfs = this._methods ?? [];\n    let methodKeys = methodIntfs.map(({ methodName }) => methodName);\n    let methods = methodIntfs.map(({ methodName }) => {\n      return async (\n        publicInput: unknown,\n        publicKey: PublicKey,\n        tokenId: Field,\n        ...args: unknown[]\n      ) => {\n        let instance = new this(publicKey, tokenId);\n        await (instance as any)[methodName](publicInput, ...args);\n      };\n    });\n    // run methods once to get information that we need already at compile time\n    let methodsMeta = await this.analyzeMethods();\n    let gates = methodKeys.map((k) => methodsMeta[k].gates);\n    let proofs = methodKeys.map((k) => methodsMeta[k].proofs);\n    let { verificationKey, provers, verify } = await compileProgram({\n      publicInputType: ZkappPublicInput,\n      publicOutputType: Empty,\n      methodIntfs,\n      methods,\n      gates,\n      proofs,\n      proofSystemTag: this,\n      cache,\n      forceRecompile,\n    });\n    this._provers = provers;\n    this._verificationKey = verificationKey;\n    // TODO: instead of returning provers, return an artifact from which provers can be recovered\n    return { verificationKey, provers, verify };\n  }\n\n  /**\n   * Computes a hash of your smart contract, which will reliably change _whenever one of your method circuits changes_.\n   * This digest is quick to compute. it is designed to help with deciding whether a contract should be re-compiled or\n   * a cached verification key can be used.\n   * @returns the digest, as a hex string\n   */\n  static async digest() {\n    // TODO: this should use the method digests in a deterministic order!\n    let methodData = await this.analyzeMethods();\n    let hash = hashConstant(Object.values(methodData).map((d) => Field(BigInt('0x' + d.digest))));\n    return hash.toBigInt().toString(16);\n  }\n\n  /**\n   * The maximum number of proofs that are verified by any of the zkApp methods.\n   * This is an internal parameter needed by the proof system.\n   */\n  static async getMaxProofsVerified() {\n    let methodData = await this.analyzeMethods();\n    return computeMaxProofsVerified(Object.values(methodData).map((d) => d.proofs.length));\n  }\n\n  /**\n   * Manually set the verification key.\n   */\n  static setVerificationKeyUnsafe(verificationKey: { data: string; hash: Field | string }) {\n    SmartContract._verificationKey = {\n      data: verificationKey.data,\n      hash: Field.from(verificationKey.hash),\n    };\n  }\n\n  /**\n   * Deploys a {@link SmartContract}.\n   *\n   * ```ts\n   * let tx = await Mina.transaction(sender, async () => {\n   *   AccountUpdate.fundNewAccount(sender);\n   *   await zkapp.deploy();\n   * });\n   * tx.sign([senderKey, zkAppKey]);\n   * ```\n   */\n  async deploy({\n    verificationKey,\n  }: {\n    verificationKey?: { data: string; hash: Field | string };\n  } = {}) {\n    let accountUpdate = this.newSelf('deploy');\n    verificationKey ??= (this.constructor as typeof SmartContract)._verificationKey;\n    if (verificationKey === undefined) {\n      if (!Mina.getProofsEnabled()) {\n        verificationKey = await VerificationKey.dummy();\n      } else {\n        throw Error(\n          `\\`${this.constructor.name}.deploy()\\` was called but no verification key was found.\\n` +\n            `Try calling \\`await ${this.constructor.name}.compile()\\` first, this will cache the verification key in the background.`\n        );\n      }\n    }\n    let { hash: hash_, data } = verificationKey;\n    let hash = Field.from(hash_);\n    accountUpdate.account.verificationKey.set({ hash, data });\n    accountUpdate.account.permissions.set(Permissions.default());\n    accountUpdate.requireSignature();\n    AccountUpdate.attachToTransaction(accountUpdate);\n\n    // init if this account is not yet deployed or has no verification key on it\n    let shouldInit =\n      !Mina.hasAccount(this.address) ||\n      Mina.getAccount(this.address).zkapp?.verificationKey === undefined;\n    if (!shouldInit) return;\n    else await this.init();\n    let initUpdate = this.self;\n    // switch back to the deploy account update so the user can make modifications to it\n    this.#executionState = {\n      transactionId: this.#executionState!.transactionId,\n      accountUpdate,\n    };\n    // check if the entire state was overwritten, show a warning if not\n    let isFirstRun = Mina.currentTransaction()?.numberOfRuns === 0;\n    if (!isFirstRun) return;\n    Provable.asProver(() => {\n      if (initUpdate.update.appState.some(({ isSome }) => !isSome.toBoolean())) {\n        console.warn(\n          `WARNING: the \\`init()\\` method was called without overwriting the entire state. This means that your zkApp will lack\nthe \\`provedState === true\\` status which certifies that the current state was verifiably produced by proofs (and not arbitrarily set by the zkApp developer).\nTo make sure the entire state is reset, consider adding this line to the beginning of your \\`init()\\` method:\nsuper.init();\n`\n        );\n      }\n    });\n  }\n  /**\n   * `SmartContract.init()` is called when a {@link SmartContract} is first deployed.\n   * By default, it initializes the smart contract's state to zero, and sets the\n   * `provedState` to `false`.\n   *\n   * @note The first time any {@link method} is called on the smart contract, `provedState`\n   * will be set to `true`.  The `init` method itself may be decorated with `@method`\n   * in this way.  Review the examples below to see how init can be called with or\n   * without a method decorator.\n   *\n   * @note `init` may be overridden to set state fields to values other than zero, but the\n   * method takes no arguments.  Therefore, only static values may be set.\n   *\n   * @note To initialize a smart contract with custom values provided as arguments, a separate\n   * method is required.\n   *\n   * @example\n   * ```ts\n   * class MyContract extends SmartContract {\n   *  @state(Field) x = State<Field>();\n   *\n   *  // Overwrite init to set static, non-zero values\n   *  init() {\n   *   super.init();\n   *   this.x.set(Field(1));\n   *  }\n   *\n   *  // Use custom method to initialize dynamic values\n   *  @method async initialize(x: Field) {\n   *    // This method may only be called once, immediately after deployment\n   *    this.account.provedState.getAndRequireEquals().assertFalse();\n   *\n   *    this.x.set(x);\n   *  }\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * class MyContract extends SmartContract {\n   *  @state(Field) x = State<Field>();\n   *\n   *  // Use init as a @method to set state fields to zero, and also\n   *  // set provedState to true, making any other initialization impossible.\n   *  @method async init() {\n   *    super.init();\n   *    this.x.set(Field(1));\n   *  }\n   *\n   *  // This method is invalid because `init` is a `@method`\n   *  @method async initialize(x: Field) {\n   *    // This assertion will fail because `provedState` is true after `init` is called\n   *    this.account.provedState.getAndRequireEquals().assertFalse();\n   *\n   *    this.x.set(x);\n   *  }\n   * }\n   * ```\n   */\n  init() {\n    // let accountUpdate = this.newSelf(); // this would emulate the behaviour of init() being a @method\n    this.account.provedState.requireEquals(Bool(false));\n    let accountUpdate = this.self;\n\n    // set all state fields to 0\n    for (let i = 0; i < ZkappStateLength; i++) {\n      AccountUpdate.setValue(accountUpdate.body.update.appState[i], Field(0));\n    }\n\n    // for all explicitly declared states, set them to their default value\n    let stateKeys = getLayout(this.constructor as typeof SmartContract).keys();\n    for (let key of stateKeys) {\n      let state = this[key as keyof this] as InternalStateType<any> | undefined;\n      if (state !== undefined && state.defaultValue !== undefined) {\n        state.set(state.defaultValue);\n      }\n    }\n\n    AccountUpdate.attachToTransaction(accountUpdate);\n  }\n\n  /**\n   * Use this command if the account update created by this SmartContract should be signed by the account owner,\n   * instead of authorized with a proof.\n   *\n   * Note that the smart contract's {@link Permissions} determine which updates have to be (can be) authorized by a signature.\n   *\n   * If you only want to avoid creating proofs for quicker testing, we advise you to\n   * use `LocalBlockchain({ proofsEnabled: false })` instead of `requireSignature()`. Setting\n   * `proofsEnabled` to `false` allows you to test your transactions with the same authorization flow as in production,\n   * with the only difference being that quick mock proofs are filled in instead of real proofs.\n   */\n  requireSignature() {\n    this.self.requireSignature();\n  }\n\n  /**\n   * Use this command if the account update created by this SmartContract should have no authorization on it,\n   * instead of being authorized with a proof.\n   *\n   * WARNING: This is a method that should rarely be useful. If you want to disable proofs for quicker testing, take a look\n   * at `LocalBlockchain({ proofsEnabled: false })`, which causes mock proofs to be created and doesn't require changing the\n   * authorization flow.\n   */\n  skipAuthorization() {\n    Authorization.setLazyNone(this.self);\n  }\n\n  /**\n   * Returns the current {@link AccountUpdate} associated to this {@link SmartContract}.\n   */\n  get self(): AccountUpdate {\n    let inTransaction = Mina.currentTransaction.has();\n    let inSmartContract = smartContractContext.get();\n    if (!inTransaction && !inSmartContract) {\n      // TODO: it's inefficient to return a fresh account update every time, would be better to return a constant \"non-writable\" account update,\n      // or even expose the .get() methods independently of any account update (they don't need one)\n      return selfAccountUpdate(this);\n    }\n    let transactionId = inTransaction ? Mina.currentTransaction.id() : NaN;\n    // running a method changes which is the \"current account update\" of this smart contract\n    // this logic also implies that when calling `this.self` inside a method on `this`, it will always\n    // return the same account update uniquely associated with that method call.\n    // it won't create new updates and add them to a transaction implicitly\n    if (inSmartContract && inSmartContract.this === this) {\n      let accountUpdate = inSmartContract.selfUpdate;\n      this.#executionState = { accountUpdate, transactionId };\n      return accountUpdate;\n    }\n    let executionState = this.#executionState;\n    if (executionState !== undefined && executionState.transactionId === transactionId) {\n      return executionState.accountUpdate;\n    }\n    // if in a transaction, but outside a @method call, we implicitly create an account update\n    // which is stable during the current transaction -- as long as it doesn't get overridden by a method call\n    let accountUpdate = selfAccountUpdate(this);\n    this.#executionState = { transactionId, accountUpdate };\n    return accountUpdate;\n  }\n\n  /**\n   * Same as `SmartContract.self` but explicitly creates a new {@link AccountUpdate}.\n   */\n  newSelf(methodName?: string): AccountUpdate {\n    let inTransaction = Mina.currentTransaction.has();\n    let transactionId = inTransaction ? Mina.currentTransaction.id() : NaN;\n    let accountUpdate = selfAccountUpdate(this, methodName);\n    this.#executionState = { transactionId, accountUpdate };\n    return accountUpdate;\n  }\n\n  #_senderState: { sender: PublicKey; transactionId: number };\n\n  sender = {\n    self: this as SmartContract,\n\n    /**\n     * The public key of the current transaction's sender account.\n     *\n     * Throws an error if not inside a transaction, or the sender wasn't passed in.\n     *\n     * **Warning**: The fact that this public key equals the current sender is not part of the proof.\n     * A malicious prover could use any other public key without affecting the validity of the proof.\n     *\n     * Consider using `this.sender.getAndRequireSignature()` if you need to prove that the sender controls this account.\n     */\n    getUnconstrained(): PublicKey {\n      // TODO this logic now has some overlap with this.self, we should combine them somehow\n      // (but with care since the logic in this.self is a bit more complicated)\n      if (!Mina.currentTransaction.has()) {\n        throw Error(\n          `this.sender is not available outside a transaction. Make sure you only use it within \\`Mina.transaction\\` blocks or smart contract methods.`\n        );\n      }\n      let transactionId = Mina.currentTransaction.id();\n      let sender;\n      if (this.self.#_senderState?.transactionId === transactionId) {\n        sender = this.self.#_senderState.sender;\n      } else {\n        sender = Provable.witness(PublicKey, () => Mina.sender());\n        this.self.#_senderState = { transactionId, sender };\n      }\n\n      // we prove that the returned public key is not the empty key, in which case\n      // `createSigned()` would skip adding the account update, and nothing is proved\n      sender.x.assertNotEquals(0);\n      return sender;\n    },\n\n    /**\n     * Return a public key that is forced to sign this transaction.\n     *\n     * Note: This doesn't prove that the return value is the transaction sender, but it proves that whoever created\n     * the transaction controls the private key associated with the returned public key.\n     */\n    getAndRequireSignature(): PublicKey {\n      let sender = this.getUnconstrained();\n      AccountUpdate.createSigned(sender);\n      return sender;\n    },\n  };\n\n  /**\n   * Current account of the {@link SmartContract}.\n   */\n  get account() {\n    return this.self.account;\n  }\n  /**\n   * Current network state of the {@link SmartContract}.\n   */\n  get network() {\n    return this.self.network;\n  }\n  /**\n   * Current global slot on the network. This is the slot at which this transaction is included in a block. Since we cannot know this value\n   * at the time of transaction construction, this only has the `assertBetween()` method but no `get()` (impossible to implement)\n   * or `assertEquals()` (confusing, because the developer can't know the exact slot at which this will be included either)\n   */\n  get currentSlot() {\n    return this.self.currentSlot;\n  }\n\n  /**\n   * Approve an account update or tree / forest of updates. Doing this means you include the account update in the zkApp's public input,\n   * which allows you to read and use its content in a proof, make assertions about it, and modify it.\n   *\n   * ```ts\n   * `@method` myApprovingMethod(update: AccountUpdate) {\n   *   this.approve(update);\n   *\n   *   // read balance on the account (for example)\n   *   let balance = update.account.balance.getAndRequireEquals();\n   * }\n   * ```\n   *\n   * Under the hood, \"approving\" just means that the account update is made a child of the zkApp in the\n   * tree of account updates that forms the transaction. Similarly, if you pass in an {@link AccountUpdateTree},\n   * the entire tree will become a subtree of the zkApp's account update.\n   *\n   * Passing in a forest is a bit different, because it means you set the entire children of the zkApp's account update\n   * at once. `approve()` will fail if the zkApp's account update already has children, to prevent you from accidentally\n   * excluding important information from the public input.\n   */\n  approve(update: AccountUpdate | AccountUpdateTree | AccountUpdateForest) {\n    this.self.approve(update);\n  }\n\n  send(args: { to: PublicKey | AccountUpdate | SmartContract; amount: number | bigint | UInt64 }) {\n    return this.self.send(args);\n  }\n\n  /**\n   * Balance of this {@link SmartContract}.\n   */\n  get balance() {\n    return this.self.balance;\n  }\n  /**\n   * A list of event types that can be emitted using this.emitEvent()`.\n   */\n  events: { [key: string]: FlexibleProvablePure<any> } = {};\n\n  // TODO: not able to type event such that it is inferred correctly so far\n  /**\n   * Conditionally emits an event.\n   *\n   * Events will be emitted as a part of the transaction and can be collected by archive nodes.\n   */\n  emitEventIf<K extends keyof this['events']>(condition: Bool, type: K, event: any) {\n    let accountUpdate = this.self;\n    let eventTypes: (keyof this['events'])[] = Object.keys(this.events);\n    if (eventTypes.length === 0)\n      throw Error(\n        'emitEvent: You are trying to emit an event without having declared the types of your events.\\n' +\n          `Make sure to add a property \\`events\\` on ${this.constructor.name}, for example: \\n` +\n          `class ${this.constructor.name} extends SmartContract {\\n` +\n          `  events = { 'my-event': Field }\\n` +\n          `}`\n      );\n    let eventNumber = eventTypes.sort().indexOf(type as string);\n    if (eventNumber === -1)\n      throw Error(\n        `emitEvent: Unknown event type \"${\n          type as string\n        }\". The declared event types are: ${eventTypes.join(', ')}.`\n      );\n    let eventType = (this.events as this['events'])[type];\n    let eventFields: Field[];\n    if (eventTypes.length === 1) {\n      // if there is just one event type, just store it directly as field elements\n      eventFields = eventType.toFields(event);\n    } else {\n      // if there is more than one event type, also store its index, like in an enum, to identify the type later\n      eventFields = [Field(eventNumber), ...eventType.toFields(event)];\n    }\n    let newEvents = Events.pushEvent(accountUpdate.body.events, eventFields);\n    accountUpdate.body.events = Provable.if(\n      condition,\n      Events,\n      newEvents,\n      accountUpdate.body.events\n    );\n  }\n\n  /**\n   * Emits an event. Events will be emitted as a part of the transaction and can be collected by archive nodes.\n   */\n  emitEvent<K extends keyof this['events']>(type: K, event: any) {\n    this.emitEventIf(Bool(true), type, event);\n  }\n\n  /**\n   * Asynchronously fetches events emitted by this {@link SmartContract} and returns an array of events with their corresponding types.\n   * @param [start=UInt32.from(0)] - The start height of the events to fetch.\n   * @param end - The end height of the events to fetch. If not provided, fetches events up to the latest height.\n   * @returns A promise that resolves to an array of objects, each containing the event type and event data for the specified range.\n   * @throws If there is an error fetching events from the Mina network.\n   * @example\n   * const startHeight = UInt32.from(1000);\n   * const endHeight = UInt32.from(2000);\n   * const events = await myZkapp.fetchEvents(startHeight, endHeight);\n   * console.log(events);\n   */\n  async fetchEvents(\n    start: UInt32 = UInt32.from(0),\n    end?: UInt32\n  ): Promise<\n    {\n      type: string;\n      event: {\n        data: ProvablePure<any>;\n        transactionInfo: {\n          transactionHash: string;\n          transactionStatus: string;\n          transactionMemo: string;\n        };\n      };\n      blockHeight: UInt32;\n      blockHash: string;\n      parentBlockHash: string;\n      globalSlot: UInt32;\n      chainStatus: string;\n    }[]\n  > {\n    // used to match field values back to their original type\n    const sortedEventTypes = Object.keys(this.events).sort();\n    if (sortedEventTypes.length === 0) {\n      throw Error(\n        'fetchEvents: You are trying to fetch events without having declared the types of your events.\\n' +\n          `Make sure to add a property \\`events\\` on ${this.constructor.name}, for example: \\n` +\n          `class ${this.constructor.name} extends SmartContract {\\n` +\n          `  events = { 'my-event': Field }\\n` +\n          `}\\n` +\n          `Or, if you want to access the events from the zkapp account ${this.address.toBase58()} without casting their types\\n` +\n          `then try Mina.fetchEvents('${this.address.toBase58()}') instead.`\n      );\n    }\n\n    const queryFilterOptions: EventActionFilterOptions = {};\n    if (start.greaterThan(UInt32.from(0)).toBoolean()) {\n      queryFilterOptions.from = start;\n    }\n    if (end) {\n      queryFilterOptions.to = end;\n    }\n    // filters all elements so that they are within the given range\n    // only returns { type: \"\", event: [] } in a flat format\n    let events = (await Mina.fetchEvents(this.address, this.self.body.tokenId, queryFilterOptions))\n      .map((event) => {\n        return event.events.map((eventData) => {\n          let { events: _events, ...rest } = event;\n          return {\n            ...rest,\n            event: eventData,\n          };\n        });\n      })\n      .flat();\n\n    return events.map((eventData) => {\n      // if there is only one event type, the event structure has no index and can directly be matched to the event type\n      if (sortedEventTypes.length === 1) {\n        let type = sortedEventTypes[0];\n        let event = this.events[type].fromFields(eventData.event.data.map((f: string) => Field(f)));\n        return {\n          ...eventData,\n          type,\n          event: {\n            data: event,\n            transactionInfo: {\n              transactionHash: eventData.event.transactionInfo.hash,\n              transactionStatus: eventData.event.transactionInfo.status,\n              transactionMemo: eventData.event.transactionInfo.memo,\n            },\n          },\n        };\n      } else {\n        // if there are multiple events we have to use the index event[0] to find the exact event type\n        let eventObjectIndex = Number(eventData.event.data[0]);\n        let type = sortedEventTypes[eventObjectIndex];\n        // all other elements of the array are values used to construct the original object, we can drop the first value since its just an index\n        let eventProps = eventData.event.data.slice(1);\n        let event = this.events[type].fromFields(eventProps.map((f: string) => Field(f)));\n        return {\n          ...eventData,\n          type,\n          event: {\n            data: event,\n            transactionInfo: {\n              transactionHash: eventData.event.transactionInfo.hash,\n              transactionStatus: eventData.event.transactionInfo.status,\n              transactionMemo: eventData.event.transactionInfo.memo,\n            },\n          },\n        };\n      }\n    });\n  }\n\n  static runOutsideCircuit(run: () => void) {\n    if (Mina.currentTransaction()?.isFinalRunOutsideCircuit || inProver()) Provable.asProver(run);\n  }\n\n  // TODO: this could also be used to quickly perform any invariant checks on account updates construction\n  /**\n   * This function is run internally before compiling a smart contract, to collect metadata about what each of your\n   * smart contract methods does.\n   *\n   * For external usage, this function can be handy because calling it involves running all methods in the same \"mode\" as `compile()` does,\n   * so it serves as a quick-to-run check for whether your contract can be compiled without errors, which can greatly speed up iterating.\n   *\n   * `analyzeMethods()` will also return the number of `rows` of each of your method circuits (i.e., the number of constraints in the underlying proof system),\n   * which is a good indicator for circuit size and the time it will take to create proofs.\n   * To inspect the created circuit in detail, you can look at the returned `gates`.\n   *\n   * Note: If this function was already called before, it will short-circuit and just return the metadata collected the first time.\n   *\n   * @returns an object, keyed by method name, each entry containing:\n   *  - `rows` the size of the constraint system created by this method\n   *  - `digest` a digest of the method circuit\n   *  - `actions` the number of actions the method dispatches\n   *  - `gates` the constraint system, represented as an array of gates\n   */\n  static async analyzeMethods({ printSummary = false } = {}) {\n    let ZkappClass = this as typeof SmartContract;\n    let methodMetadata = (ZkappClass._methodMetadata ??= {});\n    let methodIntfs = ZkappClass._methods ?? [];\n    if (!methodIntfs.every((m) => m.methodName in methodMetadata) && !inAnalyze()) {\n      let id: number;\n      let insideSmartContract = !!smartContractContext.get();\n      if (insideSmartContract) id = smartContractContext.enter(null);\n      try {\n        for (let methodIntf of methodIntfs) {\n          let accountUpdate: AccountUpdate;\n          let { rows, digest, gates, summary, proofs } = await analyzeMethod(\n            ZkappPublicInput,\n            methodIntf,\n            async (publicInput, publicKey, tokenId, ...args) => {\n              let instance: SmartContract = new ZkappClass(publicKey, tokenId);\n              let result = await (instance as any)[methodIntf.methodName](publicInput, ...args);\n              accountUpdate = instance.#executionState!.accountUpdate;\n              return result;\n            }\n          );\n          methodMetadata[methodIntf.methodName] = {\n            actions: accountUpdate!.body.actions.data.length,\n            rows,\n            digest,\n            gates,\n            proofs,\n          };\n          if (printSummary) console.log(methodIntf.methodName, summary());\n        }\n      } finally {\n        if (insideSmartContract) smartContractContext.leave(id!);\n      }\n    }\n    return methodMetadata;\n  }\n}\n\nfunction selfAccountUpdate(zkapp: SmartContract, methodName?: string) {\n  let body = Body.keepAll(zkapp.address, zkapp.tokenId);\n  let update = new (AccountUpdate as any)(body, {}, true) as AccountUpdate;\n  update.label = methodName\n    ? `${zkapp.constructor.name}.${methodName}()`\n    : `${zkapp.constructor.name}, no method`;\n  return update;\n}\n\n// per-smart-contract context for transaction construction\ntype ExecutionState = {\n  transactionId: number;\n  accountUpdate: AccountUpdate;\n};\n\nconst SmartContractContext = {\n  enter(self: SmartContract, selfUpdate: AccountUpdate) {\n    let context: SmartContractContext = {\n      this: self,\n      selfUpdate,\n      selfLayout: new AccountUpdateLayout(selfUpdate),\n    };\n    let id = smartContractContext.enter(context);\n    return { id, context };\n  },\n};\n\ntype DeployArgs = { verificationKey?: { data: string; hash: string | Field } } | undefined;\n\n// alternative API which can replace decorators, works in pure JS\n\n/**\n * `declareMethods` can be used in place of the `@method` decorator\n * to declare SmartContract methods along with their list of arguments.\n * It should be placed _after_ the class declaration.\n * Here is an example of declaring a method `update`, which takes a single argument of type `Field`:\n * ```ts\n * class MyContract extends SmartContract {\n *   // ...\n *   update(x: Field) {\n *     // ...\n *   }\n * }\n * declareMethods(MyContract, { update: [Field] }); // `[Field]` is the list of arguments!\n * ```\n * Note that a method of the same name must still be defined on the class, just without the decorator.\n */\nfunction declareMethods<T extends typeof SmartContract>(\n  SmartContract: T,\n  methodArguments: Record<string, Provable<unknown>[]>\n) {\n  for (let key in methodArguments) {\n    let argumentTypes = methodArguments[key];\n    let target = SmartContract.prototype;\n    Reflect.metadata('design:paramtypes', argumentTypes)(target, key);\n    let descriptor = Object.getOwnPropertyDescriptor(target, key)!;\n    method(SmartContract.prototype as any, key as any, descriptor);\n    Object.defineProperty(target, key, descriptor);\n  }\n}\n\nconst ProofAuthorization = {\n  setKind({ body, id }: AccountUpdate, priorAccountUpdates?: AccountUpdateLayout) {\n    body.authorizationKind.isSigned = Bool(false);\n    body.authorizationKind.isProved = Bool(true);\n    let hash = Provable.witness(Field, () => {\n      let proverData = zkAppProver.getData();\n      let isProver = proverData !== undefined;\n      assert(\n        isProver || priorAccountUpdates !== undefined,\n        'Called `setKind()` outside the prover without passing in `priorAccountUpdates`.'\n      );\n      let myAccountUpdateId = isProver ? proverData.accountUpdate.id : id;\n      let priorAccountUpdatesFlat = priorAccountUpdates?.toFlatList({\n        mutate: false,\n      });\n      priorAccountUpdatesFlat ??= proverData.transaction.accountUpdates;\n      priorAccountUpdatesFlat = priorAccountUpdatesFlat.filter((a) => a.id !== myAccountUpdateId);\n      let accountUpdate = [...priorAccountUpdatesFlat]\n        .reverse()\n        .find((body_) =>\n          body_.update.verificationKey.isSome\n            .and(body_.tokenId.equals(body.tokenId))\n            .and(body_.publicKey.equals(body.publicKey))\n            .toBoolean()\n        );\n      if (accountUpdate !== undefined) {\n        return accountUpdate.body.update.verificationKey.value.hash;\n      }\n      try {\n        let account = Mina.getAccount(body.publicKey, body.tokenId);\n        return account.zkapp?.verificationKey?.hash ?? Field(0);\n      } catch {\n        return Field(0);\n      }\n    });\n    body.authorizationKind.verificationKeyHash = hash;\n  },\n  setLazyProof(\n    accountUpdate: AccountUpdate,\n    proof: Omit<LazyProof, 'kind'>,\n    priorAccountUpdates: AccountUpdateLayout\n  ) {\n    this.setKind(accountUpdate, priorAccountUpdates);\n    accountUpdate.authorization = {};\n    accountUpdate.lazyAuthorization = { ...proof, kind: 'lazy-proof' };\n  },\n};\n\n/**\n * this is useful to debug a very common error: when the consistency check between\n * -) the account update that went into the public input, and\n * -) the account update constructed by the prover\n * fails.\n * toggling this will print the two account updates in addition to the unhelpful failed assertion error when the check fails,\n * making it easier to see where the problem lies.\n * TODO refine this into a good error message that's always used, not just for debugging\n * TODO find or write library that can print nice JS object diffs\n */\nconst DEBUG_PUBLIC_INPUT_CHECK = false;\n\nfunction debugPublicInput(accountUpdate: AccountUpdate) {\n  if (!DEBUG_PUBLIC_INPUT_CHECK) return;\n\n  // connect the public input to the account update & child account updates we created\n  Provable.asProver(() => {\n    diffRecursive(accountUpdate, zkAppProver.getData());\n  });\n}\n\nfunction diffRecursive(\n  prover: AccountUpdate,\n  inputData: {\n    transaction: ZkappCommand;\n    index: number;\n    accountUpdate: AccountUpdate;\n  }\n) {\n  let { transaction, index, accountUpdate: input } = inputData;\n  diff(transaction, index, prover.toPretty(), input.toPretty());\n  // TODO\n  let proverChildren = accountUpdateLayout()?.get(prover)?.children.mutable;\n  if (proverChildren === undefined) return;\n\n  // collect input children\n  let inputChildren: AccountUpdate[] = [];\n  let callDepth = input.body.callDepth;\n  for (let i = index; i < transaction.accountUpdates.length; i++) {\n    let update = transaction.accountUpdates[i];\n    if (update.body.callDepth <= callDepth) break;\n    if (update.body.callDepth === callDepth + 1) inputChildren.push(update);\n  }\n\n  let nChildren = inputChildren.length;\n  for (let i = 0; i < nChildren; i++) {\n    let inputChild = inputChildren[i];\n    let child = proverChildren[i].mutable;\n    if (!child) return;\n    diffRecursive(child, { transaction, index, accountUpdate: inputChild });\n  }\n}\n\n// TODO: print a nice diff string instead of the two objects\n// something like `expect` or `json-diff`, but web-compatible\nfunction diff(transaction: ZkappCommand, index: number, prover: any, input: any) {\n  delete prover.id;\n  delete prover.callDepth;\n  delete input.id;\n  delete input.callDepth;\n  if (JSON.stringify(prover) !== JSON.stringify(input)) {\n    console.log('transaction:', ZkappCommand.toPretty(transaction));\n    console.log('index', index);\n    console.log('inconsistent account updates:');\n    console.log('update created by the prover:');\n    console.log(prover);\n    console.log('update created in transaction block:');\n    console.log(input);\n  }\n}\n", "import { bytesToBigInt, changeBase } from '../crypto/bigint-helpers.js';\nimport { Field } from '../../lib/provable/wrapped.js';\n\nexport { stringToFields, stringFromFields, bytesToFields, bytesFromFields, Bijective };\n\n// functions for encoding data as field elements\n\n// these methods are not for in-snark computation -- from the snark POV,\n// encryption operates on an array of field elements.\n// we also assume here that all fields are constant!\n\n// caveat: this is suitable for encoding arbitrary bytes as fields, but not the other way round\n// to encode fields as bytes in a recoverable way, you need different methods\n/**\n * Encodes a JavaScript string into a list of {@link Field} elements.\n *\n * This function is not a valid in-snark computation.\n */\nfunction stringToFields(message: string) {\n  let bytes = new TextEncoder().encode(message);\n  return bytesToFields(bytes);\n}\n\n/**\n * Decodes a list of {@link Field} elements into a JavaScript string.\n *\n * This function is not a valid in-snark computation.\n */\nfunction stringFromFields(fields: Field[]) {\n  let bytes = bytesFromFields(fields);\n  return new TextDecoder().decode(bytes);\n}\n\nconst STOP = 0x01;\n\n/**\n * Encodes a {@link Uint8Array} into {@link Field} elements.\n */\nfunction bytesToFields(bytes: Uint8Array) {\n  // we encode 248 bits (31 bytes) at a time into one field element\n  let fields = [];\n  let currentBigInt = 0n;\n  let bitPosition = 0n;\n  for (let byte of bytes) {\n    currentBigInt += BigInt(byte) << bitPosition;\n    bitPosition += 8n;\n    if (bitPosition === 248n) {\n      fields.push(Field(currentBigInt.toString()));\n      currentBigInt = 0n;\n      bitPosition = 0n;\n    }\n  }\n  // encode the final chunk, with an added STOP byte to make the mapping invertible\n  currentBigInt += BigInt(STOP) << bitPosition;\n  fields.push(Field(currentBigInt.toString()));\n  return fields;\n}\n/**\n * Decodes a list of {@link Field} elements into a {@link Uint8Array}.\n */\nfunction bytesFromFields(fields: Field[]) {\n  // find STOP byte in last chunk to determine length of byte array\n  let lastChunk = fields.pop();\n  if (lastChunk === undefined) return new Uint8Array();\n  let lastChunkBytes = bytesOfConstantField(lastChunk);\n  let i = lastChunkBytes.lastIndexOf(STOP, 30);\n  if (i === -1) throw Error('Error (bytesFromFields): Invalid encoding.');\n  let bytes = new Uint8Array(fields.length * 31 + i);\n  bytes.set(lastChunkBytes.subarray(0, i), fields.length * 31);\n  // convert the remaining fields\n  i = 0;\n  for (let field of fields) {\n    bytes.set(bytesOfConstantField(field).subarray(0, 31), i);\n    i += 31;\n  }\n  fields.push(lastChunk);\n  return bytes;\n}\n\n// bijective fields <--> bytes mapping\n// this is suitable for converting *arbitrary* fields AND bytes back and forth\n// the interpretation of the fields/bytes array is as digits of a single big integer\n// which implies the small caveat that trailing zeroes in the field/bytes array get ignored\n// another caveat: the algorithm is O(n^(1 + t)) with t > 0; ~1MB of field elements take about 1-2s to convert\n\n// this needs the exact field size\nlet p = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;\nlet q = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;\nlet bytesPerBigInt = 32;\nlet bytesBase = 256n ** BigInt(bytesPerBigInt);\n\nconst Bijective = {\n  Fp: {\n    toBytes: (fields: Field[]) => toBytesBijective(fields, p),\n    fromBytes: (bytes: Uint8Array) => toFieldsBijective(bytes, p),\n\n    toString(fields: Field[]) {\n      return new TextDecoder().decode(toBytesBijective(fields, p));\n    },\n    fromString(message: string) {\n      let bytes = new TextEncoder().encode(message);\n      return toFieldsBijective(bytes, p);\n    },\n  },\n  Fq: {\n    toBytes: (fields: Field[]) => toBytesBijective(fields, q),\n    fromBytes: (bytes: Uint8Array) => toFieldsBijective(bytes, q),\n\n    toString(fields: Field[]) {\n      return new TextDecoder().decode(toBytesBijective(fields, q));\n    },\n    fromString(message: string) {\n      let bytes = new TextEncoder().encode(message);\n      return toFieldsBijective(bytes, q);\n    },\n  },\n};\n\nfunction toBytesBijective(fields: Field[], p: bigint) {\n  let fieldsBigInts = fields.map((x) => x.toBigInt());\n  let bytesBig = changeBase(fieldsBigInts, p, bytesBase);\n  let bytes = bigIntArrayToBytes(bytesBig, bytesPerBigInt);\n  return bytes;\n}\n\nfunction toFieldsBijective(bytes: Uint8Array, p: bigint) {\n  let bytesBig = bytesToBigIntArray(bytes, bytesPerBigInt);\n  let fieldsBigInts = changeBase(bytesBig, bytesBase, p);\n  let fields = fieldsBigInts.map(Field);\n  return fields;\n}\n\nfunction bytesOfConstantField(field: Field): Uint8Array {\n  return Uint8Array.from(Field.toBytes(field));\n}\n\nfunction bigIntToBytes(x: bigint, length: number) {\n  let bytes = [];\n  for (; x > 0; x >>= 8n) {\n    bytes.push(Number(x & 0xffn));\n  }\n  let array = new Uint8Array(bytes);\n  if (length === undefined) return array;\n  if (array.length > length) throw Error(`bigint doesn't fit into ${length} bytes.`);\n  let sizedArray = new Uint8Array(length);\n  sizedArray.set(array);\n  return sizedArray;\n}\n\nfunction bytesToBigIntArray(bytes: Uint8Array, bytesPerBigInt: number) {\n  let bigints = [];\n  for (let i = 0; i < bytes.byteLength; i += bytesPerBigInt) {\n    bigints.push(bytesToBigInt(bytes.subarray(i, i + bytesPerBigInt)));\n  }\n  return bigints;\n}\n\nfunction bigIntArrayToBytes(bigints: bigint[], bytesPerBigInt: number) {\n  let bytes = new Uint8Array(bigints.length * bytesPerBigInt);\n  let offset = 0;\n  for (let b of bigints) {\n    bytes.set(bigIntToBytes(b, bytesPerBigInt), offset);\n    offset += bytesPerBigInt;\n  }\n  // remove zero bytes\n  let i = bytes.byteLength - 1;\n  for (; i >= 0; i--) {\n    if (bytes[i] !== 0) break;\n  }\n  return bytes.slice(0, i + 1);\n}\n", "import {\n  AccountUpdate,\n  AccountUpdateForest,\n  AccountUpdateTreeBase,\n  TokenId,\n} from '../account-update.js';\nimport { Field } from '../../../provable/wrapped.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { Struct } from '../../../provable/types/struct.js';\nimport { assert } from '../../../provable/gadgets/common.js';\nimport { MerkleListIterator, MerkleList } from '../../../provable/merkle-list.js';\n\nexport { TokenAccountUpdateIterator };\n\nconst AccountUpdateIterator = MerkleListIterator.create(\n  AccountUpdateForest.prototype.innerProvable,\n  AccountUpdateForest._nextHash,\n  AccountUpdateForest.emptyHash\n);\n\nclass Layer extends Struct({\n  forest: AccountUpdateIterator,\n  mayUseToken: AccountUpdate.MayUseToken.type,\n}) {}\nconst ParentLayers = MerkleList.create<Layer>(Layer);\n\ntype MayUseToken = AccountUpdate['body']['mayUseToken'];\nconst MayUseToken = AccountUpdate.MayUseToken;\n\n/**\n * Data structure to represent a forest of account updates that is being iterated over,\n * in the context of a token manager contract.\n *\n * The iteration is done in a depth-first manner.\n *\n * ```ts\n * let forest: AccountUpdateForest = ...;\n * let tokenIterator = TokenAccountUpdateIterator.create(forest, tokenId);\n *\n * // process the first 5 account updates in the tree\n * for (let i = 0; i < 5; i++) {\n *  let { accountUpdate, usesThisToken } = tokenIterator.next();\n *  // ... do something with the account update ...\n * }\n * ```\n *\n * **Important**: Since this is specifically used by token manager contracts to process their entire subtree\n * of account updates, the iterator skips subtrees that don't inherit token permissions and can therefore definitely not use the token.\n *\n * So, the assumption is that the consumer of this iterator is only interested in account updates that use the token.\n * We still can't avoid processing some account updates that don't use the token, therefore the iterator returns a boolean\n * `usesThisToken` alongside each account update.\n */\nclass TokenAccountUpdateIterator {\n  currentLayer: Layer;\n  unfinishedParentLayers: MerkleList<Layer>;\n  selfToken: Field;\n\n  constructor(\n    forest: MerkleListIterator<AccountUpdateTreeBase>,\n    mayUseToken: MayUseToken,\n    selfToken: Field\n  ) {\n    this.currentLayer = { forest, mayUseToken };\n    this.unfinishedParentLayers = ParentLayers.empty();\n    this.selfToken = selfToken;\n  }\n\n  static create(forest: AccountUpdateForest, selfToken: Field) {\n    return new TokenAccountUpdateIterator(\n      AccountUpdateIterator.startIteratingFromLast(forest),\n      MayUseToken.ParentsOwnToken,\n      selfToken\n    );\n  }\n\n  /**\n   * Make a single step along a tree of account updates.\n   *\n   * This function is guaranteed to visit each account update in the tree that uses the token\n   * exactly once, when called repeatedly.\n   *\n   * The method makes a best effort to avoid visiting account updates that are not using the token,\n   * and in particular, to avoid returning dummy updates.\n   * However, neither can be ruled out. We're returning { update, usesThisToken: Bool } and let the\n   * caller handle the irrelevant case where `usesThisToken` is false.\n   */\n  next() {\n    // get next account update from the current forest (might be a dummy)\n    let { accountUpdate, children } = this.currentLayer.forest.previous();\n    let childForest = AccountUpdateIterator.startIteratingFromLast(children);\n    let childLayer = {\n      forest: childForest,\n      mayUseToken: MayUseToken.InheritFromParent,\n    };\n\n    let update = accountUpdate.unhash();\n    let usesThisToken = update.tokenId.equals(this.selfToken);\n\n    // check if this account update / it's children can use the token\n    let canAccessThisToken = Provable.equal(\n      MayUseToken.type,\n      update.body.mayUseToken,\n      this.currentLayer.mayUseToken\n    );\n    let isSelf = TokenId.derive(update.publicKey, update.tokenId).equals(this.selfToken);\n\n    // if we don't have to check the children, ignore the forest by jumping to its end\n    let skipSubtree = canAccessThisToken.not().or(isSelf);\n    childForest.jumpToStartIf(skipSubtree);\n\n    // there are three cases for how to proceed:\n    // 1. if we have to process children, we step down and add the current layer to the stack of unfinished parent layers\n    // 2. if we don't have to process children, but are not finished with the current layer, we stay in the current layer\n    //    (below, this is the case where the current layer is first pushed to and then popped from the stack of unfinished parent layers)\n    // 3. if both of the above are false, we step up to the next unfinished parent layer\n    let currentForest = this.currentLayer.forest;\n    let currentLayerFinished = currentForest.isAtStart();\n    let childLayerFinished = childForest.isAtStart();\n\n    this.unfinishedParentLayers.pushIf(currentLayerFinished.not(), this.currentLayer);\n    let currentOrParentLayer = this.unfinishedParentLayers.popIf(childLayerFinished);\n\n    this.currentLayer = Provable.if(childLayerFinished, Layer, currentOrParentLayer, childLayer);\n\n    return { accountUpdate: update, usesThisToken };\n  }\n\n  assertFinished(message?: string) {\n    assert(\n      this.currentLayer.forest.isAtStart(),\n      message ?? 'TokenAccountUpdateIterator not finished'\n    );\n  }\n}\n", "import { AccountUpdate, Authorization, TokenId } from '../account-update.js';\nimport { isSmartContract } from '../smart-contract-base.js';\nimport { PublicKey } from '../../../provable/crypto/signature.js';\nimport type { SmartContract } from '../zkapp.js';\nimport { UInt64 } from '../../../provable/int.js';\nimport { Bool, Field } from '../../../provable/wrapped.js';\n\nexport { tokenMethods };\n\nfunction tokenMethods(self: AccountUpdate) {\n  return {\n    /**\n     * Mints token balance to `address`. Returns the mint account update.\n     */\n    mint({\n      address,\n      amount,\n    }: {\n      address: PublicKey | AccountUpdate | SmartContract;\n      amount: number | bigint | UInt64;\n    }) {\n      let id = TokenId.derive(self.publicKey, self.tokenId);\n      let receiver = getApprovedUpdate(self, id, address, 'token.mint()');\n      receiver.balance.addInPlace(amount);\n      return receiver;\n    },\n\n    /**\n     * Burn token balance on `address`. Returns the burn account update.\n     */\n    burn({\n      address,\n      amount,\n    }: {\n      address: PublicKey | AccountUpdate | SmartContract;\n      amount: number | bigint | UInt64;\n    }) {\n      let id = TokenId.derive(self.publicKey, self.tokenId);\n      let sender = getApprovedUpdate(self, id, address, 'token.burn()');\n\n      // Sub the amount to burn from the sender's account\n      sender.balance.subInPlace(amount);\n\n      // Require signature from the sender account being deducted\n      sender.body.useFullCommitment = Bool(true);\n      Authorization.setLazySignature(sender);\n      return sender;\n    },\n\n    /**\n     * Move token balance from `from` to `to`. Returns the `to` account update.\n     */\n    send({\n      from,\n      to,\n      amount,\n    }: {\n      from: PublicKey | AccountUpdate | SmartContract;\n      to: PublicKey | AccountUpdate | SmartContract;\n      amount: number | bigint | UInt64;\n    }) {\n      let id = TokenId.derive(self.publicKey, self.tokenId);\n      let sender = getApprovedUpdate(self, id, from, 'token.send() (sender)');\n      sender.balance.subInPlace(amount);\n      sender.body.useFullCommitment = Bool(true);\n      Authorization.setLazySignature(sender);\n\n      let receiver = getApprovedUpdate(self, id, to, 'token.send() (receiver)');\n      receiver.balance.addInPlace(amount);\n\n      return receiver;\n    },\n  };\n}\n\n// helper\n\nfunction getApprovedUpdate(\n  self: AccountUpdate,\n  tokenId: Field,\n  child: PublicKey | AccountUpdate | SmartContract,\n  label: string\n) {\n  if (isSmartContract(child)) {\n    child = child.self;\n  }\n  if (child instanceof AccountUpdate) {\n    child.tokenId.assertEquals(tokenId);\n    self.approve(child);\n  }\n  if (child instanceof PublicKey) {\n    child = AccountUpdate.default(child, tokenId);\n    self.approve(child);\n  }\n  if (!child.label) child.label = `${self.label ?? 'Unlabeled'}.${label}`;\n  return child;\n}\n", "import { Bool } from '../../../provable/wrapped.js';\nimport { UInt64, Int64 } from '../../../provable/int.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { PublicKey } from '../../../provable/crypto/signature.js';\nimport {\n  AccountUpdate,\n  AccountUpdateForest,\n  AccountUpdateTree,\n  Permissions,\n  TokenId,\n} from '../account-update.js';\nimport { DeployArgs, SmartContract } from '../zkapp.js';\nimport { TokenAccountUpdateIterator } from './forest-iterator.js';\nimport { tokenMethods } from './token-methods.js';\n\nexport { TokenContract };\n\n/**\n *\n * Base token contract which\n * - implements the `Approvable` API, with the `approveBase()` method left to be defined by subclasses\n * - implements the `Transferable` API as a wrapper around the `Approvable` API\n */\nabstract class TokenContract extends SmartContract {\n  // change default permissions - important that token contracts use an access permission\n\n  /** The maximum number of account updates using the token in a single\n   * transaction that this contract supports. */\n  static MAX_ACCOUNT_UPDATES = 9;\n\n  /**\n   * Deploys a {@link TokenContract}.\n   *\n   * In addition to base smart contract deployment, this adds two steps:\n   * - set the `access` permission to `proofOrSignature()`, to prevent against unauthorized token operations\n   *   - not doing this would imply that anyone can bypass token contract authorization and simply mint themselves tokens\n   * - require the zkapp account to be new, using the `isNew` precondition.\n   *   this guarantees that the access permission is set from the very start of the existence of this account.\n   *   creating the zkapp account before deployment would otherwise be a security vulnerability that is too easy to introduce.\n   *\n   * Note that because of the `isNew` precondition, the zkapp account must not be created prior to calling `deploy()`.\n   *\n   * If the contract needs to be re-deployed, you can switch off this behaviour by overriding the `isNew` precondition:\n   * ```ts\n   * async deploy() {\n   *   await super.deploy();\n   *   // DON'T DO THIS ON THE INITIAL DEPLOYMENT!\n   *   this.account.isNew.requireNothing();\n   * }\n   * ```\n   */\n  async deploy(args?: DeployArgs) {\n    await super.deploy(args);\n\n    // set access permission, to prevent unauthorized token operations\n    this.account.permissions.set({\n      ...Permissions.default(),\n      access: Permissions.proofOrSignature(),\n    });\n\n    // assert that this account is new, to ensure unauthorized token operations\n    // are not possible before this contract is deployed\n    // see https://github.com/o1-labs/o1js/issues/1439 for details\n    this.account.isNew.requireEquals(Bool(true));\n  }\n\n  /**\n   * Returns the `tokenId` of the token managed by this contract.\n   */\n  deriveTokenId() {\n    return TokenId.derive(this.address, this.tokenId);\n  }\n\n  /**\n   * Helper methods to use from within a token contract.\n   */\n  get internal() {\n    return tokenMethods(this.self);\n  }\n\n  // APPROVABLE API has to be specified by subclasses,\n  // but the hard part is `forEachUpdate()`\n\n  abstract approveBase(forest: AccountUpdateForest): Promise<void>;\n\n  /**\n   * Iterate through the account updates in `updates` and apply `callback` to each.\n   *\n   * This method is provable and is suitable as a base for implementing `approveUpdates()`.\n   */\n  forEachUpdate(\n    updates: AccountUpdateForest,\n    callback: (update: AccountUpdate, usesToken: Bool) => void\n  ) {\n    let iterator = TokenAccountUpdateIterator.create(updates, this.deriveTokenId());\n\n    // iterate through the forest and apply user-defined logic\n    for (let i = 0; i < (this.constructor as typeof TokenContract).MAX_ACCOUNT_UPDATES; i++) {\n      let { accountUpdate, usesThisToken } = iterator.next();\n      callback(accountUpdate, usesThisToken);\n    }\n\n    // prove that we checked all updates\n    iterator.assertFinished(\n      `Number of account updates to approve exceed ` +\n        `the supported limit of ${\n          (this.constructor as typeof TokenContract).MAX_ACCOUNT_UPDATES\n        }.\\n`\n    );\n\n    // skip hashing our child account updates in the method wrapper\n    // since we just did that in the loop above\n    this.approve(updates);\n  }\n\n  /**\n   * Use `forEachUpdate()` to prove that the total balance change of child account updates is zero.\n   *\n   * This is provided out of the box as it is both a good example, and probably the most common implementation, of `approveBase()`.\n   */\n  checkZeroBalanceChange(updates: AccountUpdateForest) {\n    let totalBalanceChange = Int64.zero;\n\n    this.forEachUpdate(updates, (accountUpdate, usesToken) => {\n      totalBalanceChange = totalBalanceChange.add(\n        Provable.if(usesToken, accountUpdate.balanceChange, Int64.zero)\n      );\n    });\n\n    // prove that the total balance change is zero\n    totalBalanceChange.assertEquals(0);\n  }\n\n  /**\n   * Approve a single account update (with arbitrarily many children).\n   */\n  async approveAccountUpdate(accountUpdate: AccountUpdate | AccountUpdateTree) {\n    let forest = toForest([accountUpdate]);\n    await this.approveBase(forest);\n  }\n\n  /**\n   * Approve a list of account updates (with arbitrarily many children).\n   */\n  async approveAccountUpdates(accountUpdates: (AccountUpdate | AccountUpdateTree)[]) {\n    let forest = toForest(accountUpdates);\n    await this.approveBase(forest);\n  }\n\n  // TRANSFERABLE API - simple wrapper around Approvable API\n\n  /**\n   * Transfer `amount` of tokens from `from` to `to`.\n   */\n  async transfer(\n    from: PublicKey | AccountUpdate,\n    to: PublicKey | AccountUpdate,\n    amount: UInt64 | number | bigint\n  ) {\n    // coerce the inputs to AccountUpdate and pass to `approveBase()`\n    let tokenId = this.deriveTokenId();\n    if (from instanceof PublicKey) {\n      from = AccountUpdate.default(from, tokenId);\n      from.requireSignature();\n      from.label = `${this.constructor.name}.transfer() (from)`;\n    }\n    if (to instanceof PublicKey) {\n      to = AccountUpdate.default(to, tokenId);\n      to.label = `${this.constructor.name}.transfer() (to)`;\n    }\n\n    from.balanceChange = Int64.from(amount).neg();\n    to.balanceChange = Int64.from(amount);\n\n    let forest = toForest([from, to]);\n    await this.approveBase(forest);\n  }\n}\n\nfunction toForest(updates: (AccountUpdate | AccountUpdateTree)[]): AccountUpdateForest {\n  let trees = updates.map((a) => (a instanceof AccountUpdate ? a.extractTree() : a));\n  return AccountUpdateForest.fromReverse(trees);\n}\n", "import { Field, Scalar, Group } from '../wrapped.js';\nimport { Poseidon } from './poseidon.js';\nimport { Provable } from '../provable.js';\nimport { PrivateKey, PublicKey } from './signature.js';\nimport { bytesToWord, wordToBytes } from '../gadgets/bit-slices.js';\nimport { Bytes } from '../bytes.js';\nimport { UInt8 } from '../int.js';\nimport { chunk } from '../../util/arrays.js';\n\nexport { encrypt, decrypt, encryptBytes, decryptBytes, CipherTextBytes, CipherText };\n\ntype CipherText = {\n  publicKey: Group;\n  cipherText: Field[];\n};\ntype CipherTextBytes = CipherText & { messageLength: number };\n\n/**\n * Decrypts a {@link CipherText} using a {@link PrivateKey}.\n */\nfunction decrypt({ publicKey, cipherText }: CipherText, privateKey: PrivateKey) {\n  // key exchange\n  const sharedSecret = publicKey.scale(privateKey.s);\n  const sponge = new Poseidon.Sponge();\n  sponge.absorb(sharedSecret.x);\n  const authenticationTag = cipherText.pop();\n\n  // decryption\n  const message = [];\n  for (let i = 0; i < cipherText.length; i++) {\n    // absorb frame tag\n    if (i === cipherText.length - 1) sponge.absorb(Field(1));\n    else sponge.absorb(Field(0));\n\n    const keyStream = sponge.squeeze();\n    const messageChunk = cipherText[i].sub(keyStream);\n\n    // push the message to our final messages\n    message.push(messageChunk);\n\n    // absorb the cipher text chunk\n    sponge.absorb(cipherText[i]);\n  }\n\n  // authentication tag\n  sponge.squeeze().assertEquals(authenticationTag!);\n\n  return message;\n}\n\n/**\n * Public Key Encryption, encrypts Field elements using a {@link PublicKey}.\n */\nfunction encrypt(message: Field[], otherPublicKey: PublicKey): CipherText {\n  // key exchange\n  const privateKey = Provable.witness(Scalar, () => Scalar.random());\n  const publicKey = Group.generator.scale(privateKey);\n  const sharedSecret = otherPublicKey.toGroup().scale(privateKey);\n\n  const sponge = new Poseidon.Sponge();\n  sponge.absorb(sharedSecret.x);\n\n  // encryption\n  const cipherText = [];\n  for (let [n, chunk] of message.entries()) {\n    // absorb frame bit\n    if (n === message.length - 1) sponge.absorb(Field(1));\n    else sponge.absorb(Field(0));\n\n    const keyStream = sponge.squeeze();\n    const encryptedChunk = chunk.add(keyStream);\n    cipherText.push(encryptedChunk);\n\n    sponge.absorb(encryptedChunk);\n  }\n\n  // authentication tag\n  const authenticationTag = sponge.squeeze();\n  cipherText.push(authenticationTag);\n\n  return { publicKey, cipherText };\n}\n\n/**\n * Public Key Encryption, encrypts Bytes using a {@link PublicKey}.\n */\nfunction encryptBytes(message: Bytes, otherPublicKey: PublicKey): CipherTextBytes {\n  const bytes = message.bytes;\n  const messageLength = bytes.length;\n\n  // pad message to a multiple of 31 so they still fit into one field element\n  const multipleOf = 31;\n  const n = Math.ceil(messageLength / multipleOf) * multipleOf;\n\n  // create the padding\n  const padding = Array.from({ length: n - messageLength }, () => UInt8.from(0));\n\n  // convert message into chunks of 31 bytes\n  const chunks = chunk(bytes.concat(padding), 31);\n\n  // call into encryption() and convert chunk to field elements\n  return {\n    ...encrypt(\n      chunks.map((chunk) => bytesToWord(chunk)),\n      otherPublicKey\n    ),\n    messageLength,\n  };\n}\n\n/**\n * Decrypts a {@link CipherText} using a {@link PrivateKey}.\n */\nfunction decryptBytes(cipherText: CipherTextBytes, privateKey: PrivateKey) {\n  // calculate padding\n  const messageLength = cipherText.messageLength;\n  const multipleOf = 31;\n  const n = Math.ceil(messageLength / multipleOf) * multipleOf;\n\n  // decrypt plain field elements and convert them into bytes\n  const message = decrypt(cipherText, privateKey);\n  const bytes = message.map((m) => wordToBytes(m, 31));\n  return Bytes.from(bytes.flat().slice(0, messageLength - n));\n}\n", "import { arrayProp, CircuitValue } from './types/circuit-value.js';\nimport { Field, Bool } from './wrapped.js';\nimport { Poseidon } from './crypto/poseidon.js';\nimport { MerkleTree, MerkleWitness } from './merkle-tree.js';\nimport { Provable } from './provable.js';\nimport { BinableFp } from '../../mina-signer/src/field-bigint.js';\n\nexport { MerkleMap, MerkleMapWitness };\n\nclass MerkleMap {\n  tree: MerkleTree;\n\n  /**\n   * Creates a new, empty Merkle Map.\n   *\n   * A Merkle Map is a data structure that allows for efficient storage and\n   * retrieval of key-value pairs. The values are stored in a Merkle tree,\n   * and the keys are formed by using the first 254 bits of the key as an index.\n   * The inner Merkle tree has a height of 256.\n   *\n   * @returns A new MerkleMap\n   * @example\n   * ```ts\n   * const merkleMap = new MerkleMap();\n   * ```\n   */\n  constructor() {\n    this.tree = new MerkleTree(256);\n  }\n\n  _keyToIndex(key: Field) {\n    // the bit map is reversed to make reconstructing the key during proving more convenient\n    let bits = BinableFp.toBits(key.toBigInt()).reverse();\n\n    // Make sure that the key fits in 254 bits, in order to avoid collisions since the Pasta field modulus is smaller than 2^255\n    if (bits[0]) {\n      throw Error(\n        'Key must be less than 2^254, to avoid collisions in the field modulus. Please use a smaller key.'\n      );\n    }\n\n    let n = 0n;\n    for (let i = bits.length - 1; i >= 0; i--) {\n      n = (n << 1n) | BigInt(bits[i]);\n    }\n\n    return n;\n  }\n\n  /**\n   * Sets a key of the merkle map to a given value.\n   * @param key The key to set in the map.\n   * @param value The value to set.\n   * @example\n   * ```ts\n   * const key = Field(5);\n   * const value = Field(10);\n   * merkleMap.set(key, value);\n   * ```\n   */\n  set(key: Field, value: Field) {\n    const index = this._keyToIndex(key);\n    this.tree.setLeaf(index, value);\n  }\n\n  /**\n   * Returns a value given a key. Values are by default Field(0).\n   * @param key The key to get the value from.\n   * @returns The value stored at the key.\n   * @example\n   * ```ts\n   * const key = Field(5);\n   * const value = merkleMap.get(key);\n   * console.log(value); // Output: the value at key 5 or Field(0) if key does not exist\n   * ```\n   */\n  get(key: Field) {\n    const index = this._keyToIndex(key);\n    return this.tree.getNode(0, index);\n  }\n\n  /**\n   * Returns the root of the Merkle Map.\n   * @returns The root of the Merkle Map.\n   * @example\n   * ```ts\n   * const root = merkleMap.getRoot();\n   * ```\n   */\n  getRoot() {\n    return this.tree.getRoot();\n  }\n\n  /**\n   * Returns a circuit-compatible witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the given key.\n   * @param key The key to make a witness for.\n   * @returns A MerkleMapWitness, which can be used to assert changes to the MerkleMap, and the witness's key.\n   * @example\n   * ```ts\n   * const key = Field(5);\n   * const witness = merkleMap.getWitness(key);\n   * ```\n   */\n  getWitness(key: Field) {\n    const index = this._keyToIndex(key);\n    class MyMerkleWitness extends MerkleWitness(256) {}\n    const witness = new MyMerkleWitness(this.tree.getWitness(index));\n    return new MerkleMapWitness(witness.isLeft, witness.path);\n  }\n}\n\nclass MerkleMapWitness extends CircuitValue {\n  @arrayProp(Bool, 255) isLefts: Bool[];\n  @arrayProp(Field, 255) siblings: Field[];\n\n  constructor(isLefts: Bool[], siblings: Field[]) {\n    super();\n    this.isLefts = isLefts;\n    this.siblings = siblings;\n  }\n\n  /**\n   * Computes the merkle tree root for a given value and the key for this witness\n   * @param value The value to compute the root for.\n   * @returns A tuple of the computed merkle root, and the key that is connected to the path updated by this witness.\n   */\n  computeRootAndKey(value: Field) {\n    // Check that the computed key is less than 2^254, in order to avoid collisions since the Pasta field modulus is smaller than 2^255\n    this.isLefts[0].assertTrue();\n\n    let hash = value;\n\n    const isLeft = this.isLefts;\n    const siblings = this.siblings;\n\n    let key = Field(0);\n\n    for (let i = 0; i < 255; i++) {\n      const left = Provable.if(isLeft[i], hash, siblings[i]);\n      const right = Provable.if(isLeft[i], siblings[i], hash);\n      hash = Poseidon.hash([left, right]);\n\n      const bit = Provable.if(isLeft[i], Field(0), Field(1));\n\n      key = key.mul(2).add(bit);\n    }\n\n    return [hash, key];\n  }\n}\n", "import { Bool, Field } from './wrapped.js';\nimport { Provable } from './provable.js';\nimport { Poseidon, HashInput } from './crypto/poseidon.js';\nimport { Gadgets } from './gadgets/gadgets.js';\nimport { Struct } from './types/struct.js';\nimport { provable } from './types/provable-derivers.js';\n\nexport { Character, CircuitString };\n\nconst DEFAULT_STRING_LENGTH = 128;\n\nclass Character extends Struct({ value: Field }) {\n  constructor(value: Field | number) {\n    super({ value: Field(value) });\n  }\n\n  isNull(): Bool {\n    return this.value.equals(NullCharacter().value);\n  }\n\n  toField(): Field {\n    return this.value;\n  }\n\n  toString(): string {\n    const charCode = Number(this.value.toString());\n    return String.fromCharCode(charCode);\n  }\n\n  static fromString(str: string) {\n    return new Character(str.charCodeAt(0));\n  }\n\n  // TODO: Add support for more character sets\n  // right now it's 16 bits because 8 not supported :/\n  static check(c: { value: Field }) {\n    Gadgets.rangeCheckN(16, c.value);\n  }\n\n  static toInput(c: { value: Field }): HashInput {\n    return { packed: [[c.value, 16]] };\n  }\n}\n\nconst stringEncoder = new TextEncoder();\n\nconst stringDecoder = new TextDecoder('utf-8');\n\n// Encoding and decoding of CircuitString default is `ascii`\n// to keep backward compatibility\nexport type CircuitStringEncoding = 'utf-8' | 'ascii';\n\n// construct a provable with a `string` js type\nconst RawCircuitString = {\n  ...provable({ values: Provable.Array(Character, DEFAULT_STRING_LENGTH) }),\n\n  toValue({ values }) {\n    return stringDecoder.decode(new Uint8Array(values.map((x) => Number(x.toField().toBigInt()))));\n  },\n\n  fromValue(value) {\n    if (typeof value === 'object') return value;\n    return {\n      values: fillWithNull(\n        value.split('').map((x) => Character.fromString(x)),\n        DEFAULT_STRING_LENGTH\n      ),\n    };\n  },\n} satisfies Provable<{ values: Character[] }, string>;\n\n// by using a custom provable as struct input, we override its inference of the js type\n// otherwise the js type would be `{ values: { value: bigint }[] }` instead of `string`\n// TODO: create an API for this that is better integrated with `Struct`\n// TODO support other maxLengths\nclass CircuitString extends Struct(RawCircuitString) {\n  static encoding: CircuitStringEncoding = 'ascii';\n\n  static maxLength = DEFAULT_STRING_LENGTH;\n\n  // this is the publicly accessible constructor\n  static fromCharacters(chars: Character[]): CircuitString {\n    return new CircuitString({ values: fillWithNull(chars, this.maxLength) });\n  }\n\n  maxLength() {\n    return (this.constructor as typeof CircuitString).maxLength;\n  }\n\n  // some O(n) computation that should be only done once in the circuit\n  computeLengthAndMask() {\n    let n = this.values.length;\n    // length is the actual, dynamic length\n    let length = Field(0);\n    // mask is an array that is true where `this` has its first null character, false elsewhere\n    let mask = [];\n    let wasntNullAlready = Bool(true);\n    for (let i = 0; i < n; i++) {\n      let isNull = this.values[i].isNull();\n      mask[i] = isNull.and(wasntNullAlready);\n      wasntNullAlready = isNull.not().and(wasntNullAlready);\n      length = length.add(wasntNullAlready.toField());\n    }\n    // mask has length n+1, the last element is true when `this` has no null char\n    mask[n] = wasntNullAlready;\n    (this as any)._length = length;\n    (this as any)._mask = mask;\n    return { mask, length };\n  }\n  lengthMask(): Bool[] {\n    return (this as any)._mask ?? this.computeLengthAndMask().mask;\n  }\n  length(): Field {\n    return (this as any)._length ?? this.computeLengthAndMask().length;\n  }\n\n  /**\n   * returns true if `this` has the same value as `other`\n   */\n  equals(other: CircuitString) {\n    return Provable.equal(CircuitString, this, other);\n  }\n\n  /**\n   * appends another string to this one, returns the result and proves that it fits\n   * within the `maxLength` of this string (the other string can have a different maxLength)\n   */\n  append(str: CircuitString): CircuitString {\n    let n = this.maxLength();\n    // only allow append if the dynamic length does not overflow\n    this.length().add(str.length()).assertLessThan(n);\n\n    let chars = this.values;\n    let otherChars = fillWithNull(str.values, n);\n\n    // compute the concatenated string -- for *each* of the possible lengths of the first string\n    let possibleResults = [];\n    for (let length = 0; length < n + 1; length++) {\n      // if the first string has this `length`, then this is the result:\n      possibleResults[length] = chars.slice(0, length).concat(otherChars.slice(0, n - length));\n    }\n    // compute the actual result, by always picking the char which corresponds to the actual length\n    let result: Character[] = [];\n    let mask = this.lengthMask();\n    for (let i = 0; i < n; i++) {\n      let possibleCharsAtI = possibleResults.map((r) => r[i]);\n      result[i] = Provable.switch(mask, Character, possibleCharsAtI);\n    }\n    return CircuitString.fromCharacters(result);\n  }\n\n  hash(): Field {\n    return Poseidon.hash(this.values.map((x) => x.value));\n  }\n\n  substring(start: number, end: number): CircuitString {\n    return CircuitString.fromCharacters(this.values.slice(start, end));\n  }\n\n  toString(encoding?: CircuitStringEncoding): string {\n    const textEncoding = encoding ?? CircuitString.encoding;\n    if (textEncoding === 'ascii') {\n      return CircuitString.toValue(this).replace(/[^ -~]+/g, '');\n    } else if (textEncoding === 'utf-8') {\n      return CircuitString.toValue(this);\n    }\n    throw Error('CircuitString: unsupported encoding, only ascii and utf-8 are supported');\n  }\n\n  private static fromValueUtf8(value: string | { values: Character[] }) {\n    if (typeof value === 'object') return value;\n    const utf8Characters = Array.from(stringEncoder.encode(value)).map((x) => {\n      return new Character(x);\n    });\n    return {\n      values: fillWithNull(utf8Characters, DEFAULT_STRING_LENGTH),\n    };\n  }\n\n  // Change default encoding of all CircuitString\n  static setEncoding(encoding: CircuitStringEncoding) {\n    CircuitString.encoding = encoding;\n  }\n\n  static fromString(str: string, encoding?: CircuitStringEncoding): CircuitString {\n    const textEncoding = encoding ?? CircuitString.encoding;\n    if (str.length > this.maxLength) {\n      throw Error('CircuitString.fromString: input string exceeds max length!');\n    }\n    if (textEncoding === 'ascii') {\n      return new CircuitString(CircuitString.fromValue(str));\n    } else if (textEncoding === 'utf-8') {\n      return new CircuitString(CircuitString.fromValueUtf8(str));\n    }\n    throw Error('CircuitString: unsupported encoding, only ascii and utf-8 are supported');\n  }\n}\n\n// note: this used to be a custom class, which doesn't work\n// NullCharacter must use the same circuits as normal Characters\nlet NullCharacter = () => new Character(Field(0));\n\nfunction fillWithNull([...values]: Character[], length: number) {\n  let nullChar = NullCharacter();\n  for (let i = values.length; i < length; i++) {\n    values[i] = nullChar;\n  }\n  return values;\n}\n", "import type { Nullifier as JsonNullifier } from '../../../mina-signer/src/types.js';\nimport { Struct } from '../types/struct.js';\nimport { Field, Group, Scalar } from '../wrapped.js';\nimport { Poseidon } from './poseidon.js';\nimport { MerkleMapWitness } from '../merkle-map.js';\nimport { PrivateKey, PublicKey } from './signature.js';\nimport { Provable } from '../provable.js';\n\nexport { Nullifier };\n\n/**\n *\n * Nullifiers are used as a public commitment to a specific anonymous account,\n * to forbid actions like double spending, or allow a consistent identity between anonymous actions.\n *\n * RFC: https://github.com/o1-labs/o1js/issues/756\n *\n * Paper: https://eprint.iacr.org/2022/1255.pdf\n */\nclass Nullifier extends Struct({\n  publicKey: Group,\n  public: {\n    nullifier: Group,\n    s: Scalar,\n  },\n  private: {\n    c: Field,\n    g_r: Group,\n    h_m_pk_r: Group,\n  },\n}) {\n  static fromJSON(json: JsonNullifier): Nullifier {\n    return super.fromJSON(json as any) as Nullifier;\n  }\n\n  /**\n   * Verifies that the Nullifier belongs to a specific message. Throws an error if the Nullifier is incorrect.\n   *\n   * @example\n   *\n   * ```ts\n   * let nullifierMessage = [voteId, ...otherData];\n   * // throws an error if the nullifier is invalid or doesn't belong to this specific message\n   * nullifier.verify(nullifierMessage);\n   * ```\n   */\n  verify(message: Field[]) {\n    let {\n      publicKey,\n      public: { nullifier, s },\n      private: { c },\n    } = this;\n    // generator\n    let G = Group.generator;\n\n    // serialize public key into fields once\n    let pk_fields = Group.toFields(publicKey);\n\n    // x and y of hash(msg, pk), it doesn't return a Group because y is split into x0 and x1, both two roots of a field element\n    let h_m_pk = Poseidon.hashToGroup([...message, ...pk_fields]);\n\n    // pk^c\n    let pk_c = this.publicKey.scale(c);\n\n    // g^r = g^s / pk^c\n    let g_r = G.scale(s).sub(pk_c);\n\n    // h(m, pk)^s\n    let h_m_pk_s = h_m_pk.scale(s);\n\n    // h_m_pk_r =  h(m,pk)^s / nullifier^c\n    let h_m_pk_s_div_nullifier_s = h_m_pk_s.sub(nullifier.scale(c));\n\n    // this is supposed to match the entries generated on \"the other side\" of the nullifier (mina-signer, in an wallet enclave)\n    Poseidon.hash([\n      ...Group.toFields(G),\n      ...pk_fields,\n      ...Group.toFields(h_m_pk),\n      ...Group.toFields(nullifier),\n      ...Group.toFields(g_r),\n      ...Group.toFields(h_m_pk_s_div_nullifier_s),\n    ]).assertEquals(c, 'Nullifier does not match private input!');\n  }\n\n  /**\n   * The key of the nullifier, which belongs to a unique message and a public key.\n   * Used as an index in Merkle trees.\n   *\n   * @example\n   * ```ts\n   * // returns the key of the nullifier which can be used as index in a Merkle tree/map\n   * let key = nullifier.key();\n   * ```\n   */\n  key() {\n    return Poseidon.hash(Group.toFields(this.public.nullifier));\n  }\n\n  /**\n   * Returns the state of the Nullifier.\n   *\n   * @example\n   * ```ts\n   * // returns a Bool based on whether or not the nullifier has been used before\n   * let isUnused = nullifier.isUnused();\n   * ```\n   */\n  isUnused(witness: MerkleMapWitness, root: Field) {\n    let [newRoot, key] = witness.computeRootAndKey(Field(0));\n    key.assertEquals(this.key());\n    let isUnused = newRoot.equals(root);\n\n    let isUsed = witness.computeRootAndKey(Field(1))[0].equals(root);\n    // prove that our Merkle witness is correct\n    isUsed.or(isUnused).assertTrue();\n    return isUnused; // if this is false, `isUsed` is true because of the check before\n  }\n\n  /**\n   * Checks if the Nullifier has been used before.\n   *\n   * @example\n   * ```ts\n   * // asserts that the nullifier has not been used before, throws an error otherwise\n   * nullifier.assertUnused();\n   * ```\n   */\n  assertUnused(witness: MerkleMapWitness, root: Field) {\n    let [impliedRoot, key] = witness.computeRootAndKey(Field(0));\n    this.key().assertEquals(key);\n    impliedRoot.assertEquals(root);\n  }\n\n  /**\n   * Sets the Nullifier, returns the new Merkle root.\n   *\n   * @example\n   * ```ts\n   * // calculates the new root of the Merkle tree in which the nullifier is set to used\n   * let newRoot = nullifier.setUsed(witness);\n   * ```\n   */\n  setUsed(witness: MerkleMapWitness) {\n    let [newRoot, key] = witness.computeRootAndKey(Field(1));\n    key.assertEquals(this.key());\n    return newRoot;\n  }\n\n  /**\n   * Returns the {@link PublicKey} that is associated with this Nullifier.\n   *\n   * @example\n   * ```ts\n   * let pk = nullifier.getPublicKey();\n   * ```\n   */\n  getPublicKey() {\n    return PublicKey.fromGroup(this.publicKey);\n  }\n\n  /**\n   *\n   * _Note_: This is *not* the recommended way to create a Nullifier in production. Please use mina-signer to create Nullifiers.\n   * Also, this function cannot be run within provable code to avoid unintended creations of Nullifiers - a Nullifier should never be created inside provable code (e.g. a smart contract) directly, but rather created inside the users wallet (or other secure enclaves, so the private key never leaves that enclave).\n   *\n   * PLUME: An ECDSA Nullifier Scheme for Unique\n   * Pseudonymity within Zero Knowledge Proofs\n   * https://eprint.iacr.org/2022/1255.pdf chapter 3 page 14\n   */\n  static createTestNullifier(message: Field[], sk: PrivateKey): JsonNullifier {\n    if (Provable.inCheckedComputation()) {\n      throw Error(\n        'This function cannot not be run within provable code. If you want to create a Nullifier, run this method outside provable code or use mina-signer to do so.'\n      );\n    }\n    const Hash2 = Poseidon.hash;\n    const Hash = Poseidon.hashToGroup;\n\n    const pk = sk.toPublicKey().toGroup();\n\n    const G = Group.generator;\n\n    const r = Scalar.random();\n\n    const h_m_pk = Hash([...message, ...Group.toFields(pk)]);\n\n    const nullifier = h_m_pk.scale(sk.toBigInt());\n    const h_m_pk_r = h_m_pk.scale(r.toBigInt());\n\n    const g_r = G.scale(r.toBigInt());\n\n    const c = Hash2([\n      ...Group.toFields(G),\n      ...Group.toFields(pk),\n      ...Group.toFields(h_m_pk),\n      ...Group.toFields(nullifier),\n      ...Group.toFields(g_r),\n      ...Group.toFields(h_m_pk_r),\n    ]);\n\n    // operations on scalars (r) should be in Fq, rather than Fp\n    // while c is in Fp (due to Poseidon.hash), c needs to be handled as an element from Fq\n    const s = r.add(sk.s.mul(Scalar.from(c.toBigInt())));\n\n    return {\n      publicKey: pk.toJSON(),\n      private: {\n        c: c.toString(),\n        g_r: g_r.toJSON(),\n        h_m_pk_r: h_m_pk_r.toJSON(),\n      },\n      public: {\n        nullifier: nullifier.toJSON(),\n        s: s.toJSON(),\n      },\n    };\n  }\n}\n", "/**\n * This file contains some examples of finite fields, to be used for tests\n */\nimport { Fp, Fq, createField } from './finite-field.js';\n\nexport { exampleFields };\n\n// some primes\nlet pSmall = 101n;\nlet pBabybear = (1n << 31n) - 1n;\nlet pGoldilocks = (1n << 64n) - (1n << 32n) + 1n;\nlet p25519 = (1n << 255n) - 19n;\nlet pSecp256k1 = (1n << 256n) - (1n << 32n) - 0b1111010001n;\nlet pSecq256k1 = (1n << 256n) - 0x14551231950b75fc4402da1732fc9bebfn;\nlet pBls12_377 =\n  0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001n;\nlet qBls12_377 = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001n;\nlet pBls12_381 =\n  0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\nlet qBls12_381 = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;\n\nlet exampleFields = {\n  Fp,\n  Fq,\n  small: createField(pSmall),\n  babybear: createField(pBabybear),\n  goldilocks: createField(pGoldilocks),\n  f25519: createField(p25519),\n  secp256k1: createField(pSecp256k1),\n  secq256k1: createField(pSecq256k1),\n  secp256r1: createField(0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn),\n  bls12_377_base: createField(pBls12_377),\n  bls12_377_scalar: createField(qBls12_377),\n  bls12_381_base: createField(pBls12_381),\n  bls12_381_scalar: createField(qBls12_381),\n};\n", "import { CurveParams, Pallas, Vesta } from './elliptic-curve.js';\nimport { exampleFields } from './finite-field-examples.js';\n\nexport { CurveParams };\n\nconst secp256k1Params: CurveParams = {\n  name: 'secp256k1',\n  modulus: exampleFields.secp256k1.modulus,\n  order: exampleFields.secq256k1.modulus,\n  a: 0n,\n  b: 7n,\n  generator: {\n    x: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,\n    y: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,\n  },\n};\n\nconst secp256r1Params: CurveParams = {\n  name: 'secp256r1',\n  modulus: exampleFields.secp256r1.modulus,\n  order: 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551n,\n  a: 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffcn,\n  b: 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn,\n  generator: {\n    x: 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296n,\n    y: 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5n,\n  },\n};\n\nconst pallasParams: CurveParams = {\n  name: 'Pallas',\n  modulus: Pallas.modulus,\n  order: Pallas.order,\n  a: Pallas.a,\n  b: Pallas.b,\n  generator: Pallas.one,\n  endoBase: Pallas.endoBase,\n  endoScalar: Pallas.endoScalar,\n};\n\nconst vestaParams: CurveParams = {\n  name: 'Vesta',\n  modulus: Vesta.modulus,\n  order: Vesta.order,\n  a: Vesta.a,\n  b: Vesta.b,\n  generator: Vesta.one,\n  endoBase: Vesta.endoBase,\n  endoScalar: Vesta.endoScalar,\n};\n\nconst CurveParams = {\n  Secp256k1: secp256k1Params,\n  Secp256r1: secp256r1Params,\n  Pallas: pallasParams,\n  Vesta: vestaParams,\n};\n", "import { CurveParams as CurveParams_ } from '../../../bindings/crypto/elliptic-curve-examples.js';\nimport { CurveAffine, createCurveAffine } from '../../../bindings/crypto/elliptic-curve.js';\n\n// crypto namespace\nconst Crypto = {\n  /**\n   * Create elliptic curve arithmetic methods.\n   */\n  createCurve(params: Crypto.CurveParams): Crypto.Curve {\n    return createCurveAffine(params);\n  },\n  /**\n   * Parameters defining an elliptic curve in short Weierstra\u00DF form\n   * y^2 = x^3 + ax + b\n   */\n  CurveParams: CurveParams_,\n};\n\nnamespace Crypto {\n  /**\n   * Parameters defining an elliptic curve in short Weierstra\u00DF form\n   * y^2 = x^3 + ax + b\n   */\n  export type CurveParams = CurveParams_;\n\n  export type Curve = CurveAffine;\n}\nexport { Crypto };\n", "import { MerkleList } from '../../../provable/merkle-list.js';\nimport { Field } from '../../../provable/wrapped.js';\nimport { InferProvable } from '../../../provable/types/struct.js';\nimport { Actionable } from './offchain-state-serialization.js';\nimport { Actions } from '../account-update.js';\nimport { Hashed } from '../../../provable/packed.js';\nimport { hashWithPrefix } from '../../../provable/crypto/poseidon.js';\nimport { prefixes } from '../../../../bindings/crypto/constants.js';\nimport { ProvableType } from '../../../provable/types/provable-intf.js';\n\nexport { MerkleActions, MerkleActionHashes, HashedAction, FlatActions };\nexport { emptyActionState, emptyActionsHash };\n\nconst emptyActionsHash = Actions.empty().hash;\nconst emptyActionState = Actions.emptyActionState();\n\n/**\n * Provable representation of actions and their three levels of Merkleization.\n */\ntype MerkleActions<T> = MerkleList<MerkleList<Hashed<T>>>;\n\nfunction MerkleActions<A extends Actionable<any>>(actionType: A, fromActionState?: Field) {\n  return MerkleList.create(\n    MerkleActionList(actionType),\n    (hash, actions) => hashWithPrefix(prefixes.sequenceEvents, [hash, actions.hash]),\n    fromActionState ?? emptyActionState\n  );\n}\nMerkleActions.fromFields = actionFieldsToMerkleList;\n\ntype MerkleActionList<T> = MerkleList<Hashed<T>>;\n\nfunction MerkleActionList<A extends Actionable<any>>(actionType: A) {\n  return MerkleList.create(\n    HashedAction(actionType),\n    (hash, action) => hashWithPrefix(prefixes.sequenceEvents, [hash, action.hash]),\n    emptyActionsHash\n  );\n}\n\ntype HashedAction<T> = Hashed<T>;\n\nfunction HashedAction<A extends Actionable<any>>(actionType: A) {\n  let type = ProvableType.get(actionType as Actionable<InferProvable<A>>);\n  return Hashed.create(type, (action) => hashWithPrefix(prefixes.event, type.toFields(action)));\n}\n\nfunction actionFieldsToMerkleList<T>(\n  actionType: Actionable<T>,\n  fields: bigint[][][],\n  fromActionState?: bigint\n) {\n  let type = ProvableType.get(actionType);\n  const HashedActionT = HashedAction(type);\n  const MerkleActionListT = MerkleActionList(type);\n  const MerkleActionsT = MerkleActions(type, fromActionState ? Field(fromActionState) : undefined);\n  let actions = fields.map((event) => event.map((action) => type.fromFields(action.map(Field))));\n  let hashes = actions.map((as) => as.map((a) => HashedActionT.hash(a)));\n  return MerkleActionsT.from(hashes.map((h) => MerkleActionListT.from(h)));\n}\n\n/**\n * Simplified representation of actions where we don't use inner action lists but\n * only their hashes, which are plain Field elements.\n */\ntype MerkleActionHashes = MerkleList<Field>;\n\nfunction MerkleActionHashes(fromActionState?: Field) {\n  return MerkleList.create(\n    Field,\n    (hash, actionsHash) => hashWithPrefix(prefixes.sequenceEvents, [hash, actionsHash]),\n    fromActionState ?? emptyActionState\n  );\n}\n\n/**\n * Provable representation of a flat list of actions.\n *\n * If the amount of logic per action is heavy, it is usually good to flatten the nested actions\n * list into a single list like this one.\n */\ntype FlatActions<T> = MerkleList<Hashed<T>>;\n\nfunction FlatActions<A extends Actionable<any>>(actionType: A) {\n  return MerkleList.create(HashedAction(actionType));\n}\n", "import { SelfProof } from '../../../proof-system/zkprogram.js';\nimport { Proof } from '../../../proof-system/proof.js';\nimport { Bool, Field } from '../../../provable/wrapped.js';\nimport { SmartContract } from '../zkapp.js';\nimport { assert, assertDefined } from '../../../util/assert.js';\nimport { Constructor, From } from '../../../../bindings/lib/provable-generic.js';\nimport { Struct, InferProvable } from '../../../provable/types/struct.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { Actionable } from './offchain-state-serialization.js';\nimport { prefixes } from '../../../../bindings/crypto/constants.js';\nimport { Actions } from '../account-update.js';\nimport { contract } from '../smart-contract-context.js';\nimport { State } from '../state.js';\nimport { Option } from '../../../provable/option.js';\nimport { PublicKey } from '../../../provable/crypto/signature.js';\nimport { fetchActions, getProofsEnabled } from '../mina-instance.js';\nimport { ZkProgram } from '../../../proof-system/zkprogram.js';\nimport { Unconstrained } from '../../../provable/types/unconstrained.js';\nimport { hashWithPrefix as hashWithPrefixBigint } from '../../../../mina-signer/src/poseidon-bigint.js';\nimport { Actions as ActionsBigint } from '../../../../bindings/mina-transaction/v1/transaction-leaves-bigint.js';\nimport {\n  FlatActions,\n  HashedAction,\n  MerkleActionHashes,\n  MerkleActions,\n  emptyActionState,\n} from './action-types.js';\nimport {\n  ProvableHashable,\n  ProvablePure,\n  ProvableType,\n} from '../../../provable/types/provable-intf.js';\n\n// external API\nexport { BatchReducer, ActionBatch };\n\n// internal API\nexport { actionStackProgram, proveActionStack };\n\n/**\n * A reducer to process actions in fixed-size batches.\n *\n * ```ts\n * let batchReducer = new BatchReducer({ actionType: Action, batchSize: 5 });\n *\n * // in contract: concurrent dispatching of actions\n * batchReducer.dispatch(action);\n *\n * // reducer logic\n * // outside contract: prepare a list of { batch, proof } objects which cover all pending actions\n * let batches = await batchReducer.prepareBatches();\n *\n * // in contract: process a single batch\n * // create one transaction that does this for each batch!\n * batchReducer.processBatch({ batch, proof }, (action, isDummy) => {\n *   // ...\n * });\n * ```\n */\nclass BatchReducer<\n  ActionType extends Actionable<any>,\n  BatchSize extends number = number,\n  Action = InferProvable<ActionType>,\n> {\n  batchSize: BatchSize;\n  actionType: ProvableHashable<Action> & ProvablePure<Action>;\n  Batch: ReturnType<typeof ActionBatch>;\n\n  program: ActionStackProgram;\n  BatchProof: typeof Proof<Field, ActionStackState>;\n\n  maxUpdatesFinalProof: number;\n  maxActionsPerUpdate: number;\n\n  constructor({\n    actionType,\n    batchSize,\n    maxUpdatesPerProof = 300,\n    maxUpdatesFinalProof = 100,\n    maxActionsPerUpdate = Math.min(batchSize, 5),\n  }: {\n    /**\n     * The provable type of actions submitted by this reducer.\n     */\n    actionType: ActionType;\n\n    /**\n     * The number of actions in a batch. The idea is to process one batch per transaction, by calling `processBatch()`.\n     *\n     * The motivation for processing actions in small batches is to work around the protocol limit on the number of account updates.\n     * If every action should result in an account update, then you have to set the batch size low enough to not exceed the limit.\n     *\n     * If transaction limits are no concern, the `batchSize` could be set based on amount of logic you do per action.\n     * A smaller batch size will make proofs faster, but you might need more individual transactions as more batches are needed to process all pending actions.\n     */\n    batchSize: BatchSize;\n\n    /**\n     * The maximum number of action lists (= all actions on an account update) to process in a single recursive proof, in `prepareBatches()`.\n     *\n     * Default: 300, which will take up about 9000 constraints.\n     *\n     * The current default should be sensible for most applications, but here are some trade-offs to consider when changing it:\n     *\n     * - Using a smaller number means a smaller circuit, so recursive proofs will be faster.\n     * - Using a bigger number means you'll need fewer recursive proofs in the case a lot of actions are pending.\n     *\n     * So, go lower if you expect very few actions, and higher if you expect a lot of actions.\n     * (Note: A larger circuit causes longer compilation and proof times for your zkApp even if you _never_ need a recursive proof)\n     */\n    maxUpdatesPerProof?: number;\n\n    /**\n     * The maximum number of action lists (= all actions on an account update) to process inside `processBatch()`,\n     * i.e. in your zkApp method.\n     *\n     * Default: 100, which will take up about 3000 constraints.\n     *\n     * The current default should be sensible for most applications, but here are some trade-offs to consider when changing it:\n     *\n     * - Using a smaller number means a smaller circuit, so proofs of your method will be faster.\n     * - Using a bigger number means it's more likely that you can prove _all_ actions in the method call and won't need a recursive proof.\n     *\n     * So, go lower if you expect very few actions, and higher if you expect a lot of actions.\n     */\n    maxUpdatesFinalProof?: number;\n\n    /**\n     * The maximum number of actions dispatched in any of the zkApp methods on the contract.\n     *\n     * Note: This number just has to be an upper bound of the actual maximum, but if it's the precise number,\n     * fewer constraints will be used. (The overhead of a higher number is fairly small though.)\n     *\n     * A restriction is that the number has to be less or equal than the `batchSize`.\n     * The reason is that actions in one account update are always processed together, so if you'd have more actions in one than the batch size, we couldn't process them at all.\n     *\n     * By default, this is set to `Math.min(batchSize, 5)` which should be sensible for most applications.\n     */\n    maxActionsPerUpdate?: number;\n  }) {\n    this.batchSize = batchSize;\n    this.actionType = ProvableType.get(actionType) as ProvableHashable<Action> &\n      ProvablePure<Action>;\n    this.Batch = ActionBatch(this.actionType);\n\n    this.maxUpdatesFinalProof = maxUpdatesFinalProof;\n    this.program = actionStackProgram(maxUpdatesPerProof);\n    this.BatchProof = ZkProgram.Proof(this.program);\n\n    assert(\n      maxActionsPerUpdate <= batchSize,\n      'Invalid maxActionsPerUpdate, must be smaller than the batch size because we process entire updates at once.'\n    );\n    this.maxActionsPerUpdate = maxActionsPerUpdate;\n  }\n\n  static get initialActionState() {\n    return emptyActionState;\n  }\n  static get initialActionStack() {\n    return emptyActionState;\n  }\n\n  _contract?: BatchReducerContract;\n  _contractClass?: BatchReducerContractClass;\n\n  contractClass(): BatchReducerContractClass {\n    return assertDefined(\n      this._contractClass,\n      'Contract instance or class must be set before calling this method'\n    );\n  }\n\n  contract(): BatchReducerContract {\n    let Contract = this.contractClass();\n    return contract(Contract);\n  }\n\n  /**\n   * Set the smart contract instance this reducer is connected with.\n   *\n   * Note: This is a required step before using `dispatch()`, `proveNextBatch()` or `processNextBatch()`.\n   */\n  setContractInstance(contract: BatchReducerContract) {\n    this._contract = contract;\n    this._contractClass = contract.constructor as BatchReducerContractClass;\n  }\n\n  /**\n   * Set the smart contract class this reducer is connected with.\n   *\n   * Note: You can use either this method or `setContractInstance()` before calling `compile()`.\n   * However, `setContractInstance()` is required for `proveNextBatch()`.\n   */\n  setContractClass(contractClass: BatchReducerContractClass) {\n    this._contractClass = contractClass;\n  }\n\n  /**\n   * Submit an action.\n   */\n  dispatch(action: From<ActionType>) {\n    let update = this.contract().self;\n    let canonical = Provable.toCanonical(this.actionType, this.actionType.fromValue(action));\n    let fields = this.actionType.toFields(canonical);\n    update.body.actions = Actions.pushEvent(update.body.actions, fields);\n  }\n\n  /**\n   * Conditionally submit an action.\n   */\n  dispatchIf(condition: Bool, action: From<ActionType>) {\n    let update = this.contract().self;\n    let canonical = Provable.toCanonical(this.actionType, this.actionType.fromValue(action));\n    let fields = this.actionType.toFields(canonical);\n    let newActions = Actions.pushEvent(update.body.actions, fields);\n    update.body.actions = Provable.if(condition, Actions, newActions, update.body.actions);\n  }\n\n  /**\n   * Process a batch of actions which was created by `prepareBatches()`.\n   *\n   * **Important**: The callback exposes the action's value along with an `isDummy` flag.\n   * This is necessary because we process a dynamically-sized list in a fixed number of steps.\n   * Dummies will be passed to your callback once the actual actions are exhausted.\n   *\n   * Make sure to write your code to account for dummies. For example, when sending MINA from your contract for every action,\n   * you probably want to zero out the balance decrease in the `isDummy` case:\n   * ```ts\n   * processBatch({ batch, proof }, (action, isDummy) => {\n   *   // ... other logic ...\n   *\n   *   let amountToSend = Provable.if(isDummy, UInt64.zero, action.amount);\n   *   this.balance.subInPlace(amountToSend);\n   * });\n   * ```\n   *\n   * **Warning**: Don't call `processBatch()` on two _different_ batches within the same method. The second call\n   * would override the preconditions set by the first call, which would leave the method insecure.\n   * To process more actions per method call, increase the `batchSize`.\n   */\n  processBatch(\n    {\n      batch,\n      proof,\n    }: {\n      batch: ActionBatch<Action>;\n      proof: Proof<Field, ActionStackState>;\n    },\n    callback: (action: Action, isDummy: Bool, i: number) => void\n  ): void {\n    let { actionType, batchSize } = this;\n    let contract = this.contract();\n\n    // step 0. validate onchain states\n\n    let { useOnchainStack, processedActionState, onchainActionState, onchainStack } = batch;\n    let useNewStack = useOnchainStack.not();\n\n    // we definitely need to know the processed action state, because we will update it\n    contract.actionState.requireEquals(processedActionState);\n\n    // only require the onchain stack if we use it\n    contract.actionStack.requireEqualsIf(useOnchainStack, onchainStack);\n\n    // only require the onchain action state if we are recomputing the stack (otherwise, the onchain stack is known to be valid)\n    contract.account.actionState.requireEqualsIf(useNewStack, onchainActionState);\n\n    // step 1. continue the proof that pops pending onchain actions to build up the final stack\n\n    let { isRecursive } = batch;\n    proof.verifyIf(isRecursive);\n\n    // if the proof is valid, it has to start from onchain action state\n    Provable.assertEqualIf(isRecursive, Field, proof.publicInput, onchainActionState);\n\n    // the final piece of the proof either starts from the onchain action state + an empty stack,\n    // or from the previous proof output\n    let initialState = { actions: onchainActionState, stack: emptyActionState };\n    let startState = Provable.if(isRecursive, ActionStackState, proof.publicOutput, initialState);\n\n    // finish creating the new stack\n    let stackingResult = actionStackChunk(this.maxUpdatesFinalProof, startState, batch.witnesses);\n\n    // step 2. pick the correct stack of actions to process\n\n    // if we use the new stack, make sure it's correct: it has to go all the way back\n    // from `onchainActionState` to `processedActionState`\n    Provable.assertEqualIf(useNewStack, Field, stackingResult.actions, processedActionState);\n\n    let stackToUse = Provable.if(useOnchainStack, onchainStack, stackingResult.stack);\n\n    // our input hint gives us the actual actions contained in this stack\n    let { stack } = batch;\n    stack = stack.clone(); // defend against this code running twice\n    stack.hash.assertEquals(stackToUse);\n\n    // invariant: from this point on, the stack contains actual pending action lists in their correct (reversed) order\n\n    // step 3. pop off the actions we want to process from the stack\n\n    // we should take as many actions as possible, within the constraints that:\n    // - we process entire lists (= account updates) at once\n    // - we process at most `this.batchSize` actions\n    // - we can't process more than the stack contains\n    let nActionLists = Unconstrained.witness(() => {\n      let lists = stack.toArrayUnconstrained().get();\n      let n = 0;\n      let totalSize = 0;\n      for (let list of lists.reverse()) {\n        totalSize += list.lengthUnconstrained().get();\n        if (totalSize > batchSize) break;\n        n++;\n      }\n      return n;\n    });\n\n    // linearize the stack into a flat list which contains exactly the actions we process\n    let flatActions = FlatActions(actionType).empty();\n\n    for (let i = 0; i < batchSize; i++) {\n      // note: we allow the prover to pop off as many actions as they want (up to `batchSize`)\n      // if they pop off less than possible, it doesn't violate our invariant that the stack contains pending actions in correct order\n      let shouldPop = Provable.witness(Bool, () => i < nActionLists.get());\n      let actionList = stack.popIfUnsafe(shouldPop);\n\n      // if we didn't pop, must guarantee that the action list is empty\n      actionList = Provable.if(\n        shouldPop,\n        stack.innerProvable,\n        actionList,\n        stack.innerProvable.empty()\n      );\n\n      // push all actions to the flat list\n      actionList.forEach(this.maxActionsPerUpdate, (action, isDummy) => {\n        flatActions.pushIf(isDummy.not(), action);\n      });\n\n      // if we pop, we also update the processed action state\n      let nextActionState = Actions.updateSequenceState(processedActionState, actionList.hash);\n      processedActionState = Provable.if(shouldPop, nextActionState, processedActionState);\n    }\n\n    // step 4. run user logic on the actions\n\n    const HashedActionT = HashedAction(actionType);\n    const emptyHashedAction = HashedActionT.empty();\n\n    flatActions.forEach(batchSize, (hashedAction, isDummy, i) => {\n      // we make it easier to write the reducer code by making sure dummy actions have dummy values\n      hashedAction = Provable.if(isDummy, HashedActionT, emptyHashedAction, hashedAction);\n\n      // note: only here, we do the work of unhashing the action\n      callback(hashedAction.unhash(), isDummy, i);\n    });\n\n    // step 5. update the onchain processed action state and stack\n\n    contract.actionState.set(processedActionState);\n    contract.actionStack.set(stack.hash);\n  }\n\n  /**\n   * Compile the recursive action stack prover.\n   */\n  async compile() {\n    return await this.program.compile();\n  }\n\n  /**\n   * Create a proof which returns the next actions batch(es) to process and helps guarantee their correctness.\n   */\n  async prepareBatches(): Promise<{ proof: ActionStackProof; batch: ActionBatch<Action> }[]> {\n    let { batchSize, actionType } = this;\n    let contract = assertDefined(\n      this._contract,\n      'Contract instance must be set before proving actions'\n    );\n    let fromActionState = assertDefined(\n      await contract.actionState.fetch(),\n      'Could not fetch action state'\n    ).toBigInt();\n\n    // TODO witnesses is just a dumbed down representation of `actions`, we could compute them from actions\n    let { endActionState, witnesses, actions } = await fetchActionWitnesses(\n      contract,\n      fromActionState,\n      this.actionType\n    );\n\n    // if there are no pending actions, there is no need to call the reducer\n    if (witnesses.length === 0) return [];\n\n    let { proof, isRecursive, finalWitnesses } = await provePartialActionStack(\n      endActionState,\n      witnesses,\n      this.program,\n      this.maxUpdatesFinalProof\n    );\n\n    // create the stack from full actions\n    let stack = MerkleActions(actionType).fromReverse(actions.toArrayUnconstrained().get());\n\n    let batches: ActionBatch<Action>[] = [];\n    let baseHint = {\n      isRecursive,\n      onchainActionState: Field(endActionState),\n      witnesses: finalWitnesses,\n    };\n\n    // for the remaining batches, trace the steps of the zkapp method\n    // in updating processedActionState, stack, onchainStack\n    let stackArray = stack.toArrayUnconstrained().get();\n    let processedActionState = Field(fromActionState);\n    let onchainStack = Field(0); // incorrect, but not used in the first batch\n    let useOnchainStack = Bool(false);\n    let i = stackArray.length - 1;\n\n    // add batches as long as we haven't emptied the stack\n    while (i >= 0) {\n      batches.push({\n        ...baseHint,\n        useOnchainStack,\n        processedActionState,\n        onchainStack,\n        stack: stack.clone(),\n      });\n\n      // pop off actions as long as we can fit them in a batch\n      let currentBatchSize = 0;\n      while (i >= 0) {\n        currentBatchSize += stackArray[i].lengthUnconstrained().get();\n        if (currentBatchSize > batchSize) break;\n        let actionList = stack.pop();\n        processedActionState = Actions.updateSequenceState(processedActionState, actionList.hash);\n        i--;\n      }\n      onchainStack = stack.hash;\n      useOnchainStack = Bool(true);\n    }\n\n    // sanity check: we should have put all actions in batches\n    stack.isEmpty().assertTrue();\n\n    return batches.map((batch) => ({ proof, batch }));\n  }\n}\n\ntype BatchReducerContract = SmartContract & {\n  reducer?: undefined;\n  actionState: State<Field>;\n  actionStack: State<Field>;\n};\ntype BatchReducerContractClass = typeof SmartContract & Constructor<BatchReducerContract>;\n\n// hints for the batch reducer\n\n/**\n * Inputs to a single call of `processBatch()`.\n *\n * `proveBatches()` will prepare as many of these as we need to catch up with the chain.\n */\ntype ActionBatch<Action> = {\n  /**\n   * Whether to use the onchain stack or the new one we compute.\n   */\n  useOnchainStack: Bool;\n\n  /**\n   * Current onchain fields, kept track of externally for robustness.\n   *\n   * Note:\n   * - If `useOnchainStack = true`, the `onchainActionState` doesn't have to be correct (we only need it to prove validity of a new stack).\n   * - If `useOnchainStack = false`, the `onchainStack` doesn't have to be correct as we don't use it.\n   */\n  processedActionState: Field;\n  onchainActionState: Field;\n  onchainStack: Field;\n\n  /**\n   * The stack of actions to process.\n   *\n   * Note: this is either the current onchain stack or the new stack, + witnesses which contain the actual actions.\n   */\n  stack: MerkleActions<Action>;\n\n  /**\n   * Whether a recursive proof was needed to compute the stack, or not.\n   */\n  isRecursive: Bool;\n\n  /**\n   * Witnesses needed to finalize the stack computation.\n   */\n  witnesses: Unconstrained<ActionWitnesses>;\n};\n\nfunction ActionBatch<A extends Actionable<any>>(actionType: A) {\n  return Struct({\n    useOnchainStack: Bool,\n    processedActionState: Field,\n    onchainActionState: Field,\n    onchainStack: Field,\n    stack: MerkleActions(actionType),\n    isRecursive: Bool,\n    witnesses: Unconstrained.withEmpty<ActionWitnesses>([]),\n  });\n}\n\n// helper for fetching actions\n\nasync function fetchActionWitnesses<T>(\n  contract: { address: PublicKey; tokenId: Field },\n  fromActionState: bigint,\n  actionType: Actionable<T>\n) {\n  let result = await fetchActions(\n    contract.address,\n    { fromActionState: Field(fromActionState) },\n    contract.tokenId\n  );\n  if ('error' in result) throw Error(JSON.stringify(result));\n\n  let actionFields = result.map(({ actions }) =>\n    actions.map((action) => action.map(BigInt)).reverse()\n  );\n  let actions = MerkleActions.fromFields(actionType, actionFields, fromActionState);\n\n  let actionState = fromActionState;\n  let witnesses: ActionWitnesses = [];\n\n  let hashes = actionFields.map((actions) =>\n    actions.reduce(pushAction, ActionsBigint.empty().hash)\n  );\n  for (let actionsHash of hashes) {\n    witnesses.push({ hash: actionsHash, stateBefore: actionState });\n    actionState = ActionsBigint.updateSequenceState(actionState, actionsHash);\n  }\n  return { endActionState: actionState, witnesses, actions };\n}\n\nfunction pushAction(actionsHash: bigint, action: bigint[]): bigint {\n  return hashWithPrefixBigint(prefixes.sequenceEvents, [\n    actionsHash,\n    hashWithPrefixBigint(prefixes.event, action),\n  ]);\n}\n\n// recursive action stacking proof\n\n/**\n * Prove that a list of actions can be stacked in reverse order.\n *\n * Does not process reversing of all input actions - instead, we leave a final chunk of actions unprocessed.\n * The final chunk will be done in the smart contract which also verifies the proof.\n */\nasync function provePartialActionStack(\n  endActionState: bigint,\n  witnesses: ActionWitnesses,\n  program: ActionStackProgram,\n  finalChunkSize: number\n) {\n  let finalActionsChunk = witnesses.slice(0, finalChunkSize);\n  let remainingActions = witnesses.slice(finalChunkSize);\n\n  let { isEmpty, proof } = await proveActionStack(endActionState, remainingActions, program);\n  return {\n    proof,\n    isRecursive: isEmpty.not(),\n    finalWitnesses: Unconstrained.from(finalActionsChunk),\n  };\n}\n\nasync function proveActionStack(\n  endActionState: bigint | Field,\n  actions: ActionWitnesses,\n  program: ActionStackProgram\n): Promise<{\n  isEmpty: Bool;\n  proof: ActionStackProof;\n}> {\n  endActionState = Field(endActionState);\n  let { maxUpdatesPerProof } = program;\n  const ActionStackProof = ZkProgram.Proof(program);\n\n  let n = actions.length;\n  let isEmpty = Bool(n === 0);\n\n  // compute the final stack up front: actions in reverse order\n  let stack = MerkleActionHashes().empty();\n  for (let action of [...actions].reverse()) {\n    if (action === undefined) continue;\n    stack.push(Field(action.hash));\n  }\n\n  // if proofs are disabled, return a dummy proof\n  if (!getProofsEnabled()) {\n    let startActionState = actions[0]?.stateBefore ?? endActionState;\n    let proof = await ActionStackProof.dummy(\n      endActionState,\n      { actions: Field(startActionState), stack: stack.hash },\n      1,\n      14\n    );\n    return { isEmpty, proof };\n  }\n\n  // split actions in chunks of `maxUpdatesPerProof` each\n  let chunks: Unconstrained<ActionWitnesses>[] = [];\n  let nChunks = Math.ceil(n / maxUpdatesPerProof);\n\n  for (let i = 0, k = 0; i < nChunks; i++) {\n    let batch: ActionWitnesses = [];\n    for (let j = 0; j < maxUpdatesPerProof; j++, k++) {\n      batch[j] = actions[k];\n    }\n    chunks[i] = Unconstrained.from(batch);\n  }\n\n  // dummy proof; will be returned if there are no actions\n  let proof = await ActionStackProof.dummy(\n    Field(0),\n    { actions: emptyActionState, stack: emptyActionState },\n    1,\n    14\n  );\n\n  for (let i = nChunks - 1; i >= 0; i--) {\n    let isRecursive = Bool(i < nChunks - 1);\n    ({ proof } = await program.proveChunk(endActionState, proof, isRecursive, chunks[i]));\n  }\n  // sanity check\n  proof.publicOutput.stack.assertEquals(stack.hash, 'Stack hash mismatch');\n\n  return { isEmpty, proof };\n}\n\n/**\n * Intermediate result of popping from a list of actions and stacking them in reverse order.\n */\nclass ActionStackState extends Struct({\n  actions: Field,\n  stack: Field,\n}) {}\n\ntype ActionStackProof = Proof<Field, ActionStackState>;\ntype ActionWitnesses = ({ hash: bigint; stateBefore: bigint } | undefined)[];\n\nclass OptionActionWitness extends Option(Struct({ hash: Field, stateBefore: Field })) {}\n\ntype ActionStackProgram = {\n  name: string;\n  publicInputType: typeof Field;\n  publicOutputType: typeof ActionStackState;\n\n  compile(): Promise<{ verificationKey: { data: string; hash: Field } }>;\n\n  proveChunk(\n    input: Field,\n    proofSoFar: ActionStackProof,\n    isRecursive: Bool,\n    actionWitnesses: Unconstrained<ActionWitnesses>\n  ): Promise<{ proof: ActionStackProof }>;\n\n  maxUpdatesPerProof: number;\n};\n\n/**\n * Process a chunk of size `maxUpdatesPerProof` from the input actions,\n * stack them in reverse order.\n */\nfunction actionStackChunk(\n  maxUpdatesPerProof: number,\n  startState: ActionStackState,\n  witnesses: Unconstrained<ActionWitnesses>\n): ActionStackState {\n  // we pop off actions from the input merkle list (= input.actions + actionHashes),\n  // and push them onto a new merkle list\n  let stack = MerkleActionHashes(startState.stack).empty();\n  let actions = startState.actions;\n\n  for (let i = maxUpdatesPerProof - 1; i >= 0; i--) {\n    let { didPop, state, hash } = pop(actions, i, witnesses);\n    stack.pushIf(didPop, hash);\n    actions = state;\n  }\n\n  return new ActionStackState({ actions, stack: stack.hash });\n}\n\n/**\n * Create program that pops actions from a hash list and pushes them to a new list in reverse order.\n */\nfunction actionStackProgram(maxUpdatesPerProof: number) {\n  let program = ZkProgram({\n    name: 'action-stack-prover',\n\n    // input: actions to pop from\n    publicInput: Field,\n\n    // output: actions after popping, and the new stack\n    publicOutput: ActionStackState,\n\n    methods: {\n      proveChunk: {\n        privateInputs: [SelfProof, Bool, Unconstrained.withEmpty<ActionWitnesses>([])],\n\n        async method(\n          input: Field,\n          proofSoFar: ActionStackProof,\n          isRecursive: Bool,\n          witnesses: Unconstrained<ActionWitnesses>\n        ) {\n          // make this proof extend proofSoFar\n          proofSoFar.verifyIf(isRecursive);\n          Provable.assertEqualIf(isRecursive, Field, input, proofSoFar.publicInput);\n          let initialState = { actions: input, stack: emptyActionState };\n          let startState = Provable.if(\n            isRecursive,\n            ActionStackState,\n            proofSoFar.publicOutput,\n            initialState\n          );\n          let publicOutput = actionStackChunk(maxUpdatesPerProof, startState, witnesses);\n          return { publicOutput };\n        },\n      },\n    },\n  });\n  return Object.assign(program, { maxUpdatesPerProof });\n}\n\n/**\n * Proves: \"Here are some actions that got me from the new state to the current state\"\n *\n * Can also return a None option if there are no actions or the prover chooses to skip popping an action.\n */\nfunction pop(\n  state: Field,\n  i: number,\n  witnesses: Unconstrained<ActionWitnesses>\n): { didPop: Bool; state: Field; hash: Field } {\n  let { isSome, value: witness } = Provable.witness(OptionActionWitness, () => witnesses.get()[i]);\n  let impliedState = Actions.updateSequenceState(witness.stateBefore, witness.hash);\n  Provable.assertEqualIf(isSome, Field, impliedState, state);\n  return {\n    didPop: isSome,\n    state: Provable.if(isSome, witness.stateBefore, state),\n    hash: witness.hash,\n  };\n}\n", "/**\n * This defines a custom way to serialize various kinds of offchain state into an action.\n *\n * There is a special trick of including Merkle map (keyHash, valueHash) pairs _at the end_ of each action.\n * Thanks to the properties of Poseidon, this enables us to compute the action hash cheaply\n * if we only need to prove that (key, value) are part of it.\n */\n\nimport { ProvablePure, ProvableType, WithProvable } from '../../../provable/types/provable-intf.js';\nimport {\n  Poseidon,\n  ProvableHashable,\n  hashWithPrefix,\n  packToFields,\n  salt,\n} from '../../../provable/crypto/poseidon.js';\nimport { Field, Bool } from '../../../provable/wrapped.js';\nimport { assert } from '../../../provable/gadgets/common.js';\nimport { prefixes } from '../../../../bindings/crypto/constants.js';\nimport { Struct } from '../../../provable/types/struct.js';\nimport { Unconstrained } from '../../../provable/types/unconstrained.js';\nimport { MerkleList } from '../../../provable/merkle-list.js';\nimport * as Mina from '../mina.js';\nimport { PublicKey } from '../../../provable/crypto/signature.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { Actions } from '../account-update.js';\nimport { Option } from '../../../provable/option.js';\nimport { IndexedMerkleMap, IndexedMerkleMapBase } from '../../../provable/merkle-tree-indexed.js';\n\nexport {\n  toKeyHash,\n  toAction,\n  fromActionWithoutHashes,\n  MerkleLeaf,\n  LinearizedAction,\n  LinearizedActionList,\n  ActionList,\n  fetchMerkleLeaves,\n  fetchMerkleMap,\n  updateMerkleMap,\n  Actionable,\n};\n\ntype Action = [...Field[], Field, Field];\ntype Actionable<T, V = any> = WithProvable<ProvableHashable<T, V> & ProvablePure<T, V>>;\n\nfunction toKeyHash<K, KeyType extends Actionable<K> | undefined>(\n  prefix: Field,\n  keyType: KeyType,\n  key: KeyType extends undefined ? undefined : K\n): Field {\n  return hashPackedWithPrefix([prefix, Field(0)], keyType, key);\n}\n\nfunction toAction<K, V, KeyType extends Actionable<K> | undefined>({\n  prefix,\n  keyType,\n  valueType,\n  key,\n  value,\n  previousValue,\n}: {\n  prefix: Field;\n  keyType: KeyType;\n  valueType: Actionable<V>;\n  key: KeyType extends undefined ? undefined : K;\n  value: V;\n  previousValue?: Option<V>;\n}): Action {\n  valueType = ProvableType.get(valueType);\n  let valueSize = valueType.sizeInFields();\n  let padding = valueSize % 2 === 0 ? [] : [Field(0)];\n\n  let keyHash = hashPackedWithPrefix([prefix, Field(0)], keyType, key);\n\n  let usesPreviousValue = Bool(previousValue !== undefined).toField();\n  let previousValueHash =\n    previousValue !== undefined\n      ? Provable.if(\n          previousValue.isSome,\n          Poseidon.hashPacked(valueType, previousValue.value),\n          Field(0)\n        )\n      : Field(0);\n  let valueHash = Poseidon.hashPacked(valueType, value);\n\n  return [\n    ...valueType.toFields(value),\n    ...padding,\n    usesPreviousValue,\n    previousValueHash,\n    keyHash,\n    valueHash,\n  ];\n}\n\nfunction fromActionWithoutHashes<V>(valueType: Actionable<V>, action: Field[]): V {\n  valueType = ProvableType.get(valueType);\n  let valueSize = valueType.sizeInFields();\n  let paddingSize = valueSize % 2 === 0 ? 0 : 1;\n  assert(action.length === valueSize + paddingSize, 'invalid action size');\n\n  let value = valueType.fromFields(action.slice(0, valueSize));\n  valueType.check(value);\n\n  return value;\n}\n\nfunction hashPackedWithPrefix<T, Type extends Actionable<T> | undefined>(\n  prefix: [Field, Field],\n  type: Type,\n  value: Type extends undefined ? undefined : T\n) {\n  // hash constant prefix\n  let state = Poseidon.initialState();\n  state = Poseidon.update(state, prefix);\n\n  // hash value if a type was passed in\n  if (type !== undefined) {\n    let input = ProvableType.get(type).toInput(value as T);\n    let packed = packToFields(input);\n    state = Poseidon.update(state, packed);\n  }\n  return state[0];\n}\n\n/**\n * This represents a custom kind of action which includes a Merkle map key and value in its serialization,\n * and doesn't represent the rest of the action's field elements in provable code.\n */\nclass MerkleLeaf extends Struct({\n  key: Field,\n  value: Field,\n  usesPreviousValue: Bool,\n  previousValue: Field,\n  prefix: Unconstrained.withEmpty<Field[]>([]),\n}) {\n  static fromAction(action: Field[]) {\n    assert(action.length >= 4, 'invalid action size');\n    let [usesPreviousValue_, previousValue, key, value] = action.slice(-4);\n    let usesPreviousValue = usesPreviousValue_.assertBool();\n    let prefix = Unconstrained.from(action.slice(0, -4));\n    return new MerkleLeaf({\n      usesPreviousValue,\n      previousValue,\n      key,\n      value,\n      prefix,\n    });\n  }\n\n  /**\n   * A custom method to hash an action which only hashes the key and value in provable code.\n   * Therefore, it only proves that the key and value are part of the action, and nothing about\n   * the rest of the action.\n   */\n  static hash(action: MerkleLeaf) {\n    let preHashState = Provable.witnessFields(3, () => {\n      let prefix = action.prefix.get();\n      let init = salt(prefixes.event) as [Field, Field, Field];\n      return Poseidon.update(init, prefix);\n    });\n    return Poseidon.update(preHashState, [\n      action.usesPreviousValue.toField(),\n      action.previousValue,\n      action.key,\n      action.value,\n    ])[0];\n  }\n}\n\nfunction pushAction(actionsHash: Field, action: MerkleLeaf) {\n  return hashWithPrefix(prefixes.sequenceEvents, [actionsHash, MerkleLeaf.hash(action)]);\n}\n\nclass ActionList extends MerkleList.create(MerkleLeaf, pushAction, Actions.empty().hash) {}\n\nclass LinearizedAction extends Struct({\n  action: MerkleLeaf,\n  /**\n   * Whether this action is the last in an account update.\n   * In a linearized sequence of actions, this value determines the points at which we commit an atomic update to the Merkle tree.\n   */\n  isCheckPoint: Bool,\n}) {\n  /**\n   * A custom method to hash an action which only hashes the key and value in provable code.\n   * Therefore, it only proves that the key and value are part of the action, and nothing about\n   * the rest of the action.\n   */\n  static hash({ action, isCheckPoint }: LinearizedAction) {\n    let preHashState = Provable.witnessFields(3, () => {\n      let prefix = action.prefix.get();\n      let init = salt(prefixes.event) as [Field, Field, Field];\n      return Poseidon.update(init, prefix);\n    });\n    return Poseidon.update(preHashState, [\n      // pack two bools into 1 field\n      action.usesPreviousValue.toField().add(isCheckPoint.toField().mul(2)),\n      action.previousValue,\n      action.key,\n      action.value,\n    ])[0];\n  }\n}\n\nclass LinearizedActionList extends MerkleList.create(\n  LinearizedAction,\n  (hash: Field, action: LinearizedAction) => Poseidon.hash([hash, LinearizedAction.hash(action)]),\n  Actions.empty().hash\n) {}\n\nasync function fetchMerkleLeaves(\n  contract: { address: PublicKey; tokenId: Field },\n  config?: {\n    fromActionState?: Field;\n    endActionState?: Field;\n  }\n): Promise<MerkleList<MerkleList<MerkleLeaf>>> {\n  class MerkleActions extends MerkleList.create(\n    ActionList,\n    (hash: Field, actions: ActionList) => Actions.updateSequenceState(hash, actions.hash),\n    // if no \"start\" action hash was specified, this means we are fetching the entire history of actions, which started from the empty action state hash\n    // otherwise we are only fetching a part of the history, which starts at `fromActionState`\n    config?.fromActionState ?? Actions.emptyActionState()\n  ) {}\n\n  let result = await Mina.fetchActions(contract.address, config, contract.tokenId);\n  if ('error' in result) throw Error(JSON.stringify(result));\n\n  // convert string-Fields back into the original action type\n  let merkleLeafs = result.map((event) =>\n    event.actions.map((action) => MerkleLeaf.fromAction(action.map(Field)))\n  );\n  return MerkleActions.from(merkleLeafs.map((a) => ActionList.fromReverse(a)));\n}\n\n// TODO this should be `updateMerkleMap`, and we should call it on every get() and settle()\n/**\n * Recreate Merkle tree from fetched actions.\n *\n * We also deserialize a keyHash -> value map from the leaves.\n */\nasync function fetchMerkleMap(\n  height: number,\n  contract: { address: PublicKey; tokenId: Field },\n  endActionState?: Field\n): Promise<{\n  merkleMap: IndexedMerkleMapBase;\n  valueMap: Map<bigint, Field[]>;\n}> {\n  let result = await Mina.fetchActions(contract.address, { endActionState }, contract.tokenId);\n  if ('error' in result) throw Error(JSON.stringify(result));\n\n  let leaves = result.map((event) =>\n    event.actions.map((action) => MerkleLeaf.fromAction(action.map(Field))).reverse()\n  );\n\n  let merkleMap = new (IndexedMerkleMap(height))();\n  let valueMap = new Map<bigint, Field[]>();\n\n  updateMerkleMap(leaves, merkleMap, valueMap);\n\n  return { merkleMap, valueMap };\n}\n\nfunction updateMerkleMap(\n  updates: MerkleLeaf[][],\n  tree: IndexedMerkleMapBase,\n  valueMap?: Map<bigint, Field[]>\n) {\n  let intermediateTree = tree.clone();\n\n  for (let leaves of updates) {\n    let isValidUpdate = true;\n    let updates: { key: bigint; fullValue: Field[] }[] = [];\n\n    for (let leaf of leaves) {\n      let { key, value, usesPreviousValue, previousValue, prefix } = MerkleLeaf.toValue(leaf);\n\n      // the update is invalid if there is an unsatisfied precondition\n      let previous = intermediateTree.getOption(key).orElse(0n);\n      let isValidAction = !usesPreviousValue || previous.toBigInt() === previousValue;\n\n      if (!isValidAction) {\n        isValidUpdate = false;\n        break;\n      }\n\n      // update the intermediate tree, save updates for final tree\n      intermediateTree.set(key, value);\n      updates.push({ key, fullValue: prefix });\n    }\n\n    if (isValidUpdate) {\n      // if the update was valid, we can commit the updates\n      tree.overwrite(intermediateTree);\n      for (let { key, fullValue } of updates) {\n        if (valueMap) valueMap.set(key, fullValue);\n      }\n    } else {\n      // if the update was invalid, we have to roll back the intermediate tree\n      intermediateTree.overwrite(tree);\n    }\n  }\n}\n", "import { ZkProgram } from '../../../proof-system/zkprogram.js';\nimport { Proof } from '../../../proof-system/proof.js';\nimport { Bool, Field } from '../../../provable/wrapped.js';\nimport { MerkleList, MerkleListIterator } from '../../../provable/merkle-list.js';\nimport { Actions } from '../../../../bindings/mina-transaction/v1/transaction-leaves.js';\nimport { IndexedMerkleMap, IndexedMerkleMapBase } from '../../../provable/merkle-tree-indexed.js';\nimport { Struct } from '../../../provable/types/struct.js';\nimport { SelfProof } from '../../../proof-system/zkprogram.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { assert } from '../../../provable/gadgets/common.js';\nimport {\n  ActionList,\n  LinearizedAction,\n  LinearizedActionList,\n  MerkleLeaf,\n  updateMerkleMap,\n} from './offchain-state-serialization.js';\nimport { getProofsEnabled } from '../mina.js';\nimport { Cache } from '../../../../lib/proof-system/cache.js';\n\nexport { OffchainStateRollup, OffchainStateCommitments };\n\nclass ActionIterator extends MerkleListIterator.create(\n  ActionList,\n  (hash: Field, actions: ActionList) => Actions.updateSequenceState(hash, actions.hash),\n  // we don't have to care about the initial hash here because we will just step forward\n  Actions.emptyActionState()\n) {}\n\n/**\n * Commitments that keep track of the current state of an offchain Merkle tree constructed from actions.\n * Intended to be stored on-chain.\n *\n * Fields:\n * - `root`: The root of the current Merkle tree\n * - `length`: The number of elements in the current Merkle tree\n * - `actionState`: The hash pointing to the list of actions that have been applied to form the current Merkle tree\n */\nclass OffchainStateCommitments extends Struct({\n  // this should just be a MerkleTree type that carries the full tree as aux data\n  root: Field,\n  length: Field,\n  // TODO: make zkprogram support auxiliary data in public inputs\n  // actionState: ActionIterator,\n  actionState: Field,\n}) {\n  static emptyFromHeight(height: number) {\n    let emptyMerkleTree = new (IndexedMerkleMap(height))();\n    return new OffchainStateCommitments({\n      root: emptyMerkleTree.root,\n      length: emptyMerkleTree.length,\n      actionState: Actions.emptyActionState(),\n    });\n  }\n}\n\n// TODO: it would be nice to abstract the logic for proving a chain of state transition proofs\n\n/**\n * Common logic for the proof that we can go from OffchainStateCommitments A -> B\n */\nfunction merkleUpdateBatch(\n  {\n    maxActionsPerProof,\n    maxActionsPerUpdate,\n  }: {\n    maxActionsPerProof: number;\n    maxActionsPerUpdate: number;\n  },\n  stateA: OffchainStateCommitments,\n  actions: ActionIterator,\n  tree: IndexedMerkleMapBase\n): { commitments: OffchainStateCommitments; tree: IndexedMerkleMapBase } {\n  // this would be unnecessary if the iterator could just be the public input\n  actions.currentHash.assertEquals(stateA.actionState);\n\n  // linearize actions into a flat MerkleList, so we don't process an insane amount of dummy actions\n  let linearActions = LinearizedActionList.empty();\n\n  for (let i = 0; i < maxActionsPerProof; i++) {\n    let inner = actions.next().startIterating();\n    let isAtEnd = Bool(false);\n    for (let i = 0; i < maxActionsPerUpdate; i++) {\n      let { element: action, isDummy } = inner.Unsafe.next();\n      let isCheckPoint = inner.isAtEnd();\n      [isAtEnd, isCheckPoint] = [isAtEnd.or(isCheckPoint), isCheckPoint.and(isAtEnd.not())];\n      linearActions.pushIf(isDummy.not(), new LinearizedAction({ action, isCheckPoint }));\n    }\n    inner.assertAtEnd(`Expected at most ${maxActionsPerUpdate} actions per account update.`);\n  }\n  actions.assertAtEnd();\n\n  // tree must match the public Merkle root and length; the method operates on the tree internally\n  // TODO: this would be simpler if the tree was the public input directly\n  stateA.root.assertEquals(tree.root);\n  stateA.length.assertEquals(tree.length);\n\n  let intermediateTree = tree.clone();\n  let isValidUpdate = Bool(true);\n\n  linearActions.forEach(maxActionsPerProof, (element, isDummy) => {\n    let { action, isCheckPoint } = element;\n    let { key, value, usesPreviousValue, previousValue } = action;\n\n    // set (key, value) in the intermediate tree - if the action is not a dummy\n    let actualPreviousValue = intermediateTree.setIf(isDummy.not(), key, value);\n\n    // if an expected previous value was provided, check whether it matches the actual previous value\n    // otherwise, the entire update in invalidated\n    let matchesPreviousValue = actualPreviousValue.orElse(0n).equals(previousValue);\n    let isValidAction = usesPreviousValue.implies(matchesPreviousValue);\n    isValidUpdate = isValidUpdate.and(isValidAction);\n\n    // at checkpoints, update the tree, if the entire update was valid\n    tree.overwriteIf(isCheckPoint.and(isValidUpdate), intermediateTree);\n\n    // at checkpoints, reset intermediate values\n    isValidUpdate = Provable.if(isCheckPoint, Bool(true), isValidUpdate);\n    intermediateTree.overwriteIf(isCheckPoint, tree);\n  });\n\n  return {\n    commitments: {\n      root: tree.root,\n      length: tree.length,\n      actionState: actions.currentHash,\n    },\n    tree,\n  };\n}\n\n/**\n * This program represents a proof that we can go from OffchainStateCommitments A -> B\n */\nfunction OffchainStateRollup({\n  /**\n   * the constraints used in one batch proof with a height-31 tree are:\n   *\n   * 1967*A + 87*A*U + 2\n   *\n   * where A = maxActionsPerProof and U = maxActionsPerUpdate.\n   *\n   * To determine defaults, we set U=4 which should cover most use cases while ensuring\n   * that the main loop which is independent of U dominates.\n   *\n   * Targeting ~50k constraints, to leave room for recursive verification, yields A=22.\n   */\n  maxActionsPerProof = 22,\n  maxActionsPerUpdate = 4,\n  logTotalCapacity = 30,\n} = {}) {\n  class IndexedMerkleMapN extends IndexedMerkleMap(logTotalCapacity + 1) {}\n\n  let offchainStateRollup = ZkProgram({\n    name: 'merkle-map-rollup',\n    publicInput: OffchainStateCommitments,\n    publicOutput: OffchainStateCommitments,\n    methods: {\n      /**\n       * `firstBatch()` creates the initial proof A -> B\n       */\n      firstBatch: {\n        // [actions, tree]\n        privateInputs: [ActionIterator, IndexedMerkleMapN],\n        auxiliaryOutput: IndexedMerkleMapN,\n\n        async method(\n          stateA: OffchainStateCommitments,\n          actions: ActionIterator,\n          tree: IndexedMerkleMapN\n        ) {\n          let result = merkleUpdateBatch(\n            { maxActionsPerProof, maxActionsPerUpdate },\n            stateA,\n            actions,\n            tree\n          );\n          return {\n            publicOutput: result.commitments,\n            auxiliaryOutput: result.tree,\n          };\n        },\n      },\n      /**\n       * `nextBatch()` takes an existing proof A -> B, adds its own logic to prove B -> B', so that the output is a proof A -> B'\n       */\n      nextBatch: {\n        // [actions, tree, proof]\n        privateInputs: [ActionIterator, IndexedMerkleMapN, SelfProof],\n        auxiliaryOutput: IndexedMerkleMapN,\n\n        async method(\n          stateA: OffchainStateCommitments,\n          actions: ActionIterator,\n          tree: IndexedMerkleMapN,\n          recursiveProof: Proof<OffchainStateCommitments, OffchainStateCommitments>\n        ) {\n          recursiveProof.verify();\n\n          // in the recursive case, the recursive proof's initial state has to match this proof's initial state\n          Provable.assertEqual(OffchainStateCommitments, recursiveProof.publicInput, stateA);\n\n          // the state we start with\n          let stateB = recursiveProof.publicOutput;\n\n          let result = merkleUpdateBatch(\n            { maxActionsPerProof, maxActionsPerUpdate },\n            stateB,\n            actions,\n            tree\n          );\n          return {\n            publicOutput: result.commitments,\n            auxiliaryOutput: result.tree,\n          };\n        },\n      },\n    },\n  });\n\n  let RollupProof = offchainStateRollup.Proof;\n\n  let isCompiled = false;\n\n  return {\n    Proof: RollupProof,\n    program: offchainStateRollup,\n\n    async compile(options?: { cache?: Cache; forceRecompile?: boolean; proofsEnabled?: boolean }) {\n      if (isCompiled) return;\n      let result = await offchainStateRollup.compile(options);\n      isCompiled = true;\n      return result;\n    },\n\n    async prove(tree: IndexedMerkleMapN, actions: MerkleList<MerkleList<MerkleLeaf>>) {\n      assert(tree.height === logTotalCapacity + 1, 'Tree height must match');\n      if (getProofsEnabled()) await this.compile();\n      // clone the tree so we don't modify the input\n      tree = tree.clone();\n\n      // input state\n      let iterator = actions.startIterating();\n      let inputState = new OffchainStateCommitments({\n        root: tree.root,\n        length: tree.length,\n        actionState: iterator.currentHash,\n      });\n\n      // if proofs are disabled, create a dummy proof and final state, and return\n      if (!getProofsEnabled()) {\n        // convert actions to nested array\n        let actionsList = actions.data\n          .get()\n          .map(({ element: actionsList }) =>\n            actionsList.data\n              .get()\n              .map(({ element }) => element)\n              // TODO reverse needed because of bad internal merkle list representation\n              .reverse()\n          )\n          // TODO reverse needed because of bad internal merkle list representation\n          .reverse();\n\n        // update the tree outside the circuit\n        updateMerkleMap(actionsList, tree);\n\n        let finalState = new OffchainStateCommitments({\n          root: tree.root,\n          length: tree.length,\n          actionState: iterator.hash,\n        });\n        let proof = await RollupProof.dummy(inputState, finalState, 2, 15);\n        return { proof, tree, nProofs: 0 };\n      }\n\n      // base proof\n      let slice = sliceActions(iterator, maxActionsPerProof);\n      let { proof, auxiliaryOutput } = await offchainStateRollup.firstBatch(\n        inputState,\n        slice,\n        tree\n      );\n\n      // overwrite the tree with its updated version\n      tree = auxiliaryOutput;\n\n      // recursive proofs\n      let nProofs = 1;\n      for (let i = 1; ; i++) {\n        if (iterator.isAtEnd().toBoolean()) break;\n        nProofs++;\n\n        let slice = sliceActions(iterator, maxActionsPerProof);\n\n        // overwrite tree, proof\n        ({ proof, auxiliaryOutput: tree } = await offchainStateRollup.nextBatch(\n          inputState,\n          slice,\n          tree,\n          proof\n        ));\n      }\n\n      return { proof, tree, nProofs };\n    },\n  };\n}\n\n// from a nested list of actions, create a slice (iterator) starting at `index` that has at most `batchSize` actions in it.\n// also moves the original iterator forward to start after the slice\nfunction sliceActions(actions: ActionIterator, batchSize: number) {\n  class ActionListsList extends MerkleList.create(\n    ActionList,\n    (hash: Field, actions: ActionList) => Actions.updateSequenceState(hash, actions.hash),\n    actions.currentHash\n  ) {}\n\n  let slice = ActionListsList.empty();\n  let totalSize = 0;\n\n  while (true) {\n    // stop if we reach the end of the list\n    if (actions.isAtEnd().toBoolean()) break;\n\n    let nextList = actions.data.get()[actions._index('next')].element;\n    let nextSize = nextList.data.get().length;\n    assert(nextSize <= batchSize, 'Actions in one update exceed maximum batch size');\n    if (totalSize + nextSize > batchSize) break;\n\n    let nextMerkleList = actions.next();\n    slice.push(nextMerkleList);\n    totalSize += nextSize;\n  }\n\n  return slice.startIterating();\n}\n", "import { InferProvable } from '../../../provable/types/struct.js';\nimport {\n  Actionable,\n  fetchMerkleLeaves,\n  fetchMerkleMap,\n  fromActionWithoutHashes,\n  toAction,\n  toKeyHash,\n} from './offchain-state-serialization.js';\nimport { Field } from '../../../provable/wrapped.js';\nimport { Proof } from '../../../proof-system/proof.js';\nimport { OffchainStateCommitments, OffchainStateRollup } from './offchain-state-rollup.js';\nimport { Option, OptionOrValue } from '../../../provable/option.js';\nimport { Constructor, InferValue } from '../../../../bindings/lib/provable-generic.js';\nimport { SmartContract } from '../zkapp.js';\nimport { assert } from '../../../provable/gadgets/common.js';\nimport { State } from '../state.js';\nimport { Actions } from '../account-update.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { Poseidon } from '../../../provable/crypto/poseidon.js';\nimport { contract } from '../smart-contract-context.js';\nimport { IndexedMerkleMap } from '../../../provable/merkle-tree-indexed.js';\nimport { assertDefined } from '../../../util/assert.js';\nimport { ProvableType } from '../../../provable/types/provable-intf.js';\n\n// external API\nexport { OffchainState, OffchainStateCommitments };\n\n// internal API\nexport { OffchainField, OffchainMap, OffchainStateInstance };\n\ntype OffchainStateInstance<Config extends { [key: string]: OffchainStateKind }> = {\n  /**\n   * The individual fields of the offchain state.\n   *\n   * ```ts\n   * const state = OffchainState({ totalSupply: OffchainState.Field(UInt64) });\n   *\n   * state.fields.totalSupply.overwrite(UInt64.from(100));\n   *\n   * let supply = await state.fields.totalSupply.get();\n   * ```\n   */\n  readonly fields: {\n    [K in keyof Config]: OffchainStateIntf<Config[K]>;\n  };\n\n  /**\n   * Set the contract that this offchain state instance is connected with.\n   *\n   * This tells the offchain state about the account to fetch data from and modify, and lets it handle actions and onchain state.\n   */\n  setContractInstance(contractInstance: OffchainStateContract<Config>): void;\n\n  /**\n   * Set the smart contract class that this offchain state instance is connected with.\n   *\n   * This is an alternative for `setContractInstance()` which lets you compile offchain state without having a contract instance.\n   * However, you must call `setContractInstance()` before calling `createSettlementProof()`.\n   */\n  setContractClass(contractClass: OffchainStateContractClass<Config>): void;\n\n  /**\n   * Create a proof that updates the commitments to offchain state: Merkle root and action state.\n   */\n  createSettlementProof(): Promise<Proof<OffchainStateCommitments, OffchainStateCommitments>>;\n\n  /**\n   * Settle the offchain state.\n   *\n   * Use this in a contract method as follows:\n   *\n   * @example\n   * ```ts\n   * class StateProof extends offchainState.Proof {}\n   *\n   * const offchainState = OffchainState(...);\n   *\n   * const offchainStateInstance = offchainState.init();\n   *\n   * class MyContract extends SmartContract {\n   *   @state(OffchainStateCommitments) offchainStateCommitments = State(OffchainStateCommitments.empty());\n   *\n   *   offchainState = offchainStateInstance;\n   *\n   *   \\@method\n   *   async settle(proof: StateProof) {\n   */\n  settle(proof: Proof<OffchainStateCommitments, OffchainStateCommitments>): Promise<void>;\n\n  /**\n   * Commitments to the offchain state, to use in your onchain state.\n   */\n  commitments(): State<OffchainStateCommitments>;\n};\n\ntype OffchainState<Config extends { [key: string]: OffchainStateKind }> = {\n  /**\n   * Compile the offchain state ZkProgram.\n   */\n  compile(): Promise<void>;\n\n  /**\n   * The custom proof class for state settlement proofs, that have to be passed into the settling method.\n   */\n  Proof: typeof Proof<OffchainStateCommitments, OffchainStateCommitments>;\n\n  /**\n   * Create an empty set of offchain state commitments to use as a default value\n   */\n  emptyCommitments(): State<OffchainStateCommitments>;\n\n  /**\n   * Initialize an offchain state instance for a specific contract, or\n   * return a memoized instance if one already exists for the contract.\n   */\n  init(contractInstance: OffchainStateContract<Config>): OffchainStateInstance<Config>;\n};\n\ntype OffchainStateContract<Config extends { [key: string]: OffchainStateKind }> = SmartContract & {\n  offchainStateCommitments: State<OffchainStateCommitments>;\n  offchainState: OffchainStateInstance<Config>;\n};\ntype OffchainStateContractClass<Config extends { [key: string]: OffchainStateKind }> =\n  typeof SmartContract & Constructor<OffchainStateContract<Config>>;\n\n/**\n * Offchain state for a `SmartContract`.\n *\n * ```ts\n * // declare your offchain state\n *\n * const offchainState = OffchainState({\n *   accounts: OffchainState.Map(PublicKey, UInt64),\n *   totalSupply: OffchainState.Field(UInt64),\n * });\n *\n * // use it in a contract, by adding an onchain state field of type `OffchainStateCommitments`\n *\n * class MyContract extends SmartContract {\n *  \\@state(OffchainStateCommitments) offchainState = State(\n *    OffchainStateCommitments.empty()\n *   );\n *\n *   // ...\n * }\n *\n * // set the contract instance\n *\n * let contract = new MyContract(address);\n * offchainState.setContractInstance(contract);\n * ```\n *\n * See the individual methods on `offchainState` for more information on usage.\n */\nfunction OffchainState<const Config extends { [key: string]: OffchainStateKind }>(\n  config: Config,\n  options?: {\n    /**\n     * The base-2 logarithm of the total capacity of the offchain state.\n     *\n     * Example: if you want to have 1 million individual state fields and map entries available,\n     * set this to 20, because 2^20 ~= 1M.\n     *\n     * The default is 30, which allows for ~1 billion entries.\n     *\n     * Passing in lower numbers will reduce the number of constraints required to prove offchain state updates,\n     * which we will make proof creation slightly faster.\n     * Instead, you could also use a smaller total capacity to increase the `maxActionsPerProof`, so that fewer proofs are required,\n     * which will reduce the proof time even more, but only in the case of many actions.\n     */\n    logTotalCapacity?: number;\n    /**\n     * The maximum number of offchain state actions that can be included in a single account update.\n     *\n     * In other words, you must not call `.update()` or `.overwrite()` more than this number of times in any of your smart contract methods.\n     *\n     * The default is 4.\n     *\n     * Note: When increasing this, consider decreasing `maxActionsPerProof` or `logTotalCapacity` in order to not exceed the circuit size limit.\n     */\n    maxActionsPerUpdate?: number;\n    maxActionsPerProof?: number;\n  }\n): OffchainState<Config> {\n  // read options\n  let { logTotalCapacity = 30, maxActionsPerUpdate = 4, maxActionsPerProof } = options ?? {};\n  const height = logTotalCapacity + 1;\n  class IndexedMerkleMapN extends IndexedMerkleMap(height) {}\n\n  const emptyMerkleMapRoot = new IndexedMerkleMapN().root;\n\n  let rollup = OffchainStateRollup({\n    logTotalCapacity,\n    maxActionsPerProof,\n    maxActionsPerUpdate,\n  });\n\n  function OffchainStateInstance(): OffchainStateInstance<Config> {\n    type InternalState = {\n      _contract: OffchainStateContract<Config> | undefined;\n      _contractClass: OffchainStateContractClass<Config> | undefined;\n      contract: OffchainStateContract<Config>;\n      contractClass: OffchainStateContractClass<Config>;\n      merkleMap: IndexedMerkleMapN;\n      valueMap: Map<bigint, Field[]>;\n    };\n\n    function defaultInternalState(): InternalState {\n      return {\n        _contract: undefined,\n        _contractClass: undefined,\n        merkleMap: new IndexedMerkleMapN(),\n        valueMap: new Map(),\n\n        get contract() {\n          return assertDefined(internal._contract, 'Must call `setContractInstance()` first');\n        },\n\n        get contractClass() {\n          return assertDefined(\n            internal._contractClass,\n            'Must call `setContractInstance()` or `setContractClass()` first'\n          );\n        },\n      };\n    }\n\n    // setup internal state of this \"class\"\n    let internal = defaultInternalState();\n\n    const onchainActionState = async () => {\n      let actionState = (await internal.contract.offchainStateCommitments.fetch())?.actionState;\n      assert(actionState !== undefined, 'Could not fetch action state');\n      return actionState;\n    };\n\n    const merkleMaps = async () => {\n      if (\n        internal.merkleMap.root.toString() !== emptyMerkleMapRoot.toString() ||\n        internal.valueMap.size > 0\n      ) {\n        return { merkleMap: internal.merkleMap, valueMap: internal.valueMap };\n      }\n      let actionState = await onchainActionState();\n      let { merkleMap, valueMap } = await fetchMerkleMap(height, internal.contract, actionState);\n      internal.merkleMap = merkleMap;\n      internal.valueMap = valueMap;\n      return { merkleMap, valueMap };\n    };\n\n    function getContract(): OffchainStateContract<Config> {\n      return contract(internal.contractClass);\n    }\n\n    function maybeContract() {\n      try {\n        return getContract();\n      } catch {\n        return internal.contract;\n      }\n    }\n\n    /**\n     * generic get which works for both fields and maps\n     */\n    async function get<V, VValue>(key: Field, valueType: Actionable<V, VValue>) {\n      // get onchain merkle root\n      let state = maybeContract().offchainStateCommitments.getAndRequireEquals();\n\n      // witness the merkle map & anchor against the onchain root\n      let map = await Provable.witnessAsync(\n        IndexedMerkleMapN,\n        async () => (await merkleMaps()).merkleMap\n      );\n      map.root.assertEquals(state.root, 'root mismatch');\n      map.length.assertEquals(state.length, 'length mismatch');\n\n      // get the value hash\n      let valueHash = map.getOption(key);\n\n      // witness the full value\n      const optionType = Option(valueType);\n      let value = await Provable.witnessAsync(optionType, async () => {\n        let { valueMap } = await merkleMaps();\n        let valueFields = valueMap.get(key.toBigInt());\n        if (valueFields === undefined) {\n          return optionType.none();\n        }\n        let value = fromActionWithoutHashes(valueType, valueFields);\n        return optionType.from(value);\n      });\n\n      // assert that the value hash matches the value, or both are none\n      let hashMatches = Poseidon.hashPacked(valueType, value.value).equals(valueHash.value);\n      let bothNone = value.isSome.or(valueHash.isSome).not();\n      assert(hashMatches.or(bothNone), 'value hash mismatch');\n\n      return value;\n    }\n\n    function field<T, TValue>(\n      index: number,\n      type: Actionable<T, TValue>\n    ): OffchainField<T, TValue> {\n      type = ProvableType.get(type);\n      const prefix = Field(index);\n      let optionType = Option(type);\n\n      return {\n        _type: type,\n\n        overwrite(value) {\n          // serialize into action\n          let action = toAction({\n            prefix,\n            keyType: undefined,\n            valueType: type,\n            key: undefined,\n            value: type.fromValue(value),\n          });\n\n          // push action on account update\n          let update = getContract().self;\n          update.body.actions = Actions.pushEvent(update.body.actions, action);\n        },\n\n        update({ from, to }) {\n          // serialize into action\n          let action = toAction({\n            prefix,\n            keyType: undefined,\n            valueType: type,\n            key: undefined,\n            value: type.fromValue(to),\n            previousValue: optionType.fromValue(from),\n          });\n\n          // push action on account update\n          let update = getContract().self;\n          update.body.actions = Actions.pushEvent(update.body.actions, action);\n        },\n\n        async get() {\n          let key = toKeyHash(prefix, undefined, undefined);\n          return await get(key, type);\n        },\n      };\n    }\n\n    function map<K, V, VValue>(\n      index: number,\n      keyType: Actionable<K>,\n      valueType: Actionable<V, VValue>\n    ): OffchainMap<K, V, VValue> {\n      keyType = ProvableType.get(keyType);\n      valueType = ProvableType.get(valueType);\n      const prefix = Field(index);\n      let optionType = Option(valueType);\n\n      return {\n        _keyType: keyType,\n        _valueType: valueType,\n\n        overwrite(key, value) {\n          // serialize into action\n          let action = toAction({\n            prefix,\n            keyType,\n            valueType,\n            key,\n            value: valueType.fromValue(value),\n          });\n\n          // push action on account update\n          let update = getContract().self;\n          update.body.actions = Actions.pushEvent(update.body.actions, action);\n        },\n\n        update(key, { from, to }) {\n          // serialize into action\n          let action = toAction({\n            prefix,\n            keyType,\n            valueType,\n            key,\n            value: valueType.fromValue(to),\n            previousValue: optionType.fromValue(from),\n          });\n\n          // push action on account update\n          let update = getContract().self;\n          update.body.actions = Actions.pushEvent(update.body.actions, action);\n        },\n\n        async get(key) {\n          let keyHash = toKeyHash(prefix, keyType, key);\n          return await get(keyHash, valueType);\n        },\n      };\n    }\n\n    return {\n      setContractInstance(contractInstance) {\n        internal._contract = contractInstance;\n        internal._contractClass =\n          contractInstance.constructor as OffchainStateContractClass<Config>;\n      },\n      setContractClass(contractClass) {\n        internal._contractClass = contractClass;\n      },\n      async createSettlementProof() {\n        let { merkleMap } = await merkleMaps();\n\n        // fetch pending actions\n        let actionState = await onchainActionState();\n        let actions = await fetchMerkleLeaves(internal.contract, {\n          fromActionState: actionState,\n        });\n\n        let result = await rollup.prove(merkleMap, actions);\n\n        // update internal merkle maps as well\n        // TODO make this not insanely recompute everything\n        // - take new tree from `result`\n        // - update value map in `prove()`, or separately based on `actions`\n        let { merkleMap: newMerkleMap, valueMap: newValueMap } = await fetchMerkleMap(\n          height,\n          internal.contract\n        );\n        internal.merkleMap = newMerkleMap;\n        internal.valueMap = newValueMap;\n\n        return result.proof;\n      },\n\n      async settle(proof: Proof<OffchainStateCommitments, OffchainStateCommitments>) {\n        // verify the proof\n        proof.verify();\n\n        // check that proof moves state forward from the one currently stored\n        let state = getContract().offchainStateCommitments.getAndRequireEquals();\n        Provable.assertEqual(OffchainStateCommitments, state, proof.publicInput);\n\n        // require that proof uses the correct pending actions\n        getContract().account.actionState.requireEquals(proof.publicOutput.actionState);\n\n        // update the state\n        getContract().offchainStateCommitments.set(proof.publicOutput);\n      },\n\n      commitments() {\n        return getContract().offchainStateCommitments;\n      },\n\n      fields: Object.fromEntries(\n        Object.entries(config).map(([key, kind], i) => [\n          key,\n          kind.kind === 'offchain-field'\n            ? field(i, kind.type)\n            : map(i, kind.keyType, kind.valueType),\n        ])\n      ) as any,\n    };\n  }\n\n  const memoizedInstances = new Map<String, OffchainStateInstance<Config>>();\n\n  return {\n    init(contractInstance: OffchainStateContract<Config>) {\n      let key = 'COMPILE_TIME';\n      let contractAddress = contractInstance.address;\n      if (contractAddress.isConstant()) {\n        key = contractAddress.toBase58();\n      } else {\n        Provable.asProver(() => {\n          key = contractAddress.toBase58();\n        });\n      }\n      let instance = memoizedInstances.get(key);\n      if (instance === undefined) {\n        instance = OffchainStateInstance();\n        instance.setContractClass(\n          contractInstance.constructor as OffchainStateContractClass<Config>\n        );\n        memoizedInstances.set(key, instance);\n      }\n      return instance;\n    },\n\n    async compile() {\n      await rollup.compile();\n    },\n\n    Proof: rollup.Proof,\n\n    emptyCommitments() {\n      return State(OffchainStateCommitments.emptyFromHeight(height));\n    },\n  };\n}\n\nOffchainState.Map = OffchainMap;\nOffchainState.Field = OffchainField;\nOffchainState.Commitments = OffchainStateCommitments;\n\n// type helpers\n\ntype Any = Actionable<any>;\n\nfunction OffchainField<T extends Any>(type: T) {\n  return { kind: 'offchain-field' as const, type };\n}\ntype OffchainField<T, TValue> = {\n  _type: Provable<T, TValue>;\n\n  /**\n   * Get the value of the field, or none if it doesn't exist yet.\n   */\n  get(): Promise<Option<T, TValue>>;\n\n  /**\n   * Update the value of the field, while requiring a specific previous value.\n   *\n   * If the previous value does not match, the update will not be applied.\n   *\n   * Note that the previous value is an option: to require that the field was not set before, use `Option(type).none()` or `undefined`.\n   */\n  update(update: { from: OptionOrValue<T, TValue>; to: T | TValue }): void;\n\n  /**\n   * Set the value of the field to the given value, without taking into account the previous value.\n   *\n   * **Warning**: if this is performed by multiple zkapp calls concurrently (between one call to `settle()` and the next),\n   * calls that are applied later will simply overwrite and ignore whatever changes were made by earlier calls.\n   *\n   * This behaviour can imply a security risk in many applications, so use `overwrite()` with caution.\n   */\n  overwrite(value: T | TValue): void;\n};\n\nfunction OffchainMap<K extends Any, V extends Any>(key: K, value: V) {\n  return { kind: 'offchain-map' as const, keyType: key, valueType: value };\n}\ntype OffchainMap<K, V, VValue> = {\n  _keyType: Provable<K>;\n  _valueType: Provable<V, VValue>;\n\n  /**\n   * Get the value for this key, or none if it doesn't exist.\n   */\n  get(key: K): Promise<Option<V, VValue>>;\n\n  /**\n   * Update the value of the field, while requiring a specific previous value.\n   *\n   * If the previous value does not match, the update will not be applied.\n   *\n   * Note that the previous value is an option: to require that the field was not set before, use `Option(type).none()` or `undefined`.\n   */\n  update(key: K, update: { from: OptionOrValue<V, VValue>; to: V | VValue }): void;\n\n  /**\n   * Set the value for this key to the given value, without taking into account the previous value.\n   *\n   * **Warning**: if the same key is modified by multiple zkapp calls concurrently (between one call to `settle()` and the next),\n   * calls that are applied later will simply overwrite and ignore whatever changes were made by earlier calls.\n   *\n   * This behaviour can imply a security risk in many applications, so use `overwrite()` with caution.\n   */\n  overwrite(key: K, value: V | VValue): void;\n};\n\ntype OffchainStateKind =\n  | { kind: 'offchain-field'; type: Any }\n  | { kind: 'offchain-map'; keyType: Any; valueType: Any };\n\ntype OffchainStateIntf<Kind extends OffchainStateKind> = Kind extends {\n  kind: 'offchain-field';\n  type: infer T;\n}\n  ? OffchainField<InferProvable<T>, InferValue<T>>\n  : Kind extends {\n        kind: 'offchain-map';\n        keyType: infer K;\n        valueType: infer V;\n      }\n    ? OffchainMap<InferProvable<K>, InferProvable<V>, InferValue<V>>\n    : never;\n", "import { From } from '../../bindings/lib/provable-generic.js';\nimport { Bool } from '../provable/bool.js';\nimport { Provable } from '../provable/provable.js';\nimport { ProvableType } from '../provable/types/provable-intf.js';\nimport { InferProvable } from '../provable/types/struct.js';\nimport { mapObject, mapToObject, zip } from '../util/arrays.js';\nimport { Tuple } from '../util/types.js';\nimport { Proof } from './proof.js';\nimport { Undefined, Void } from './zkprogram.js';\n\nexport { Recursive };\n\nfunction Recursive<\n  PublicInputType extends Provable<any>,\n  PublicOutputType extends Provable<any>,\n  PrivateInputs extends {\n    [Key in string]: Tuple<ProvableType>;\n  },\n>(\n  zkprogram: {\n    name: string;\n    publicInputType: PublicInputType;\n    publicOutputType: PublicOutputType;\n    privateInputTypes: PrivateInputs;\n    rawMethods: {\n      [Key in keyof PrivateInputs]: (\n        ...args: any\n      ) => Promise<{ publicOutput: InferProvable<PublicOutputType> }>;\n    };\n    maxProofsVerified: () => Promise<0 | 1 | 2>;\n  } & {\n    [Key in keyof PrivateInputs]: (...args: any) => Promise<{\n      proof: Proof<InferProvable<PublicInputType>, InferProvable<PublicOutputType>>;\n    }>;\n  }\n): {\n  [Key in keyof PrivateInputs]: RecursiveProver<\n    InferProvable<PublicInputType>,\n    PublicInputType,\n    InferProvable<PublicOutputType>,\n    PrivateInputs[Key]\n  > & {\n    if: ConditionalRecursiveProver<\n      InferProvable<PublicInputType>,\n      PublicInputType,\n      InferProvable<PublicOutputType>,\n      PrivateInputs[Key]\n    >;\n  };\n} {\n  type PublicInput = InferProvable<PublicInputType>;\n  type PublicOutput = InferProvable<PublicOutputType>;\n  type MethodKey = keyof PrivateInputs;\n\n  let {\n    publicInputType,\n    publicOutputType,\n    privateInputTypes: privateInputs,\n    rawMethods: methods,\n  } = zkprogram;\n\n  let hasPublicInput = publicInputType !== Undefined && publicInputType !== Void;\n\n  class SelfProof extends Proof<PublicInput, PublicOutput> {\n    static publicInputType = publicInputType;\n    static publicOutputType = publicOutputType;\n    static tag = () => zkprogram;\n  }\n\n  let methodKeys: MethodKey[] = Object.keys(methods);\n\n  let regularRecursiveProvers = mapToObject(methodKeys, (key) => {\n    return async function proveRecursively_(\n      conditionAndConfig: Bool | { condition: Bool; domainLog2?: number },\n      publicInput: PublicInput,\n      ...args: TupleFrom<PrivateInputs[MethodKey]>\n    ): Promise<PublicOutput> {\n      let condition =\n        conditionAndConfig instanceof Bool ? conditionAndConfig : conditionAndConfig.condition;\n\n      // create the base proof in a witness block\n      let proof = await Provable.witnessAsync(SelfProof, async () => {\n        // move method args to constants\n        let constInput = Provable.toConstant<PublicInput>(\n          publicInputType,\n          publicInputType.fromValue(publicInput)\n        );\n        let constArgs = zip(args, privateInputs[key]).map(([arg, type]) =>\n          Provable.toConstant(type, ProvableType.get(type).fromValue(arg))\n        );\n\n        if (!condition.toBoolean()) {\n          let publicOutput: PublicOutput = ProvableType.synthesize(publicOutputType);\n          let maxProofsVerified = await zkprogram.maxProofsVerified();\n          return SelfProof.dummy(\n            publicInput,\n            publicOutput,\n            maxProofsVerified,\n            conditionAndConfig instanceof Bool ? undefined : conditionAndConfig.domainLog2\n          );\n        }\n\n        let prover = zkprogram[key];\n\n        if (hasPublicInput) {\n          let { proof } = await prover(constInput, ...constArgs);\n          return proof;\n        } else {\n          let { proof } = await prover(...constArgs);\n          return proof;\n        }\n      });\n\n      // assert that the witnessed proof has the correct public input (which will be used by Pickles as part of verification)\n      if (hasPublicInput) {\n        Provable.assertEqual(publicInputType, proof.publicInput, publicInput);\n      }\n\n      // declare and verify the proof, and return its public output\n      proof.declare();\n      proof.verifyIf(condition);\n      return proof.publicOutput;\n    };\n  });\n\n  return mapObject(\n    regularRecursiveProvers,\n    (\n      prover\n    ): RecursiveProver<PublicInput, PublicInputType, PublicOutput, PrivateInputs[MethodKey]> & {\n      if: ConditionalRecursiveProver<\n        PublicInput,\n        PublicInputType,\n        PublicOutput,\n        PrivateInputs[MethodKey]\n      >;\n    } => {\n      if (!hasPublicInput) {\n        return Object.assign(\n          ((...args: any) => prover(new Bool(true), undefined as any, ...args)) as any,\n          {\n            if: (condition: Bool | { condition: Bool; domainLog2?: number }, ...args: any) =>\n              prover(condition, undefined as any, ...args),\n          }\n        );\n      } else {\n        return Object.assign(\n          ((pi: PublicInput, ...args: any) => prover(new Bool(true), pi, ...args)) as any,\n          {\n            if: (\n              condition: Bool | { condition: Bool; domainLog2?: number },\n              pi: PublicInput,\n              ...args: any\n            ) => prover(condition, pi, ...args),\n          }\n        );\n      }\n    }\n  );\n}\n\ntype RecursiveProver<\n  PublicInput,\n  PublicInputType,\n  PublicOutput,\n  Args extends Tuple<ProvableType>,\n> = PublicInput extends undefined\n  ? (...args: TupleFrom<Args>) => Promise<PublicOutput>\n  : (publicInput: From<PublicInputType>, ...args: TupleFrom<Args>) => Promise<PublicOutput>;\n\ntype ConditionalRecursiveProver<\n  PublicInput,\n  PublicInputType,\n  PublicOutput,\n  Args extends Tuple<ProvableType>,\n> = PublicInput extends undefined\n  ? (\n      condition: Bool | { condition: Bool; domainLog2?: number },\n      ...args: TupleFrom<Args>\n    ) => Promise<PublicOutput>\n  : (\n      condition: Bool | { condition: Bool; domainLog2?: number },\n      publicInput: From<PublicInputType>,\n      ...args: TupleFrom<Args>\n    ) => Promise<PublicOutput>;\n\ntype TupleFrom<T> = {\n  [I in keyof T]: From<T[I]>;\n};\n", "import { getRustConversion } from '../../bindings/crypto/bindings.js';\nimport { Pickles, Snarky, initializeBindings, wasm, withThreadPool } from '../../bindings.js';\nimport { MlFieldArray, MlFieldConstArray } from '../ml/fields.js';\nimport {\n  ConstraintSystemSummary,\n  gatesFromJson,\n  printGates,\n  snarkContext,\n  summarizeGates,\n} from '../provable/core/provable-context.js';\nimport { Provable } from '../provable/provable.js';\nimport { InferProvable, provablePure } from '../provable/types/provable-derivers.js';\nimport { ProvableTypePure } from '../provable/types/provable-intf.js';\nimport { Field } from '../provable/wrapped.js';\nimport { prettifyStacktrace, prettifyStacktracePromise } from '../util/errors.js';\nimport { Get, Tuple } from '../util/types.js';\nimport { TupleToInstances } from './zkprogram.js';\n\n// external API\nexport { KimchiJsonProof, KimchiProof, KimchiVerificationKey, ZkFunction };\n\ntype PublicInput<Config extends ZkFunctionConfig> = InferProvable<Get<Config, 'publicInputType'>>;\ntype PrivateInputs<Config extends ZkFunctionConfig> = TupleToInstances<Config['privateInputTypes']>;\n\ntype ZkFunctionConfig = {\n  name: string;\n  publicInputType?: ProvableTypePure;\n  privateInputTypes: Tuple<ProvableTypePure>;\n  lazyMode?: boolean;\n};\n\ntype MainType<\n  PublicInput,\n  PrivateInputs extends Tuple<ProvableTypePure>,\n> = PublicInput extends undefined\n  ? (...args: TupleToInstances<PrivateInputs>) => void\n  : (publicInput: InferProvable<PublicInput>, ...args: TupleToInstances<PrivateInputs>) => void;\n\ntype InferMainType<Config extends ZkFunctionConfig> = MainType<\n  Get<Config, 'publicInputType'>,\n  Config['privateInputTypes']\n>;\n\ntype ProveMethodType<Config extends ZkFunctionConfig> =\n  Get<Config, 'publicInputType'> extends undefined\n    ? (...args: PrivateInputs<Config>) => Promise<KimchiProof>\n    : (publicInput: PublicInput<Config>, ...args: PrivateInputs<Config>) => Promise<KimchiProof>;\n\nfunction ZkFunction<Config extends ZkFunctionConfig>(\n  config: Config & {\n    main: InferMainType<Config>;\n  }\n) {\n  const publicInputType = provablePure(config.publicInputType ?? undefined);\n  const hasPublicInput = config.publicInputType !== undefined;\n\n  type Keypair = Snarky.Keypair;\n  let _keypair: Keypair | undefined;\n\n  return {\n    /**\n     * Generates and stores a proving key and a verification key for this circuit(ZkFunction).\n     *\n     * @returns The generated verification key.\n     *\n     * @example\n     * ```ts\n     * const { verificationKey } = await zkf.compile();\n     * ```\n     * @warning Must be called before `prove` or `analyzeMethod`.\n     */\n    async compile() {\n      const main = mainFromCircuitData(config);\n      const publicInputSize = publicInputType.sizeInFields();\n      const lazyMode = config.lazyMode ?? false;\n      await initializeBindings();\n      _keypair = await prettifyStacktracePromise(\n        withThreadPool(async () => {\n          return Snarky.circuit.compile(main, publicInputSize, lazyMode);\n        })\n      );\n      const verificationKey = new KimchiVerificationKey(\n        Snarky.circuit.keypair.getVerificationKey(_keypair)\n      );\n      return { verificationKey };\n    },\n\n    /**\n     * Returns a low-level JSON representation of the constraint system (gates)\n     *\n     * @throws If compile() has not been called yet.\n     *\n     * @example\n     * ```ts\n     * await zkf.compile();\n     * const cs = zkf.analyzeMethod();\n     * console.log(cs);\n     * ```\n     */\n    analyzeMethod(): Omit<ConstraintSystemSummary, 'digest'> {\n      if (!_keypair) throw new Error('Cannot find prover artifacts. Please call compile() first!');\n      try {\n        let { gates, publicInputSize } = gatesFromJson(\n          Snarky.circuit.keypair.getConstraintSystemJSON(_keypair)\n        );\n        return {\n          rows: gates.length,\n          gates,\n          publicInputSize,\n          print() {\n            printGates(gates);\n          },\n          summary() {\n            return summarizeGates(gates);\n          },\n        };\n      } catch (error) {\n        throw prettifyStacktrace(error);\n      }\n    },\n\n    /**\n     * Proves a statement using the public input and private inputs of the circuit(ZkFunction).\n     *\n     * @param publicInput The public input to the circuit if it exists.\n     * @param privateInputs The private inputs to the circuit.\n     * @returns The generated proof.\n     *\n     * @throws If `compile` has not been called.\n     *\n     * @example\n     * ```ts\n     * const { verificationKey } = await zkf.compile();\n     * const proof = await zkf.prove(publicInput, privateInput1, privateInput2);\n     * ```\n     */\n    async prove(...args: Parameters<ProveMethodType<Config>>) {\n      if (!_keypair) throw new Error('Cannot find prover artifacts. Please call compile() first!');\n\n      const publicInput = hasPublicInput ? args[0] : undefined;\n      const privateInputs = (hasPublicInput ? args.slice(1) : args) as PrivateInputs<Config>;\n      const publicInputSize = publicInputType.sizeInFields();\n      const publicInputFields = publicInputType.toFields(publicInput);\n      const main = mainFromCircuitData(config, privateInputs);\n      await initializeBindings();\n      return withThreadPool(async () => {\n        const proof = Snarky.circuit.prove(\n          main,\n          publicInputSize,\n          MlFieldConstArray.to(publicInputFields),\n          _keypair!\n        );\n        return new KimchiProof(proof, publicInputFields);\n      });\n    },\n\n    /**\n     * Verifies a proof using the verification key of the circuit(ZkFunction).\n     *\n     * @param proof The proof to verify.\n     * @param verificationKey The key to verify against.\n     *\n     * @returns `true` if the proof is valid, otherwise `false`.\n     *\n     * @example\n     * ```ts\n     * const { verificationKey } = await zkf.compile();\n     * const proof = await zkf.prove(publicInput, privateInput1, privateInput2);\n     * const isValid = await zkf.verify(proof, verificationKey);\n     * ```\n     */\n    async verify(proof: KimchiProof, verificationKey: KimchiVerificationKey) {\n      return await proof.verify(verificationKey);\n    },\n  };\n}\n\n/**\n * Serializable representation of a Kimchi proof, useful for caching compiled proofs.\n */\ntype KimchiJsonProof = {\n  /** Array of string, where each string is a `Field` in the publicInputFields of this proof */\n  publicInputFields: string[];\n  /** The proof itself, encoded as a Base64 string */\n  proof: string;\n};\n\n/**\n * Encapsulates a {@link ZkFunction} proof together with its public input fields.\n *\n * Generated by {@link ZkFunction.prove}, it wraps the raw `Snarky.Proof`\n * and the array of `Field` inputs used for verification.\n *\n * You can call `verify` on a `Proof` to check its validity against a\n * {@link VerificationKey}.\n */\nclass KimchiProof {\n  value: Snarky.Proof;\n  publicInputFields: Field[];\n\n  constructor(value: Snarky.Proof, publicInputFields: Field[]) {\n    this.value = value;\n    this.publicInputFields = publicInputFields;\n  }\n\n  toJSON(): KimchiJsonProof {\n    const proofWithEvalsMl: any = Snarky.circuit.proofToBackendProofEvals(\n      MlFieldConstArray.to(this.publicInputFields),\n      this.value\n    );\n    const rustConversion = getRustConversion(wasm);\n    const rustProof = rustConversion.fp.proofToRust(proofWithEvalsMl);\n    return {\n      proof: rustProof.serialize(),\n      publicInputFields: this.publicInputFields.map((f) => f.toString()),\n    };\n  } \n\n  static fromJSON(json: KimchiJsonProof): KimchiProof {\n    const bytes = Uint8Array.from(Buffer.from(json.proof, 'base64'));\n    const rustProof = wasm.WasmFpProverProof.deserialize(bytes);\n    const rustConversion = getRustConversion(wasm);\n    const proofWithEvalsMl = Snarky.circuit.proofFromBackendProofEvals(\n      rustConversion.fp.proofFromRust(rustProof)\n    );\n    const publicInputFields = json.publicInputFields.map((s) => Field(s));\n    return new KimchiProof(proofWithEvalsMl, publicInputFields);\n  } \n \n  /**\n   * Verifies this proof using the provided verification key.\n   * @param verificationKey The key to verify against.\n   * @returns A promise that resolves to `true` if valid, otherwise `false`.\n   */\n  async verify(verificationKey: KimchiVerificationKey) {\n    await initializeBindings();\n    return prettifyStacktracePromise(\n      withThreadPool(async () =>\n        Snarky.circuit.verify(\n          MlFieldConstArray.to(this.publicInputFields),\n          this.value,\n          verificationKey.value\n        )\n      )\n    );\n  }\n}\n\n/**\n * A verification key is used to verify a {@link Proof}.\n */\nclass KimchiVerificationKey {\n  value: Snarky.VerificationKey;\n\n  constructor(value: Snarky.VerificationKey) {\n    this.value = value;\n  }\n \n  toString(): string {\n    const rustConversion = getRustConversion(wasm);\n    const rustVerifierIndex = rustConversion.fp.verifierIndexToRust(this.value as any);\n    const verifierIndexBase64 =\n      wasm.caml_pasta_fp_plonk_verifier_index_serialize(rustVerifierIndex);\n    return Buffer.from(verifierIndexBase64, 'utf8').toString('base64');\n  }\n\n  static fromString(base64: string): KimchiVerificationKey {\n    const srsFp = Pickles.loadSrsFp();\n    const rustVerifierIndex = wasm.caml_pasta_fp_plonk_verifier_index_deserialize(\n      srsFp,\n      Buffer.from(base64, 'base64').toString('utf8')\n    );\n    const rustConversion = getRustConversion(wasm);\n    const verifierIndexMl: unknown = rustConversion.fp.verifierIndexFromRust(rustVerifierIndex);\n    return new KimchiVerificationKey(verifierIndexMl);\n  } \n}\n\nfunction mainFromCircuitData<Config extends ZkFunctionConfig>(\n  config: Config & { main: InferMainType<Config> },\n  privateInputs?: PrivateInputs<Config>\n): Snarky.Main {\n  return function main(publicInputFields: MlFieldArray) {\n    let id = snarkContext.enter({ inCheckedComputation: true });\n    try {\n      const publicInput = provablePure(config.publicInputType ?? undefined).fromFields(\n        MlFieldArray.from(publicInputFields)\n      ) as PublicInput<Config>;\n\n      const privateInputs_ = config.privateInputTypes.map((typ, i) =>\n        Provable.witness(typ, () => (privateInputs ? privateInputs[i] : undefined))\n      ) as PrivateInputs<Config>;\n\n      if (config.publicInputType !== undefined) {\n        (config.main as (...args: unknown[]) => void)(publicInput, ...privateInputs_);\n      } else {\n        (config.main as (...args: unknown[]) => void)(...privateInputs_);\n      }\n    } finally {\n      snarkContext.leave(id);\n    }\n  };\n}\n", "import { Bool } from './bool.js';\nimport { Field } from './field.js';\nimport { Provable } from './provable.js';\nimport { ProvablePureExtended } from './types/struct.js';\nimport { Gadgets } from './gadgets/gadgets.js';\nimport { assert } from './gadgets/common.js';\nimport { provable, provableFromClass } from './types/provable-derivers.js';\nimport { Unconstrained } from './types/unconstrained.js';\n\nexport { createProvableBigInt, ProvableBigInt };\n\ntype BigIntParameter = {\n  limbNum: number;\n  limbSize: number;\n  mask: bigint;\n  max: bigint;\n};\n\n/**\n * Creates a class representing a ProvableBigInt with modular arithmetic capabilities.\n * This is particularly useful for implementing prime fields that don't fit into the native field.\n *\n * ```ts\n * const BigInt521 = createProvableBigInt(2n ** 521n - 1n); // creates a class for 521-bit integers\n * ```\n *\n * `createProvableBigInt(modulus, config?)` takes two parameters:\n * - `modulus`: The modulus of the field (must be a prime)\n * - `config`: Optional configuration for custom limb size and numbers\n *\n * The returned class supports comprehensive arithmetic operations including:\n * - Basic operations: addition, double, subtraction, multiplication, square, division\n * - Advanced operations: inverse, negate, sqrt, power\n * - Comparison operations: equals, assertEquals, greaterThan, lessthan, greaterThanOrEqual, lessThanOrEqual\n * - Conversion methods: fromBigInt, toBigInt, fromFields, toFields, fromBits, toBits\n *\n * Implementation details:\n *\n * Internally, a ProvableBigInt is represented as an array of Field elements (limbs),\n * where each limb holds 116 bits as default. The total size is determined by the configuration,\n * with preset options supporting different bit lengths:\n * - 348 bits (3 limbs)\n * - 464 bits (4 limbs)\n * - 580 bits (5 limbs)\n * - 1044 bits (9 limbs)\n * - 2088 bits (18 limbs)\n * - 4176 bits (36 limbs)\n *\n * Each arithmetic operation ensures the result is a valid element of the prime field.\n *\n * @example\n * ```ts\n * // Create a Provable BigInt class with modulus 2^521 - 1\n * const BigInt521 = createProvableBigInt(2n ** 521n - 1n);\n *\n * // Create instances\n * const a = BigInt521.fromBigInt(123n);\n * const b = BigInt521.fromBigInt(456n);\n * const c = BigInt521.fromBigInt(1024n);\n *\n * // Perform operations\n * const sum = a.add(b);\n * const double = a.double();\n * const diff = a.sub(b);\n * const product = a.mul(b);\n * const square = a.square();\n * const quotient = a.div(b);\n * const inverse = a.inverse();\n * const negation = a.negate();\n * const power = a.pow(b);\n * const sqrt = c.sqrt();\n * ```\n *\n * The class automatically handles modular reduction after\n * arithmetic operations to maintain valid representations. All operations are\n * designed to be provable and optimised for less constraints.\n *\n * @param modulus The modulus for the big integer arithmetic (must be prime)\n * @param config Optional configuration specifying a custom limb size and number\n * @returns A class representing ProvableBigInts with the specified modulus\n * @throws If the modulus is zero, negative, or exceeds the maximum supported size\n */\nfunction createProvableBigInt(modulus: bigint, config?: BigIntParameter) {\n  const config_ = config ?? findConfig(modulus);\n  assert(modulus !== 0n, `ProvableBigInt: modulus must be non-zero, got ${modulus}`);\n  assert(modulus > 0n, `ProvableBigInt: modulus must be positive, got ${modulus}`);\n  assert(\n    modulus < config_.max,\n    `ProvableBigInt: modulus exceeds the max supported size of 2^${config_.max}`\n  );\n  assert(isPrime(modulus), 'ProvableBigInt: modulus must be prime');\n  let fields = bigintToLimbs(modulus, config_);\n\n  class ProvableBigInt_ extends ProvableBigInt<ProvableBigInt_> {\n    constructor(fields: Field[], value: Unconstrained<bigint>) {\n      super(fields, Unconstrained.from(value));\n    }\n\n    get Constructor() {\n      return this.constructor as typeof ProvableBigInt;\n    }\n\n    static {\n      this._modulus = new ProvableBigInt_(fields, Unconstrained.from(modulus));\n      this._config = config_;\n      this._provable = provableFromClass(ProvableBigInt_, {\n        fields: Provable.Array(Field, config_.limbNum),\n      });\n    }\n\n    /**\n     * Returns a ProvableBigInt representing zero\n     * @returns A ProvableBigInt representing zero\n     */\n    static zero(): ProvableBigInt_ {\n      return ProvableBigInt_.fromBigInt(0n);\n    }\n\n    /**\n     * Returns a ProvableBigInt representing one\n     * @returns A ProvableBigInt representing one\n     */\n    static one(): ProvableBigInt_ {\n      return ProvableBigInt_.fromBigInt(1n);\n    }\n\n    /**\n     * Returns a ProvableBigInt representing one\n     * @returns A ProvableBigInt representing one\n     */\n    static max(): ProvableBigInt_ {\n      return ProvableBigInt_.fromBigInt(modulus - 1n);\n    }\n\n    /**\n     * Creates a ProvableBigInt instance from a JS bigint, string, number, or boolean\n     * @param x\n     * @returns ProvableBigInt instance from the input\n     */\n    static from(x: bigint | string | number | boolean): ProvableBigInt_ {\n      return ProvableBigInt_.fromBigInt(BigInt(x));\n    }\n\n    /**\n     * Creates a ProvableBigInt instance from a JS bigint\n     * @param x\n     * @returns ProvableBigInt instance from the input\n     */\n    static fromBigInt(x: bigint): ProvableBigInt_ {\n      let value = x;\n      if (value < 0n) {\n        value = ((x % modulus) + modulus) % modulus;\n      }\n      if (value >= ProvableBigInt_.modulus.toBigInt()) {\n        value = value % modulus;\n      }\n      let fields = bigintToLimbs(value, ProvableBigInt_.config);\n      return new ProvableBigInt_(fields, Unconstrained.from(value));\n    }\n\n    /**\n     * Converts a ProvableBigInt instance to a JS bigint\n     * @returns JS bigint representation of the ProvableBigInt\n     */\n    toBigInt(): bigint {\n      let result = 0n;\n      for (let i = 0; i < this.Constructor.config.limbNum; i++) {\n        result |= this.fields[i].toBigInt() << BigInt(this.Constructor.config.limbSize * i);\n      }\n      return result;\n    }\n\n    /**\n     * Converts a ProvableBigInt instance to field array representation of the limbs\n     * @returns Limbs of the ProvableBigInt\n     */\n    toFields(): Field[] {\n      return this.fields.slice(0, this.Constructor.config.limbNum);\n    }\n\n    static Unsafe = {\n      /**\n       * Creates a ProvableBigInt instance from an limbs as an array of fields\n       * **WARNING**: This method is UNSAFE and lacks checks on the fields. Use with caution as it can lead to incorrect results or security vulnerabilities.\n       * @param fields The limbs of the ProvableBigInt. Must be of the correct length.\n       * @returns A ProvableBigInt instance from the fields\n       */\n      fromFields(fields: Field[]): ProvableBigInt_ {\n        let value = 0n;\n        for (let i = 0; i < ProvableBigInt_.config.limbNum; i++) {\n          value |= BigInt(fields[i].toBigInt()) << BigInt(ProvableBigInt_.config.limbSize * i);\n        }\n        return new ProvableBigInt_(fields, Unconstrained.from(value));\n      },\n\n      /**\n       * Creates a ProvableBigInt instance from an array of bits\n       * **WARNING**: This method is UNSAFE and lacks checks on the bits. Use with caution as it can lead to incorrect results or security vulnerabilities.\n       * @param bits\n       * @returns A ProvableBigInt instance from the bits\n       */\n      fromBits(bits: Bool[]): ProvableBigInt_ {\n        let value = 0n;\n        let bigint = Provable.witness(ProvableBigInt_, () => {\n          for (let i = 0; i < bits.length; i++) {\n            if (bits[i].toBoolean()) {\n              value |= 1n << BigInt(i);\n            }\n          }\n          return ProvableBigInt_.fromBigInt(value);\n        });\n        return bigint;\n      },\n    };\n\n    /**\n     * Converts a ProvableBigInt instance to an array of bits\n     * @returns An array of bits representing the ProvableBigInt\n     */\n    toBits(): Bool[] {\n      return this.fields.flatMap((field) => {\n        return field.toBits(this.Constructor.config.limbSize);\n      });\n    }\n\n    /**\n     * Clones a ProvableBigInt instance\n     * @returns A new ProvableBigInt instance with the same value\n     */\n    clone(): ProvableBigInt_ {\n      return new ProvableBigInt_(this.fields, this.value);\n    }\n\n    /**\n     * Adds two ProvableBigInt instances\n     * Cost: Cheap\n     * @param a The ProvableBigInt to add\n     * @returns The sum as a ProvableBigInt\n     */\n    add(a: ProvableBigInt_, isDouble = false): ProvableBigInt_ {\n      if (isDouble) a = this;\n      // witness q, r so that x+y = q*p + r\n      let { q, r } = Provable.witness(provable({ q: ProvableBigInt_, r: ProvableBigInt_ }), () => {\n        let xPlusY = this.toBigInt() + a.toBigInt();\n        let p0 = this.Constructor.modulus.toBigInt();\n        let q = xPlusY / p0;\n        let r = xPlusY - q * p0;\n        return {\n          q: ProvableBigInt_.fromBigInt(q),\n          r: ProvableBigInt_.fromBigInt(r),\n        };\n      });\n\n      let delta: Field[] = Array.from({ length: this.Constructor.config.limbNum }, () =>\n        Field.from(0)\n      );\n      let [X, Y, Q, R, P] = [\n        this.fields,\n        a.fields,\n        q.fields,\n        r.fields,\n        this.Constructor.modulus.fields,\n      ];\n\n      // compute X + Y limb-by-limb\n      for (let i = 0; i < this.Constructor.config.limbNum; i++) {\n        if (isDouble) delta[i] = X[i].mul(2);\n        else delta[i] = X[i].add(Y[i]);\n      }\n\n      // subtract q*p limb-by-limb\n      for (let i = 0; i < this.Constructor.config.limbNum; i++) {\n        for (let j = 0; j < this.Constructor.config.limbNum; j++) {\n          if (i + j < this.Constructor.config.limbNum) {\n            delta[i + j] = delta[i + j].sub(Q[i].mul(P[j]));\n          }\n        }\n      }\n\n      // subtract r limb-by-limb\n      for (let i = 0; i < this.Constructor.config.limbNum; i++) {\n        delta[i] = delta[i].sub(R[i]).seal();\n      }\n\n      let carry = Field.from(0);\n\n      for (let i = 0; i < this.Constructor.config.limbNum - 1; i++) {\n        let deltaPlusCarry = delta[i].add(carry).seal();\n\n        carry = Provable.witness(Field, () =>\n          deltaPlusCarry.div(1n << BigInt(this.Constructor.config.limbSize))\n        );\n        rangeCheck(carry, 128, true);\n\n        // ensure that after adding the carry, the limb is a multiple of 2^limbSize\n        deltaPlusCarry.assertEquals(carry.mul(1n << BigInt(this.Constructor.config.limbSize)));\n      }\n\n      // the final limb plus carry should be zero to assert correctness\n      delta[this.Constructor.config.limbNum - 1].add(carry).assertEquals(0n);\n\n      return r;\n    }\n\n    /**\n     * Doubles a ProvableBigInt\n     * Cost: Cheap\n     * @returns The double of a ProvableBigInt\n     */\n    double(): ProvableBigInt_ {\n      return this.add(this, true);\n    }\n\n    /**\n     * Subtracts one ProvableBigInt from another\n     * Cost: Cheap\n     * @param a The ProvableBigInt to subtract\n     * @returns The difference as a ProvableBigInt\n     */\n    sub(a: ProvableBigInt_): ProvableBigInt_ {\n      return this.add(a.negate());\n    }\n\n    /**\n     * Multiplies two ProvableBigInt instances\n     * Cost: Cheap\n     * @param a The ProvableBigInt to multiply\n     * @returns The product as a ProvableBigInt\n     */\n    mul(a: ProvableBigInt_, isSquare = false): ProvableBigInt_ {\n      if (isSquare) a = this;\n\n      let { q, r } = Provable.witness(provable({ q: ProvableBigInt_, r: ProvableBigInt_ }), () => {\n        let xy = this.toBigInt() * a.toBigInt();\n        let p0 = this.Constructor.modulus.toBigInt();\n        let q = xy / p0;\n        let r = xy - q * p0;\n        return {\n          q: ProvableBigInt_.fromBigInt(q),\n          r: ProvableBigInt_.fromBigInt(r),\n        };\n      });\n\n      let delta: Field[] = Array.from(\n        { length: 2 * this.Constructor.config.limbNum - 1 },\n        () => new Field(0)\n      );\n      let [X, Y, Q, R, P] = [\n        this.fields,\n        a.fields,\n        q.fields,\n        r.fields,\n        this.Constructor.modulus.fields,\n      ];\n\n      for (let i = 0; i < this.Constructor.config.limbNum; i++) {\n        if (isSquare) {\n          for (let j = 0; j < i; j++) {\n            delta[i + j] = delta[i + j].add(X[i].mul(X[j]).mul(2n));\n          }\n          delta[2 * i] = delta[2 * i].add(X[i].mul(X[i]));\n        } else {\n          for (let j = 0; j < this.Constructor.config.limbNum; j++) {\n            delta[i + j] = delta[i + j].add(X[i].mul(Y[j]));\n          }\n        }\n\n        for (let j = 0; j < this.Constructor.config.limbNum; j++) {\n          delta[i + j] = delta[i + j].sub(Q[i].mul(P[j]));\n        }\n\n        delta[i] = delta[i].sub(R[i]).seal();\n      }\n\n      let carry = new Field(0);\n\n      for (let i = 0; i < 2 * this.Constructor.config.limbNum - 2; i++) {\n        let deltaPlusCarry = delta[i].add(carry).seal();\n\n        carry = Provable.witness(Field, () =>\n          deltaPlusCarry.div(1n << BigInt(this.Constructor.config.limbSize))\n        );\n        rangeCheck(carry, 128, true);\n\n        deltaPlusCarry.assertEquals(carry.mul(1n << BigInt(this.Constructor.config.limbSize)));\n      }\n\n      delta[2 * this.Constructor.config.limbNum - 2].add(carry).assertEquals(0n);\n\n      return r;\n    }\n\n    /**\n     * Computes the square root of a ProvableBigInt\n     * Cost: Cheap\n     * @returns The square root as a ProvableBigInt\n     */\n    square(): ProvableBigInt_ {\n      return this.mul(this, true);\n    }\n\n    /**\n     * Divides one ProvableBigInt by another.\n     * Cost: Cheap-Moderate\n     * @param a The divisor as a ProvableBigInt\n     * @returns The quotient as ProvableBigInt\n     */\n    div(a: ProvableBigInt_): ProvableBigInt_ {\n      const inv_a = a.inverse();\n\n      let res = this.mul(inv_a);\n\n      return res;\n    }\n\n    /**\n     * Computes the modular inverse of a ProvableBigInt\n     * Cost: Cheap\n     * @returns The inverse as a ProvableBigInt\n     */\n    inverse(): ProvableBigInt_ {\n      let { res } = Provable.witness(\n        provable({ res: ProvableBigInt_ as typeof ProvableBigInt }),\n        () => {\n          const p = this.Constructor.modulus.toBigInt();\n          let t = 0n;\n          let newT = 1n;\n          let r = p;\n          let newR = this.toBigInt();\n\n          // Loop until newR is equal to zero\n          while (newR !== 0n) {\n            const quotient = r / newR;\n\n            [t, newT] = [newT, t - quotient * newT];\n            [r, newR] = [newR, r - quotient * newR];\n          }\n\n          // If r is bigger than 1, a is not invertible\n          if (r > 1n) {\n            throw new Error('a is not invertible');\n          }\n\n          // If t is smaller than zero, add modulus\n          if (t < 0n) {\n            t = t + p;\n          }\n\n          return { res: ProvableBigInt_.fromBigInt(t) };\n        }\n      );\n\n      res.mul(this).assertEquals(ProvableBigInt_.one());\n\n      return res;\n    }\n\n    /**\n     * Computes the additive inverse of a ProvableBigInt\n     * Cost: Cheap\n     * @returns The additive inverse as a ProvableBigInt\n     */\n    negate(): ProvableBigInt_ {\n      let { negation } = Provable.witness(provable({ negation: ProvableBigInt_ }), () => {\n        let thisVal = this.toBigInt();\n        let p = this.Constructor.modulus.toBigInt();\n        let negVal = 0n;\n        if (thisVal !== 0n) {\n          negVal = p - thisVal;\n        }\n        return {\n          negation: ProvableBigInt_.fromBigInt(negVal),\n        };\n      });\n\n      this.add(negation).assertEquals(ProvableBigInt_.zero());\n\n      return negation;\n    }\n\n    /**\n     * Computes the power of a ProvableBigInt raised to an exponent\n     * Cost: Expensive\n     * @param exp The exponent\n     * @returns The result as a ProvableBigInt\n     */\n    pow(exp: ProvableBigInt_): ProvableBigInt_ {\n      const exponentBits = exp.toBits();\n      const processChunk = function* (bits: Bool[], chunkSize: number) {\n        for (let i = 0; i < bits.length; i += chunkSize) {\n          yield bits.slice(i, i + chunkSize);\n        }\n      };\n\n      let result = ProvableBigInt_.one();\n      let base = this.clone();\n\n      for (const chunk of processChunk(exponentBits, 100)) {\n        for (const bit of chunk) {\n          result = Provable.if(bit, ProvableBigInt_, result.mul(base), result);\n          base = base.mul(base);\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * Computes the square root of a Provable BigInt\n     * Cost: Cheap\n     * @returns The square root as a ProvableBigInt\n     */\n    sqrt(): ProvableBigInt_ {\n      let r = Provable.witness(ProvableBigInt_, () => {\n        const p = this.Constructor.modulus.toBigInt();\n        // Special cases\n        // Case 1: If input is 0, square root is 0\n        if (this.toBigInt() === 0n) return ProvableBigInt_.fromBigInt(0n);\n\n        // Case 2: If p \u2261 3 (mod 4), we can use a simpler formula\n        // In this case, the square root is a^((p+1)/4) mod p\n        if (p % 4n === 3n) {\n          const pplusonedivfour = (p + 1n) / 4n;\n          const pplusonedivfour_reduced = pplusonedivfour % p;\n          const sqrt = modularExponentiation(this.toBigInt(), pplusonedivfour_reduced, p);\n          return ProvableBigInt_.fromBigInt(sqrt);\n        }\n\n        // Tonelli-Shanks Algorithm\n        // Step 1: Factor out powers of 2 from p-1\n        // Write p-1 = Q * 2^S where Q is odd\n        let Q = p - 1n;\n        let S = 0n;\n        while (Q % 2n === 0n) {\n          Q /= 2n;\n          S += 1n;\n        }\n\n        // Step 2: Find a quadratic non-residue z\n        // This is any number z where z^((p-1)/2) \u2261 -1 (mod p)\n        let z = 2n;\n        while (modularExponentiation(z, (p - 1n) / 2n, p) !== p - 1n) {\n          z += 1n;\n        }\n\n        // Step 3: Initialize main loop variables\n        let M = S;\n        let c = modularExponentiation(z, Q, p);\n        let t = modularExponentiation(this.toBigInt(), Q, p);\n        let R = modularExponentiation(this.toBigInt(), (Q + 1n) / 2n, p);\n\n        // Main loop of Tonelli-Shanks algorithm\n        while (t !== 0n && t !== 1n) {\n          // Find least value of i, 0 < i < M, such that t^(2^i) = 1\n          let t2i = t;\n          let i = 0n;\n          for (i = 1n; i < M; i++) {\n            t2i = t2i ** 2n;\n            t2i %= p;\n            if (t2i === 1n) break;\n          }\n\n          // If no solution found, the input has no square root\n          if (i === M && M - i - 1n < 0n) {\n            throw new Error(\n              'Tonelli-Shanks algorithm failed to find a solution. Make sure modulo is prime!'\n            );\n          }\n\n          // Update variables for next iteration\n          const b = modularExponentiation(c, 2n ** (M - i - 1n), p);\n          M = i;\n          c = b ** 2n % p;\n          t = (t * c) % p;\n          R = (R * b) % p;\n        }\n\n        return ProvableBigInt_.fromBigInt(R);\n      });\n\n      r.square().assertEquals(this);\n\n      return r;\n    }\n\n    /**\n     * Checks if one ProvableBigInt is greater than another\n     * Cost: Moderate\n     * @param a The ProvableBigInt to compare\n     * @returns A Bool indicating if a is greater than b\n     *\n     * TODO: Comparators should ensure than inputs are canonical fields (value < p).\n     *       e.g.\n     *       ```ts\n     *       let delta = x.sub(x); // not guaranteed to be < p, could be = p\n     *       delta.greaterThan(ProvableBigInt.zero()).assertTrue(); // (p > 0) = true, (0 > 0) = false\n     *       ```\n     *\n     */\n    greaterThan(a: ProvableBigInt_): Bool {\n      return this.fields\n        .map((field, i) => ({\n          isGreater: field.greaterThan(a.fields[i]),\n          isEqual: field.equals(a.fields[i]),\n        }))\n        .reduce(\n          (result, { isGreater, isEqual }) => isGreater.or(result.and(isEqual)),\n          new Bool(false)\n        );\n    }\n\n    /**\n     * Checks if one ProvableBigInt is greater than or equal to another\n     * Cost: Moderate\n     * @param a The ProvableBigInt to compare\n     * @returns A Bool indicating if a is greater than or equal to b\n     *\n     * TODO: @see {@link greaterThan}\n     *\n     */\n    greaterThanOrEqual(a: ProvableBigInt_): Bool {\n      return this.fields\n        .map((field, i) => ({\n          isGreater: field.greaterThan(a.fields[i]),\n          isEqual: field.equals(a.fields[i]),\n        }))\n        .reduce(\n          (result, { isGreater, isEqual }) => isGreater.or(result.and(isEqual)),\n          new Bool(false)\n        )\n        .or(this.equals(a));\n    }\n\n    /**\n     * Checks if one ProvableBigInt is less than another\n     * Cost: Moderate\n     * @param a The ProvableBigInt to compare\n     * @returns A Bool indicating if a is less than b\n     *\n     * TODO: @see {@link greaterThan}\n     *\n     */\n    lessThan(a: ProvableBigInt_): Bool {\n      return this.fields\n        .map((field, i) => ({\n          isLess: field.lessThan(a.fields[i]),\n          isEqual: field.equals(a.fields[i]),\n        }))\n        .reduce((result, { isLess, isEqual }) => isLess.or(result.and(isEqual)), new Bool(false));\n    }\n\n    /**\n     * Checks if one ProvableBigInt is less than or equal to another\n     * Cost: Moderate\n     * @param a The ProvableBigInt to compare\n     * @returns A Bool indicating if a is less than or equal to b\n     *\n     * TODO: @see {@link greaterThan}\n     */\n    lessThanOrEqual(a: ProvableBigInt_): Bool {\n      return this.fields\n        .map((field, i) => ({\n          isLess: field.lessThan(a.fields[i]),\n          isEqual: field.equals(a.fields[i]),\n        }))\n        .reduce((result, { isLess, isEqual }) => isLess.or(result.and(isEqual)), new Bool(false))\n        .or(this.equals(a));\n    }\n\n    /**\n     * Checks if one ProvableBigInt is equal to another\n     * Cost: Cheap\n     * @param a The ProvableBigInt to compare\n     * @returns A Bool indicating if a is equal to b\n     *\n     * TODO: @see {@link greaterThan}\n     */\n    equals(a: ProvableBigInt_): Bool {\n      return this.fields\n        .map((field, i) => field.equals(a.fields[i]))\n        .reduce((result, isEqual) => result.and(isEqual), new Bool(true));\n    }\n\n    /**\n     * Checks if one ProvableBigInt is less than or equal to another\n     * Cost: Cheap\n     * @param a The ProvableBigInt to compare\n     * @returns A Bool indicating if a is less than or equal to b\n     *\n     * TODO: @see {@link greaterThan}\n     */\n    assertEquals(a: ProvableBigInt_) {\n      this.equals(a).assertTrue('ProvableBigInts are not equal');\n    }\n  }\n  return ProvableBigInt_;\n}\n\nabstract class ProvableBigInt<T> {\n  fields: Field[];\n  value: Unconstrained<bigint>;\n\n  static _provable?: ProvablePureExtended<\n    ProvableBigInt<ProvableBigInt<any>>,\n    { fields: bigint[] },\n    { fields: string[] }\n  >;\n\n  static get provable() {\n    assert(this._provable !== undefined, 'ProvableBigInt not initialized');\n    return this._provable;\n  }\n\n  public static _modulus?: ProvableBigInt<any>;\n  public static _config?: BigIntParameter;\n\n  static get modulus(): ProvableBigInt<any> {\n    assert(this._modulus !== undefined, 'Modulus not initialized');\n    return this._modulus;\n  }\n\n  static get config(): BigIntParameter {\n    assert(this._config !== undefined, 'Config not initialized');\n    return this._config;\n  }\n\n  constructor(fields: Field[], value: Unconstrained<bigint>) {\n    this.fields = fields;\n    this.value = Unconstrained.from(value);\n  }\n\n  abstract get Constructor(): typeof ProvableBigInt;\n  abstract toBigInt(): bigint;\n  abstract toFields(): Field[];\n  abstract toBits(): Bool[];\n  abstract clone(): T;\n  abstract add(a: T, isDouble?: boolean): T;\n  abstract double(): T;\n  abstract sub(a: T): T;\n  abstract mul(a: T, isSquare?: boolean): T;\n  abstract square(): T;\n  abstract div(a: T): T;\n  abstract inverse(): T;\n  abstract negate(): T;\n  abstract pow(exp: T): T;\n  abstract sqrt(): T;\n  abstract greaterThan(a: T): Bool;\n  abstract greaterThanOrEqual(a: T): Bool;\n  abstract lessThan(a: T): Bool;\n  abstract lessThanOrEqual(a: T): Bool;\n  abstract equals(a: T): Bool;\n  abstract assertEquals(a: T): void;\n}\n\nfunction rangeCheck(x: Field, bits: number, signed?: boolean) {\n  const supportedBits = new Set([32, 48, 64, 116, 128]);\n  if (!supportedBits.has(bits)) {\n    throw new Error(`Unsupported bit size: ${bits}`);\n  }\n\n  switch (bits) {\n    case 32:\n      Gadgets.rangeCheck32(x);\n      break;\n    case 48:\n      rangeCheck48(x);\n      break;\n    case 64:\n      Gadgets.rangeCheck64(x);\n      break;\n    case 116:\n      rangeCheck116(x);\n      break;\n    case 128:\n      if (signed) {\n        rangeCheck128Signed(x);\n      } else {\n        throw new Error('128-bit unsigned range check not implemented');\n      }\n      break;\n  }\n}\n\nfunction rangeCheck48(x: Field) {\n  let [x0, x1] = Provable.witnessFields(2, () => [\n    x.toBigInt() & ((1n << 32n) - 1n),\n    x.toBigInt() >> 32n,\n  ]);\n\n  Gadgets.rangeCheck32(x0); // 32 bits\n  Gadgets.rangeCheck16(x1); // 16 bits\n  x0.add(x1.mul(1n << 32n)).assertEquals(x); // 48 bits\n}\n\nfunction rangeCheck116(x: Field) {\n  let [x0, x1] = Provable.witnessFields(2, () => [\n    x.toBigInt() & ((1n << 64n) - 1n),\n    x.toBigInt() >> 64n,\n  ]);\n\n  Gadgets.rangeCheck64(x0); // 64 bits\n  let [x52] = Gadgets.rangeCheck64(x1);\n  x52.assertEquals(0n); // 52 bits\n  x0.add(x1.mul(1n << 64n)).assertEquals(x);\n}\n\nfunction rangeCheck128Signed(xSigned: Field) {\n  let x = xSigned.add(1n << 127n);\n\n  let [x0, x1] = Provable.witnessFields(2, () => {\n    const x0 = x.toBigInt() & ((1n << 64n) - 1n);\n    const x1 = x.toBigInt() >> 64n;\n    return [x0, x1];\n  });\n\n  Gadgets.rangeCheck64(x0);\n  Gadgets.rangeCheck64(x1);\n\n  x0.add(x1.mul(1n << 64n)).assertEquals(x);\n}\n\nfunction findConfig(modulus: bigint): BigIntParameter {\n  const bitLength = modulus.toString(2).length;\n  const defaultLimbSize = 116;\n  const limbCount = Math.ceil(bitLength / defaultLimbSize);\n  const maxBitLength = limbCount * defaultLimbSize;\n\n  return {\n    limbNum: limbCount,\n    limbSize: defaultLimbSize,\n    mask: (1n << BigInt(defaultLimbSize)) - 1n,\n    max: (1n << BigInt(maxBitLength)) - 1n,\n  };\n}\n\nfunction modularExponentiation(base: bigint, exponent: bigint, modulus: bigint): bigint {\n  let result = 1n;\n  base = base % modulus;\n\n  while (exponent > 0n) {\n    if (exponent % 2n === 1n) {\n      result = (result * base) % modulus;\n    }\n    exponent = exponent >> 1n;\n    base = (base * base) % modulus;\n  }\n\n  return result;\n}\n\n/**\n * Miller-Rabin primality test\n * @param n The number to test for primality\n * @param k Number of iterations (higher = more accurate)\n * @returns true if n is probably prime, false if n is definitely composite\n */\nfunction isPrime(n: bigint, k: number = 10): boolean {\n  if (n === 2n || n === 3n) return true;\n  if (n < 2n) return false;\n  if (n % 2n === 0n) return false;\n\n  // write n - 1 = 2^r * d, d is odd\n  let d = n - 1n;\n  let r = 0n;\n  for (; d % 2n === 0n; d /= 2n, r++);\n\n  WitnessLoop: for (let i = 0; i < k; i++) {\n    let a = randomBigintInRange(2n, n - 2n);\n    let x = modularExponentiation(a, d, n);\n    if (x === 1n || x === n - 1n) continue;\n    for (let j = 0; j + 1 < r; j++) {\n      x = (x * x) % n;\n      if (x === 1n) return false;\n      if (x === n - 1n) continue WitnessLoop;\n    }\n    return false;\n  }\n  return true;\n}\n\n/**\n * Generates a random bigint in the range [min, max)\n * @param min The minimum value (inclusive)\n * @param max The maximum value (exclusive)\n * @returns A random bigint in the range [min, max)\n */\nfunction randomBigintInRange(min: bigint, max: bigint): bigint {\n  const range = max - min;\n  const length = Math.ceil(range.toString(2).length / 8);\n\n  while (true) {\n    // Generate random bytes\n    const bytes = new Uint8Array(length);\n    crypto.getRandomValues(bytes);\n\n    // Convert bytes to bigint\n    let x = BigInt(0);\n    for (const byte of bytes) {\n      x = (x << 8n) + BigInt(byte);\n    }\n\n    // Check if x is within the range\n    if (x < range) {\n      return min + x;\n    }\n  }\n}\n\nfunction bigintToLimbs(x: bigint, config: BigIntParameter): Field[] {\n  let fields = [];\n  for (let i = 0; i < config.limbNum; i++) {\n    fields.push(Field.from(x & config.mask)); // fields[i] = x & mask\n    x >>= BigInt(config.limbSize); // x = x >> limbSize\n  }\n  return fields;\n}\n", "export * from './account-update.js';\nexport * from './account.js';\nexport * from './authorization.js';\nexport * from './core.js';\nexport * from './permissions.js';\nexport * from './preconditions.js';\nexport * from './state.js';\nexport * from './transaction.js';\nexport * from './views.js';\nexport * from './zkapp-logic.js';\nexport * from './dsl/mina-program.js';\nexport * from './currency.js';\n", "// NOTE: these leaves are currently backwards compatible with the old encoding format, but the\n// auxiliary components may change format in the future\n\nimport { FieldsDecoder, ProvableSerializable } from './util.js';\nimport { versionBytes } from '../../crypto/constants.js';\nimport { withVersionNumber } from '../../lib/binable.js';\nimport { Bool } from '../../../lib/provable/bool.js';\nimport { Field } from '../../../lib/provable/field.js';\nimport { Provable } from '../../../lib/provable/provable.js';\nimport { HashInput } from '../../../lib/provable/types/provable-derivers.js';\nimport { Struct } from '../../../lib/provable/types/struct.js';\nimport { toBase58Check } from '../../../lib/util/base58.js';\n\nexport { Bool } from '../../../lib/provable/bool.js';\nexport { Field } from '../../../lib/provable/field.js';\nexport { Int64, UInt32, UInt64, Sign } from '../../../lib/provable/int.js';\nexport { PublicKey } from '../../../lib/provable/crypto/signature.js';\n\n// for now, we erase the value conversion in the proxy, as it is currently not utilized\nfunction proxyProvableSerializable<T, Val>(\n  T: ProvableSerializable<T, Val>\n): ProvableSerializable<T, T> {\n  return {\n    sizeInFields(): number {\n      return T.sizeInFields();\n    },\n\n    toJSON(x: T): any {\n      return T.toJSON(x);\n    },\n\n    toInput(x: T): HashInput {\n      return T.toInput(x);\n    },\n\n    toFields(x: T): Field[] {\n      return T.toFields(x);\n    },\n\n    toAuxiliary(x?: T): any[] {\n      return T.toAuxiliary(x);\n    },\n\n    fromFields(fields: Field[], aux: any[]): T {\n      return T.fromFields(fields, aux);\n    },\n\n    toValue(x: T): T {\n      return x;\n    },\n\n    fromValue(x: T): T {\n      return x;\n    },\n\n    check(x: T) {\n      T.check(x);\n    },\n  };\n}\n\nexport interface Option<T> {\n  isSome: Bool;\n  value: T;\n}\n\nexport function Option<T>(T: ProvableSerializable<T>) {\n  return {\n    sizeInFields(): number {\n      return Bool.sizeInFields() + T.sizeInFields();\n    },\n\n    toJSON(x: Option<T>): any {\n      return x.isSome.toBoolean() ? T.toJSON(x.value) : null;\n    },\n\n    toInput(x: Option<T>): HashInput {\n      const flagInput = Bool.toInput(x.isSome);\n      const valueInput = T.toInput(x.value);\n      return {\n        fields: valueInput.fields,\n        packed: flagInput.packed!.concat(valueInput.packed ?? []),\n      };\n    },\n\n    toFields(x: Option<T>): Field[] {\n      return [...Bool.toFields(x.isSome), ...T.toFields(x.value)];\n    },\n\n    toAuxiliary(x?: Option<T>): any[] {\n      return T.toAuxiliary(x?.value);\n    },\n\n    fromFields(fields: Field[], aux: any[]): Option<T> {\n      const decoder = new FieldsDecoder(fields);\n      const isSome = decoder.decode(Bool.sizeInFields(), Bool.fromFields);\n      const value = decoder.decode(T.sizeInFields(), (f) => T.fromFields(f, aux));\n      return { isSome, value };\n    },\n\n    toValue(x: Option<T>): Option<T> {\n      return x;\n    },\n\n    fromValue(x: Option<T>): Option<T> {\n      return x;\n    },\n\n    check(_x: Option<T>) {\n      throw new Error('TODO');\n    },\n  };\n}\n\nOption.map = <A, B>(option: Option<A>, f: (value: A) => B): Option<B> => ({\n  isSome: option.isSome,\n  value: f(option.value),\n});\n\nOption.none = <T>(defaultValue: T): Option<T> => ({\n  isSome: new Bool(false),\n  value: defaultValue,\n});\n\nOption.some = <T>(value: T): Option<T> => ({\n  isSome: new Bool(true),\n  value,\n});\n\nexport interface Range<T> {\n  lower: T;\n  upper: T;\n}\n\nexport function Range<T>(T: Provable<T>) {\n  return Struct({\n    lower: T,\n    upper: T,\n  });\n}\n\nexport interface CommittedList {\n  data: Field[][];\n  hash: Field;\n}\n\nexport const CommittedList: ProvableSerializable<CommittedList> = {\n  sizeInFields(): number {\n    return 1;\n  },\n\n  toJSON(x: CommittedList): any {\n    return x.data.map((datum) => datum.map(Field.toJSON));\n  },\n\n  toInput(x: CommittedList): HashInput {\n    return { fields: [x.hash] };\n  },\n\n  toFields(x: CommittedList): Field[] {\n    return [x.hash];\n  },\n\n  toAuxiliary(x?: CommittedList): any[] {\n    if (x === undefined)\n      throw new Error('cannot convert undefined CommittedList into auxiliary data');\n    return [x.data];\n  },\n\n  fromFields(fields: Field[], aux: any[]): CommittedList {\n    // TODO: runtime type-check the aux data\n    return { data: aux[0], hash: fields[0] };\n  },\n\n  toValue(x: CommittedList): CommittedList {\n    return x;\n  },\n\n  fromValue(x: CommittedList): CommittedList {\n    return x;\n  },\n\n  check(_x: CommittedList) {\n    throw new Error('TODO');\n  },\n};\n\nexport type Events = CommittedList;\n\nexport const Events = CommittedList;\n\nexport type Actions = CommittedList;\n\nexport const Actions = CommittedList;\n\nexport type AuthRequiredIdentifier = 'Impossible' | 'None' | 'Proof' | 'Signature' | 'Either';\n// TODO: Both\n\nexport interface AuthRequired {\n  constant: Bool;\n  signatureNecessary: Bool;\n  signatureSufficient: Bool;\n}\n\nexport const AuthRequired = {\n  ...proxyProvableSerializable<AuthRequired, any>(\n    Struct({ constant: Bool, signatureNecessary: Bool, signatureSufficient: Bool })\n  ),\n\n  empty(): AuthRequired {\n    return {\n      constant: new Bool(true),\n      signatureNecessary: new Bool(false),\n      signatureSufficient: new Bool(true),\n    };\n  },\n\n  isImpossible(x: AuthRequired): Bool {\n    return Bool.allTrue([x.constant, x.signatureNecessary, x.signatureSufficient.not()]);\n  },\n\n  isNone(x: AuthRequired): Bool {\n    return Bool.allTrue([x.constant, x.signatureNecessary.not(), x.signatureSufficient]);\n  },\n\n  isProof(x: AuthRequired): Bool {\n    return Bool.allTrue([\n      x.constant.not(),\n      x.signatureNecessary.not(),\n      x.signatureSufficient.not(),\n    ]);\n  },\n\n  isSignature(x: AuthRequired): Bool {\n    return Bool.allTrue([x.constant.not(), x.signatureNecessary, x.signatureSufficient]);\n  },\n\n  isEither(x: AuthRequired): Bool {\n    return Bool.allTrue([x.constant.not(), x.signatureNecessary.not(), x.signatureSufficient]);\n  },\n\n  identifier(x: AuthRequired): AuthRequiredIdentifier {\n    if (AuthRequired.isImpossible(x).toBoolean()) {\n      return 'Impossible';\n    } else if (AuthRequired.isNone(x).toBoolean()) {\n      return 'None';\n    } else if (AuthRequired.isProof(x).toBoolean()) {\n      return 'Proof';\n    } else if (AuthRequired.isSignature(x).toBoolean()) {\n      return 'Signature';\n    } else if (AuthRequired.isEither(x).toBoolean()) {\n      return 'Either';\n    } else {\n      throw new Error('invariant broken: invalid authorization level encoding');\n    }\n  },\n\n  toJSON(x: AuthRequired): any {\n    return AuthRequired.identifier(x);\n  },\n};\n\nAuthRequired satisfies ProvableSerializable<AuthRequired>;\n\nexport type StateHash = Field;\n\nexport const StateHash: ProvableSerializable<StateHash> = {\n  ...proxyProvableSerializable<Field, any>(Field),\n\n  toJSON(x: StateHash): any {\n    const bytes = withVersionNumber(Field, 1).toBytes(x);\n    return toBase58Check(bytes, versionBytes.stateHash);\n  },\n};\n\nexport type TokenId = Field;\n\nexport const TokenId = Field;\n\nexport interface TokenSymbol {\n  field: Field;\n  symbol: string;\n}\n\nexport const TokenSymbol: ProvableSerializable<TokenSymbol> = {\n  ...proxyProvableSerializable<TokenSymbol, any>(Struct({ field: Field, symbol: String })),\n\n  toJSON(x: TokenSymbol): any {\n    return x.symbol;\n  },\n\n  toInput(x: TokenSymbol): HashInput {\n    return { packed: [[x.field, 48]] };\n  },\n};\n\nexport interface ZkappUri {\n  data: string;\n  hash: Field;\n}\n\nexport const ZkappUri: ProvableSerializable<ZkappUri> = {\n  ...proxyProvableSerializable<ZkappUri, any>(Struct({ data: String, hash: Field })),\n\n  toJSON(x: ZkappUri): any {\n    return x.data;\n  },\n\n  toAuxiliary(x?: ZkappUri): any[] {\n    return [x?.data];\n  },\n\n  fromFields(fields: Field[], aux: any[]) {\n    return {\n      data: aux[0],\n      hash: fields[0],\n    };\n  },\n};\n", "import { Field } from '../../../lib/provable/field.js';\nimport { Provable } from '../../../lib/provable/provable.js';\nimport { HashInput } from '../../../lib/provable/types/provable-derivers.js';\n\nexport type ProvableSerializable<T, Val = any> = Provable<T, Val> & {\n  toJSON(x: T): any;\n  toInput(x: T): HashInput;\n};\n\n// TODO: refactor Provable to use this kind of an interface (will save a lot of array slicing)\n// TODO: this could also handle aux data in addition to fields\nexport class FieldsDecoder {\n  constructor(\n    private fields: Field[],\n    private index: number = 0\n  ) {}\n\n  decode<T>(size: number, f: (subFields: Field[]) => T): T {\n    const subFields = this.fields.slice(this.index, this.index + size);\n    this.index += size;\n    return f(subFields);\n  }\n}\n", "import * as BindingsLeaves from './leaves.js';\nimport { FieldsDecoder, ProvableSerializable } from './util.js';\nimport { versionBytes } from '../../crypto/constants.js';\nimport { Provable } from '../../../lib/provable/provable.js';\nimport { HashInput } from '../../../lib/provable/types/provable-derivers.js';\nimport { toBase58Check } from '../../../lib/util/base58.js';\n\nconst JsArray = Array;\n\nabstract class ProvableBindingsType<T, Actual> {\n  abstract Type(): ProvableSerializable<Actual>;\n\n  sizeInFields(): number {\n    return this.Type().sizeInFields();\n  }\n\n  toJSON(x: T): any {\n    return this.Type().toJSON(x as never as Actual);\n  }\n\n  toInput(x: T): HashInput {\n    return this.Type().toInput(x as never as Actual);\n  }\n\n  toFields(x: T): BindingsLeaves.Field[] {\n    return this.Type().toFields(x as never as Actual);\n  }\n\n  toAuxiliary(x?: T): any[] {\n    return this.Type().toAuxiliary(x as never as Actual);\n  }\n\n  fromFields(fields: BindingsLeaves.Field[], aux: any[]): T {\n    return this.Type().fromFields(fields, aux) as never as T;\n  }\n\n  toValue(x: T): T {\n    return x;\n  }\n\n  fromValue(x: T): T {\n    return x;\n  }\n\n  check(x: T) {\n    return this.Type().check(x as never as Actual);\n  }\n}\n\nexport type BindingsType<T> =\n  | BindingsType.Leaf<T>\n  | BindingsType.Object<T>\n  | BindingsType.Option<T>\n  | BindingsType.Array<T>;\n\nfunction assertBindingsTypeImplementsProvable<\n  T,\n  B extends BindingsType<T> & ProvableSerializable<T>,\n>(_x?: B) {}\n\nassertBindingsTypeImplementsProvable<number, BindingsType<number>>();\nassertBindingsTypeImplementsProvable<string, BindingsType<string>>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.AuthRequired,\n  BindingsType<BindingsLeaves.AuthRequired>\n>();\nassertBindingsTypeImplementsProvable<BindingsLeaves.Bool, BindingsType<BindingsLeaves.Bool>>();\nassertBindingsTypeImplementsProvable<BindingsLeaves.Field, BindingsType<BindingsLeaves.Field>>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.PublicKey,\n  BindingsType<BindingsLeaves.PublicKey>\n>();\nassertBindingsTypeImplementsProvable<BindingsLeaves.Sign, BindingsType<BindingsLeaves.Sign>>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.TokenId,\n  BindingsType<BindingsLeaves.TokenId>\n>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.TokenSymbol,\n  BindingsType<BindingsLeaves.TokenSymbol>\n>();\nassertBindingsTypeImplementsProvable<BindingsLeaves.UInt32, BindingsType<BindingsLeaves.UInt32>>();\nassertBindingsTypeImplementsProvable<BindingsLeaves.UInt64, BindingsType<BindingsLeaves.UInt64>>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.ZkappUri,\n  BindingsType<BindingsLeaves.ZkappUri>\n>();\nassertBindingsTypeImplementsProvable<{ x: number }, BindingsType<{ x: number }>>();\nassertBindingsTypeImplementsProvable<number[], BindingsType<number[]>>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.Option<number>,\n  BindingsType<BindingsLeaves.Option<number>>\n>();\nassertBindingsTypeImplementsProvable<\n  BindingsLeaves.Option<BindingsLeaves.Range<number>>,\n  BindingsType<BindingsLeaves.Option<BindingsLeaves.Range<number>>>\n>();\n\nexport namespace BindingsType {\n  export class Object<T> implements Provable<T> {\n    readonly _T!: T extends { [key: string]: any } ? void : never;\n    readonly name: string;\n    readonly keys: (keyof T)[];\n    readonly entries: T extends { [key: string]: any }\n      ? { [key in keyof T]: BindingsType<T[key]> }\n      : never;\n\n    constructor({\n      name,\n      keys,\n      entries,\n    }: {\n      name: Object<T>['name'];\n      keys: Object<T>['keys'];\n      entries: Object<T>['entries'];\n    }) {\n      this.name = name;\n      this.keys = keys;\n      this.entries = entries;\n    }\n\n    sizeInFields(): number {\n      let sum = 0;\n      for (const key of this.keys) {\n        sum += this.entries[key].sizeInFields();\n      }\n      return sum;\n    }\n\n    toJSON(x: T): any {\n      // TODO: type safety\n      const x2 = x as { [key in keyof T]: any };\n      const json: Partial<T> = {};\n      for (const key of this.keys) {\n        json[key] = this.entries[key].toJSON(x2[key]);\n      }\n      return json;\n    }\n\n    toInput(x: T): HashInput {\n      // TODO: type safety\n      const x2 = x as { [key in keyof T]: any };\n      const acc: HashInput = { fields: [], packed: [] };\n      for (const key of this.keys) {\n        // surely there is an optimization here to avoid allocating so many temporary arrays\n        const { fields, packed } = this.entries[key].toInput(x2[key]);\n        acc.fields!.push(...(fields ?? []));\n        acc.packed!.push(...(packed ?? []));\n      }\n      return acc;\n    }\n\n    toFields(x: T): BindingsLeaves.Field[] {\n      // TODO: type safety\n      const x2 = x as { [key in keyof T]: any };\n      return this.keys.map((key) => this.entries[key].toFields(x2[key])).flat();\n    }\n\n    toAuxiliary(x?: T): any[] {\n      // TODO: type safety\n      const x2 = x as { [key in keyof T]: any } | undefined;\n      const entries2 = this.entries as { [key in keyof T]: BindingsType<any> };\n      return this.keys.map((key) =>\n        entries2[key].toAuxiliary(x2 !== undefined ? x2[key] : undefined)\n      );\n    }\n\n    fromFields(fields: BindingsLeaves.Field[], aux: any[]): T {\n      const decoder = new FieldsDecoder(fields);\n      // TODO: make this type-safe\n      // const obj: Partial<T> = {};\n      const obj: any = {};\n\n      for (const i in this.keys) {\n        const key = this.keys[i];\n        const entryType = this.entries[key];\n        const entryAux = aux[i];\n        // console.log(`${this.name}[${JSON.stringify(key)}] :: aux = ${JSON.stringify(entryAux)}`);\n        obj[key] = decoder.decode(entryType.sizeInFields(), (entryFields) =>\n          entryType.fromFields(entryFields, entryAux)\n        );\n      }\n\n      return obj;\n    }\n\n    toValue(x: T): T {\n      return x;\n    }\n\n    fromValue(x: T): T {\n      return x;\n    }\n\n    check(_x: T) {\n      throw new Error('TODO');\n    }\n  }\n\n  export class Array<T> implements Provable<T> {\n    readonly _T!: T extends any[] ? void : never;\n    readonly staticLength: number | null;\n    readonly inner: T extends (infer U)[] ? BindingsType<U> : never;\n\n    constructor({\n      staticLength,\n      inner,\n    }: {\n      staticLength: Array<T>['staticLength'];\n      inner: Array<T>['inner'];\n    }) {\n      this.staticLength = staticLength;\n      this.inner = inner;\n    }\n\n    sizeInFields(): number {\n      if (this.staticLength !== null) {\n        return this.staticLength * this.inner.sizeInFields();\n      } else {\n        return 0;\n      }\n    }\n\n    toJSON(x: T extends any[] ? T : never): any {\n      // TODO: type safety\n      const inner: BindingsType<any> = this.inner;\n      return x.map((el) => inner.toJSON(el));\n    }\n\n    toInput(x: T): HashInput {\n      if (!(x instanceof JsArray)) throw new Error('impossible');\n\n      // TODO: type safety\n      const inner: BindingsType<any> = this.inner;\n      const acc: HashInput = { fields: [], packed: [] };\n      x.forEach((el) => {\n        const { fields, packed } = inner.toInput(el);\n        acc.fields!.push(...(fields ?? []));\n        acc.packed!.push(...(packed ?? []));\n      });\n      return acc;\n    }\n\n    toFields(x: T): BindingsLeaves.Field[] {\n      if (!(x instanceof JsArray)) throw new Error('impossible');\n\n      // TODO: type safety\n      const inner: BindingsType<any> = this.inner;\n      return x.map((el) => inner.toFields(el)).flat();\n    }\n\n    toAuxiliary(x?: T): any[] {\n      if (this.staticLength !== null) {\n        if (x !== undefined) {\n          // TODO: type safety\n          const x2 = x as any[];\n          if (x2.length !== this.staticLength) throw new Error('invalid array length');\n          return x2.map((v) => this.inner.toAuxiliary(v));\n        } else {\n          return new JsArray(this.staticLength).fill(this.inner.toAuxiliary());\n        }\n      } else {\n        // TODO: type safety\n        return x as any[];\n      }\n    }\n\n    fromFields(fields: BindingsLeaves.Field[], aux: any[]): T {\n      if (this.staticLength !== null) {\n        const decoder = new FieldsDecoder(fields);\n        const x = new JsArray();\n        for (let i = 0; i < this.staticLength; i++)\n          x[i] = decoder.decode(this.inner.sizeInFields(), (f) => this.inner.fromFields(f, aux[i]));\n        // TODO: type safety\n        return x as T;\n      } else {\n        // TODO: type safety\n        return aux as T;\n      }\n    }\n\n    toValue(x: T): T {\n      return x;\n    }\n\n    fromValue(x: T): T {\n      return x;\n    }\n\n    check(_x: T) {\n      throw new Error('TODO');\n    }\n  }\n\n  export type Option<T> = Option.OrUndefined<T> | Option.Flagged<T> | Option.ClosedInterval<T>;\n\n  export namespace Option {\n    export class OrUndefined<T> implements Provable<T> {\n      readonly _T!: T extends infer _U | undefined ? void : never;\n\n      constructor(public readonly inner: T extends infer U | undefined ? BindingsType<U> : never) {}\n\n      sizeInFields(): number {\n        return 0;\n      }\n\n      toJSON(x: T): any {\n        // TODO: type safety\n        const x2 = x as any | undefined;\n        const inner = this.inner as BindingsType<any>;\n        return x2 !== undefined ? inner.toJSON(x2) : null;\n      }\n\n      toInput(_x: T): any {\n        return {};\n      }\n\n      toFields(_x: T): BindingsLeaves.Field[] {\n        return [];\n      }\n\n      toAuxiliary(x?: T): any[] {\n        return x === undefined ? [false] : [true, this.inner.toAuxiliary(x)];\n      }\n\n      fromFields(fields: BindingsLeaves.Field[], aux: any[]): T {\n        // TODO: type safety\n        return (aux[0] ? this.inner.fromFields(fields, aux[1]) : undefined) as T;\n      }\n\n      toValue(x: T): T {\n        return x;\n      }\n\n      fromValue(x: T): T {\n        return x;\n      }\n\n      check(_x: T) {\n        throw new Error('TODO');\n      }\n    }\n\n    export class Flagged<T> extends ProvableBindingsType<T, BindingsLeaves.Option<any>> {\n      readonly _T!: T extends BindingsLeaves.Option<any> ? void : never;\n\n      constructor(\n        public readonly inner: T extends BindingsLeaves.Option<infer U> ? BindingsType<U> : never\n      ) {\n        super();\n      }\n\n      Type() {\n        return BindingsLeaves.Option(this.inner as ProvableSerializable<any>);\n      }\n    }\n\n    export class ClosedInterval<T> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Option<BindingsLeaves.Range<any>>\n    > {\n      readonly _T!: T extends BindingsLeaves.Option<BindingsLeaves.Range<any>> ? void : never;\n\n      constructor(\n        public readonly inner: T extends BindingsLeaves.Option<BindingsLeaves.Range<infer U>>\n          ? BindingsType<U>\n          : never\n      ) {\n        super();\n      }\n\n      Type() {\n        return BindingsLeaves.Option(BindingsLeaves.Range(this.inner as ProvableSerializable<any>));\n      }\n    }\n  }\n\n  export type Leaf<T> =\n    | Leaf.Number<T>\n    | Leaf.String<T>\n    | Leaf.Actions<T>\n    | Leaf.AuthRequired<T>\n    | Leaf.Bool<T>\n    | Leaf.Events<T>\n    | Leaf.Field<T>\n    | Leaf.Int64<T>\n    | Leaf.PublicKey<T>\n    | Leaf.Sign<T>\n    | Leaf.StateHash<T>\n    | Leaf.TokenId<T>\n    | Leaf.TokenSymbol<T>\n    | Leaf.UInt32<T>\n    | Leaf.UInt64<T>\n    | Leaf.ZkappUri<T>;\n\n  export namespace Leaf {\n    abstract class AuxiliaryLeaf<T> {\n      constructor() {}\n\n      sizeInFields(): number {\n        return 0;\n      }\n\n      toJSON(x: T): any {\n        return x;\n      }\n\n      toInput(_x: T): HashInput {\n        return {};\n      }\n\n      toFields(_x: T): BindingsLeaves.Field[] {\n        return [];\n      }\n\n      toAuxiliary(x?: T): any[] {\n        return [x];\n      }\n\n      fromFields(_fields: BindingsLeaves.Field[], aux: any[]): T {\n        return aux[0];\n      }\n\n      toValue(x: T): T {\n        return x;\n      }\n\n      fromValue(x: T): T {\n        return x;\n      }\n\n      check(_x: T) {\n        throw new Error('TODO');\n      }\n    }\n\n    export class Number<T = number> extends AuxiliaryLeaf<T> {\n      readonly _T!: T extends number ? void : never;\n      readonly type: 'number' = 'number';\n    }\n\n    export class String<T = string> extends AuxiliaryLeaf<T> {\n      readonly _T!: T extends string ? void : never;\n      readonly type: 'string' = 'string';\n    }\n\n    export class Actions<T = BindingsLeaves.Actions> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Actions\n    > {\n      readonly _T!: T extends number ? void : never;\n      readonly type: 'number' = 'number';\n\n      Type() {\n        return BindingsLeaves.Actions;\n      }\n    }\n\n    export class AuthRequired<T = BindingsLeaves.AuthRequired> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.AuthRequired\n    > {\n      readonly _T!: T extends BindingsLeaves.AuthRequired ? void : never;\n      readonly type: 'AuthRequired' = 'AuthRequired';\n\n      Type() {\n        return BindingsLeaves.AuthRequired;\n      }\n    }\n\n    export class Bool<T = BindingsLeaves.Bool> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Bool\n    > {\n      readonly _T!: T extends BindingsLeaves.Bool ? void : never;\n      readonly type: 'Bool' = 'Bool';\n\n      Type() {\n        return BindingsLeaves.Bool;\n      }\n    }\n\n    export class Events<T = BindingsLeaves.Events> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Events\n    > {\n      readonly _T!: T extends number ? void : never;\n      readonly type: 'number' = 'number';\n\n      Type() {\n        return BindingsLeaves.Events;\n      }\n    }\n\n    export class Field<T = BindingsLeaves.Field> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Field\n    > {\n      readonly _T!: T extends BindingsLeaves.Field ? void : never;\n      readonly type: 'Field' = 'Field';\n\n      Type() {\n        return BindingsLeaves.Field;\n      }\n    }\n\n    export class Int64<T = BindingsLeaves.Int64> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Int64\n    > {\n      readonly _T!: T extends BindingsLeaves.Int64 ? void : never;\n      readonly type: 'Int64' = 'Int64';\n\n      Type() {\n        return BindingsLeaves.Int64;\n      }\n    }\n\n    export class PublicKey<T = BindingsLeaves.PublicKey> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.PublicKey\n    > {\n      readonly _T!: T extends BindingsLeaves.PublicKey ? void : never;\n      readonly type: 'PublicKey' = 'PublicKey';\n\n      Type() {\n        return BindingsLeaves.PublicKey;\n      }\n    }\n\n    export class Sign<T = BindingsLeaves.Sign> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.Sign\n    > {\n      readonly _T!: T extends BindingsLeaves.Sign ? void : never;\n      readonly type: 'Sign' = 'Sign';\n\n      Type() {\n        return BindingsLeaves.Sign;\n      }\n    }\n\n    export class StateHash<T = BindingsLeaves.StateHash> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.StateHash\n    > {\n      readonly _T!: T extends BindingsLeaves.StateHash ? void : never;\n      readonly type: 'StateHash' = 'StateHash';\n\n      Type() {\n        return BindingsLeaves.StateHash;\n      }\n    }\n\n    // TODO NOW\n    export class TokenId<T = BindingsLeaves.TokenId> implements Provable<T> {\n      readonly _T!: T extends BindingsLeaves.TokenId ? void : never;\n      readonly type: 'TokenId' = 'TokenId';\n\n      constructor() {}\n\n      sizeInFields(): number {\n        return BindingsLeaves.Field.sizeInFields();\n      }\n\n      toJSON(x: T): any {\n        // TODO: type safety\n        return toBase58Check(\n          BindingsLeaves.Field.toBytes(x as BindingsLeaves.Field),\n          versionBytes.tokenIdKey\n        );\n      }\n\n      toInput(x: T): HashInput {\n        // TODO: type safety\n        return BindingsLeaves.Field.toInput(x as BindingsLeaves.Field);\n      }\n\n      toFields(x: T): BindingsLeaves.Field[] {\n        // TODO: type safety\n        return BindingsLeaves.Field.toFields(x as BindingsLeaves.Field);\n      }\n\n      toAuxiliary(_x?: T): any[] {\n        return [];\n      }\n\n      fromFields(fields: BindingsLeaves.Field[], _aux: any[]): T {\n        // TODO: type safety\n        return BindingsLeaves.Field.fromFields(fields) as T;\n      }\n\n      toValue(x: T): T {\n        return x;\n      }\n\n      fromValue(x: T): T {\n        return x;\n      }\n\n      check(_x: T) {\n        throw new Error('TODO');\n      }\n    }\n\n    export class TokenSymbol<T = BindingsLeaves.TokenSymbol> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.TokenSymbol\n    > {\n      readonly _T!: T extends BindingsLeaves.TokenId ? void : never;\n      readonly type: 'TokenId' = 'TokenId';\n\n      Type() {\n        return BindingsLeaves.TokenSymbol;\n      }\n    }\n\n    export class UInt32<T = BindingsLeaves.UInt32> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.UInt32\n    > {\n      readonly _T!: T extends BindingsLeaves.UInt32 ? void : never;\n      readonly type: 'UInt32' = 'UInt32';\n\n      Type() {\n        return BindingsLeaves.UInt32;\n      }\n    }\n\n    export class UInt64<T = BindingsLeaves.UInt64> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.UInt64\n    > {\n      readonly _T!: T extends BindingsLeaves.UInt64 ? void : never;\n      readonly type: 'UInt64' = 'UInt64';\n\n      Type() {\n        return BindingsLeaves.UInt64;\n      }\n    }\n\n    export class ZkappUri<T = BindingsLeaves.ZkappUri> extends ProvableBindingsType<\n      T,\n      BindingsLeaves.ZkappUri\n    > {\n      readonly _T!: T extends BindingsLeaves.ZkappUri ? void : never;\n      readonly type: 'ZkappUri';\n\n      Type() {\n        return BindingsLeaves.ZkappUri;\n      }\n    }\n  }\n}\n", "// @generated this file is auto-generated - don't edit it directly\nimport {\n  Actions,\n  AuthRequired,\n  Bool,\n  Events,\n  Field,\n  Int64,\n  Option,\n  PublicKey,\n  Range,\n  StateHash,\n  TokenId,\n  TokenSymbol,\n  UInt32,\n  UInt64,\n  ZkappUri,\n} from '../../v2/leaves.js';\nimport { BindingsType } from '../../v2/schema.js';\nexport {\n  Account,\n  AccountPrecondition,\n  AccountTiming,\n  AccountUpdateBody,\n  AccountUpdateModification,\n  AuthorizationKindStructured,\n  Control,\n  EpochDataPrecondition,\n  EpochLedgerPrecondition,\n  FeePayerBody,\n  MayUseToken,\n  NetworkPrecondition,\n  Permissions,\n  Preconditions,\n  Timing,\n  Types,\n  VerificationKeyPermission,\n  VerificationKeyWithHash,\n  ZkappAccount,\n  ZkappAccountUpdate,\n  ZkappCommand,\n  ZkappFeePayer,\n};\ntype FeePayerBody = {\n  publicKey: PublicKey;\n  fee: UInt64;\n  validUntil: UInt32 | undefined;\n  nonce: UInt32;\n};\nconst FeePayerBody: BindingsType.Object<FeePayerBody> = new BindingsType.Object({\n  name: 'FeePayerBody',\n  keys: ['publicKey', 'fee', 'validUntil', 'nonce'],\n  entries: {\n    publicKey: new BindingsType.Leaf.PublicKey(),\n    fee: new BindingsType.Leaf.UInt64(),\n    validUntil: new BindingsType.Option.OrUndefined<UInt32>(new BindingsType.Leaf.UInt32()),\n    nonce: new BindingsType.Leaf.UInt32(),\n  },\n});\ntype VerificationKeyWithHash = { data: string; hash: Field };\nconst VerificationKeyWithHash: BindingsType.Object<VerificationKeyWithHash> =\n  new BindingsType.Object({\n    name: 'VerificationKeyWithHash',\n    keys: ['data', 'hash'],\n    entries: { data: new BindingsType.Leaf.String(), hash: new BindingsType.Leaf.Field() },\n  });\ntype VerificationKeyPermission = { auth: AuthRequired; txnVersion: UInt32 };\nconst VerificationKeyPermission: BindingsType.Object<VerificationKeyPermission> =\n  new BindingsType.Object({\n    name: 'VerificationKeyPermission',\n    keys: ['auth', 'txnVersion'],\n    entries: {\n      auth: new BindingsType.Leaf.AuthRequired(),\n      txnVersion: new BindingsType.Leaf.UInt32(),\n    },\n  });\ntype Timing = {\n  initialMinimumBalance: UInt64;\n  cliffTime: UInt32;\n  cliffAmount: UInt64;\n  vestingPeriod: UInt32;\n  vestingIncrement: UInt64;\n};\nconst Timing: BindingsType.Object<Timing> = new BindingsType.Object({\n  name: 'Timing',\n  keys: ['initialMinimumBalance', 'cliffTime', 'cliffAmount', 'vestingPeriod', 'vestingIncrement'],\n  entries: {\n    initialMinimumBalance: new BindingsType.Leaf.UInt64(),\n    cliffTime: new BindingsType.Leaf.UInt32(),\n    cliffAmount: new BindingsType.Leaf.UInt64(),\n    vestingPeriod: new BindingsType.Leaf.UInt32(),\n    vestingIncrement: new BindingsType.Leaf.UInt64(),\n  },\n});\ntype EpochLedgerPrecondition = { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\nconst EpochLedgerPrecondition: BindingsType.Object<EpochLedgerPrecondition> =\n  new BindingsType.Object({\n    name: 'EpochLedgerPrecondition',\n    keys: ['hash', 'totalCurrency'],\n    entries: {\n      hash: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n      totalCurrency: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt64()),\n    },\n  });\ntype AccountPrecondition = {\n  balance: Option<Range<UInt64>>;\n  nonce: Option<Range<UInt32>>;\n  receiptChainHash: Option<Field>;\n  delegate: Option<PublicKey>;\n  state: Option<Field>[];\n  actionState: Option<Field>;\n  provedState: Option<Bool>;\n  isNew: Option<Bool>;\n};\nconst AccountPrecondition: BindingsType.Object<AccountPrecondition> = new BindingsType.Object({\n  name: 'AccountPrecondition',\n  keys: [\n    'balance',\n    'nonce',\n    'receiptChainHash',\n    'delegate',\n    'state',\n    'actionState',\n    'provedState',\n    'isNew',\n  ],\n  entries: {\n    balance: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt64()),\n    nonce: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt32()),\n    receiptChainHash: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    delegate: new BindingsType.Option.Flagged(new BindingsType.Leaf.PublicKey()),\n    state: new BindingsType.Array({\n      staticLength: 8,\n      inner: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    }),\n    actionState: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    provedState: new BindingsType.Option.Flagged(new BindingsType.Leaf.Bool()),\n    isNew: new BindingsType.Option.Flagged(new BindingsType.Leaf.Bool()),\n  },\n});\ntype MayUseToken = { parentsOwnToken: Bool; inheritFromParent: Bool };\nconst MayUseToken: BindingsType.Object<MayUseToken> = new BindingsType.Object({\n  name: 'MayUseToken',\n  keys: ['parentsOwnToken', 'inheritFromParent'],\n  entries: {\n    parentsOwnToken: new BindingsType.Leaf.Bool(),\n    inheritFromParent: new BindingsType.Leaf.Bool(),\n  },\n});\ntype AuthorizationKindStructured = { isSigned: Bool; isProved: Bool; verificationKeyHash: Field };\nconst AuthorizationKindStructured: BindingsType.Object<AuthorizationKindStructured> =\n  new BindingsType.Object({\n    name: 'AuthorizationKindStructured',\n    keys: ['isSigned', 'isProved', 'verificationKeyHash'],\n    entries: {\n      isSigned: new BindingsType.Leaf.Bool(),\n      isProved: new BindingsType.Leaf.Bool(),\n      verificationKeyHash: new BindingsType.Leaf.Field(),\n    },\n  });\ntype Control = { proof: string | undefined; signature: string | undefined };\nconst Control: BindingsType.Object<Control> = new BindingsType.Object({\n  name: 'Control',\n  keys: ['proof', 'signature'],\n  entries: {\n    proof: new BindingsType.Option.OrUndefined<string>(new BindingsType.Leaf.String()),\n    signature: new BindingsType.Option.OrUndefined<string>(new BindingsType.Leaf.String()),\n  },\n});\ntype AccountTiming = {\n  isTimed: Bool;\n  initialMinimumBalance: UInt64;\n  cliffTime: UInt32;\n  cliffAmount: UInt64;\n  vestingPeriod: UInt32;\n  vestingIncrement: UInt64;\n};\nconst AccountTiming: BindingsType.Object<AccountTiming> = new BindingsType.Object({\n  name: 'AccountTiming',\n  keys: [\n    'isTimed',\n    'initialMinimumBalance',\n    'cliffTime',\n    'cliffAmount',\n    'vestingPeriod',\n    'vestingIncrement',\n  ],\n  entries: {\n    isTimed: new BindingsType.Leaf.Bool(),\n    initialMinimumBalance: new BindingsType.Leaf.UInt64(),\n    cliffTime: new BindingsType.Leaf.UInt32(),\n    cliffAmount: new BindingsType.Leaf.UInt64(),\n    vestingPeriod: new BindingsType.Leaf.UInt32(),\n    vestingIncrement: new BindingsType.Leaf.UInt64(),\n  },\n});\ntype ZkappFeePayer = {\n  body: { publicKey: PublicKey; fee: UInt64; validUntil: UInt32 | undefined; nonce: UInt32 };\n  authorization: string;\n};\nconst ZkappFeePayer: BindingsType.Object<ZkappFeePayer> = new BindingsType.Object({\n  name: 'ZkappFeePayer',\n  keys: ['body', 'authorization'],\n  entries: { body: FeePayerBody, authorization: new BindingsType.Leaf.String() },\n});\ntype Permissions = {\n  editState: AuthRequired;\n  access: AuthRequired;\n  send: AuthRequired;\n  receive: AuthRequired;\n  setDelegate: AuthRequired;\n  setPermissions: AuthRequired;\n  setVerificationKey: { auth: AuthRequired; txnVersion: UInt32 };\n  setZkappUri: AuthRequired;\n  editActionState: AuthRequired;\n  setTokenSymbol: AuthRequired;\n  incrementNonce: AuthRequired;\n  setVotingFor: AuthRequired;\n  setTiming: AuthRequired;\n};\nconst Permissions: BindingsType.Object<Permissions> = new BindingsType.Object({\n  name: 'Permissions',\n  keys: [\n    'editState',\n    'access',\n    'send',\n    'receive',\n    'setDelegate',\n    'setPermissions',\n    'setVerificationKey',\n    'setZkappUri',\n    'editActionState',\n    'setTokenSymbol',\n    'incrementNonce',\n    'setVotingFor',\n    'setTiming',\n  ],\n  entries: {\n    editState: new BindingsType.Leaf.AuthRequired(),\n    access: new BindingsType.Leaf.AuthRequired(),\n    send: new BindingsType.Leaf.AuthRequired(),\n    receive: new BindingsType.Leaf.AuthRequired(),\n    setDelegate: new BindingsType.Leaf.AuthRequired(),\n    setPermissions: new BindingsType.Leaf.AuthRequired(),\n    setVerificationKey: VerificationKeyPermission,\n    setZkappUri: new BindingsType.Leaf.AuthRequired(),\n    editActionState: new BindingsType.Leaf.AuthRequired(),\n    setTokenSymbol: new BindingsType.Leaf.AuthRequired(),\n    incrementNonce: new BindingsType.Leaf.AuthRequired(),\n    setVotingFor: new BindingsType.Leaf.AuthRequired(),\n    setTiming: new BindingsType.Leaf.AuthRequired(),\n  },\n});\ntype EpochDataPrecondition = {\n  ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n  seed: Option<Field>;\n  startCheckpoint: Option<Field>;\n  lockCheckpoint: Option<Field>;\n  epochLength: Option<Range<UInt32>>;\n};\nconst EpochDataPrecondition: BindingsType.Object<EpochDataPrecondition> = new BindingsType.Object({\n  name: 'EpochDataPrecondition',\n  keys: ['ledger', 'seed', 'startCheckpoint', 'lockCheckpoint', 'epochLength'],\n  entries: {\n    ledger: EpochLedgerPrecondition,\n    seed: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    startCheckpoint: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    lockCheckpoint: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    epochLength: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt32()),\n  },\n});\ntype ZkappAccount = {\n  appState: Field[];\n  verificationKey: { data: string; hash: Field } | undefined;\n  zkappVersion: UInt32;\n  actionState: Field[];\n  lastActionSlot: UInt32;\n  provedState: Bool;\n  zkappUri: string;\n};\nconst ZkappAccount: BindingsType.Object<ZkappAccount> = new BindingsType.Object({\n  name: 'ZkappAccount',\n  keys: [\n    'appState',\n    'verificationKey',\n    'zkappVersion',\n    'actionState',\n    'lastActionSlot',\n    'provedState',\n    'zkappUri',\n  ],\n  entries: {\n    appState: new BindingsType.Array({\n      staticLength: 8,\n      inner: new BindingsType.Leaf.Field(),\n    }),\n    verificationKey: new BindingsType.Option.OrUndefined<{ data: string; hash: Field }>(\n      VerificationKeyWithHash\n    ),\n    zkappVersion: new BindingsType.Leaf.UInt32(),\n    actionState: new BindingsType.Array({\n      staticLength: 5,\n      inner: new BindingsType.Leaf.Field(),\n    }),\n    lastActionSlot: new BindingsType.Leaf.UInt32(),\n    provedState: new BindingsType.Leaf.Bool(),\n    zkappUri: new BindingsType.Leaf.String(),\n  },\n});\ntype AccountUpdateModification = {\n  appState: Option<Field>[];\n  delegate: Option<PublicKey>;\n  verificationKey: Option<{ data: string; hash: Field }>;\n  permissions: Option<{\n    editState: AuthRequired;\n    access: AuthRequired;\n    send: AuthRequired;\n    receive: AuthRequired;\n    setDelegate: AuthRequired;\n    setPermissions: AuthRequired;\n    setVerificationKey: { auth: AuthRequired; txnVersion: UInt32 };\n    setZkappUri: AuthRequired;\n    editActionState: AuthRequired;\n    setTokenSymbol: AuthRequired;\n    incrementNonce: AuthRequired;\n    setVotingFor: AuthRequired;\n    setTiming: AuthRequired;\n  }>;\n  zkappUri: Option<ZkappUri>;\n  tokenSymbol: Option<TokenSymbol>;\n  timing: Option<{\n    initialMinimumBalance: UInt64;\n    cliffTime: UInt32;\n    cliffAmount: UInt64;\n    vestingPeriod: UInt32;\n    vestingIncrement: UInt64;\n  }>;\n  votingFor: Option<StateHash>;\n};\nconst AccountUpdateModification: BindingsType.Object<AccountUpdateModification> =\n  new BindingsType.Object({\n    name: 'AccountUpdateModification',\n    keys: [\n      'appState',\n      'delegate',\n      'verificationKey',\n      'permissions',\n      'zkappUri',\n      'tokenSymbol',\n      'timing',\n      'votingFor',\n    ],\n    entries: {\n      appState: new BindingsType.Array({\n        staticLength: 8,\n        inner: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n      }),\n      delegate: new BindingsType.Option.Flagged(new BindingsType.Leaf.PublicKey()),\n      verificationKey: new BindingsType.Option.Flagged(VerificationKeyWithHash),\n      permissions: new BindingsType.Option.Flagged(Permissions),\n      zkappUri: new BindingsType.Option.Flagged(new BindingsType.Leaf.ZkappUri()),\n      tokenSymbol: new BindingsType.Option.Flagged(new BindingsType.Leaf.TokenSymbol()),\n      timing: new BindingsType.Option.Flagged(Timing),\n      votingFor: new BindingsType.Option.Flagged(new BindingsType.Leaf.StateHash()),\n    },\n  });\ntype NetworkPrecondition = {\n  snarkedLedgerHash: Option<Field>;\n  blockchainLength: Option<Range<UInt32>>;\n  minWindowDensity: Option<Range<UInt32>>;\n  totalCurrency: Option<Range<UInt64>>;\n  globalSlotSinceGenesis: Option<Range<UInt32>>;\n  stakingEpochData: {\n    ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n    seed: Option<Field>;\n    startCheckpoint: Option<Field>;\n    lockCheckpoint: Option<Field>;\n    epochLength: Option<Range<UInt32>>;\n  };\n  nextEpochData: {\n    ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n    seed: Option<Field>;\n    startCheckpoint: Option<Field>;\n    lockCheckpoint: Option<Field>;\n    epochLength: Option<Range<UInt32>>;\n  };\n};\nconst NetworkPrecondition: BindingsType.Object<NetworkPrecondition> = new BindingsType.Object({\n  name: 'NetworkPrecondition',\n  keys: [\n    'snarkedLedgerHash',\n    'blockchainLength',\n    'minWindowDensity',\n    'totalCurrency',\n    'globalSlotSinceGenesis',\n    'stakingEpochData',\n    'nextEpochData',\n  ],\n  entries: {\n    snarkedLedgerHash: new BindingsType.Option.Flagged(new BindingsType.Leaf.Field()),\n    blockchainLength: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt32()),\n    minWindowDensity: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt32()),\n    totalCurrency: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt64()),\n    globalSlotSinceGenesis: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt32()),\n    stakingEpochData: EpochDataPrecondition,\n    nextEpochData: EpochDataPrecondition,\n  },\n});\ntype Account = {\n  publicKey: PublicKey;\n  tokenId: TokenId;\n  tokenSymbol: string;\n  balance: UInt64;\n  nonce: UInt32;\n  receiptChainHash: Field;\n  delegate: PublicKey | undefined;\n  votingFor: Field;\n  timing: {\n    isTimed: Bool;\n    initialMinimumBalance: UInt64;\n    cliffTime: UInt32;\n    cliffAmount: UInt64;\n    vestingPeriod: UInt32;\n    vestingIncrement: UInt64;\n  };\n  permissions: {\n    editState: AuthRequired;\n    access: AuthRequired;\n    send: AuthRequired;\n    receive: AuthRequired;\n    setDelegate: AuthRequired;\n    setPermissions: AuthRequired;\n    setVerificationKey: { auth: AuthRequired; txnVersion: UInt32 };\n    setZkappUri: AuthRequired;\n    editActionState: AuthRequired;\n    setTokenSymbol: AuthRequired;\n    incrementNonce: AuthRequired;\n    setVotingFor: AuthRequired;\n    setTiming: AuthRequired;\n  };\n  zkapp:\n    | {\n        appState: Field[];\n        verificationKey: { data: string; hash: Field } | undefined;\n        zkappVersion: UInt32;\n        actionState: Field[];\n        lastActionSlot: UInt32;\n        provedState: Bool;\n        zkappUri: string;\n      }\n    | undefined;\n};\nconst Account: BindingsType.Object<Account> = new BindingsType.Object({\n  name: 'Account',\n  keys: [\n    'publicKey',\n    'tokenId',\n    'tokenSymbol',\n    'balance',\n    'nonce',\n    'receiptChainHash',\n    'delegate',\n    'votingFor',\n    'timing',\n    'permissions',\n    'zkapp',\n  ],\n  entries: {\n    publicKey: new BindingsType.Leaf.PublicKey(),\n    tokenId: new BindingsType.Leaf.TokenId(),\n    tokenSymbol: new BindingsType.Leaf.String(),\n    balance: new BindingsType.Leaf.UInt64(),\n    nonce: new BindingsType.Leaf.UInt32(),\n    receiptChainHash: new BindingsType.Leaf.Field(),\n    delegate: new BindingsType.Option.OrUndefined<PublicKey>(new BindingsType.Leaf.PublicKey()),\n    votingFor: new BindingsType.Leaf.Field(),\n    timing: AccountTiming,\n    permissions: Permissions,\n    zkapp: new BindingsType.Option.OrUndefined<{\n      appState: Field[];\n      verificationKey: { data: string; hash: Field } | undefined;\n      zkappVersion: UInt32;\n      actionState: Field[];\n      lastActionSlot: UInt32;\n      provedState: Bool;\n      zkappUri: string;\n    }>(ZkappAccount),\n  },\n});\ntype Preconditions = {\n  network: {\n    snarkedLedgerHash: Option<Field>;\n    blockchainLength: Option<Range<UInt32>>;\n    minWindowDensity: Option<Range<UInt32>>;\n    totalCurrency: Option<Range<UInt64>>;\n    globalSlotSinceGenesis: Option<Range<UInt32>>;\n    stakingEpochData: {\n      ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n      seed: Option<Field>;\n      startCheckpoint: Option<Field>;\n      lockCheckpoint: Option<Field>;\n      epochLength: Option<Range<UInt32>>;\n    };\n    nextEpochData: {\n      ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n      seed: Option<Field>;\n      startCheckpoint: Option<Field>;\n      lockCheckpoint: Option<Field>;\n      epochLength: Option<Range<UInt32>>;\n    };\n  };\n  account: {\n    balance: Option<Range<UInt64>>;\n    nonce: Option<Range<UInt32>>;\n    receiptChainHash: Option<Field>;\n    delegate: Option<PublicKey>;\n    state: Option<Field>[];\n    actionState: Option<Field>;\n    provedState: Option<Bool>;\n    isNew: Option<Bool>;\n  };\n  validWhile: Option<Range<UInt32>>;\n};\nconst Preconditions: BindingsType.Object<Preconditions> = new BindingsType.Object({\n  name: 'Preconditions',\n  keys: ['network', 'account', 'validWhile'],\n  entries: {\n    network: NetworkPrecondition,\n    account: AccountPrecondition,\n    validWhile: new BindingsType.Option.ClosedInterval(new BindingsType.Leaf.UInt32()),\n  },\n});\ntype AccountUpdateBody = {\n  publicKey: PublicKey;\n  tokenId: TokenId;\n  update: {\n    appState: Option<Field>[];\n    delegate: Option<PublicKey>;\n    verificationKey: Option<{ data: string; hash: Field }>;\n    permissions: Option<{\n      editState: AuthRequired;\n      access: AuthRequired;\n      send: AuthRequired;\n      receive: AuthRequired;\n      setDelegate: AuthRequired;\n      setPermissions: AuthRequired;\n      setVerificationKey: { auth: AuthRequired; txnVersion: UInt32 };\n      setZkappUri: AuthRequired;\n      editActionState: AuthRequired;\n      setTokenSymbol: AuthRequired;\n      incrementNonce: AuthRequired;\n      setVotingFor: AuthRequired;\n      setTiming: AuthRequired;\n    }>;\n    zkappUri: Option<ZkappUri>;\n    tokenSymbol: Option<TokenSymbol>;\n    timing: Option<{\n      initialMinimumBalance: UInt64;\n      cliffTime: UInt32;\n      cliffAmount: UInt64;\n      vestingPeriod: UInt32;\n      vestingIncrement: UInt64;\n    }>;\n    votingFor: Option<StateHash>;\n  };\n  balanceChange: Int64;\n  incrementNonce: Bool;\n  events: Events;\n  actions: Actions;\n  callData: Field;\n  callDepth: number;\n  preconditions: {\n    network: {\n      snarkedLedgerHash: Option<Field>;\n      blockchainLength: Option<Range<UInt32>>;\n      minWindowDensity: Option<Range<UInt32>>;\n      totalCurrency: Option<Range<UInt64>>;\n      globalSlotSinceGenesis: Option<Range<UInt32>>;\n      stakingEpochData: {\n        ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n        seed: Option<Field>;\n        startCheckpoint: Option<Field>;\n        lockCheckpoint: Option<Field>;\n        epochLength: Option<Range<UInt32>>;\n      };\n      nextEpochData: {\n        ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n        seed: Option<Field>;\n        startCheckpoint: Option<Field>;\n        lockCheckpoint: Option<Field>;\n        epochLength: Option<Range<UInt32>>;\n      };\n    };\n    account: {\n      balance: Option<Range<UInt64>>;\n      nonce: Option<Range<UInt32>>;\n      receiptChainHash: Option<Field>;\n      delegate: Option<PublicKey>;\n      state: Option<Field>[];\n      actionState: Option<Field>;\n      provedState: Option<Bool>;\n      isNew: Option<Bool>;\n    };\n    validWhile: Option<Range<UInt32>>;\n  };\n  useFullCommitment: Bool;\n  implicitAccountCreationFee: Bool;\n  mayUseToken: { parentsOwnToken: Bool; inheritFromParent: Bool };\n  authorizationKind: { isSigned: Bool; isProved: Bool; verificationKeyHash: Field };\n};\nconst AccountUpdateBody: BindingsType.Object<AccountUpdateBody> = new BindingsType.Object({\n  name: 'AccountUpdateBody',\n  keys: [\n    'publicKey',\n    'tokenId',\n    'update',\n    'balanceChange',\n    'incrementNonce',\n    'events',\n    'actions',\n    'callData',\n    'callDepth',\n    'preconditions',\n    'useFullCommitment',\n    'implicitAccountCreationFee',\n    'mayUseToken',\n    'authorizationKind',\n  ],\n  entries: {\n    publicKey: new BindingsType.Leaf.PublicKey(),\n    tokenId: new BindingsType.Leaf.TokenId(),\n    update: AccountUpdateModification,\n    balanceChange: new BindingsType.Leaf.Int64(),\n    incrementNonce: new BindingsType.Leaf.Bool(),\n    events: new BindingsType.Leaf.Events(),\n    actions: new BindingsType.Leaf.Actions(),\n    callData: new BindingsType.Leaf.Field(),\n    callDepth: new BindingsType.Leaf.Number(),\n    preconditions: Preconditions,\n    useFullCommitment: new BindingsType.Leaf.Bool(),\n    implicitAccountCreationFee: new BindingsType.Leaf.Bool(),\n    mayUseToken: MayUseToken,\n    authorizationKind: AuthorizationKindStructured,\n  },\n});\ntype ZkappAccountUpdate = {\n  body: {\n    publicKey: PublicKey;\n    tokenId: TokenId;\n    update: {\n      appState: Option<Field>[];\n      delegate: Option<PublicKey>;\n      verificationKey: Option<{ data: string; hash: Field }>;\n      permissions: Option<{\n        editState: AuthRequired;\n        access: AuthRequired;\n        send: AuthRequired;\n        receive: AuthRequired;\n        setDelegate: AuthRequired;\n        setPermissions: AuthRequired;\n        setVerificationKey: { auth: AuthRequired; txnVersion: UInt32 };\n        setZkappUri: AuthRequired;\n        editActionState: AuthRequired;\n        setTokenSymbol: AuthRequired;\n        incrementNonce: AuthRequired;\n        setVotingFor: AuthRequired;\n        setTiming: AuthRequired;\n      }>;\n      zkappUri: Option<ZkappUri>;\n      tokenSymbol: Option<TokenSymbol>;\n      timing: Option<{\n        initialMinimumBalance: UInt64;\n        cliffTime: UInt32;\n        cliffAmount: UInt64;\n        vestingPeriod: UInt32;\n        vestingIncrement: UInt64;\n      }>;\n      votingFor: Option<StateHash>;\n    };\n    balanceChange: Int64;\n    incrementNonce: Bool;\n    events: Events;\n    actions: Actions;\n    callData: Field;\n    callDepth: number;\n    preconditions: {\n      network: {\n        snarkedLedgerHash: Option<Field>;\n        blockchainLength: Option<Range<UInt32>>;\n        minWindowDensity: Option<Range<UInt32>>;\n        totalCurrency: Option<Range<UInt64>>;\n        globalSlotSinceGenesis: Option<Range<UInt32>>;\n        stakingEpochData: {\n          ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n          seed: Option<Field>;\n          startCheckpoint: Option<Field>;\n          lockCheckpoint: Option<Field>;\n          epochLength: Option<Range<UInt32>>;\n        };\n        nextEpochData: {\n          ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n          seed: Option<Field>;\n          startCheckpoint: Option<Field>;\n          lockCheckpoint: Option<Field>;\n          epochLength: Option<Range<UInt32>>;\n        };\n      };\n      account: {\n        balance: Option<Range<UInt64>>;\n        nonce: Option<Range<UInt32>>;\n        receiptChainHash: Option<Field>;\n        delegate: Option<PublicKey>;\n        state: Option<Field>[];\n        actionState: Option<Field>;\n        provedState: Option<Bool>;\n        isNew: Option<Bool>;\n      };\n      validWhile: Option<Range<UInt32>>;\n    };\n    useFullCommitment: Bool;\n    implicitAccountCreationFee: Bool;\n    mayUseToken: { parentsOwnToken: Bool; inheritFromParent: Bool };\n    authorizationKind: { isSigned: Bool; isProved: Bool; verificationKeyHash: Field };\n  };\n  authorization: { proof: string | undefined; signature: string | undefined };\n};\nconst ZkappAccountUpdate: BindingsType.Object<ZkappAccountUpdate> = new BindingsType.Object({\n  name: 'ZkappAccountUpdate',\n  keys: ['body', 'authorization'],\n  entries: { body: AccountUpdateBody, authorization: Control },\n});\ntype ZkappCommand = {\n  feePayer: {\n    body: { publicKey: PublicKey; fee: UInt64; validUntil: UInt32 | undefined; nonce: UInt32 };\n    authorization: string;\n  };\n  accountUpdates: {\n    body: {\n      publicKey: PublicKey;\n      tokenId: TokenId;\n      update: {\n        appState: Option<Field>[];\n        delegate: Option<PublicKey>;\n        verificationKey: Option<{ data: string; hash: Field }>;\n        permissions: Option<{\n          editState: AuthRequired;\n          access: AuthRequired;\n          send: AuthRequired;\n          receive: AuthRequired;\n          setDelegate: AuthRequired;\n          setPermissions: AuthRequired;\n          setVerificationKey: { auth: AuthRequired; txnVersion: UInt32 };\n          setZkappUri: AuthRequired;\n          editActionState: AuthRequired;\n          setTokenSymbol: AuthRequired;\n          incrementNonce: AuthRequired;\n          setVotingFor: AuthRequired;\n          setTiming: AuthRequired;\n        }>;\n        zkappUri: Option<ZkappUri>;\n        tokenSymbol: Option<TokenSymbol>;\n        timing: Option<{\n          initialMinimumBalance: UInt64;\n          cliffTime: UInt32;\n          cliffAmount: UInt64;\n          vestingPeriod: UInt32;\n          vestingIncrement: UInt64;\n        }>;\n        votingFor: Option<StateHash>;\n      };\n      balanceChange: Int64;\n      incrementNonce: Bool;\n      events: Events;\n      actions: Actions;\n      callData: Field;\n      callDepth: number;\n      preconditions: {\n        network: {\n          snarkedLedgerHash: Option<Field>;\n          blockchainLength: Option<Range<UInt32>>;\n          minWindowDensity: Option<Range<UInt32>>;\n          totalCurrency: Option<Range<UInt64>>;\n          globalSlotSinceGenesis: Option<Range<UInt32>>;\n          stakingEpochData: {\n            ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n            seed: Option<Field>;\n            startCheckpoint: Option<Field>;\n            lockCheckpoint: Option<Field>;\n            epochLength: Option<Range<UInt32>>;\n          };\n          nextEpochData: {\n            ledger: { hash: Option<Field>; totalCurrency: Option<Range<UInt64>> };\n            seed: Option<Field>;\n            startCheckpoint: Option<Field>;\n            lockCheckpoint: Option<Field>;\n            epochLength: Option<Range<UInt32>>;\n          };\n        };\n        account: {\n          balance: Option<Range<UInt64>>;\n          nonce: Option<Range<UInt32>>;\n          receiptChainHash: Option<Field>;\n          delegate: Option<PublicKey>;\n          state: Option<Field>[];\n          actionState: Option<Field>;\n          provedState: Option<Bool>;\n          isNew: Option<Bool>;\n        };\n        validWhile: Option<Range<UInt32>>;\n      };\n      useFullCommitment: Bool;\n      implicitAccountCreationFee: Bool;\n      mayUseToken: { parentsOwnToken: Bool; inheritFromParent: Bool };\n      authorizationKind: { isSigned: Bool; isProved: Bool; verificationKeyHash: Field };\n    };\n    authorization: { proof: string | undefined; signature: string | undefined };\n  }[];\n  memo: string;\n};\nconst ZkappCommand: BindingsType.Object<ZkappCommand> = new BindingsType.Object({\n  name: 'ZkappCommand',\n  keys: ['feePayer', 'accountUpdates', 'memo'],\n  entries: {\n    feePayer: ZkappFeePayer,\n    accountUpdates: new BindingsType.Array({\n      staticLength: null,\n      inner: ZkappAccountUpdate,\n    }),\n    memo: new BindingsType.Leaf.String(),\n  },\n});\nconst Types: { [key: string]: BindingsType<any> } = {\n  ZkappCommand,\n  ZkappFeePayer,\n  FeePayerBody,\n  ZkappAccountUpdate,\n  AccountUpdateBody,\n  AccountUpdateModification,\n  VerificationKeyWithHash,\n  Permissions,\n  VerificationKeyPermission,\n  Timing,\n  Preconditions,\n  NetworkPrecondition,\n  EpochDataPrecondition,\n  EpochLedgerPrecondition,\n  AccountPrecondition,\n  MayUseToken,\n  AuthorizationKindStructured,\n  Control,\n  Account,\n  AccountTiming,\n  ZkappAccount,\n};\n", "import { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { UInt32 } from '../../provable/int.js';\nimport { PrivateKey, PublicKey } from '../../provable/crypto/signature.js';\nimport { HashInput } from '../../provable/types/provable-derivers.js';\nimport * as Bindings from '../../../bindings/mina-transaction/v2/index.js';\nimport { NetworkId } from '../../../mina-signer/src/types.js';\nimport { protocolVersions } from '../../../bindings/crypto/constants.js';\n\nexport {\n  AccountUpdateAuthorization,\n  AccountUpdateAuthorizationEnvironment,\n  AccountUpdateAuthorizationKind,\n  AccountUpdateAuthorizationKindIdentifier,\n  AccountUpdateAuthorizationKindWithZkappContext,\n  AuthorizationLevelIdentifier,\n  VerificationKeyAuthorizationLevel,\n  ZkappFeePaymentAuthorizationEnvironment,\n  ZkappCommandAuthorizationEnvironment,\n};\n\ntype AuthorizationLevelIdentifier = Bindings.Leaves.AuthRequiredIdentifier;\nexport class AuthorizationLevel {\n  // TODO: it would be nice if these could be private, but then the subtyping doesn't work... maybe we can do a trick here with object splats?\n  constant: Bool;\n  signatureNecessary: Bool;\n  signatureSufficient: Bool;\n\n  constructor({\n    constant,\n    signatureNecessary,\n    signatureSufficient,\n  }: {\n    constant: Bool;\n    signatureNecessary: Bool;\n    signatureSufficient: Bool;\n  }) {\n    this.constant = constant;\n    this.signatureNecessary = signatureNecessary;\n    this.signatureSufficient = signatureSufficient;\n  }\n\n  toInternalRepr(): Bindings.Leaves.AuthRequired {\n    return this;\n  }\n\n  static fromInternalRepr(x: Bindings.Leaves.AuthRequired): AuthorizationLevel {\n    return new AuthorizationLevel(x);\n  }\n\n  toJSON(): any {\n    return AuthorizationLevel.toJSON(this);\n  }\n\n  toInput(): HashInput {\n    return AuthorizationLevel.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return AuthorizationLevel.toFields(this);\n  }\n\n  isImpossible(): Bool {\n    return Bindings.Leaves.AuthRequired.isImpossible(this);\n  }\n\n  isNone(): Bool {\n    return Bindings.Leaves.AuthRequired.isNone(this);\n  }\n\n  isProof(): Bool {\n    return Bindings.Leaves.AuthRequired.isProof(this);\n  }\n\n  isSignature(): Bool {\n    return Bindings.Leaves.AuthRequired.isSignature(this);\n  }\n\n  isProofOrSignature(): Bool {\n    return Bindings.Leaves.AuthRequired.isEither(this);\n  }\n\n  requiresProof(): Bool {\n    return this.isProof().or(this.isProofOrSignature());\n  }\n\n  requiresSignature(): Bool {\n    return this.isSignature().or(this.isProofOrSignature());\n  }\n\n  isSatisfied(authKind: AccountUpdateAuthorizationKind): Bool {\n    return Bool.allTrue([\n      this.requiresProof().implies(authKind.isProved),\n      this.requiresSignature().implies(authKind.isSigned),\n    ]);\n  }\n\n  // TODO: property test that this is the inverse of `from` identifier\n  identifier(): AuthorizationLevelIdentifier {\n    if (this.isImpossible().toBoolean()) {\n      return 'Impossible';\n    } else if (this.isNone().toBoolean()) {\n      return 'None';\n    } else if (this.isProof().toBoolean()) {\n      return 'Proof';\n    } else if (this.isSignature().toBoolean()) {\n      return 'Signature';\n    } else if (this.isProofOrSignature().toBoolean()) {\n      return 'Either';\n    } else {\n      throw new Error('internal error: invalid authorization level');\n    }\n  }\n\n  static Impossible(): AuthorizationLevel {\n    return new AuthorizationLevel({\n      constant: new Bool(true),\n      signatureNecessary: new Bool(true),\n      signatureSufficient: new Bool(false),\n    });\n  }\n\n  static None(): AuthorizationLevel {\n    return new AuthorizationLevel({\n      constant: new Bool(true),\n      signatureNecessary: new Bool(false),\n      signatureSufficient: new Bool(true),\n    });\n  }\n\n  static Proof(): AuthorizationLevel {\n    return new AuthorizationLevel({\n      constant: new Bool(false),\n      signatureNecessary: new Bool(false),\n      signatureSufficient: new Bool(false),\n    });\n  }\n\n  static Signature(): AuthorizationLevel {\n    return new AuthorizationLevel({\n      constant: new Bool(false),\n      signatureNecessary: new Bool(true),\n      signatureSufficient: new Bool(true),\n    });\n  }\n\n  static ProofOrSignature(): AuthorizationLevel {\n    return new AuthorizationLevel({\n      constant: new Bool(false),\n      signatureNecessary: new Bool(false),\n      signatureSufficient: new Bool(true),\n    });\n  }\n\n  // TODO: ProofAndSignature\n\n  static sizeInFields(): number {\n    return Bindings.Leaves.AuthRequired.sizeInFields();\n  }\n\n  static empty(): AuthorizationLevel {\n    return new AuthorizationLevel(Bindings.Leaves.AuthRequired.empty());\n  }\n\n  static toJSON(x: AuthorizationLevel): any {\n    return Bindings.Leaves.AuthRequired.toJSON(x);\n  }\n\n  static toInput(x: AuthorizationLevel): HashInput {\n    return Bindings.Leaves.AuthRequired.toInput(x);\n  }\n\n  static toFields(x: AuthorizationLevel): Field[] {\n    return Bindings.Leaves.AuthRequired.toFields(x);\n  }\n\n  static toAuxiliary(x?: AuthorizationLevel): any[] {\n    return Bindings.Leaves.AuthRequired.toAuxiliary(x);\n  }\n\n  static fromFields(fields: Field[], aux: any[]): AuthorizationLevel {\n    return new AuthorizationLevel(Bindings.Leaves.AuthRequired.fromFields(fields, aux));\n  }\n\n  static check(x: AuthorizationLevel) {\n    Bindings.Leaves.AuthRequired.check(x);\n  }\n\n  static toValue(x: AuthorizationLevel): AuthorizationLevel {\n    return x;\n  }\n\n  static fromValue(x: AuthorizationLevel): AuthorizationLevel {\n    return x;\n  }\n\n  static from(x: AuthorizationLevelIdentifier | AuthorizationLevel): AuthorizationLevel {\n    switch (x) {\n      case 'Signature':\n        return AuthorizationLevel.Signature();\n      case 'Proof':\n        return AuthorizationLevel.Proof();\n      // TODO: rename this\n      case 'Either':\n        return AuthorizationLevel.ProofOrSignature();\n      case 'None':\n        return AuthorizationLevel.None();\n      case 'Impossible':\n        return AuthorizationLevel.Impossible();\n      default:\n        return x;\n    }\n  }\n}\n\nclass VerificationKeyAuthorizationLevel {\n  auth: AuthorizationLevel;\n  txnVersion: UInt32;\n\n  constructor(\n    auth: AuthorizationLevel,\n    txnVersion: UInt32 = UInt32.from(protocolVersions.txnVersion)\n  ) {\n    this.auth = auth;\n    this.txnVersion = txnVersion;\n  }\n\n  toJSON(): { auth: AuthorizationLevelIdentifier; txnVersion: string } {\n    return {\n      auth: this.auth.toJSON(),\n      txnVersion: this.txnVersion.toString(),\n    };\n  }\n\n  // private static get layout(): BindingsLayout {\n  //   return bindingsLayout.AccountUpdate\n  //     .get('body', 'update', 'permissions')\n  //     .unwrapOption()\n  //     .inner\n  //     .get('setVerificationKey')\n  //     .unwrapObject();\n  // }\n\n  static sizeInFields(): number {\n    return Bindings.Leaves.AuthRequired.sizeInFields();\n  }\n\n  static empty(): VerificationKeyAuthorizationLevel {\n    return new VerificationKeyAuthorizationLevel(AuthorizationLevel.empty(), UInt32.zero);\n  }\n\n  static toFields(_x: VerificationKeyAuthorizationLevel): Field[] {\n    throw new Error('TODO');\n    // return Bindings.AuthRequired.toFields(x);\n  }\n\n  static toAuxiliary(_x?: VerificationKeyAuthorizationLevel): any[] {\n    throw new Error('TODO');\n    // return Bindings.AuthRequired.toAuxiliary(x);\n  }\n\n  static fromFields(_fields: Field[], _aux: any[]): VerificationKeyAuthorizationLevel {\n    throw new Error('TODO');\n    /*\n    BindingsLayout.Object.fromFields(fields, aux)\n\n    const schema = {\n      auth: AuthorizationLevel.fromFields,\n      txnVersion: UInt32.fromFields,\n    };\n\n    return new VerificationKeyAuthorizationLevel(BindingsLayout.fromFields(VerificationKeyAuthorizationLevel.bindingsLayout, this, ));\n    */\n  }\n\n  static check(_x: VerificationKeyAuthorizationLevel) {\n    throw new Error('TODO');\n    // Bindings.AuthRequired.check(x);\n  }\n\n  static toValue(x: VerificationKeyAuthorizationLevel): VerificationKeyAuthorizationLevel {\n    return x;\n  }\n\n  static fromValue(x: VerificationKeyAuthorizationLevel): VerificationKeyAuthorizationLevel {\n    return x;\n  }\n\n  static from(\n    x: AuthorizationLevelIdentifier | AuthorizationLevel | VerificationKeyAuthorizationLevel\n  ): VerificationKeyAuthorizationLevel {\n    if (x instanceof VerificationKeyAuthorizationLevel) {\n      return x;\n    } else {\n      return new VerificationKeyAuthorizationLevel(AuthorizationLevel.from(x));\n    }\n  }\n}\n\ninterface AccountUpdateAuthorization {\n  proof: string | null;\n  signature: string | null;\n}\n\ntype AccountUpdateAuthorizationKindIdentifier =\n  | 'None'\n  | 'Signature'\n  | 'Proof'\n  | 'SignatureAndProof';\n\nclass AccountUpdateAuthorizationKind {\n  isSigned: Bool;\n  isProved: Bool;\n\n  constructor({ isSigned, isProved }: { isSigned: Bool; isProved: Bool }) {\n    this.isSigned = isSigned;\n    this.isProved = isProved;\n  }\n\n  // NB: only safe to call in prover contexts\n  // TODO: we should replace this with a circuit-safe representation using ZkEnum\n  identifier(): AccountUpdateAuthorizationKindIdentifier {\n    if (this.isSigned.toBoolean()) {\n      if (this.isProved.toBoolean()) {\n        return 'SignatureAndProof';\n      } else {\n        return 'Signature';\n      }\n    } else {\n      if (this.isProved.toBoolean()) {\n        return 'Proof';\n      } else {\n        return 'None';\n      }\n    }\n  }\n\n  static from(\n    x: AccountUpdateAuthorizationKindIdentifier | AccountUpdateAuthorizationKind\n  ): AccountUpdateAuthorizationKind {\n    if (x instanceof AccountUpdateAuthorizationKind) return x;\n\n    switch (x) {\n      case 'None':\n        return AccountUpdateAuthorizationKind.None();\n      case 'Signature':\n        return AccountUpdateAuthorizationKind.Signature();\n      case 'Proof':\n        return AccountUpdateAuthorizationKind.Proof();\n      case 'SignatureAndProof':\n        return AccountUpdateAuthorizationKind.SignatureAndProof();\n    }\n  }\n\n  static None(): AccountUpdateAuthorizationKind {\n    return new AccountUpdateAuthorizationKind({\n      isSigned: new Bool(false),\n      isProved: new Bool(false),\n    });\n  }\n\n  static Signature(): AccountUpdateAuthorizationKind {\n    return new AccountUpdateAuthorizationKind({\n      isSigned: new Bool(true),\n      isProved: new Bool(false),\n    });\n  }\n\n  static Proof(): AccountUpdateAuthorizationKind {\n    return new AccountUpdateAuthorizationKind({\n      isSigned: new Bool(false),\n      isProved: new Bool(true),\n    });\n  }\n\n  static SignatureAndProof(): AccountUpdateAuthorizationKind {\n    return new AccountUpdateAuthorizationKind({\n      isSigned: new Bool(true),\n      isProved: new Bool(true),\n    });\n  }\n}\n\nclass AccountUpdateAuthorizationKindWithZkappContext {\n  isSigned: Bool;\n  isProved: Bool;\n  verificationKeyHash: Field;\n\n  constructor(kind: AccountUpdateAuthorizationKind, verificationKeyHash: Field) {\n    this.isSigned = kind.isSigned;\n    this.isProved = kind.isProved;\n    this.verificationKeyHash = verificationKeyHash;\n  }\n\n  toJSON(): any {\n    Bindings.Layout.AuthorizationKindStructured.toJSON(this);\n  }\n}\n\ntype AccountUpdateAuthorizationEnvironment = ZkappCommandAuthorizationEnvironment & {\n  accountUpdateForestCommitment: bigint; // TODO: Field;\n  fullTransactionCommitment?: bigint; // TODO: Field;\n};\n\ninterface ZkappFeePaymentAuthorizationEnvironment {\n  networkId: NetworkId;\n  privateKey: PrivateKey;\n  fullTransactionCommitment: bigint; // TODO: Field\n}\n\ninterface ZkappCommandAuthorizationEnvironment {\n  networkId: NetworkId;\n  getPrivateKey(publicKey: PublicKey): Promise<PrivateKey>;\n}\n", "import {\n  AuthorizationLevel,\n  AuthorizationLevelIdentifier,\n  VerificationKeyAuthorizationLevel,\n} from './authorization.js';\nimport { Field } from '../../provable/field.js';\nimport { Provable } from '../../provable/provable.js';\nimport * as BindingsLayout from '../../../bindings/mina-transaction/gen/v2/js-layout.js';\n\n// TODO: rename some of these to make them clearer (eg editActionState, timing)\n// TODO: consider only allowing the identifiers to be specified to some special Permissions.constant function (to avoid people breaking the DSL pattern accidentally)\nexport type PermissionsDescription = {\n  editState: AuthorizationLevelIdentifier | AuthorizationLevel;\n  access: AuthorizationLevelIdentifier | AuthorizationLevel;\n  send: AuthorizationLevelIdentifier | AuthorizationLevel;\n  receive: AuthorizationLevelIdentifier | AuthorizationLevel;\n  setDelegate: AuthorizationLevelIdentifier | AuthorizationLevel;\n  setPermissions: AuthorizationLevelIdentifier | AuthorizationLevel;\n  // IMPORTANT TODO: we should be using special auth level identifiers here\n  setVerificationKey:\n    | AuthorizationLevelIdentifier\n    | AuthorizationLevel\n    | VerificationKeyAuthorizationLevel;\n  setZkappUri: AuthorizationLevelIdentifier | AuthorizationLevel;\n  editActionState: AuthorizationLevelIdentifier | AuthorizationLevel;\n  setTokenSymbol: AuthorizationLevelIdentifier | AuthorizationLevel;\n  incrementNonce: AuthorizationLevelIdentifier | AuthorizationLevel;\n  setVotingFor: AuthorizationLevelIdentifier | AuthorizationLevel;\n  setTiming: AuthorizationLevelIdentifier | AuthorizationLevel;\n};\n\nexport class Permissions {\n  editState: AuthorizationLevel;\n  access: AuthorizationLevel;\n  send: AuthorizationLevel;\n  receive: AuthorizationLevel;\n  setDelegate: AuthorizationLevel;\n  setPermissions: AuthorizationLevel;\n  setVerificationKey: VerificationKeyAuthorizationLevel;\n  setZkappUri: AuthorizationLevel;\n  editActionState: AuthorizationLevel;\n  setTokenSymbol: AuthorizationLevel;\n  incrementNonce: AuthorizationLevel;\n  setVotingFor: AuthorizationLevel;\n  setTiming: AuthorizationLevel;\n\n  constructor(descr: PermissionsDescription) {\n    this.editState = AuthorizationLevel.from(descr.editState);\n    this.access = AuthorizationLevel.from(descr.access);\n    this.send = AuthorizationLevel.from(descr.send);\n    this.receive = AuthorizationLevel.from(descr.receive);\n    this.setDelegate = AuthorizationLevel.from(descr.setDelegate);\n    this.setPermissions = AuthorizationLevel.from(descr.setPermissions);\n    this.setVerificationKey = VerificationKeyAuthorizationLevel.from(descr.setVerificationKey);\n    this.setZkappUri = AuthorizationLevel.from(descr.setZkappUri);\n    this.editActionState = AuthorizationLevel.from(descr.editActionState);\n    this.setTokenSymbol = AuthorizationLevel.from(descr.setTokenSymbol);\n    this.incrementNonce = AuthorizationLevel.from(descr.incrementNonce);\n    this.setVotingFor = AuthorizationLevel.from(descr.setVotingFor);\n    this.setTiming = AuthorizationLevel.from(descr.setTiming);\n  }\n\n  toJSON(): any {\n    return Permissions.toJSON(this);\n  }\n\n  static defaults(): Permissions {\n    return new Permissions({\n      editState: 'Signature',\n      send: 'Signature',\n      receive: 'None',\n      setDelegate: 'Signature',\n      setPermissions: 'Signature',\n      setVerificationKey: 'Signature',\n      setZkappUri: 'Signature',\n      editActionState: 'Proof',\n      setTokenSymbol: 'Signature',\n      incrementNonce: 'Signature',\n      setVotingFor: 'Signature',\n      setTiming: 'Signature',\n      access: 'None',\n    });\n  }\n\n  static empty(): Permissions {\n    return new Permissions({\n      editState: 'None',\n      send: 'None',\n      receive: 'None',\n      setDelegate: 'None',\n      setPermissions: 'None',\n      setVerificationKey: 'None',\n      setZkappUri: 'None',\n      editActionState: 'None',\n      setTokenSymbol: 'None',\n      incrementNonce: 'None',\n      setVotingFor: 'None',\n      setTiming: 'None',\n      access: 'None',\n    });\n  }\n\n  // TODO: port these definitions\n\n  // initial: (): Permissions => ({\n  //   editState: Permission.signature(),\n  //   send: Permission.signature(),\n  //   receive: Permission.none(),\n  //   setDelegate: Permission.signature(),\n  //   setPermissions: Permission.signature(),\n  //   setVerificationKey: {\n  //     auth: Permission.signature(),\n  //     txnVersion: TransactionVersion.current(),\n  //   },\n  //   setZkappUri: Permission.signature(),\n  //   editActionState: Permission.signature(),\n  //   setTokenSymbol: Permission.signature(),\n  //   incrementNonce: Permission.signature(),\n  //   setVotingFor: Permission.signature(),\n  //   setTiming: Permission.signature(),\n  //   access: Permission.none(),\n  // }),\n\n  // dummy: (): Permissions => ({\n  //   editState: Permission.none(),\n  //   send: Permission.none(),\n  //   receive: Permission.none(),\n  //   access: Permission.none(),\n  //   setDelegate: Permission.none(),\n  //   setPermissions: Permission.none(),\n  //   setVerificationKey: {\n  //     auth: Permission.signature(),\n  //     txnVersion: TransactionVersion.current(),\n  //   },\n  //   setZkappUri: Permission.none(),\n  //   editActionState: Permission.none(),\n  //   setTokenSymbol: Permission.none(),\n  //   incrementNonce: Permission.none(),\n  //   setVotingFor: Permission.none(),\n  //   setTiming: Permission.none(),\n  // }),\n\n  // allImpossible: (): Permissions => ({\n  //   editState: Permission.impossible(),\n  //   send: Permission.impossible(),\n  //   receive: Permission.impossible(),\n  //   access: Permission.impossible(),\n  //   setDelegate: Permission.impossible(),\n  //   setPermissions: Permission.impossible(),\n  //   setVerificationKey: {\n  //     auth: Permission.signature(),\n  //     txnVersion: TransactionVersion.current(),\n  //   },\n  //   setZkappUri: Permission.impossible(),\n  //   editActionState: Permission.impossible(),\n  //   setTokenSymbol: Permission.impossible(),\n  //   incrementNonce: Permission.impossible(),\n  //   setVotingFor: Permission.impossible(),\n  //   setTiming: Permission.impossible(),\n  // }),\n\n  static sizeInFields(): number {\n    return BindingsLayout.Permissions.sizeInFields();\n  }\n\n  static toJSON(p: Permissions): any {\n    return BindingsLayout.Permissions.toJSON(p);\n  }\n\n  static toFields(p: Permissions): Field[] {\n    return BindingsLayout.Permissions.toFields(p);\n  }\n\n  static fromFields(fields: Field[], aux: any[]): Permissions {\n    return Permissions.fromInternalRepr(BindingsLayout.Permissions.fromFields(fields, aux));\n  }\n\n  static toAuxiliary(x?: Permissions): any[] {\n    return BindingsLayout.Permissions.toAuxiliary(x);\n  }\n\n  static toValue(x: Permissions): Permissions {\n    return x;\n  }\n\n  static fromValue(x: Permissions): Permissions {\n    return x;\n  }\n\n  static check(_x: Permissions) {\n    throw new Error('TODO');\n  }\n\n  static fromInternalRepr(x: BindingsLayout.Permissions): Permissions {\n    return new Permissions({\n      editState: new AuthorizationLevel(x.editState),\n      send: new AuthorizationLevel(x.send),\n      receive: new AuthorizationLevel(x.receive),\n      setDelegate: new AuthorizationLevel(x.setDelegate),\n      setPermissions: new AuthorizationLevel(x.setPermissions),\n      setVerificationKey: new VerificationKeyAuthorizationLevel(\n        new AuthorizationLevel(x.setVerificationKey.auth),\n        x.setVerificationKey.txnVersion\n      ),\n      setZkappUri: new AuthorizationLevel(x.setZkappUri),\n      editActionState: new AuthorizationLevel(x.editActionState),\n      setTokenSymbol: new AuthorizationLevel(x.setTokenSymbol),\n      incrementNonce: new AuthorizationLevel(x.incrementNonce),\n      setVotingFor: new AuthorizationLevel(x.setVotingFor),\n      setTiming: new AuthorizationLevel(x.setTiming),\n      access: new AuthorizationLevel(x.access),\n    });\n  }\n\n  static from(x: PermissionsDescription | Permissions): Permissions {\n    return x instanceof Permissions ? x : new Permissions(x);\n  }\n}\n\nAuthorizationLevel satisfies Provable<AuthorizationLevel>;\nVerificationKeyAuthorizationLevel satisfies Provable<VerificationKeyAuthorizationLevel>;\nPermissions satisfies Provable<Permissions>;\n", "import { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { Provable } from '../../provable/types/provable-intf.js';\nimport * as Bindings from '../../../bindings/mina-transaction/v2/index.js';\nimport { bytesToBits, stringToBytes } from '../../../bindings/lib/binable.js';\nimport { GenericHashInput } from '../../../bindings/lib/generic.js';\nimport { hashWithPrefix, packToFields } from '../../../lib/provable/crypto/poseidon.js';\nimport { prefixes } from '../../../bindings/crypto/constants.js';\nimport { Types } from '../../../bindings/mina-transaction/v1/types.js';\n\nexport {\n  Option,\n  Range,\n  mapUndefined,\n  Empty,\n  Update,\n  Compare,\n  Eq,\n  ToFields,\n  Tuple,\n  ProvableTuple,\n  ProvableInstance,\n  ProvableTupleInstances,\n  TokenId,\n  ZkappUri,\n  mapObject,\n};\n\n// boo typescript\nfunction mapObject<In extends { [key: string]: any }, Out extends { [key in keyof In]: any }>(\n  object: In,\n  f: <Key extends keyof In>(key: Key) => Out[Key]\n): { [key in keyof In]: Out[key] } {\n  const newObject: Partial<{ [key in keyof In]: Out[key] }> = {};\n  for (const key in object) {\n    newObject[key] = f(key);\n  }\n  return newObject as { [key in keyof In]: Out[key] };\n}\n\nconst { Option, Range } = Bindings.Leaves;\ntype Option<T> = Bindings.Leaves.Option<T>;\ntype Range<T> = Bindings.Leaves.Range<T>;\n\nclass ZkappUri {\n  readonly data: string;\n  readonly hash: Field;\n\n  constructor(uri: string | { data: string; hash: Field }) {\n    if (typeof uri === 'object') {\n      this.data = uri.data;\n      this.hash = uri.hash;\n    } else {\n      this.data = uri;\n\n      let packed: Field[];\n      if (uri.length === 0) {\n        packed = [new Field(0), new Field(0)];\n      } else {\n        const bits = bytesToBits(stringToBytes(uri));\n        bits.push(true);\n        const input: GenericHashInput<Field> = {\n          packed: bits.map((b) => [new Field(Number(b)), 1]),\n        };\n        packed = packToFields(input);\n      }\n\n      this.hash = hashWithPrefix(prefixes.zkappUri, packed);\n    }\n  }\n\n  toJSON(): Types.Json.AccountUpdate['body']['update']['zkappUri'] {\n    return this.data.toString();\n  }\n\n  static empty(): ZkappUri {\n    return new ZkappUri('');\n  }\n\n  static from(uri: ZkappUri | string): ZkappUri {\n    return uri instanceof ZkappUri ? uri : new ZkappUri(uri);\n  }\n}\n\nclass TokenId {\n  // TODO: construct this from it's parts, don't pass in the raw Field directly\n  constructor(public value: Field) {}\n\n  equals(x: TokenId): Bool {\n    return this.value.equals(x.value);\n  }\n\n  toString(): string {\n    return this.value.toString();\n  }\n\n  static MINA: TokenId = new TokenId(new Field(1));\n}\n\nfunction mapUndefined<A, B>(value: A | undefined, f: (a: A) => B): B | undefined {\n  return value === undefined ? undefined : f(value);\n}\n\ninterface Empty<T> {\n  empty: () => T;\n}\n\ninterface Eq<T> {\n  equals(x: T): Bool;\n}\n\ntype Compare<T extends Compare<T>> = Eq<T> & {\n  lessThan(x: T): Bool;\n  lessThanOrEqual(x: T): Bool;\n  greaterThan(x: T): Bool;\n  greaterThanOrEqual(x: T): Bool;\n};\n\ninterface ToFields {\n  toFields(): Field[];\n}\n\ntype Tuple<T> = [T, ...T[]] | [];\n\ntype ProvableTuple = Tuple<Provable<any>>;\n\ntype ProvableInstance<P> = P extends Provable<infer T> ? (unknown extends T ? T : never) : never;\n\ntype ProvableTupleInstances<T extends ProvableTuple> = {\n  [I in keyof T]: ProvableInstance<T[I]>;\n};\n\nclass Update<T> {\n  constructor(\n    public set: Bool,\n    public value: T\n  ) {}\n\n  toOption(): Option<T> {\n    return { isSome: this.set, value: this.value };\n  }\n\n  static fromOption<T>(option: Option<T>): Update<T> {\n    return new Update(option.isSome, option.value);\n  }\n\n  static disabled<T>(defaultValue: T): Update<T> {\n    return new Update(new Bool(false), defaultValue);\n  }\n\n  static set<T>(value: T): Update<T> {\n    return new Update(new Bool(true), value);\n  }\n\n  static from<T>(value: Update<T> | T | undefined, defaultValue: T): Update<T> {\n    if (value instanceof Update) {\n      return value;\n    } else if (value !== undefined) {\n      return Update.set(value);\n    } else {\n      return Update.disabled(defaultValue);\n    }\n  }\n}\n", "import { Compare, Eq, Option, Range } from './core.js';\nimport {\n  GenericStatePreconditions,\n  StatePreconditions,\n  StateDefinition,\n  StateLayout,\n} from './state.js';\nimport { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { HashInput } from '../../provable/types/provable-derivers.js';\n// TODO: pull last remanants of old transaction leaves into v2 bindings\nimport { Actions } from '../../../bindings/mina-transaction/v1/transaction-leaves.js';\nimport * as BindingsLayout from '../../../bindings/mina-transaction/gen/v2/js-layout.js';\nimport { ZkappConstants } from '../v1/constants.js';\nimport { MinaAmount } from './currency.js';\n\nexport {\n  Preconditions,\n  Precondition,\n  PreconditionsDescription,\n  EpochDataPreconditions,\n  EpochLedgerPreconditions,\n};\n\nnamespace Precondition {\n  export class Equals<T extends Eq<T>> {\n    constructor(\n      public isEnabled: Bool,\n      public value: T\n    ) {}\n\n    toStringHuman(): string {\n      if (!this.isEnabled.toBoolean()) {\n        return 'disabled';\n      } else {\n        return `== ${this.value}`;\n      }\n    }\n\n    toValue<D>(defaultValue: D): T | D {\n      if (this.isEnabled.toBoolean()) {\n        return this.value;\n      } else {\n        return defaultValue;\n      }\n    }\n\n    mapToValue<D, R>(defaultValue: D, f: (t: T) => R): R | D {\n      if (this.isEnabled.toBoolean()) {\n        return f(this.value);\n      } else {\n        return defaultValue;\n      }\n    }\n\n    toOption(): Option<T> {\n      return { isSome: this.isEnabled, value: this.value };\n    }\n\n    isSatisfied(x: T): Bool {\n      return Bool.or(this.isEnabled.not(), this.value.equals(x));\n    }\n\n    static disabled<T extends Eq<T>>(defaultValue: T): Equals<T> {\n      return new Equals(new Bool(false), defaultValue);\n    }\n\n    static equals<T extends Eq<T>>(value: T): Equals<T> {\n      return new Equals(new Bool(true), value);\n    }\n\n    static fromOption<T extends Eq<T>>(option: Option<T>): Equals<T> {\n      return new Equals(option.isSome, option.value);\n    }\n\n    static from<T extends Eq<T>>(value: Equals<T> | T | undefined, defaultValue: T): Equals<T> {\n      if (value instanceof Equals) {\n        return value;\n      } else if (value !== undefined) {\n        return Equals.equals(value);\n      } else {\n        return Equals.disabled(defaultValue);\n      }\n    }\n  }\n\n  export class InRange<T extends Compare<T>> {\n    constructor(\n      public isEnabled: Bool,\n      public lower: T,\n      public upper: T\n    ) {}\n\n    toStringHuman(): string {\n      if (!this.isEnabled.toBoolean()) {\n        return 'disabled';\n      } else if (this.lower.equals(this.upper).toBoolean()) {\n        return `== ${this.lower}`;\n      } else {\n        return `between (${this.lower}, ${this.upper})`;\n      }\n    }\n\n    toValue<D>(defaultValue: D): { lower: T; upper: T } | D {\n      if (this.isEnabled.toBoolean()) {\n        return { lower: this.lower, upper: this.upper };\n      } else {\n        return defaultValue;\n      }\n    }\n\n    mapToValue<D, R>(defaultValue: D, f: (t: T) => R): { lower: R; upper: R } | D {\n      if (this.isEnabled.toBoolean()) {\n        return { lower: f(this.lower), upper: f(this.upper) };\n      } else {\n        return defaultValue;\n      }\n    }\n\n    toOption(): Option<Range<T>> {\n      return {\n        isSome: this.isEnabled,\n        value: {\n          lower: this.lower,\n          upper: this.upper,\n        },\n      };\n    }\n\n    isSatisfied(x: T): Bool {\n      return Bool.or(\n        this.isEnabled.not(),\n        Bool.and(this.lower.lessThanOrEqual(x), this.upper.greaterThanOrEqual(x))\n      );\n    }\n\n    static disabled<T extends Compare<T>>(defaultValue: T | { lower: T; upper: T }): InRange<T> {\n      const isDefaultRange =\n        typeof defaultValue === 'object' &&\n        defaultValue !== null &&\n        'lower' in defaultValue &&\n        'upper' in defaultValue;\n      const lower = isDefaultRange ? defaultValue.lower : defaultValue;\n      const upper = isDefaultRange ? defaultValue.upper : defaultValue;\n      return new InRange(new Bool(false), lower, upper);\n    }\n\n    static equals<T extends Compare<T>>(value: T): InRange<T> {\n      return new InRange(new Bool(true), value, value);\n    }\n\n    static betweenInclusive<T extends Compare<T>>(lower: T, upper: T): InRange<T> {\n      return new InRange(new Bool(true), lower, upper);\n    }\n\n    static fromOption<T extends Compare<T>>(option: Option<Range<T>>): InRange<T> {\n      return new InRange(option.isSome, option.value.lower, option.value.upper);\n    }\n\n    // TODO: lessThan, greaterThan\n\n    static from<T extends Compare<T>>(\n      value: InRange<T> | T | undefined,\n      defaultValue: T | { lower: T; upper: T }\n    ): InRange<T> {\n      if (value instanceof InRange) {\n        return value;\n      } else if (value !== undefined) {\n        return InRange.equals(value);\n      } else {\n        return InRange.disabled(defaultValue);\n      }\n    }\n  }\n}\n\ntype PreconditionsDescription<State extends StateLayout> = {\n  network?: NetworkPreconditionsDescription | NetworkPreconditions;\n  account?: AccountPreconditionsDescription<State> | AccountPreconditions<State>;\n  validWhile?: UInt32 | Precondition.InRange<UInt32>;\n};\n\nclass Preconditions<State extends StateLayout = 'GenericState'> {\n  readonly network: NetworkPreconditions;\n  readonly account: AccountPreconditions<State>;\n  readonly validWhile: Precondition.InRange<UInt32>;\n\n  constructor(State: StateDefinition<State>, descr?: PreconditionsDescription<State>) {\n    this.network = NetworkPreconditions.from(descr?.network);\n    this.account = AccountPreconditions.from(State, descr?.account);\n    this.validWhile = Precondition.InRange.from(descr?.validWhile, {\n      lower: UInt32.empty(),\n      upper: UInt32.MAXINT(),\n    });\n  }\n\n  toGeneric(): Preconditions {\n    return new Preconditions<'GenericState'>('GenericState', {\n      ...this,\n      account: this.account.toGeneric(),\n    });\n  }\n\n  static fromGeneric<State extends StateLayout>(\n    x: Preconditions,\n    State: StateDefinition<State>\n  ): Preconditions<State> {\n    return new Preconditions(State, {\n      ...this,\n      account: AccountPreconditions.fromGeneric(x.account, State),\n    });\n  }\n\n  toInternalRepr(): BindingsLayout.Preconditions {\n    return {\n      network: this.network.toInternalRepr(),\n      account: this.account.toInternalRepr(),\n      validWhile: this.validWhile.toOption(),\n    };\n  }\n\n  static fromInternalRepr(x: BindingsLayout.Preconditions): Preconditions {\n    return new Preconditions('GenericState', {\n      network: NetworkPreconditions.fromInternalRepr(x.network),\n      account: AccountPreconditions.fromInternalRepr(x.account),\n      validWhile: Precondition.InRange.fromOption(x.validWhile),\n    });\n  }\n\n  toJSON(): any {\n    return Preconditions.toJSON(this);\n  }\n\n  toInput(): HashInput {\n    return Preconditions.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return Preconditions.toFields(this);\n  }\n\n  static sizeInFields(): number {\n    return BindingsLayout.Preconditions.sizeInFields();\n  }\n\n  static emptyPoly<State extends StateLayout>(State: StateDefinition<State>): Preconditions<State> {\n    return new Preconditions(State);\n  }\n\n  static empty(): Preconditions {\n    return new Preconditions('GenericState');\n  }\n\n  static check<State extends StateLayout>(_x: Preconditions<State>) {\n    throw new Error('TODO');\n  }\n\n  static toJSON<State extends StateLayout>(x: Preconditions<State>): any {\n    return BindingsLayout.Preconditions.toJSON(x.toInternalRepr());\n  }\n\n  static toInput<State extends StateLayout>(x: Preconditions<State>): HashInput {\n    return BindingsLayout.Preconditions.toInput(x.toInternalRepr());\n  }\n\n  static toFields<State extends StateLayout>(x: Preconditions<State>): Field[] {\n    return BindingsLayout.Preconditions.toFields(x.toInternalRepr());\n  }\n\n  static fromFields(fields: Field[], aux: any[]): Preconditions {\n    return Preconditions.fromInternalRepr(BindingsLayout.Preconditions.fromFields(fields, aux));\n  }\n\n  static toAuxiliary<State extends StateLayout>(x?: Preconditions<State>): any[] {\n    return BindingsLayout.Preconditions.toAuxiliary(x?.toInternalRepr());\n  }\n\n  static toValue<State extends StateLayout>(x: Preconditions<State>): Preconditions<State> {\n    return x;\n  }\n\n  static fromValue<State extends StateLayout>(x: Preconditions<State>): Preconditions<State> {\n    return x;\n  }\n\n  static from<State extends StateLayout>(\n    State: StateDefinition<State>,\n    value: Preconditions<State> | PreconditionsDescription<State> | undefined\n  ): Preconditions<State> {\n    if (value instanceof Preconditions) {\n      return value;\n    } else if (value === undefined) {\n      return Preconditions.emptyPoly(State);\n    } else {\n      return new Preconditions(State, value);\n    }\n  }\n}\n\ntype EpochLedgerPreconditionsDescription = {\n  hash?: Field | Precondition.Equals<Field>;\n  totalCurrency?: MinaAmount | Precondition.InRange<MinaAmount>;\n};\n\nclass EpochLedgerPreconditions {\n  readonly hash: Precondition.Equals<Field>;\n  readonly totalCurrency: Precondition.InRange<MinaAmount>;\n\n  constructor(descr?: EpochLedgerPreconditionsDescription) {\n    this.hash = Precondition.Equals.from(descr?.hash, new Field(0));\n    this.totalCurrency = Precondition.InRange.from(descr?.totalCurrency, {\n      lower: UInt64.empty(),\n      upper: UInt64.MAXINT(),\n    });\n  }\n\n  toInternalRepr(): BindingsLayout.EpochLedgerPrecondition {\n    return {\n      hash: this.hash.toOption(),\n      totalCurrency: this.totalCurrency.toOption(),\n    };\n  }\n\n  static fromInternalRepr(x: BindingsLayout.EpochLedgerPrecondition): EpochLedgerPreconditions {\n    return new EpochLedgerPreconditions({\n      hash: Precondition.Equals.fromOption(x.hash),\n      totalCurrency: Precondition.InRange.fromOption(x.totalCurrency),\n    });\n  }\n\n  toJSON(): any {\n    return EpochLedgerPreconditions.toJSON(this);\n  }\n\n  toInput(): HashInput {\n    return EpochLedgerPreconditions.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return EpochLedgerPreconditions.toFields(this);\n  }\n\n  static sizeInFields(): number {\n    return BindingsLayout.EpochLedgerPrecondition.sizeInFields();\n  }\n\n  static empty(): EpochLedgerPreconditions {\n    return new EpochLedgerPreconditions();\n  }\n\n  static check(_x: EpochLedgerPreconditions) {\n    throw new Error('TODO');\n  }\n\n  static toJSON(x: EpochLedgerPreconditions): any {\n    return BindingsLayout.EpochLedgerPrecondition.toJSON(x.toInternalRepr());\n  }\n\n  static toInput(x: EpochLedgerPreconditions): HashInput {\n    return BindingsLayout.EpochLedgerPrecondition.toInput(x.toInternalRepr());\n  }\n\n  static toFields(x: EpochLedgerPreconditions): Field[] {\n    return BindingsLayout.EpochLedgerPrecondition.toFields(x.toInternalRepr());\n  }\n\n  static fromFields(fields: Field[], aux: any[]): EpochLedgerPreconditions {\n    return EpochLedgerPreconditions.fromInternalRepr(\n      BindingsLayout.EpochLedgerPrecondition.fromFields(fields, aux)\n    );\n  }\n\n  static toAuxiliary(x?: EpochLedgerPreconditions): any[] {\n    return BindingsLayout.EpochLedgerPrecondition.toAuxiliary(x?.toInternalRepr());\n  }\n\n  static toValue(x: EpochLedgerPreconditions): EpochLedgerPreconditions {\n    return x;\n  }\n\n  static fromValue(x: EpochLedgerPreconditions): EpochLedgerPreconditions {\n    return x;\n  }\n\n  static from(\n    value: EpochLedgerPreconditions | EpochLedgerPreconditionsDescription | undefined\n  ): EpochLedgerPreconditions {\n    if (value instanceof EpochLedgerPreconditions) {\n      return value;\n    } else if (value === undefined) {\n      return EpochLedgerPreconditions.empty();\n    } else {\n      return new EpochLedgerPreconditions(value);\n    }\n  }\n}\n\ntype EpochDataPreconditionsDescription = {\n  ledger?: EpochLedgerPreconditions | EpochLedgerPreconditionsDescription;\n  seed?: Field | Precondition.Equals<Field>;\n  startCheckpoint?: Field | Precondition.Equals<Field>;\n  lockCheckpoint?: Field | Precondition.Equals<Field>;\n  epochLength?: UInt32 | Precondition.InRange<UInt32>;\n};\n\nclass EpochDataPreconditions {\n  readonly ledger: EpochLedgerPreconditions;\n  readonly seed: Precondition.Equals<Field>;\n  readonly startCheckpoint: Precondition.Equals<Field>;\n  readonly lockCheckpoint: Precondition.Equals<Field>;\n  readonly epochLength: Precondition.InRange<UInt32>;\n\n  constructor(descr?: EpochDataPreconditionsDescription) {\n    this.ledger = EpochLedgerPreconditions.from(descr?.ledger);\n    this.seed = Precondition.Equals.from(descr?.seed, new Field(0));\n    this.startCheckpoint = Precondition.Equals.from(descr?.startCheckpoint, new Field(0));\n    this.lockCheckpoint = Precondition.Equals.from(descr?.lockCheckpoint, new Field(0));\n    this.epochLength = Precondition.InRange.from(descr?.epochLength, {\n      lower: UInt32.empty(),\n      upper: UInt32.MAXINT(),\n    });\n  }\n\n  toInternalRepr(): BindingsLayout.EpochDataPrecondition {\n    return {\n      ledger: this.ledger.toInternalRepr(),\n      seed: this.seed.toOption(),\n      startCheckpoint: this.startCheckpoint.toOption(),\n      lockCheckpoint: this.lockCheckpoint.toOption(),\n      epochLength: this.epochLength.toOption(),\n    };\n  }\n\n  static fromInternalRepr(x: BindingsLayout.EpochDataPrecondition): EpochDataPreconditions {\n    return new EpochDataPreconditions({\n      ledger: EpochLedgerPreconditions.fromInternalRepr(x.ledger),\n      seed: Precondition.Equals.fromOption(x.seed),\n      startCheckpoint: Precondition.Equals.fromOption(x.startCheckpoint),\n      lockCheckpoint: Precondition.Equals.fromOption(x.lockCheckpoint),\n      epochLength: Precondition.InRange.fromOption(x.epochLength),\n    });\n  }\n\n  toJSON(): any {\n    return EpochDataPreconditions.toJSON(this);\n  }\n\n  toInput(): HashInput {\n    return EpochDataPreconditions.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return EpochDataPreconditions.toFields(this);\n  }\n\n  static sizeInFields(): number {\n    return BindingsLayout.EpochDataPrecondition.sizeInFields();\n  }\n\n  static empty(): EpochDataPreconditions {\n    return new EpochDataPreconditions();\n  }\n\n  static check(_x: EpochDataPreconditions) {\n    throw new Error('TODO');\n  }\n\n  static toJSON(x: EpochDataPreconditions): any {\n    return BindingsLayout.EpochDataPrecondition.toJSON(x.toInternalRepr());\n  }\n\n  static toInput(x: EpochDataPreconditions): HashInput {\n    return BindingsLayout.EpochDataPrecondition.toInput(x.toInternalRepr());\n  }\n\n  static toFields(x: EpochDataPreconditions): Field[] {\n    return BindingsLayout.EpochDataPrecondition.toFields(x.toInternalRepr());\n  }\n\n  static fromFields(fields: Field[], aux: any[]): EpochDataPreconditions {\n    return EpochDataPreconditions.fromInternalRepr(\n      BindingsLayout.EpochDataPrecondition.fromFields(fields, aux)\n    );\n  }\n\n  static toAuxiliary(x?: EpochDataPreconditions): any[] {\n    return BindingsLayout.EpochDataPrecondition.toAuxiliary(x?.toInternalRepr());\n  }\n\n  static toValue(x: EpochDataPreconditions): EpochDataPreconditions {\n    return x;\n  }\n\n  static fromValue(x: EpochDataPreconditions): EpochDataPreconditions {\n    return x;\n  }\n\n  static from(\n    value: EpochDataPreconditions | EpochDataPreconditionsDescription | undefined\n  ): EpochDataPreconditions {\n    if (value instanceof EpochDataPreconditions) {\n      return value;\n    } else if (value === undefined) {\n      return EpochDataPreconditions.empty();\n    } else {\n      return new EpochDataPreconditions(value);\n    }\n  }\n}\n\ntype NetworkPreconditionsDescription = {\n  snarkedLedgerHash?: Field | Precondition.Equals<Field>;\n  blockchainLength?: UInt32 | Precondition.InRange<UInt32>;\n  minWindowDensity?: UInt32 | Precondition.InRange<UInt32>;\n  totalCurrency?: MinaAmount | Precondition.InRange<MinaAmount>;\n  globalSlotSinceGenesis?: UInt32 | Precondition.InRange<UInt32>;\n  stakingEpochData?: EpochDataPreconditions | EpochDataPreconditionsDescription;\n  nextEpochData?: EpochDataPreconditions | EpochDataPreconditionsDescription;\n};\n\nclass NetworkPreconditions {\n  readonly snarkedLedgerHash: Precondition.Equals<Field>;\n  readonly blockchainLength: Precondition.InRange<UInt32>;\n  readonly minWindowDensity: Precondition.InRange<UInt32>;\n  readonly totalCurrency: Precondition.InRange<MinaAmount>;\n  readonly globalSlotSinceGenesis: Precondition.InRange<UInt32>;\n  readonly stakingEpochData: EpochDataPreconditions;\n  readonly nextEpochData: EpochDataPreconditions;\n\n  constructor(descr?: NetworkPreconditionsDescription) {\n    this.snarkedLedgerHash = Precondition.Equals.from(descr?.snarkedLedgerHash, Field.empty());\n    this.blockchainLength = Precondition.InRange.from(descr?.blockchainLength, {\n      lower: UInt32.empty(),\n      upper: UInt32.MAXINT(),\n    });\n    this.minWindowDensity = Precondition.InRange.from(descr?.minWindowDensity, {\n      lower: UInt32.empty(),\n      upper: UInt32.MAXINT(),\n    });\n    this.totalCurrency = Precondition.InRange.from(descr?.totalCurrency, {\n      lower: UInt64.empty(),\n      upper: UInt64.MAXINT(),\n    });\n    this.globalSlotSinceGenesis = Precondition.InRange.from(descr?.globalSlotSinceGenesis, {\n      lower: UInt32.empty(),\n      upper: UInt32.MAXINT(),\n    });\n    this.stakingEpochData = EpochDataPreconditions.from(descr?.stakingEpochData);\n    this.nextEpochData = EpochDataPreconditions.from(descr?.nextEpochData);\n  }\n\n  toInternalRepr(): BindingsLayout.NetworkPrecondition {\n    return {\n      snarkedLedgerHash: this.snarkedLedgerHash.toOption(),\n      blockchainLength: this.blockchainLength.toOption(),\n      minWindowDensity: this.minWindowDensity.toOption(),\n      totalCurrency: this.totalCurrency.toOption(),\n      globalSlotSinceGenesis: this.globalSlotSinceGenesis.toOption(),\n      stakingEpochData: this.stakingEpochData.toInternalRepr(),\n      nextEpochData: this.nextEpochData.toInternalRepr(),\n    };\n  }\n\n  static fromInternalRepr(x: BindingsLayout.NetworkPrecondition): NetworkPreconditions {\n    return new NetworkPreconditions({\n      snarkedLedgerHash: Precondition.Equals.fromOption(x.snarkedLedgerHash),\n      blockchainLength: Precondition.InRange.fromOption(x.blockchainLength),\n      minWindowDensity: Precondition.InRange.fromOption(x.minWindowDensity),\n      totalCurrency: Precondition.InRange.fromOption(x.totalCurrency),\n      globalSlotSinceGenesis: Precondition.InRange.fromOption(x.globalSlotSinceGenesis),\n      stakingEpochData: EpochDataPreconditions.fromInternalRepr(x.stakingEpochData),\n      nextEpochData: EpochDataPreconditions.fromInternalRepr(x.nextEpochData),\n    });\n  }\n\n  static empty(): NetworkPreconditions {\n    return new NetworkPreconditions();\n  }\n\n  toJSON(): any {\n    return NetworkPreconditions.toJSON(this);\n  }\n\n  toInput(): HashInput {\n    return NetworkPreconditions.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return NetworkPreconditions.toFields(this);\n  }\n\n  static sizeInFields(): number {\n    return BindingsLayout.NetworkPrecondition.sizeInFields();\n  }\n\n  static check(_x: NetworkPreconditions) {\n    throw new Error('TODO');\n  }\n\n  static toJSON(x: NetworkPreconditions): any {\n    return BindingsLayout.NetworkPrecondition.toJSON(x.toInternalRepr());\n  }\n\n  static toInput(x: NetworkPreconditions): HashInput {\n    return BindingsLayout.NetworkPrecondition.toInput(x.toInternalRepr());\n  }\n\n  static toFields(x: NetworkPreconditions): Field[] {\n    return BindingsLayout.NetworkPrecondition.toFields(x.toInternalRepr());\n  }\n\n  static fromFields(fields: Field[], aux: any[]): NetworkPreconditions {\n    return NetworkPreconditions.fromInternalRepr(\n      BindingsLayout.NetworkPrecondition.fromFields(fields, aux)\n    );\n  }\n\n  static toAuxiliary(x?: NetworkPreconditions): any[] {\n    return BindingsLayout.NetworkPrecondition.toAuxiliary(x?.toInternalRepr());\n  }\n\n  static toValue(x: NetworkPreconditions): NetworkPreconditions {\n    return x;\n  }\n\n  static fromValue(x: NetworkPreconditions): NetworkPreconditions {\n    return x;\n  }\n\n  static from(\n    value: NetworkPreconditions | NetworkPreconditionsDescription | undefined\n  ): NetworkPreconditions {\n    if (value instanceof NetworkPreconditions) {\n      return value;\n    } else if (value === undefined) {\n      return NetworkPreconditions.empty();\n    } else {\n      return new NetworkPreconditions(value);\n    }\n  }\n}\n\ntype AccountPreconditionsDescription<State extends StateLayout> = {\n  balance?: MinaAmount | Precondition.InRange<MinaAmount>;\n  nonce?: UInt32 | Precondition.InRange<UInt32>;\n  receiptChainHash?: Field | Precondition.Equals<Field>;\n  delegate?: PublicKey | Precondition.Equals<PublicKey>;\n  state?: StatePreconditions<State>;\n  actionState?: Field | Precondition.Equals<Field>;\n  // NB: renamed from the protocol's type name of `provenState`\n  isProven?: Bool | Precondition.Equals<Bool>;\n  isNew?: Bool | Precondition.Equals<Bool>;\n};\n\nclass AccountPreconditions<State extends StateLayout = 'GenericState'> {\n  // TODO: should these really be read-only?\n  readonly State: StateDefinition<State>;\n  readonly balance: Precondition.InRange<MinaAmount>;\n  readonly nonce: Precondition.InRange<UInt32>;\n  readonly receiptChainHash: Precondition.Equals<Field>;\n  readonly delegate: Precondition.Equals<PublicKey>;\n  readonly state: StatePreconditions<State>;\n  readonly actionState: Precondition.Equals<Field>;\n  readonly isProven: Precondition.Equals<Bool>;\n  readonly isNew: Precondition.Equals<Bool>;\n\n  constructor(State: StateDefinition<State>, descr?: AccountPreconditionsDescription<State>) {\n    this.State = State;\n    this.balance = Precondition.InRange.from(descr?.balance, {\n      lower: UInt64.empty(),\n      upper: UInt64.MAXINT(),\n    });\n    this.nonce = Precondition.InRange.from(descr?.nonce, {\n      lower: UInt32.empty(),\n      upper: UInt32.MAXINT(),\n    });\n    this.receiptChainHash = Precondition.Equals.from(descr?.receiptChainHash, Field.empty());\n    this.delegate = Precondition.Equals.from(descr?.delegate, PublicKey.empty());\n    this.state = descr?.state ?? StatePreconditions.empty(State);\n    this.actionState = Precondition.Equals.from(descr?.actionState, Actions.emptyActionState());\n    this.isProven = Precondition.Equals.from(descr?.isProven, Bool.empty());\n    this.isNew = Precondition.Equals.from(descr?.isNew, Bool.empty());\n  }\n\n  toGeneric(): AccountPreconditions {\n    return AccountPreconditions.generic({\n      ...this,\n      state: StatePreconditions.toGeneric(this.State, this.state),\n    });\n  }\n\n  static fromGeneric<State extends StateLayout>(\n    x: AccountPreconditions,\n    State: StateDefinition<State>\n  ): AccountPreconditions<State> {\n    return new AccountPreconditions(State, {\n      ...this,\n      state: StatePreconditions.fromGeneric(x.state, State),\n    });\n  }\n\n  toInternalRepr(): BindingsLayout.AccountPrecondition {\n    const statePreconditions = StatePreconditions.toFieldPreconditions(this.State, this.state);\n\n    if (statePreconditions.length !== ZkappConstants.MAX_ZKAPP_STATE_FIELDS) {\n      throw new Error('invalid number of zkapp state field constraints');\n    }\n\n    return {\n      balance: this.balance.toOption(),\n      nonce: this.nonce.toOption(),\n      receiptChainHash: this.receiptChainHash.toOption(),\n      delegate: this.delegate.toOption(),\n      state: statePreconditions.map((c) => c.toOption()),\n      actionState: this.actionState.toOption(),\n      provedState: this.isProven.toOption(),\n      isNew: this.isNew.toOption(),\n    };\n  }\n\n  static fromInternalRepr(x: BindingsLayout.AccountPrecondition): AccountPreconditions {\n    return new AccountPreconditions<'GenericState'>('GenericState', {\n      balance: Precondition.InRange.fromOption(x.balance),\n      nonce: Precondition.InRange.fromOption(x.nonce),\n      receiptChainHash: Precondition.Equals.fromOption(x.receiptChainHash),\n      delegate: Precondition.Equals.fromOption(x.delegate),\n      state: new GenericStatePreconditions(x.state.map(Precondition.Equals.fromOption<Field>)),\n      actionState: Precondition.Equals.fromOption(x.actionState),\n      isProven: Precondition.Equals.fromOption(x.provedState),\n      isNew: Precondition.Equals.fromOption(x.isNew),\n    });\n  }\n\n  toJSON(): any {\n    return AccountPreconditions.toJSON(this);\n  }\n\n  toInput(): HashInput {\n    return AccountPreconditions.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return AccountPreconditions.toFields(this);\n  }\n\n  static generic(descr?: AccountPreconditionsDescription<'GenericState'>): AccountPreconditions {\n    return new AccountPreconditions<'GenericState'>('GenericState', descr);\n  }\n\n  static sizeInFields(): number {\n    return BindingsLayout.AccountPrecondition.sizeInFields();\n  }\n\n  static emptyPoly<State extends StateLayout>(\n    State: StateDefinition<State>\n  ): AccountPreconditions<State> {\n    return new AccountPreconditions(State);\n  }\n\n  static empty(): AccountPreconditions {\n    return this.emptyPoly('GenericState');\n  }\n\n  static check<State extends StateLayout>(_x: AccountPreconditions<State>) {\n    throw new Error('TODO');\n  }\n\n  static toJSON<State extends StateLayout>(x: AccountPreconditions<State>): any {\n    return BindingsLayout.AccountPrecondition.toJSON(x.toInternalRepr());\n  }\n\n  static toInput<State extends StateLayout>(x: AccountPreconditions<State>): HashInput {\n    return BindingsLayout.AccountPrecondition.toInput(x.toInternalRepr());\n  }\n\n  static toFields<State extends StateLayout>(x: AccountPreconditions<State>): Field[] {\n    return BindingsLayout.AccountPrecondition.toFields(x.toInternalRepr());\n  }\n\n  static fromFields(fields: Field[], aux: any[]): AccountPreconditions {\n    return AccountPreconditions.fromInternalRepr(\n      BindingsLayout.AccountPrecondition.fromFields(fields, aux)\n    );\n  }\n\n  static toAuxiliary<State extends StateLayout>(x?: AccountPreconditions<State>): any[] {\n    return BindingsLayout.AccountPrecondition.toAuxiliary(x?.toInternalRepr());\n  }\n\n  static toValue<State extends StateLayout>(\n    x: AccountPreconditions<State>\n  ): AccountPreconditions<State> {\n    return x;\n  }\n\n  static fromValue<State extends StateLayout>(\n    x: AccountPreconditions<State>\n  ): AccountPreconditions<State> {\n    return x;\n  }\n\n  static from<State extends StateLayout>(\n    State: StateDefinition<State>,\n    value: AccountPreconditions<State> | AccountPreconditionsDescription<State> | undefined\n  ): AccountPreconditions<State> {\n    if (value instanceof AccountPreconditions) {\n      return value;\n    } else if (value === undefined) {\n      return AccountPreconditions.emptyPoly(State);\n    } else {\n      return new AccountPreconditions(State, value);\n    }\n  }\n}\n", "/* ZkApp State\n * -----------\n *\n * ZkApp State is typed using a StateLayout type variable, which is a mapped-type mapping from state\n * names to Provable type implementations. A top-level StateDefinition is defined by zkApp\n * developers and passed when constructing AccountUpdates (and related structures). The\n * StatePreconditions and StateDefinition types define the internal representation of State values\n * in preconditions and updates within AccountUpdates. There is also a GenericState representation\n * which maps to the standard field array representation which is used by the protocol.\n */\n\n// TODO: there is a lot of duplication here on the generic representation that we can reduce\n\nimport { Empty, Eq, ProvableInstance, Update } from './core.js';\nimport { Precondition } from './preconditions.js';\nimport { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { Provable } from '../../provable/provable.js';\nimport { Unconstrained } from '../../provable/types/unconstrained.js';\nimport { ZkappConstants } from '../v1/constants.js';\n\nexport {\n  StateValues,\n  GenericStatePreconditions,\n  StatePreconditions,\n  StateDefinition,\n  StateUpdates,\n  StateLayout,\n  GenericStateUpdates,\n  StateMask,\n  StateReader,\n  State,\n};\n\nconst { MAX_ZKAPP_STATE_FIELDS } = ZkappConstants;\n\n// TODO IMMEDIATELY: This representation doesn't actually work, because if you specify a state\n//                   element in a custom state layout that doesn't satisfy the StateElement type,\n//                   typescript will just replace the state element types in the layout with `any`.\n//                   Fucking typescript.\ntype StateElement<T extends Eq<T>> = Provable<T> & Empty<T>;\n// type StateElementInstance<E> = E extends StateElement<infer T> ? T : never;\n// TODO: custom state layouts need to specify the order of their keys\ntype CustomStateLayout = { [name: string]: Provable<any> & Empty<any> };\ntype StateLayout = 'GenericState' | CustomStateLayout;\n\nconst CustomStateLayout = {\n  project<StateIn extends CustomStateLayout, StateOut extends { [name in keyof StateIn]: unknown }>(\n    Layout: StateIn,\n    f: (key: keyof StateIn, value: StateIn[typeof key]) => StateOut[typeof key]\n  ): StateOut {\n    const entriesIn = Object.entries(Layout) as [keyof StateIn, Provable<any>][];\n    const entriesOut = entriesIn.map(([key, T]) => [key, f(key, T as StateIn[typeof key])]);\n    return Object.fromEntries(entriesOut);\n  },\n\n  // mapToArray<State extends CustomStateLayout, Out>(\n  //   Layout: State,\n  //   f: (key: keyof State, value: State[typeof key]) => Out\n  // ): Out[] {\n  //   const out: Out[] = [];\n  //   const keys = Object.keys(Layout) as (keyof State)[];\n  //   keys.forEach((key) => out.push(f(key, Layout[key])));\n  //   return out;\n  // }\n};\n\ntype StateDefinition<State extends StateLayout> = State extends 'GenericState'\n  ? 'GenericState'\n  : { Layout: State } & Provable<{\n      [name in keyof State]: ProvableInstance<State[name]>;\n    }>;\n\nconst StateDefinition = {\n  split2<State extends StateLayout, Generic1, Custom1, Generic2, Custom2>(\n    definition: StateDefinition<State>,\n    value1: State extends 'GenericState' ? Generic1 : Custom1,\n    value2: State extends 'GenericState' ? Generic2 : Custom2,\n    generic: (x1: Generic1, x2: Generic2) => void,\n    custom: (layout: CustomStateLayout, x1: Custom1, x2: Custom2) => void\n  ) {\n    if (definition === 'GenericState') {\n      return generic(value1 as Generic1, value2 as Generic2);\n    } else {\n      return custom(definition.Layout, value1 as Custom1, value2 as Custom2);\n    }\n  },\n\n  map<State extends StateLayout, GenericIn, CustomIn, GenericOut, CustomOut>(\n    definition: StateDefinition<State>,\n    value: State extends 'GenericState' ? GenericIn : CustomIn,\n    generic: (x: GenericIn) => GenericOut,\n    custom: (layout: CustomStateLayout, x: CustomIn) => CustomOut\n  ): State extends 'GenericState' ? GenericOut : CustomOut {\n    if (definition === 'GenericState') {\n      return generic(value as GenericIn) as State extends 'GenericState' ? GenericOut : CustomOut;\n    } else {\n      return custom(definition.Layout, value as CustomIn) as State extends 'GenericState'\n        ? GenericOut\n        : CustomOut;\n    }\n  },\n\n  map2<\n    State extends StateLayout,\n    GenericIn1,\n    CustomIn1,\n    GenericIn2,\n    CustomIn2,\n    GenericOut,\n    CustomOut,\n  >(\n    definition: StateDefinition<State>,\n    value1: State extends 'GenericState' ? GenericIn1 : CustomIn1,\n    value2: State extends 'GenericState' ? GenericIn2 : CustomIn2,\n    generic: (x1: GenericIn1, x2: GenericIn2) => GenericOut,\n    custom: (layout: CustomStateLayout, x1: CustomIn1, x2: CustomIn2) => CustomOut\n  ): State extends 'GenericState' ? GenericOut : CustomOut {\n    if (definition === 'GenericState') {\n      return generic(value1 as GenericIn1, value2 as GenericIn2) as State extends 'GenericState'\n        ? GenericOut\n        : CustomOut;\n    } else {\n      return custom(\n        definition.Layout,\n        value1 as CustomIn1,\n        value2 as CustomIn2\n      ) as State extends 'GenericState' ? GenericOut : CustomOut;\n    }\n  },\n\n  project<State extends StateLayout, Generic, Custom>(\n    definition: StateDefinition<State>,\n    generic: () => Generic,\n    custom: (layout: CustomStateLayout) => Custom\n  ): State extends 'GenericState' ? Generic : Custom {\n    return StateDefinition.map(definition, undefined, generic, custom);\n  },\n\n  convert<State extends StateLayout, Generic, Custom, Out>(\n    definition: StateDefinition<State>,\n    value: State extends 'GenericState' ? Generic : Custom,\n    generic: (x: Generic) => Out,\n    custom: (layout: CustomStateLayout, x: Custom) => Out\n  ): Out {\n    return StateDefinition.map(definition, value, generic, custom);\n  },\n};\n\n// TODO: allow for explicit ordering/mapping of state field indices\n\nfunction State<State extends CustomStateLayout>(Layout: State): StateDefinition<State> {\n  // TODO: proxy provable definition out of Struct with helper\n  // class StateDef extends Struct(Layout) {}\n\n  // TODO: check sizeInFields\n  const sizeInFields = Object.values(Layout)\n    .map((T) => T.sizeInFields())\n    .reduce((a, b) => a + b, 0);\n\n  return {\n    Layout,\n    sizeInFields(): number {\n      return sizeInFields;\n    },\n    toFields(x: {\n      [name in keyof State]: ProvableInstance<State[name]>;\n    }): Field[] {\n      const fields = [];\n      for (const key in Layout) {\n        fields.push(...Layout[key].toFields(x[key]));\n      }\n      return fields;\n    },\n    toAuxiliary(x?: {\n      [name in keyof State]: ProvableInstance<State[name]>;\n    }): any[] {\n      const aux = [];\n      for (const key in Layout) {\n        aux.push(Layout[key].toAuxiliary(x !== undefined ? x[key] : undefined));\n      }\n      return aux;\n    },\n    fromFields(\n      _fields: Field[],\n      _aux: any[]\n    ): { [name in keyof State]: ProvableInstance<State[name]> } {\n      throw new Error('TODO');\n    },\n    toValue(x: { [name in keyof State]: ProvableInstance<State[name]> }): {\n      [name in keyof State]: ProvableInstance<State[name]>;\n    } {\n      return x;\n    },\n    fromValue(x: {\n      [name in keyof State]: ProvableInstance<State[name]>;\n    }): { [name in keyof State]: ProvableInstance<State[name]> } {\n      return x;\n    },\n    check(_x: {\n      [name in keyof State]: ProvableInstance<State[name]>;\n    }): void {\n      throw new Error('TODO');\n    },\n  } as StateDefinition<State>;\n  // TODO: ^ get rid of the type-cast here (typescript's error message here is very unhelpful)\n}\n\ntype StatePreconditions<State extends StateLayout> = State extends 'GenericState'\n  ? GenericStatePreconditions\n  : {\n      [name in keyof State]: Precondition.Equals<\n        ProvableInstance<State[name]> & Eq<ProvableInstance<State[name]>>\n      >;\n    };\n\nconst StatePreconditions = {\n  empty<State extends StateLayout>(State: StateDefinition<State>): StatePreconditions<State> {\n    return StateDefinition.project(\n      State,\n      GenericStatePreconditions.empty,\n      (Layout: CustomStateLayout) =>\n        CustomStateLayout.project(Layout, (_key, T) => Precondition.Equals.disabled(T.empty()))\n    );\n  },\n\n  toGeneric<State extends StateLayout>(\n    State: StateDefinition<State>,\n    statePreconditions: StatePreconditions<State>\n  ): StatePreconditions<'GenericState'> {\n    return StateDefinition.convert(\n      State,\n      statePreconditions,\n      (x: GenericStatePreconditions) => x as StatePreconditions<'GenericState'>,\n      (\n        Layout: CustomStateLayout,\n        preconditions: {\n          [name in keyof State]: Precondition.Equals<\n            ProvableInstance<State[name]> & Eq<ProvableInstance<State[name]>>\n          >;\n        }\n      ) => {\n        // const fieldPreconditions = CustomStateLayout.mapToArray<typeof Layout, Precondition.Equals<Field>>(\n        //   Layout,\n        //   (key: keyof State, T) => {\n        //     const precondition = preconditions[key];\n        //     const fields = T.toFields(precondition.value);\n        //     return fields.map((field) => new Precondition.Equals(precondition.isEnabled, field));\n        //   }\n        // ).flat();\n\n        const entries = Object.entries(Layout) as [keyof State, StateElement<any>][];\n        const fieldPreconditions = entries.flatMap(([key, T]) => {\n          const precondition = preconditions[key];\n          const fields = T.toFields(precondition.value);\n          return fields.map((field) => new Precondition.Equals(precondition.isEnabled, field));\n        });\n\n        return new GenericStatePreconditions(fieldPreconditions);\n      }\n    );\n  },\n\n  fromGeneric<State extends StateLayout>(\n    statePreconditions: StatePreconditions<'GenericState'>,\n    State: StateDefinition<State>\n  ): StatePreconditions<State> {\n    return StateDefinition.project(\n      State,\n      () => statePreconditions,\n      (Layout: CustomStateLayout) => {\n        // NB: this relies on the order of map being deterministic\n        // TODO: make the order of custom state layout keys deterministic (lol)\n        let i = 0;\n        return CustomStateLayout.project(Layout, (_key, T) => {\n          const fieldPreconditions = statePreconditions.preconditions.slice(\n            i,\n            i + T.sizeInFields()\n          );\n          i += T.sizeInFields();\n          if (fieldPreconditions.length === 0)\n            throw new Error('invalid state element field length');\n\n          const isEnabled = fieldPreconditions[0].isEnabled;\n          const allPreconditionsShareEnablement = Bool.allTrue(\n            fieldPreconditions.map((precondition) => precondition.isEnabled.equals(isEnabled))\n          );\n          if (allPreconditionsShareEnablement.not().toBoolean())\n            throw new Error(\n              'state field preconditions mapping to the same state field element were not all enabled/disabled equally'\n            );\n\n          const fields = fieldPreconditions.map((precondition) => precondition.value);\n          const value = T.fromFields(fields, /* TODO */ []);\n\n          return new Precondition.Equals(isEnabled, value);\n        });\n      }\n    );\n  },\n\n  toFieldPreconditions<State extends StateLayout>(\n    State: StateDefinition<State>,\n    preconditions: StatePreconditions<State>\n  ): Precondition.Equals<Field>[] {\n    return [...StatePreconditions.toGeneric(State, preconditions).preconditions];\n  },\n};\n\ntype StateUpdates<State extends StateLayout> = State extends 'GenericState'\n  ? GenericStateUpdates\n  : {\n      [name in keyof State]?: ProvableInstance<State[name]> | Update<ProvableInstance<State[name]>>;\n    };\n\nconst StateUpdates = {\n  empty<State extends StateLayout>(State: StateDefinition<State>): StateUpdates<State> {\n    return StateDefinition.project(State, GenericStateUpdates.empty, (Layout: CustomStateLayout) =>\n      CustomStateLayout.project(Layout, (_key, T) => Update.disabled(T.empty()))\n    );\n  },\n\n  anyValuesAreSet<State extends StateLayout>(stateUpdates: StateUpdates<State>): Bool {\n    const updates: Update<unknown>[] =\n      stateUpdates instanceof GenericStateUpdates\n        ? stateUpdates.updates\n        : Object.values(stateUpdates);\n    return Bool.anyTrue(updates.map((update) => update.set));\n  },\n\n  toGeneric<State extends StateLayout>(\n    State: StateDefinition<State>,\n    stateUpdates: StateUpdates<State>\n  ): StateUpdates<'GenericState'> {\n    return StateDefinition.convert(\n      State,\n      stateUpdates,\n      (x: GenericStateUpdates) => x as StateUpdates<'GenericState'>,\n      (\n        Layout: CustomStateLayout,\n        updates: {\n          [name in keyof State]?:\n            | ProvableInstance<State[name]>\n            | Update<ProvableInstance<State[name]>>;\n        }\n      ) => {\n        const entries = Object.entries(Layout) as [keyof State, Provable<any> & Empty<any>][];\n        const fieldUpdates = entries.flatMap(([key, T]) => {\n          const update = updates[key];\n          const update2 =\n            update === undefined\n              ? new Update(new Bool(false), T.empty())\n              : update instanceof Update\n                ? update\n                : new Update(new Bool(true), update);\n          const fields = T.toFields(update2.value);\n          return fields.map((field) => new Update(update2.set, field));\n        });\n\n        return new GenericStateUpdates(fieldUpdates);\n      }\n    );\n  },\n\n  fromGeneric<State extends StateLayout>(\n    stateUpdates: StateUpdates<'GenericState'>,\n    State: StateDefinition<State>\n  ): StateUpdates<State> {\n    return StateDefinition.project(\n      State,\n      () => stateUpdates,\n      (Layout: CustomStateLayout) => {\n        // NB: this relies on the order of map being deterministic\n        // TODO: make the order of custom state layout keys deterministic (lol)\n        let i = 0;\n        return CustomStateLayout.project(Layout, (_key, T) => {\n          const fieldUpdates = stateUpdates.updates.slice(i, i + T.sizeInFields());\n          i += T.sizeInFields();\n          if (fieldUpdates.length === 0) throw new Error('invalid state element field length');\n\n          const set = fieldUpdates[0].set;\n          const allUpdatesShareEnablement = Bool.allTrue(\n            fieldUpdates.map((precondition) => precondition.set.equals(set))\n          );\n          if (allUpdatesShareEnablement.not().toBoolean())\n            throw new Error(\n              'state field preconditions mapping to the same state field element were not all enabled/disabled equally'\n            );\n\n          const fields = fieldUpdates.map((precondition) => precondition.value);\n          const value = T.fromFields(fields, /* TODO */ []);\n\n          return new Update(set, value);\n        });\n      }\n    );\n  },\n\n  toFieldUpdates<State extends StateLayout>(\n    State: StateDefinition<State>,\n    updates: StateUpdates<State>\n  ): Update<Field>[] {\n    return [...StateUpdates.toGeneric(State, updates).updates];\n  },\n};\n\ntype StateValues<State extends StateLayout> = State extends 'GenericState'\n  ? GenericStateValues\n  : { [name in keyof State]: ProvableInstance<State[name]> };\n\nconst StateValues = {\n  empty<State extends StateLayout>(State: StateDefinition<State>): StateValues<State> {\n    return StateDefinition.project(State, GenericStateValues.empty, (Layout: CustomStateLayout) =>\n      CustomStateLayout.project(Layout, (_key, T) => T.empty())\n    );\n  },\n\n  toGeneric<State extends StateLayout>(\n    State: StateDefinition<State>,\n    stateValues: StateValues<State>\n  ): StateValues<'GenericState'> {\n    return StateDefinition.convert(\n      State,\n      stateValues,\n      (x: GenericStateValues) => x as StateValues<'GenericState'>,\n      (\n        Layout: CustomStateLayout,\n        updates: { [name in keyof State]?: ProvableInstance<State[name]> }\n      ) => {\n        const entries = Object.entries(Layout) as [keyof State, Provable<any>][];\n        const fieldValues = entries.flatMap(([key, T]) => {\n          const value = updates[key];\n          return T.toFields(value);\n        });\n\n        return new GenericStateValues(fieldValues);\n      }\n    );\n  },\n\n  fromGeneric<State extends StateLayout>(\n    stateValues: StateValues<'GenericState'>,\n    State: StateDefinition<State>\n  ): StateValues<State> {\n    return StateDefinition.project(\n      State,\n      () => stateValues,\n      (Layout: CustomStateLayout) => {\n        // NB: this relies on the order of map being deterministic\n        // TODO: make the order of custom state layout keys deterministic (lol)\n        let i = 0;\n        return CustomStateLayout.project(Layout, (_key, T) => {\n          const fields = stateValues.values.slice(i, i + T.sizeInFields());\n          i += T.sizeInFields();\n          return T.fromFields(fields, /* TODO */ []);\n        });\n      }\n    );\n  },\n\n  checkPreconditions<State extends StateLayout>(\n    State: StateDefinition<State>,\n    stateValues: StateValues<State>,\n    statePreconditions: StatePreconditions<State>\n  ): void {\n    StateDefinition.split2(\n      State,\n      stateValues,\n      statePreconditions,\n      (values, preconditions) => {\n        for (const i in values.values) {\n          if (preconditions.preconditions[i].isSatisfied(values.values[i]).not().toBoolean())\n            throw new Error(`precondition for state field ${i} not satisfied`);\n        }\n      },\n      () => {\n        // TODO: evaluate these directly on the custom state representation and give meaningful errors\n        StateValues.checkPreconditions(\n          'GenericState',\n          StateValues.toGeneric(State, stateValues),\n          StatePreconditions.toGeneric(State, statePreconditions)\n        );\n      }\n    );\n\n    // if(State === 'GenericState') {\n    //   // unsafely narrow types manually since typescript can't\n    //   const state = (values as GenericStateValues).values;\n    //   const statePreconditions = preconditions as GenericStatePreconditions;\n\n    //   if(state.length !== MAX_ZKAPP_STATE_FIELDS)\n    //     throw new Error('internal error: invalid number of generic state field values');\n    //   if(state.length !== statePreconditions.preconditions.length)\n    //     throw new Error('internal error: invalid number of generic state field preconditions');\n\n    //   for(const i in state) {\n    //     if(statePreconditions.preconditions[i].isSatisfied(state[i]).not().toBoolean())\n    //       throw new Error(`precondition for state field ${i} not satisfied`);\n    //   }\n    // } else {\n    //   // TODO: evaluate these directly on the custom state representation and give meaningful errors\n    //   StateValues.checkPreconditions(\n    //     'GenericState',\n    //     StateValues.toGeneric(State, values),\n    //     StatePreconditions.toGeneric(State, preconditions)\n    //   );\n    // }\n  },\n\n  applyUpdates<State extends StateLayout>(\n    State: StateDefinition<State>,\n    stateValues: StateValues<State>,\n    stateUpdates: StateUpdates<State>\n  ): StateValues<State> {\n    return StateDefinition.map2(\n      State,\n      stateValues,\n      stateUpdates,\n      (values, updates) =>\n        values.map((value, i) => {\n          const update = updates.updates[i];\n          return update.set.toBoolean() ? update.value : value;\n        }),\n      (Layout, values, updates): { [name in keyof State]: ProvableInstance<State[name]> } => {\n        const result = { ...values };\n        for (const key in Layout) {\n          const update = updates[key as keyof State];\n          if (update !== undefined) {\n            const updateValue =\n              update instanceof Update ? update : new Update(new Bool(true), update);\n            if (updateValue.set.toBoolean()) {\n              result[key as keyof State] = updateValue.value;\n            }\n          }\n        }\n        return result;\n      }\n    );\n  },\n};\n\ntype StateMask<State extends StateLayout> = State extends 'GenericState'\n  ? GenericStateMask\n  : { [name in keyof State]?: ProvableInstance<State[name]> };\n\nconst StateMask = {\n  create<State extends StateLayout>(State: StateDefinition<State>): StateMask<State> {\n    return StateDefinition.project(State, GenericStateMask.empty, () => ({}));\n  },\n};\n\ntype StateReader<State extends StateLayout> = State extends 'GenericState'\n  ? GenericStateReader\n  : {\n      [name in keyof State]: State[name] extends Provable<infer U> ? () => U : never;\n    };\n\nconst StateReader = {\n  create<State extends StateLayout>(\n    State: StateDefinition<State>,\n    stateValues: Unconstrained<StateValues<State>>,\n    stateMask: Unconstrained<StateMask<State>>\n  ): StateReader<State> {\n    if (State === 'GenericState') {\n      const values = stateValues as Unconstrained<GenericStateValues>;\n      const mask = stateMask as Unconstrained<GenericStateMask>;\n      return new GenericStateReader(values, mask) as StateReader<State>;\n    } else {\n      const values = stateValues as Unconstrained<{\n        [name in keyof State]: ProvableInstance<State[name]>;\n      }>;\n      const mask = stateMask as Unconstrained<{\n        [name in keyof State]?: ProvableInstance<State[name]>;\n      }>;\n      return CustomStateLayout.project(State.Layout, (key, T) => (): ProvableInstance<typeof T> => {\n        return Provable.witness(T, () => {\n          const value = values.get()[key as keyof State];\n          mask.get()[key as keyof State] = value;\n          return value;\n        });\n      }) as StateReader<State>;\n    }\n  },\n};\n\nclass StateFieldsArray<T> {\n  constructor(\n    private fieldElements: T[],\n    empty: () => T\n  ) {\n    if (this.fieldElements.length > MAX_ZKAPP_STATE_FIELDS) {\n      throw new Error('exceeded maximum number of state elements');\n    }\n\n    if (this.fieldElements.length < MAX_ZKAPP_STATE_FIELDS) {\n      for (let i = this.fieldElements.length; i < MAX_ZKAPP_STATE_FIELDS; i++) {\n        this.fieldElements.push(empty());\n      }\n    }\n\n    if (this.fieldElements.length !== MAX_ZKAPP_STATE_FIELDS) {\n      throw new Error('internal error: invariant broken');\n    }\n  }\n\n  get fields(): T[] {\n    return [...this.fieldElements];\n  }\n}\n\nclass GenericStateValues extends StateFieldsArray<Field> {\n  constructor(values: Field[]) {\n    super(values, Field.empty);\n  }\n\n  get values(): Field[] {\n    return this.fields;\n  }\n\n  get(index: number): Field {\n    if (index >= MAX_ZKAPP_STATE_FIELDS) throw new Error('zkapp state index out of bounds');\n    return this.fields[index];\n  }\n\n  map(f: (x: Field, i: number) => Field): GenericStateValues {\n    return new GenericStateValues(this.values.map(f));\n  }\n\n  static empty(): GenericStateValues {\n    return new GenericStateValues([]);\n  }\n}\n\nclass GenericStatePreconditions extends StateFieldsArray<Precondition.Equals<Field>> {\n  constructor(preconditions: Precondition.Equals<Field>[]) {\n    super(preconditions, () => Precondition.Equals.disabled(Field.empty()));\n  }\n\n  get preconditions(): Precondition.Equals<Field>[] {\n    return this.fields;\n  }\n\n  static empty(): GenericStatePreconditions {\n    return new GenericStatePreconditions([]);\n  }\n}\n\nclass GenericStateUpdates extends StateFieldsArray<Update<Field>> {\n  constructor(updates: Update<Field>[]) {\n    super(updates, () => Update.disabled(Field.empty()));\n  }\n\n  get updates(): Update<Field>[] {\n    return this.fields;\n  }\n\n  static empty(): GenericStateUpdates {\n    return new GenericStateUpdates([]);\n  }\n}\n\nclass GenericStateMask extends StateFieldsArray<Field | undefined> {\n  constructor() {\n    super([], () => undefined);\n  }\n\n  set(index: number, value: Field): void {\n    if (index >= MAX_ZKAPP_STATE_FIELDS) throw new Error('zkapp state index out of bounds');\n    this.fields[index] = value;\n  }\n\n  static empty(): GenericStateMask {\n    return new GenericStateMask();\n  }\n}\n\nclass GenericStateReader {\n  constructor(\n    private values: Unconstrained<GenericStateValues>,\n    private mask: Unconstrained<GenericStateMask>\n  ) {}\n\n  read(index: number): Field {\n    return Provable.witness(Field, () => {\n      const value = this.values.get().get(index);\n      this.mask.get().set(index, value);\n      return value;\n    });\n  }\n}\n", "import { Permissions } from './permissions.js';\nimport { StateDefinition, StateLayout, StateValues } from './state.js';\nimport { VerificationKey } from '../../proof-system/verification-key.js';\nimport { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { UInt64, UInt32 } from '../../provable/int.js';\nimport { Provable } from '../../provable/provable.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { Unconstrained } from '../../provable/types/unconstrained.js';\nimport { TokenSymbol } from '../../../lib/provable/crypto/poseidon.js';\nimport { TokenId, ZkappUri } from './core.js';\n\nexport { AccountId, AccountTiming, AccountIdSet, Account, AccountIdMap };\n\nfunction accountIdKeys(accountId: AccountId): {\n  publicKey: string;\n  tokenId: string;\n} {\n  return {\n    publicKey: accountId.publicKey.toBase58(),\n    tokenId: accountId.tokenId.toString(),\n  };\n}\n\nclass AccountId {\n  constructor(\n    public publicKey: PublicKey,\n    public tokenId: TokenId\n  ) {}\n\n  equals(x: AccountId): Bool {\n    return Bool.allTrue([this.publicKey.equals(x.publicKey), this.tokenId.equals(x.tokenId)]);\n  }\n\n  static empty(): AccountId {\n    return new AccountId(PublicKey.empty(), TokenId.MINA);\n  }\n\n  static sizeInFields(): number {\n    return PublicKey.sizeInFields() + Field.sizeInFields();\n  }\n\n  static toFields(x: AccountId): Field[] {\n    return [...PublicKey.toFields(x.publicKey), x.tokenId.value];\n  }\n\n  static toAuxiliary(_x?: AccountId): any[] {\n    return [];\n  }\n\n  static fromFields(fields: Field[], _aux: any[]): AccountId {\n    return new AccountId(\n      PublicKey.fromFields(fields.slice(0, PublicKey.sizeInFields())),\n      new TokenId(fields[PublicKey.sizeInFields()])\n    );\n  }\n\n  static toValue(x: AccountId): AccountId {\n    return x;\n  }\n\n  static fromValue(x: AccountId): AccountId {\n    return x;\n  }\n\n  static check(_x: AccountId) {\n    // TODO NOW\n  }\n}\n\nclass AccountIdMap<T> {\n  private data: { [publicKey: string]: { [tokenId: string]: T } };\n\n  constructor() {\n    this.data = {};\n  }\n\n  has(accountId: AccountId): boolean {\n    const { publicKey, tokenId } = accountIdKeys(accountId);\n    const tokenAccounts = this.data[publicKey] ?? {};\n    return tokenId in tokenAccounts;\n  }\n\n  get(accountId: AccountId): T | null {\n    const { publicKey, tokenId } = accountIdKeys(accountId);\n    const tokenAccounts = this.data[publicKey] ?? {};\n    return tokenAccounts[tokenId] ?? null;\n  }\n\n  set(accountId: AccountId, value: T): void {\n    const { publicKey, tokenId } = accountIdKeys(accountId);\n    if (!(publicKey in this.data)) this.data[publicKey] = {};\n    this.data[publicKey][tokenId] = value;\n  }\n\n  update(accountId: AccountId, f: (x: T | null) => T): void {\n    const value = this.get(accountId);\n    const updatedValue = f(value);\n    this.set(accountId, updatedValue);\n  }\n}\n\nclass AccountIdSet {\n  private idMap: AccountIdMap<null>;\n\n  constructor() {\n    this.idMap = new AccountIdMap();\n  }\n\n  has(accountId: AccountId): boolean {\n    return this.idMap.has(accountId);\n  }\n\n  add(accountId: AccountId): void {\n    this.idMap.set(accountId, null);\n  }\n}\n\nclass AccountTiming {\n  initialMinimumBalance: UInt64;\n  cliffTime: UInt32;\n  cliffAmount: UInt64;\n  vestingPeriod: UInt32;\n  vestingIncrement: UInt64;\n\n  constructor({\n    initialMinimumBalance,\n    cliffTime,\n    cliffAmount,\n    vestingPeriod,\n    vestingIncrement,\n  }: {\n    initialMinimumBalance: UInt64;\n    cliffTime: UInt32;\n    cliffAmount: UInt64;\n    vestingPeriod: UInt32;\n    vestingIncrement: UInt64;\n  }) {\n    this.initialMinimumBalance = initialMinimumBalance;\n    this.cliffTime = cliffTime;\n    this.cliffAmount = cliffAmount;\n    this.vestingPeriod = vestingPeriod;\n    this.vestingIncrement = vestingIncrement;\n  }\n\n  minimumBalanceAtSlot(globalSlot: UInt32): UInt64 {\n    // TODO: implement the provable friendly version of this function\n    // const beforeVestingCliff = globalSlot.lessThan(this.cliffTime);\n    // Provable.if(\n    //   beforeVestingCliff,\n    //   UInt64,\n    //   this.initialMinimumBalance,\n    //   ...\n    // )\n\n    if (Provable.inCheckedComputation())\n      throw new Error('cannot call minimumBalanceAtSlot from a checked computation');\n\n    if (globalSlot.lessThan(this.cliffTime).toBoolean()) {\n      return this.initialMinimumBalance;\n    } else if (this.vestingPeriod.equals(UInt32.zero).toBoolean()) {\n      return UInt64.zero;\n    } else if (this.initialMinimumBalance.lessThan(this.cliffAmount).toBoolean()) {\n      return UInt64.zero;\n    } else {\n      const minBalanceAfterCliff = this.initialMinimumBalance.sub(this.cliffAmount);\n      const numPeriodsVested = globalSlot.sub(this.cliffTime).div(this.vestingPeriod).toUInt64();\n\n      const vestingDecrementWillOverflow =\n        !numPeriodsVested.equals(UInt64.zero).toBoolean() &&\n        UInt64.MAXINT().div(numPeriodsVested).lessThan(this.vestingIncrement).toBoolean();\n      const vestingDecrement = vestingDecrementWillOverflow\n        ? UInt64.MAXINT()\n        : numPeriodsVested.mul(this.vestingIncrement);\n\n      if (minBalanceAfterCliff.lessThan(vestingDecrement).toBoolean()) {\n        return UInt64.zero;\n      } else {\n        return minBalanceAfterCliff.sub(vestingDecrement);\n      }\n    }\n  }\n\n  static empty(): AccountTiming {\n    return new AccountTiming({\n      initialMinimumBalance: UInt64.empty(),\n      cliffTime: UInt32.empty(),\n      cliffAmount: UInt64.empty(),\n      vestingPeriod: UInt32.empty(),\n      vestingIncrement: UInt64.empty(),\n    });\n  }\n}\n\nclass Account<State extends StateLayout = 'GenericState'> {\n  State: StateDefinition<State>;\n  isNew: Unconstrained<boolean>;\n\n  accountId: AccountId;\n  tokenSymbol: TokenSymbol;\n  balance: UInt64;\n  nonce: UInt32;\n  receiptChainHash: Field; // TODO: ReceiptChainHash\n  delegate: PublicKey | null;\n  votingFor: Field; // TODO: StateHash;\n  timing: AccountTiming;\n  permissions: Permissions;\n\n  // TODO: it's important that we have the notion of \"default\" zkapp state, to and convert accordingly to/from JSON\n  zkapp: {\n    state: StateValues<State>;\n    verificationKey: VerificationKey;\n    // TODO:\n    // zkappVersion: ...;\n    actionState: Field[];\n    // lastActionSlot: ...;\n    // TODO: s/isProven/isProved/ (it's either \"was proven\" or \"is proved\", not \"is proven\")\n    isProven: Bool;\n    zkappUri: ZkappUri;\n  };\n\n  constructor(\n    State: StateDefinition<State>,\n    isNew: boolean | Unconstrained<boolean>,\n    data: {\n      accountId: AccountId;\n      tokenSymbol: TokenSymbol;\n      balance: UInt64;\n      nonce: UInt32;\n      receiptChainHash: Field;\n      delegate: PublicKey | null;\n      votingFor: Field;\n      timing: AccountTiming;\n      permissions: Permissions;\n      zkapp?: {\n        state: StateValues<State>;\n        verificationKey: VerificationKey;\n        // TODO:\n        // zkappVersion: ...;\n        actionState: Field[];\n        // lastActionSlot: ...;\n        // TODO: s/isProven/isProved/ (it's either \"was proven\" or \"is proved\", not \"is proven\")\n        isProven: Bool;\n        zkappUri: ZkappUri;\n      };\n    }\n  ) {\n    this.State = State;\n\n    this.isNew = isNew instanceof Unconstrained ? isNew : Unconstrained.from(isNew);\n\n    this.accountId = data.accountId;\n    this.tokenSymbol = data.tokenSymbol;\n    this.balance = data.balance;\n    this.nonce = data.nonce;\n    this.receiptChainHash = data.receiptChainHash;\n    this.delegate = data.delegate;\n    this.votingFor = data.votingFor;\n    this.timing = data.timing;\n    this.permissions = data.permissions;\n    this.zkapp = {\n      state: data.zkapp?.state ?? StateValues.empty(this.State),\n      verificationKey: data.zkapp?.verificationKey ?? VerificationKey.dummySync(),\n      actionState: [new Field(0), new Field(0), new Field(0), new Field(0), new Field(0)], // TODO NOW\n      isProven: data.zkapp?.isProven ?? new Bool(false),\n      zkappUri: data.zkapp?.zkappUri ?? ZkappUri.empty(),\n    };\n  }\n\n  /*\n    checkAndApplyFeePayment(\n      feePayment: ZkappFeePayment\n    ):\n      | { status: 'Applied'; updatedAccount: Account<State> }\n      | { status: 'Failed'; errors: Error[] } {\n      const errors: Error[] = [];\n  \n      if (this.accountId.tokenId.equals(TokenId.MINA).not().toBoolean())\n        errors.push(new Error('cannot pay zkapp fee with a non-mina account'));\n  \n      if (this.accountId.publicKey.equals(feePayment.publicKey).not().toBoolean())\n        errors.push(\n          new Error('fee payment public key does not match account public key')\n        );\n  \n      if (this.nonce.equals(feePayment.nonce).not().toBoolean())\n        errors.push(new Error('invalid account nonce'));\n  \n      if (this.balance.lessThan(feePayment.fee).toBoolean())\n        errors.push(\n          new Error(\n            'account does not have enough balance to pay the required fee'\n          )\n        );\n  \n      // TODO: validWhile (probably checked elsewhere)\n  \n      if (errors.length === 0) {\n        const updatedAccount = new Account(this.State, false, {\n          ...this,\n          balance: this.balance.sub(feePayment.fee),\n          nonce: this.nonce.add(UInt32.one),\n        });\n        return { status: 'Applied', updatedAccount };\n      } else {\n        return { status: 'Failed', errors };\n      }\n    }\n  \n    // TODO: replay checks (probably live on the AccountUpdate itself, but needs to be called near this)\n    checkAndApplyUpdate<Event, Action>(\n      update: AccountUpdate<State, Event, Action>\n    ):\n      | { status: 'Applied'; updatedAccount: Account<State> }\n      | { status: 'Failed'; errors: Error[] } {\n      const errors: Error[] = [];\n  \n      if (this.accountId.equals(update.accountId).not().toBoolean())\n        errors.push(\n          new Error(\n            'account id in account update does not match actual account id'\n          )\n        );\n  \n      // TODO: check verificationKeyHash\n      // TODO: check mayUseToken (somewhere, maybe not here)\n  \n      // CHECK PRECONDITIONS\n  \n      function preconditionError(\n        preconditionName: string,\n        constraint: { toStringHuman(): string },\n        value: unknown\n      ): Error {\n        return new Error(\n          `${preconditionName} precondition failed: ${value} does not satisfy \"${constraint.toStringHuman()}\"`\n        );\n      }\n  \n      // WARNING: failing to specify the type parameter on this function exhibits unsound behavior\n      //          (thanks typescript)\n      function checkPrecondition<T>(\n        preconditionName: string,\n        constraint: { isSatisfied(x: T): Bool; toStringHuman(): string },\n        value: T\n      ): void {\n        if (constraint.isSatisfied(value).not().toBoolean())\n          errors.push(preconditionError(preconditionName, constraint, value));\n      }\n  \n      checkPrecondition<UInt64>(\n        'balance',\n        update.preconditions.account.balance,\n        this.balance\n      );\n      checkPrecondition<UInt32>(\n        'nonce',\n        update.preconditions.account.nonce,\n        this.nonce\n      );\n      checkPrecondition<Field>(\n        'receiptChainHash',\n        update.preconditions.account.receiptChainHash,\n        this.receiptChainHash\n      );\n      if (this.delegate !== null)\n        checkPrecondition<PublicKey>(\n          'delegate',\n          update.preconditions.account.delegate,\n          this.delegate\n        );\n      checkPrecondition<Bool>(\n        'isProven',\n        update.preconditions.account.isProven,\n        this.zkapp.isProven\n      );\n  \n      StateValues.checkPreconditions(\n        this.State,\n        this.zkapp.state,\n        update.preconditions.account.state\n      );\n  \n      const actionState = this.zkapp?.actionState ?? [];\n      const actionStateSatisfied = Bool.anyTrue(\n        actionState.map((s) =>\n          update.preconditions.account.actionState.isSatisfied(s)\n        )\n      );\n      if (actionStateSatisfied.not().toBoolean())\n        errors.push(\n          preconditionError(\n            'actionState',\n            update.preconditions.account.actionState,\n            actionState\n          )\n        );\n  \n      // TODO: updates.preconditions.account.isNew\n  \n      // TODO: network (probably checked elsewhere)\n      // TODO: validWhile (probably checked elsewhere)\n  \n      // CHECK PERMISSIONS\n  \n      function checkPermission(\n        permissionName: string,\n        requiredAuthLevel: AuthorizationLevel,\n        actionIsPerformed: boolean\n      ): void {\n        if(actionIsPerformed && !requiredAuthLevel.isSatisfied(update.authorizationKind))\n          errors.push(new Error(\n            `${permissionName} permission was violated: account update has authorization kind ${update.authorizationKind.identifier()}, but required auth level is ${requiredAuthLevel.identifier()}`\n          ));\n      }\n  \n      checkPermission('access', this.permissions.access, true);\n      checkPermission('send', this.permissions.send, update.balanceChange.isNegative().toBoolean());\n      checkPermission('receive', this.permissions.receive, update.balanceChange.isPositive().toBoolean());\n      checkPermission('incrementNonce', this.permissions.incrementNonce, update.incrementNonce.toBoolean());\n      checkPermission('setDelegate', this.permissions.setDelegate, update.delegateUpdate.set.toBoolean());\n      checkPermission('setPermissions', this.permissions.setPermissions, update.permissionsUpdate.set.toBoolean());\n      checkPermission('setVerificationKey', this.permissions.setVerificationKey.auth, update.verificationKeyUpdate.set.toBoolean());\n      checkPermission('setZkappUri', this.permissions.setZkappUri, update.zkappUriUpdate.set.toBoolean());\n      checkPermission('setTokenSymbol', this.permissions.setTokenSymbol, update.tokenSymbolUpdate.set.toBoolean());\n      checkPermission('setVotingFor', this.permissions.setVotingFor, update.votingForUpdate.set.toBoolean());\n      checkPermission('setTiming', this.permissions.setTiming, update.timingUpdate.set.toBoolean());\n      checkPermission('editActionState', this.permissions.editActionState, update.pushActions.data.length > 0);\n      checkPermission('editState', this.permissions.editState, StateUpdates.anyValuesAreSet(update.stateUpdates).toBoolean());\n  \n      // APPLY UPDATES\n  \n      // TODO: account for implicitAccountCreationFee here\n      let updatedBalance: UInt64 = this.balance;\n      // TODO: why is Int64 not comparable?\n      // if(update.balanceChange.lessThan(Int64.create(this.balance, Sign.minusOne)).toBoolean())\n      if (\n        update.balanceChange.isNegative().toBoolean() &&\n        update.balanceChange.magnitude.greaterThan(this.balance).toBoolean()\n      ) {\n        errors.push(\n          new Error(\n            `insufficient balance for balanceChange (balance = ${this.balance}, balanceChange = -${update.balanceChange.magnitude})`\n          )\n        );\n      } else {\n        // TODO: check for overflows?\n        const isPos = update.balanceChange.isPositive().toBoolean();\n        const amount = update.balanceChange.magnitude;\n        updatedBalance = isPos\n          ? this.balance.add(amount)\n          : this.balance.sub(amount);\n      }\n  \n      // TODO: pushEvents\n      // TODO: pushActions\n  \n      if (errors.length === 0) {\n        function applyUpdate<T>(update: Update<T>, value: T): T {\n          return update.set.toBoolean() ? update.value : value;\n        }\n  \n        const allStateUpdated = Bool.allTrue(\n          StateUpdates.toFieldUpdates(this.State, update.stateUpdates).map(\n            (update) => update.set\n          )\n        );\n  \n        const updatedAccount = new Account(this.State, false, {\n          ...this,\n          balance: updatedBalance,\n          tokenSymbol: applyUpdate(update.tokenSymbolUpdate, this.tokenSymbol),\n          nonce: update.incrementNonce.toBoolean()\n            ? this.nonce.add(UInt32.one)\n            : this.nonce,\n          delegate: applyUpdate(update.delegateUpdate, this.delegate),\n          votingFor: applyUpdate(update.votingForUpdate, this.votingFor),\n          timing: applyUpdate(update.timingUpdate, this.timing),\n          permissions: applyUpdate(update.permissionsUpdate, this.permissions),\n          zkapp: {\n            state: StateValues.applyUpdates(\n              this.State,\n              this.zkapp.state,\n              update.stateUpdates\n            ),\n            verificationKey: applyUpdate(\n              update.verificationKeyUpdate,\n              this.zkapp.verificationKey\n            ),\n            // actionState: TODO,\n            isProven: this.zkapp.isProven.or(allStateUpdated),\n            zkappUri: applyUpdate(update.zkappUriUpdate, this.zkapp.zkappUri),\n          },\n        });\n  \n        return { status: 'Applied', updatedAccount };\n      } else {\n        return { status: 'Failed', errors };\n      }\n    }\n    */\n\n  toGeneric(): Account {\n    return new Account<'GenericState'>('GenericState', this.isNew, {\n      ...this,\n      zkapp: {\n        ...this.zkapp,\n        state: StateValues.toGeneric(this.State, this.zkapp.state),\n      },\n    });\n  }\n\n  static fromGeneric<State extends StateLayout>(\n    account: Account,\n    State: StateDefinition<State>\n  ): Account<State> {\n    return new Account(State, account.isNew, {\n      ...account,\n      zkapp: {\n        ...account.zkapp,\n        state: StateValues.fromGeneric(account.zkapp.state, State),\n      },\n    });\n  }\n\n  static empty(accountId: AccountId): Account {\n    return new Account('GenericState', true, {\n      accountId,\n      tokenSymbol: TokenSymbol.empty(),\n      balance: UInt64.zero,\n      nonce: UInt32.zero,\n      receiptChainHash: new Field(0), // ReceiptChainHash.empty()\n      delegate: null,\n      votingFor: new Field(0),\n      timing: AccountTiming.empty(),\n      permissions: Permissions.defaults(),\n    });\n  }\n}\n", "import { AccountId, AccountTiming } from './account.js';\nimport {\n  AccountUpdateAuthorization,\n  AccountUpdateAuthorizationEnvironment,\n  AccountUpdateAuthorizationKind,\n  AccountUpdateAuthorizationKindIdentifier,\n  AccountUpdateAuthorizationKindWithZkappContext,\n} from './authorization.js';\nimport { Option, TokenId, Update, ZkappUri, mapUndefined } from './core.js';\nimport { Permissions, PermissionsDescription } from './permissions.js';\nimport { Preconditions, PreconditionsDescription } from './preconditions.js';\nimport { GenericStateUpdates, StateDefinition, StateLayout, StateUpdates } from './state.js';\nimport { Pickles } from '../../../bindings.js';\nimport { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { Int64, UInt64 } from '../../provable/int.js';\nimport { Proof } from '../../proof-system/zkprogram.js';\nimport {\n  emptyHashWithPrefix,\n  hashWithPrefix,\n  packToFields,\n  TokenSymbol,\n} from '../../provable/crypto/poseidon.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { HashInput } from '../../provable/types/provable-derivers.js';\nimport { Provable } from '../../provable/types/provable-intf.js';\nimport { mocks, prefixes } from '../../../bindings/crypto/constants.js';\nimport * as Bindings from '../../../bindings/mina-transaction/v2/index.js';\nimport * as PoseidonBigint from '../../../mina-signer/src/poseidon-bigint.js';\nimport {\n  Signature,\n  signFieldElement,\n  zkAppBodyPrefix,\n} from '../../../mina-signer/src/signature.js';\nimport { NetworkId } from '../../../mina-signer/src/types.js';\nimport { Struct } from '../../provable/types/struct.js';\nimport { VerificationKey } from '../../../lib/proof-system/verification-key.js';\n\n// TODO: make private abstractions over many fields (eg new apis for Update and Constraint.*)\n// TODO: replay checks\nexport {\n  AccountUpdate,\n  Authorized,\n  GenericData,\n  AccountUpdateTree,\n  AccountUpdateTreeDescription,\n  ContextFreeAccountUpdateDescription,\n  ContextFreeAccountUpdate,\n  DynamicProvable,\n  AccountUpdateCommitment,\n  CommittedList,\n  EventsHashConfig,\n  ActionsHashConfig,\n};\nclass AccountUpdateCommitment extends Struct({\n  accountUpdateCommitment: Field,\n}) {\n  constructor(accountUpdateCommitment: Field) {\n    super({ accountUpdateCommitment });\n  }\n}\n\n// TODO: move elsewhere\ntype DynamicProvable<T> =\n  | Provable<T>\n  | {\n      toFields(x: T): Field[];\n      toAuxiliary(x: T): any[];\n      fromFieldsDynamic(fields: Field[], aux: any[]): { value: T; fieldsConsumed: number };\n    };\n\n// TODO: move elsewhere\nconst GenericData: DynamicProvable<Field[]> = {\n  toFields(x: Field[]): Field[] {\n    return x;\n  },\n\n  toAuxiliary(x: Field[]): any[] {\n    return [x.length];\n  },\n\n  fromFieldsDynamic(fields: Field[], aux: any[]): { value: Field[]; fieldsConsumed: number } {\n    const [_len] = aux;\n    let len = _len ?? fields.length;\n    return { value: fields.slice(0, len), fieldsConsumed: len };\n  },\n};\n\n// TODO: move elsewhere\n/*\ninterface Hashable {\n  hash(): Field;\n}\n*/\n// TODO: move elsewhere\ninterface HashableDataConfig<Item> {\n  readonly emptyPrefix: string;\n  readonly consPrefix: string;\n  hash(item: Item): Field;\n}\n\nfunction EventsHashConfig<T>(T: DynamicProvable<T>): HashableDataConfig<T> {\n  return {\n    emptyPrefix: 'MinaZkappEventsEmpty',\n    consPrefix: prefixes.events,\n    hash(x: T): Field {\n      const fields = T.toFields(x);\n      return hashWithPrefix(prefixes.event, fields);\n    },\n  };\n}\n\nfunction ActionsHashConfig<T>(T: DynamicProvable<T>): HashableDataConfig<T> {\n  return {\n    emptyPrefix: 'MinaZkappActionsEmpty',\n    consPrefix: prefixes.sequenceEvents,\n    hash(x: T): Field {\n      const fields = T.toFields(x);\n      return hashWithPrefix(prefixes.event, fields);\n    },\n  };\n}\n\n// TODO: move elsewhere\nclass CommittedList<Item> {\n  readonly Item: DynamicProvable<Item>;\n  readonly data: Item[];\n  readonly hash: Field;\n\n  constructor({ Item, data, hash }: { Item: DynamicProvable<Item>; data: Item[]; hash: Field }) {\n    this.Item = Item;\n    this.data = data;\n    this.hash = hash;\n  }\n\n  toInternalRepr(): { data: Field[][]; hash: Field } {\n    return {\n      data: this.data.map(this.Item.toFields),\n      hash: this.hash,\n    };\n  }\n\n  // IMPORTANT: It is the callers responsibility to ensure the commitment will compute the same\n  //            after mapping the list (this function does not check this for you at runtime).\n  mapUnsafe<B>(NewItem: DynamicProvable<B>, f: (a: Item) => B): CommittedList<B> {\n    return new CommittedList({\n      Item: NewItem,\n      data: this.data.map(f),\n      hash: this.hash,\n    });\n  }\n\n  static hashList<Item>(config: HashableDataConfig<Item>, items: Item[]): Field {\n    let hash = emptyHashWithPrefix(config.emptyPrefix);\n\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      hash = hashWithPrefix(config.consPrefix, [hash, config.hash(item)]);\n    }\n\n    return hash;\n  }\n\n  static from<Item>(\n    Item: DynamicProvable<Item>,\n    config: HashableDataConfig<Item>,\n    value: undefined | Item[] | CommittedList<Item> | Bindings.Leaves.CommittedList\n  ): CommittedList<Item> {\n    if (value instanceof CommittedList) return value;\n\n    let items: Item[];\n    //let hash;\n    if (value === undefined) {\n      items = [];\n    } else if (value instanceof Array) {\n      items = value;\n    } else {\n      // TODO: think about this a bit more... we don't have the aux data here, so we should do\n      // something to restrict the types\n      if ('fromFields' in Item) {\n        items = value.data.map((fields) => Item.fromFields(fields, []));\n      } else {\n        items = value.data.map((fields) => {\n          const { value: result, fieldsConsumed } = Item.fromFieldsDynamic(fields, []);\n          if (fieldsConsumed !== fields.length)\n            throw new Error('expected all fields to be consumed when casting dynamic item');\n          return result;\n        });\n      }\n      //hash = value.hash;\n    }\n\n    //hash = hash ?? CommittedList.hashList(config, items);\n\n    return new CommittedList({\n      Item,\n      data: items,\n      hash: CommittedList.hashList(config, items),\n    });\n  }\n}\n\ninterface MayUseToken {\n  parentsOwnToken: Bool;\n  inheritFromParent: Bool;\n}\n\ntype AccountUpdateTreeDescription<RootDescription, Child> = RootDescription & {\n  // TODO: support using commitments?\n  children?: AccountUpdateTree<Child>[];\n};\n\n// TODO: CONSIDER -- merge this logic into AccountUpdate\n//  class AccountUpdateTree<AccountUpdateType> {\nclass AccountUpdateTree<Root, Child = Root> {\n  constructor(\n    public rootAccountUpdate: Root,\n    public children: AccountUpdateTree<Child, Child>[]\n  ) {}\n\n  // depth first traversal (parents before children)\n  static forEachNode<T>(\n    tree: AccountUpdateTree<T>,\n    depth: number,\n    f: (accountUpdate: T, depth: number) => void\n  ): void {\n    f(tree.rootAccountUpdate, depth);\n    tree.children.forEach((child) => AccountUpdateTree.forEachNode(child, depth + 1, f));\n  }\n\n  // inverted depth first traversal (children before parents)\n  static forEachNodeInverted<T>(\n    tree: AccountUpdateTree<T>,\n    depth: number,\n    f: (accountUpdate: T, depth: number) => void\n  ): void {\n    tree.children.forEach((child) => AccountUpdateTree.forEachNodeInverted(child, depth + 1, f));\n    f(tree.rootAccountUpdate, depth);\n  }\n\n  static reduce<T, R>(tree: AccountUpdateTree<T>, f: (accountUpdate: T, childValues: R[]) => R): R {\n    const childValues = tree.children.map((child) => AccountUpdateTree.reduce(child, f));\n    return f(tree.rootAccountUpdate, childValues);\n  }\n\n  // TODO: delete (realized I didn't need it part way through writing)\n  // // build context as we descend the tree, map, then reduce as we ascend\n  // static mapReduceWithContext<T, Ctx, R>(\n  //   tree: AccountUpdateTree<T>,\n  //   context: Ctx,\n  //   mapContext: (ctx: Ctx, index: number) => Ctx,\n  //   map: (ctx: Ctx, accountUpdate: T) => R,\n  //   reduce: (values: R[]) => R\n  // ): R {\n  //   if(tree.children.length === 0) {\n  //     return map(context, tree.rootAccountUpdate);\n  //   } else {\n  //     const reducedValues = tree.children.map((child, index) =>\n  //       AccountUpdateTree.mapReduceWithContext(\n  //         child,\n  //         mapContext(context, index),\n  //         mapContext,\n  //         map,\n  //         reduce\n  //       );\n  //     );\n  //     return reduce(reducedValues);\n  //   }\n  // }\n\n  // TODO: refactor the type parameter interfaces\n\n  static mapRoot<RootIn, RootOut, Child>(\n    tree: AccountUpdateTree<RootIn, Child>,\n    f: (accountUpdate: RootIn) => RootOut\n  ): AccountUpdateTree<RootOut, Child> {\n    const newAccountUpdate = f(tree.rootAccountUpdate);\n    return new AccountUpdateTree(newAccountUpdate, tree.children);\n  }\n\n  static async map<A, B>(\n    tree: AccountUpdateTree<A>,\n    f: (accountUpdate: A) => Promise<B>\n  ): Promise<AccountUpdateTree<B>> {\n    const newAccountUpdate = await f(tree.rootAccountUpdate);\n    const newChildren = await AccountUpdateTree.mapForest(tree.children, f);\n    return new AccountUpdateTree(newAccountUpdate, newChildren);\n  }\n\n  static mapForest<A, B>(\n    forest: AccountUpdateTree<A>[],\n    f: (a: A) => Promise<B>\n  ): Promise<AccountUpdateTree<B>[]> {\n    return Promise.all(forest.map((tree) => AccountUpdateTree.map(tree, f)));\n  }\n\n  // TODO: I think this can be safely made polymorphic over the account update state, actions, and events representations\n  // TODO: Field, not bigint\n  static hash(tree: AccountUpdateTree<AccountUpdate>, networkId: NetworkId): bigint {\n    // TODO: is it ok to do this and ignore the toValue encodings entirely?\n    const accountUpdateFieldInput = tree.rootAccountUpdate.toInput();\n    const accountUpdateBigintInput = {\n      fields: accountUpdateFieldInput.fields?.map((f: Field) => f.toBigInt()),\n      packed: accountUpdateFieldInput.packed?.map(([f, n]: [Field, number]): [bigint, number] => [\n        f.toBigInt(),\n        n,\n      ]),\n    };\n\n    // TODO: negotiate between this implementation and AccountUpdate#hash to figure out what is correct\n    // TODO NOW: ^ this was done, but we need to update this function to share code still\n    const accountUpdateCommitment = PoseidonBigint.hashWithPrefix(\n      zkAppBodyPrefix(networkId),\n      PoseidonBigint.packToFields(accountUpdateBigintInput)\n    );\n    const childrenCommitment = AccountUpdateTree.hashForest(networkId, tree.children);\n    return PoseidonBigint.hashWithPrefix(prefixes.accountUpdateNode, [\n      accountUpdateCommitment,\n      childrenCommitment,\n    ]);\n  }\n\n  // TODO: Field, not bigint\n  static hashForest(networkId: NetworkId, forest: AccountUpdateTree<AccountUpdate>[]): bigint {\n    const consHash = (acc: bigint, tree: AccountUpdateTree<AccountUpdate>) =>\n      PoseidonBigint.hashWithPrefix(prefixes.accountUpdateCons, [\n        AccountUpdateTree.hash(tree, networkId),\n        acc,\n      ]);\n    return [...forest].reverse().reduce(consHash, 0n);\n  }\n\n  static unrollForest<AccountUpdateType, Return>(\n    forest: AccountUpdateTree<AccountUpdateType>[],\n    f: (accountUpdate: AccountUpdateType, depth: number) => Return\n  ): Return[] {\n    const seq: Return[] = [];\n    forest.forEach((tree) =>\n      AccountUpdateTree.forEachNode(tree, 0, (accountUpdate, depth) =>\n        seq.push(f(accountUpdate, depth))\n      )\n    );\n    return seq;\n  }\n\n  static sizeInFields(): number {\n    return AccountUpdate.sizeInFields();\n  }\n\n  static toFields(x: AccountUpdateTree<AccountUpdate>): Field[] {\n    return AccountUpdate.toFields(x.rootAccountUpdate);\n  }\n\n  static toAuxiliary(x?: AccountUpdateTree<AccountUpdate>): any[] {\n    return [AccountUpdate.toAuxiliary(x?.rootAccountUpdate), x?.children ?? []];\n  }\n\n  static fromFields(fields: Field[], aux: any[]): AccountUpdateTree<AccountUpdate> {\n    return new AccountUpdateTree(AccountUpdate.fromFields(fields, aux[0]), aux[1]);\n  }\n\n  static toValue(x: AccountUpdateTree<AccountUpdate>): AccountUpdateTree<AccountUpdate> {\n    return x;\n  }\n\n  static fromValue(x: AccountUpdateTree<AccountUpdate>): AccountUpdateTree<AccountUpdate> {\n    return x;\n  }\n\n  static check(_x: AccountUpdateTree<AccountUpdate>): void {\n    // TODO\n  }\n\n  static from<RootDescription, Root, Child>(\n    descr: AccountUpdateTreeDescription<RootDescription, Child>,\n    createAccountUpdate: (descr: RootDescription) => Root\n  ): AccountUpdateTree<Root, Child> {\n    return new AccountUpdateTree(createAccountUpdate(descr), descr.children ?? []);\n  }\n}\n\ninterface ContextFreeAccountUpdateDescription<\n  State extends StateLayout = 'GenericState',\n  Event = Field[],\n  Action = Field[],\n> {\n  // TODO: accept identifiers for authorization kind\n  authorizationKind: AccountUpdateAuthorizationKindIdentifier | AccountUpdateAuthorizationKind;\n  preconditions?: PreconditionsDescription<State> | Preconditions<State>;\n  balanceChange?: Int64;\n  incrementNonce?: Bool;\n  useFullCommitment?: Bool;\n  implicitAccountCreationFee?: Bool;\n  mayUseToken?: MayUseToken;\n  pushEvents?: Event[] | CommittedList<Event>;\n  pushActions?: Action[] | CommittedList<Action>;\n  setState?: StateUpdates<State>;\n  setPermissions?: PermissionsDescription | Permissions | Update<Permissions>;\n  setDelegate?: PublicKey | Update<PublicKey>;\n  setVerificationKey?: VerificationKey | Update<VerificationKey>;\n  setZkappUri?: string | ZkappUri | Update<ZkappUri>;\n  setTokenSymbol?: string | TokenSymbol | Update<TokenSymbol>;\n  setTiming?: AccountTiming | Update<AccountTiming>;\n  setVotingFor?: Field | Update<Field>;\n}\n\n// in a ZkModule context: ContextFreeAccountUpdate is an AccountUpdate without an account id and call data\n\nclass ContextFreeAccountUpdate<\n  State extends StateLayout = 'GenericState',\n  Event = Field[],\n  Action = Field[],\n> {\n  readonly State: StateDefinition<State>;\n  authorizationKind: AccountUpdateAuthorizationKind;\n  preconditions: Preconditions<State>;\n  balanceChange: Int64;\n  incrementNonce: Bool;\n  useFullCommitment: Bool;\n  implicitAccountCreationFee: Bool;\n  mayUseToken: MayUseToken;\n  pushEvents: CommittedList<Event>;\n  pushActions: CommittedList<Action>;\n  // TODO: standardize on these being set* for *Update, don't do both\n  stateUpdates: StateUpdates<State>;\n  permissionsUpdate: Update<Permissions>;\n  delegateUpdate: Update<PublicKey>;\n  verificationKeyUpdate: Update<VerificationKey>;\n  zkappUriUpdate: Update<ZkappUri>;\n  tokenSymbolUpdate: Update<TokenSymbol>;\n  timingUpdate: Update<AccountTiming>;\n  votingForUpdate: Update<Field>;\n\n  constructor(\n    State: StateDefinition<State>,\n    Event: DynamicProvable<Event>,\n    Action: DynamicProvable<Action>,\n    descr:\n      | ContextFreeAccountUpdateDescription<State, Event, Action>\n      | ContextFreeAccountUpdate<State, Event, Action>\n  ) {\n    function castUpdate<A, B>(\n      value: undefined | A | Update<B>,\n      defaultValue: B,\n      f: (a: A) => B\n    ): Update<B> {\n      if (value instanceof Update) {\n        return value;\n      } else {\n        return Update.from(mapUndefined(value, f), defaultValue);\n      }\n    }\n\n    this.State = State;\n    this.authorizationKind = AccountUpdateAuthorizationKind.from(descr.authorizationKind);\n    this.preconditions =\n      mapUndefined(descr.preconditions, (x) => Preconditions.from(State, x)) ??\n      Preconditions.emptyPoly(State);\n    this.balanceChange = descr.balanceChange ?? Int64.create(UInt64.zero);\n    this.incrementNonce = descr.incrementNonce ?? new Bool(false);\n    this.useFullCommitment = descr.useFullCommitment ?? new Bool(false);\n    this.implicitAccountCreationFee = descr.implicitAccountCreationFee ?? new Bool(false);\n    this.mayUseToken = descr.mayUseToken ?? {\n      parentsOwnToken: new Bool(false),\n      inheritFromParent: new Bool(false),\n    };\n    this.pushEvents = CommittedList.from(Event, EventsHashConfig(Event), descr.pushEvents);\n    this.pushActions = CommittedList.from(Action, ActionsHashConfig(Action), descr.pushActions);\n\n    if (descr instanceof ContextFreeAccountUpdate) {\n      this.stateUpdates = descr.stateUpdates;\n      this.permissionsUpdate = descr.permissionsUpdate;\n      this.delegateUpdate = descr.delegateUpdate;\n      this.verificationKeyUpdate = descr.verificationKeyUpdate;\n      this.zkappUriUpdate = descr.zkappUriUpdate;\n      this.tokenSymbolUpdate = descr.tokenSymbolUpdate;\n      this.timingUpdate = descr.timingUpdate;\n      this.votingForUpdate = descr.votingForUpdate;\n    } else {\n      this.stateUpdates = descr.setState ?? StateUpdates.empty(State);\n      this.permissionsUpdate = castUpdate(\n        descr.setPermissions,\n        Permissions.empty(),\n        Permissions.from\n      );\n      this.delegateUpdate = Update.from(descr.setDelegate, PublicKey.empty());\n      this.verificationKeyUpdate = Update.from(descr.setVerificationKey, VerificationKey.empty());\n      this.zkappUriUpdate = castUpdate(descr.setZkappUri, ZkappUri.empty(), ZkappUri.from);\n      this.tokenSymbolUpdate = castUpdate(\n        descr.setTokenSymbol,\n        TokenSymbol.empty(),\n        TokenSymbol.from\n      );\n      this.timingUpdate = Update.from(descr.setTiming, AccountTiming.empty());\n      this.votingForUpdate = Update.from(descr.setVotingFor, Field.empty());\n    }\n  }\n\n  toGeneric(): ContextFreeAccountUpdate {\n    return ContextFreeAccountUpdate.generic({\n      authorizationKind: this.authorizationKind,\n      preconditions: this.preconditions.toGeneric(),\n      balanceChange: this.balanceChange,\n      incrementNonce: this.incrementNonce,\n      useFullCommitment: this.useFullCommitment,\n      implicitAccountCreationFee: this.implicitAccountCreationFee,\n      mayUseToken: this.mayUseToken,\n      pushEvents: this.pushEvents.mapUnsafe(GenericData, this.pushEvents.Item.toFields),\n      pushActions: this.pushActions.mapUnsafe(GenericData, this.pushActions.Item.toFields),\n      setState: StateUpdates.toGeneric(this.State, this.stateUpdates),\n      setPermissions: this.permissionsUpdate,\n      setDelegate: this.delegateUpdate,\n      setVerificationKey: this.verificationKeyUpdate,\n      setZkappUri: this.zkappUriUpdate,\n      setTokenSymbol: this.tokenSymbolUpdate,\n      setTiming: this.timingUpdate,\n      setVotingFor: this.votingForUpdate,\n    });\n  }\n\n  static fromGeneric<State extends StateLayout, Event, Action>(\n    x: ContextFreeAccountUpdate,\n    State: StateDefinition<State>,\n    Event: DynamicProvable<Event>,\n    Action: DynamicProvable<Action>\n  ): ContextFreeAccountUpdate<State, Event, Action> {\n    // TODO: this method is broken because we aren't storing aux data in the generic format...\n    return new ContextFreeAccountUpdate(State, Event, Action, {\n      authorizationKind: x.authorizationKind,\n      preconditions: Preconditions.fromGeneric(x.preconditions, State),\n      balanceChange: x.balanceChange,\n      incrementNonce: x.incrementNonce,\n      useFullCommitment: x.useFullCommitment,\n      implicitAccountCreationFee: x.implicitAccountCreationFee,\n      mayUseToken: x.mayUseToken,\n      pushEvents: x.pushEvents.mapUnsafe(Event, (fields) =>\n        // TODO: this is really unsafe, make it safe\n        'fromFieldsDynamic' in Event\n          ? Event.fromFieldsDynamic(fields, []).value\n          : Event.fromFields(fields, [])\n      ),\n      pushActions: x.pushActions.mapUnsafe(Action, (fields) =>\n        // TODO: this is really unsafe, make it safe\n        'fromFieldsDynamic' in Action\n          ? Action.fromFieldsDynamic(fields, []).value\n          : Action.fromFields(fields, [])\n      ),\n      setState: StateUpdates.fromGeneric(x.stateUpdates, State),\n      setPermissions: x.permissionsUpdate,\n      setDelegate: x.delegateUpdate,\n      setVerificationKey: x.verificationKeyUpdate,\n      setZkappUri: x.zkappUriUpdate,\n      setTokenSymbol: x.tokenSymbolUpdate,\n      setTiming: x.timingUpdate,\n      setVotingFor: x.votingForUpdate,\n    });\n  }\n\n  static generic(descr: ContextFreeAccountUpdateDescription): ContextFreeAccountUpdate {\n    return new ContextFreeAccountUpdate('GenericState', GenericData, GenericData, descr);\n  }\n\n  static emptyPoly<State extends StateLayout, Event, Action>(\n    State: StateDefinition<State>,\n    Event: DynamicProvable<Event>,\n    Action: DynamicProvable<Action>\n  ) {\n    return new ContextFreeAccountUpdate(State, Event, Action, {\n      authorizationKind: AccountUpdateAuthorizationKind.None(),\n    });\n  }\n\n  static empty(): ContextFreeAccountUpdate {\n    return ContextFreeAccountUpdate.emptyPoly('GenericState', GenericData, GenericData);\n  }\n\n  static from<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    State: StateDefinition<State>,\n    Event: DynamicProvable<Event>,\n    Action: DynamicProvable<Action>,\n    x:\n      | ContextFreeAccountUpdateDescription<State, Event, Action>\n      | ContextFreeAccountUpdate<State, Event, Action>\n      | undefined\n  ): ContextFreeAccountUpdate<State, Event, Action> {\n    if (x instanceof ContextFreeAccountUpdate) return x;\n    if (x === undefined) return ContextFreeAccountUpdate.emptyPoly(State, Event, Action);\n    return new ContextFreeAccountUpdate(State, Event, Action, x);\n  }\n}\n\ntype AccountUpdateDescription<State extends StateLayout, Event = Field[], Action = Field[]> = (\n  | {\n      update: ContextFreeAccountUpdate<State, Event, Action>;\n      proof?: Proof<undefined, AccountUpdateCommitment>;\n    }\n  | ContextFreeAccountUpdateDescription<State, Event, Action>\n) & {\n  accountId: AccountId;\n  verificationKeyHash?: Field;\n  callData?: Field;\n};\n\nclass AccountUpdate<\n  State extends StateLayout = 'GenericState',\n  Event = Field[],\n  Action = Field[],\n> extends ContextFreeAccountUpdate<State, Event, Action> {\n  accountId: AccountId;\n  verificationKeyHash: Field;\n  callData: Field;\n\n  // TODO: this probable shouldn't live here, but somewhere else\n  proof: 'NoProofRequired' | 'ProofPending' | Proof<undefined, AccountUpdateCommitment>;\n  // TODO: circuit friendly representation (we really don't want to toBoolean() in the constructor here...)\n  // proof: {pending: true, isRequired: Bool} | Proof<undefined, AccountUpdateCommitment>;\n\n  constructor(\n    State: StateDefinition<State>,\n    Event: DynamicProvable<Event>,\n    Action: DynamicProvable<Action>,\n    descr: AccountUpdateDescription<State, Event, Action>\n  ) {\n    // TODO NOW: THIS PATTERN IS BROKEN (we are casting and update into a description, which only works because the missing fields are all optional)\n\n    const superInput = 'update' in descr ? descr.update : descr;\n    super(State, Event, Action, superInput);\n\n    if (this.authorizationKind.isProved.toBoolean()) {\n      this.proof = 'proof' in descr && descr.proof !== undefined ? descr.proof : 'ProofPending';\n    } else {\n      if ('proof' in descr && descr.proof !== undefined) {\n        throw new Error(\n          'proof was provided when constructing an AccountUpdate that does not require a proof'\n        );\n      }\n      this.proof = 'NoProofRequired';\n    }\n\n    this.accountId = descr.accountId;\n    this.verificationKeyHash =\n      descr.verificationKeyHash ?? new Field(mocks.dummyVerificationKeyHash);\n    this.callData = descr.callData ?? new Field(0);\n  }\n\n  get authorizationKindWithZkappContext(): AccountUpdateAuthorizationKindWithZkappContext {\n    return new AccountUpdateAuthorizationKindWithZkappContext(\n      this.authorizationKind,\n      this.verificationKeyHash\n    );\n  }\n\n  toInternalRepr(callDepth: number): Bindings.Layout.AccountUpdateBody {\n    return {\n      authorizationKind: this.authorizationKindWithZkappContext,\n      publicKey: this.accountId.publicKey,\n      tokenId: this.accountId.tokenId.value,\n      callData: this.callData,\n      callDepth: callDepth,\n      balanceChange: this.balanceChange,\n      incrementNonce: this.incrementNonce,\n      useFullCommitment: this.useFullCommitment,\n      implicitAccountCreationFee: this.implicitAccountCreationFee,\n      mayUseToken: this.mayUseToken,\n      events: this.pushEvents.toInternalRepr(),\n      actions: this.pushActions.toInternalRepr(),\n      preconditions: this.preconditions.toInternalRepr(),\n      update: {\n        appState: StateUpdates.toFieldUpdates(this.State, this.stateUpdates).map((update) =>\n          update.toOption()\n        ),\n        delegate: this.delegateUpdate.toOption(),\n        verificationKey: Option.map(this.verificationKeyUpdate.toOption(), (data) =>\n          data instanceof VerificationKey ? new VerificationKey(data) : data\n        ),\n        permissions: this.permissionsUpdate.toOption(),\n        zkappUri: this.zkappUriUpdate.toOption(),\n        tokenSymbol: this.tokenSymbolUpdate.toOption(),\n        timing: this.timingUpdate.toOption(),\n        votingFor: this.votingForUpdate.toOption(),\n      },\n    };\n  }\n\n  toInput(): HashInput {\n    return Bindings.Layout.AccountUpdateBody.toInput(this.toInternalRepr(0));\n  }\n\n  commit(networkId: NetworkId): AccountUpdateCommitment {\n    const commitment = hashWithPrefix(zkAppBodyPrefix(networkId), packToFields(this.toInput()));\n    return new AccountUpdateCommitment(commitment);\n  }\n\n  toGeneric(): AccountUpdate {\n    return new AccountUpdate('GenericState', GenericData, GenericData, {\n      update: super.toGeneric(),\n      proof: this.proof instanceof Proof ? this.proof : undefined,\n      accountId: this.accountId,\n      verificationKeyHash: this.verificationKeyHash,\n      callData: this.callData,\n    });\n  }\n\n  static fromGeneric<State extends StateLayout, Event, Action>(\n    x: AccountUpdate,\n    State: StateDefinition<State>,\n    Event: DynamicProvable<Event>,\n    Action: DynamicProvable<Action>\n  ): AccountUpdate<State, Event, Action> {\n    return new AccountUpdate(State, Event, Action, {\n      update: ContextFreeAccountUpdate.fromGeneric(x, State, Event, Action),\n      proof: x.proof instanceof Proof ? x.proof : undefined,\n      accountId: x.accountId,\n      verificationKeyHash: x.verificationKeyHash,\n      callData: x.callData,\n    });\n  }\n\n  async authorize(\n    authEnv: AccountUpdateAuthorizationEnvironment\n  ): Promise<Authorized<State, Event, Action>> {\n    let proof = null;\n    let signature = null;\n\n    switch (this.proof) {\n      case 'NoProofRequired':\n        if (this.authorizationKind.isProved.toBoolean()) {\n          throw new Error(\n            `account update proof was marked as not required, but authorization kind was ${this.authorizationKind.identifier()}`\n          );\n        } else {\n          break;\n        }\n      case 'ProofPending':\n        if (this.authorizationKind.isProved.toBoolean()) {\n          throw new Error(\n            `account update proof is still pending; a proof must be generated and assigned to an account update before calling authorize`\n          );\n        } else {\n          console.warn(\n            `account update is marked to required a proof, but the authorization kind is ${this.authorizationKind.identifier()} (and the proof is still pending)`\n          );\n          break;\n        }\n      default:\n        if (this.authorizationKind.isProved.toBoolean()) {\n          proof = Pickles.proofToBase64Transaction(this.proof.proof);\n        } else {\n          console.warn(\n            `account update has a proof, but no proof is required by authorization kind ${this.authorizationKind.identifier()}, so it will not be included`\n          );\n        }\n    }\n\n    if (this.authorizationKind.isSigned.toBoolean()) {\n      let txnCommitment;\n      if (this.useFullCommitment.toBoolean()) {\n        if (authEnv.fullTransactionCommitment === undefined) {\n          throw new Error(\n            'unable to authorize account update: useFullCommitment is true, but not full transaction commitment was provided in authorization environment'\n          );\n        }\n        txnCommitment = authEnv.fullTransactionCommitment;\n      } else {\n        txnCommitment = authEnv.accountUpdateForestCommitment;\n      }\n\n      const privateKey = await authEnv.getPrivateKey(this.accountId.publicKey);\n\n      const sig = signFieldElement(txnCommitment, privateKey.toBigInt(), authEnv.networkId);\n      signature = Signature.toBase58(sig);\n    }\n\n    return new Authorized({ proof, signature }, this);\n  }\n\n  static create(x: AccountUpdateDescription<'GenericState', Field[], Field[]>): AccountUpdate {\n    return new AccountUpdate('GenericState', GenericData, GenericData, x);\n  }\n\n  static fromInternalRepr(x: Bindings.Layout.AccountUpdateBody): AccountUpdate {\n    return new AccountUpdate('GenericState', GenericData, GenericData, {\n      accountId: new AccountId(x.publicKey, new TokenId(x.tokenId)),\n      verificationKeyHash: x.authorizationKind.verificationKeyHash,\n      authorizationKind: new AccountUpdateAuthorizationKind(x.authorizationKind),\n      callData: x.callData,\n      balanceChange: Int64.create(x.balanceChange.magnitude, x.balanceChange.sgn),\n      incrementNonce: x.incrementNonce,\n      useFullCommitment: x.useFullCommitment,\n      implicitAccountCreationFee: x.implicitAccountCreationFee,\n      mayUseToken: x.mayUseToken,\n      pushEvents: CommittedList.from(GenericData, EventsHashConfig(GenericData), x.events),\n      pushActions: CommittedList.from(GenericData, ActionsHashConfig(GenericData), x.actions),\n      preconditions: Preconditions.fromInternalRepr(x.preconditions),\n      setState: new GenericStateUpdates(x.update.appState.map(Update.fromOption)),\n      setDelegate: Update.fromOption(x.update.delegate),\n      setVerificationKey: Update.fromOption(x.update.verificationKey),\n      setPermissions: Update.fromOption(\n        Option.map(x.update.permissions, Permissions.fromInternalRepr)\n      ),\n      setZkappUri: Update.fromOption(Option.map(x.update.zkappUri, (uri) => new ZkappUri(uri))),\n      setTokenSymbol: Update.fromOption(\n        Option.map(x.update.tokenSymbol, (symbol) => new TokenSymbol(symbol))\n      ),\n      setTiming: Update.fromOption(\n        Option.map(x.update.timing, (timing) => new AccountTiming(timing))\n      ),\n      setVotingFor: Update.fromOption(x.update.votingFor),\n    });\n  }\n\n  static sizeInFields(): number {\n    return Bindings.Layout.AccountUpdateBody.sizeInFields();\n  }\n\n  static toFields(x: AccountUpdate): Field[] {\n    return Bindings.Layout.AccountUpdateBody.toFields(x.toInternalRepr(0));\n  }\n\n  static toAuxiliary(x?: AccountUpdate, callDepth?: number): any[] {\n    return Bindings.Layout.AccountUpdateBody.toAuxiliary(x?.toInternalRepr(callDepth ?? 0));\n  }\n\n  static fromFields(fields: Field[], aux: any[]): AccountUpdate {\n    return AccountUpdate.fromInternalRepr(\n      Bindings.Layout.AccountUpdateBody.fromFields(fields, aux)\n    );\n  }\n\n  static toValue(x: AccountUpdate): AccountUpdate {\n    return x;\n  }\n\n  static fromValue(x: AccountUpdate): AccountUpdate {\n    return x;\n  }\n\n  static check(_x: AccountUpdate): void {\n    // TODO\n  }\n\n  static empty(): AccountUpdate {\n    return new AccountUpdate('GenericState', GenericData, GenericData, {\n      accountId: AccountId.empty(),\n      callData: Field.empty(),\n      update: ContextFreeAccountUpdate.empty(),\n    });\n  }\n}\n\n// TODO NOW: un-namespace this\n\n/*\ntype ContextFreeDescription<\n  State extends StateLayout = 'GenericState',\n  Event = Field[],\n  Action = Field[]\n> = ContextFreeAccountUpdateDescription<State, Event, Action>;\ntype ContextFree<\n  State extends StateLayout = 'GenericState',\n  Event = Field[],\n  Action = Field[]\n> = ContextFreeAccountUpdate<State, Event, Action>;\nconst ContextFree = ContextFreeAccountUpdate;\n*/\n// TODO: can we enforce that Authorized account updates are immutable?\nclass Authorized<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]> {\n  authorization: AccountUpdateAuthorization;\n  private update: AccountUpdate<State, Event, Action>;\n\n  constructor(\n    authorization: AccountUpdateAuthorization,\n    update: AccountUpdate<State, Event, Action>\n  ) {\n    this.authorization = authorization;\n    this.update = update;\n  }\n\n  toAccountUpdate(): AccountUpdate<State, Event, Action> {\n    return this.update;\n  }\n\n  get State(): StateDefinition<State> {\n    return this.update.State;\n  }\n  get authorizationKind(): AccountUpdateAuthorizationKind {\n    return this.update.authorizationKind;\n  }\n  get accountId(): AccountId {\n    return this.update.accountId;\n  }\n  get verificationKeyHash(): Field {\n    return this.update.verificationKeyHash;\n  }\n  get callData(): Field {\n    return this.update.callData;\n  }\n  get preconditions(): Preconditions<State> {\n    return this.update.preconditions;\n  }\n  get balanceChange(): Int64 {\n    return this.update.balanceChange;\n  }\n  get incrementNonce(): Bool {\n    return this.update.incrementNonce;\n  }\n  get useFullCommitment(): Bool {\n    return this.update.useFullCommitment;\n  }\n  get implicitAccountCreationFee(): Bool {\n    return this.update.implicitAccountCreationFee;\n  }\n  get mayUseToken(): MayUseToken {\n    return this.update.mayUseToken;\n  }\n  get pushEvents(): CommittedList<Event> {\n    return this.update.pushEvents;\n  }\n  get pushActions(): CommittedList<Action> {\n    return this.update.pushActions;\n  }\n  get stateUpdates(): StateUpdates<State> {\n    return this.update.stateUpdates;\n  }\n  get permissionsUpdate(): Update<Permissions> {\n    return this.update.permissionsUpdate;\n  }\n  get delegateUpdate(): Update<PublicKey> {\n    return this.update.delegateUpdate;\n  }\n  get verificationKeyUpdate(): Update<VerificationKey> {\n    return this.update.verificationKeyUpdate;\n  }\n  get zkappUriUpdate(): Update<ZkappUri> {\n    return this.update.zkappUriUpdate;\n  }\n  get tokenSymbolUpdate(): Update<TokenSymbol> {\n    return this.update.tokenSymbolUpdate;\n  }\n  get timingUpdate(): Update<AccountTiming> {\n    return this.update.timingUpdate;\n  }\n  get votingForUpdate(): Update<Field> {\n    return this.update.votingForUpdate;\n  }\n  get authorizationKindWithZkappContext(): AccountUpdateAuthorizationKindWithZkappContext {\n    return this.update.authorizationKindWithZkappContext;\n  }\n\n  hash(netId: NetworkId): Field {\n    let input = Bindings.Layout.ZkappAccountUpdate.toInput(this.toInternalRepr(0));\n    return hashWithPrefix(zkAppBodyPrefix(netId), packToFields(input));\n  }\n\n  toInternalRepr(callDepth: number): Bindings.Layout.ZkappAccountUpdate {\n    return {\n      authorization: {\n        proof: this.authorization.proof === null ? undefined : this.authorization.proof,\n        signature: this.authorization.signature === null ? undefined : this.authorization.signature,\n      },\n      body: this.update.toInternalRepr(callDepth),\n    };\n  }\n\n  static fromInternalRepr(x: Bindings.Layout.ZkappAccountUpdate): Authorized {\n    return new Authorized(\n      {\n        // when the internal representation is returned from the previous version when casting from fields,\n        // (if there is no proof or authorization, values are set to false rather than to undefined)\n        proof: (x.authorization.proof as any) !== false ? (x.authorization.proof ?? null) : null,\n        signature:\n          (x.authorization.proof as any) !== false ? (x.authorization.signature ?? null) : null,\n      },\n      AccountUpdate.fromInternalRepr(x.body)\n    );\n  }\n\n  toJSON(callDepth: number): any {\n    return Authorized.toJSON(this, callDepth);\n  }\n\n  toInput(): HashInput {\n    return Authorized.toInput(this);\n  }\n\n  toFields(): Field[] {\n    return Authorized.toFields(this);\n  }\n\n  static empty(): Authorized {\n    return new Authorized({ proof: null, signature: null }, AccountUpdate.empty());\n  }\n\n  static sizeInFields(): number {\n    return Bindings.Layout.ZkappAccountUpdate.sizeInFields();\n  }\n\n  static toJSON<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    x: Authorized<State, Event, Action>,\n    callDepth: number\n  ): any {\n    return Bindings.Layout.ZkappAccountUpdate.toJSON(x.toInternalRepr(callDepth));\n  }\n\n  static toInput<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    x: Authorized<State, Event, Action>\n  ): HashInput {\n    return Bindings.Layout.ZkappAccountUpdate.toInput(x.toInternalRepr(0));\n  }\n\n  static toFields<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    x: Authorized<State, Event, Action>\n  ): Field[] {\n    return Bindings.Layout.ZkappAccountUpdate.toFields(x.toInternalRepr(0));\n  }\n\n  static toAuxiliary<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    x?: Authorized<State, Event, Action>,\n    callDepth?: number\n  ): any[] {\n    return Bindings.Layout.ZkappAccountUpdate.toAuxiliary(x?.toInternalRepr(callDepth ?? 0));\n  }\n\n  static fromFields(fields: Field[], aux: any[]): Authorized {\n    return Authorized.fromInternalRepr(Bindings.Layout.ZkappAccountUpdate.fromFields(fields, aux));\n  }\n\n  static toValue<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    x: Authorized<State, Event, Action>\n  ): Authorized<State, Event, Action> {\n    return x;\n  }\n\n  static fromValue<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    x: Authorized<State, Event, Action>\n  ): Authorized<State, Event, Action> {\n    return x;\n  }\n\n  static check<State extends StateLayout = 'GenericState', Event = Field[], Action = Field[]>(\n    _x: Authorized<State, Event, Action>\n  ) {\n    throw new Error('TODO');\n  }\n}\n", "import { AccountId } from './account.js';\nimport { TokenId } from './core.js';\nimport StackTrace from 'stacktrace-js';\n\n// TODO: We currently accumulate full errors with stack traces pointing to the internal code that\n//       performs the checks. This is nice for debugging, but undesirable for performance reasons,\n//       and we won't want to show this information to developers using the API, only to ones\n//       working on it. We should improve this in the future.\n\nimport StackFrame = StackTrace.StackFrame;\n\nexport function getCallerFrame(): StackFrame {\n  const frames = StackTrace.getSync();\n  if (frames.length < 3)\n    throw new Error('cannot call getCallerFrame when the stack has less than 2 frames');\n  return frames[2];\n}\n\nexport class ZkappCommandErrorTrace {\n  constructor(\n    public generalErrors: Error[],\n    public feePaymentErrors: Error[],\n    public accountUpdateForestTrace: AccountUpdateErrorTrace[]\n  ) {}\n\n  hasErrors(): boolean {\n    function accountUpdateForestHasErrors(forestTrace: AccountUpdateErrorTrace[]): boolean {\n      for (const trace of forestTrace)\n        if (trace.errors.length > 0 || accountUpdateForestHasErrors(trace.childTraces)) return true;\n      return false;\n    }\n\n    return (\n      this.feePaymentErrors.length > 0 ||\n      accountUpdateForestHasErrors(this.accountUpdateForestTrace)\n    );\n  }\n\n  generateReport(): string {\n    const makeIndent = (depth: number) => ' '.repeat(2 * depth);\n    const renderAccountId = (accountId: AccountId) => {\n      const isMinaAccount = accountId.tokenId.equals(TokenId.MINA).toBoolean();\n      const pubkeyString = accountId.publicKey.toBase58();\n      return isMinaAccount ? pubkeyString : `${pubkeyString}[token ${accountId.tokenId}]`;\n    };\n    const renderCallSite = (callSite: StackFrame) =>\n      `${callSite.getFileName()}:${callSite.getLineNumber()}`;\n\n    let out = '';\n\n    function writeErrors(depth: number, errors: Error[]): void {\n      if (errors.length === 0) {\n        out += 'ok\\n';\n      } else {\n        const indent = makeIndent(depth + 1);\n\n        // out += 'error';\n        // if(callSite !== null) out += ` (${callSite})`;\n        // out += '\\n';\n        out += 'error\\n';\n\n        errors.forEach((error) => {\n          out += `${indent}* ${error.message}\\n`;\n        });\n      }\n    }\n\n    function writeAccountUpdateTrace(depth: number, trace: AccountUpdateErrorTrace): void {\n      const indent = makeIndent(depth);\n      out += `${indent}${renderAccountId(trace.accountId)} (${renderCallSite(trace.callSite)}): `;\n      writeErrors(depth, trace.errors);\n      trace.childTraces.forEach((accountUpdateTrace) =>\n        writeAccountUpdateTrace(depth + 1, accountUpdateTrace)\n      );\n    }\n\n    out += 'ZKAPP COMMAND ERROR TRACE\\n';\n    out += '=========================\\n';\n    writeErrors(0, this.generalErrors);\n    out += '  feePayment: ';\n    writeErrors(1, this.feePaymentErrors);\n    out += '  accountUpdates:\\n';\n    this.accountUpdateForestTrace.forEach((accountUpdateTrace) =>\n      writeAccountUpdateTrace(2, accountUpdateTrace)\n    );\n    out += '=========================\\n';\n\n    return out;\n  }\n}\n\nexport interface AccountUpdateErrorTrace {\n  accountId: AccountId;\n  callSite: StackFrame;\n  // TODO: methodSite: StackFrame | null;\n  errors: Error[];\n  childTraces: AccountUpdateErrorTrace[];\n}\n\n//  interface TransactionErrors {\n//   warnings: Error[];\n//   errors: Error[];\n// }\n", "import { AccountUpdate } from './account-update.js';\nimport { Account } from './account.js';\nimport { AuthorizationLevel } from './authorization.js';\nimport { Update } from './core.js';\nimport { Permissions } from './permissions.js';\nimport {\n  Preconditions,\n  EpochDataPreconditions,\n  EpochLedgerPreconditions,\n} from './preconditions.js';\nimport { StateLayout, StateUpdates, StateValues } from './state.js';\nimport { ZkappFeePayment } from './transaction.js';\nimport { ChainView, EpochData, EpochLedgerData } from './views.js';\nimport { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { Int64, Sign, UInt64, UInt32 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { ZkappConstants } from '../v1/constants.js';\n\nexport { checkAndApplyAccountUpdate, checkAndApplyFeePayment, ApplyState };\n\ntype ApplyResult<T> = ({ status: 'Applied' } & T) | { status: 'Failed'; errors: Error[] };\n\ntype ApplyState<T> = { status: 'Alive'; value: T } | { status: 'Dead' };\n\nfunction updateApplyState<T>(\n  applyState: ApplyState<T>,\n  errors: Error[],\n  f: (x: T) => T | Error\n): ApplyState<T> {\n  switch (applyState.status) {\n    case 'Alive':\n      const result = f(applyState.value);\n      if (result instanceof Error) {\n        errors.push(result);\n        return { status: 'Dead' };\n      } else {\n        return { status: 'Alive', value: result };\n      }\n    case 'Dead':\n      return applyState;\n  }\n}\n\n// TODO: make this function checked-friendly, and move this function into the Int64 type directly\nfunction tryAddInt64(a: Int64, b: Int64): Int64 | null {\n  if (a.sgn.equals(b.sgn).toBoolean() && a.magnitude.lessThan(b.magnitude).toBoolean()) return null;\n\n  return a.add(b);\n}\n\nfunction checkPreconditions<State extends StateLayout>(\n  chain: ChainView,\n  account: Account<State>,\n  preconditions: Preconditions<State>,\n  errors: Error[]\n): void {\n  function preconditionError(\n    preconditionName: string,\n    constraint: { toStringHuman(): string },\n    value: unknown\n  ): Error {\n    return new Error(\n      `${preconditionName} precondition failed: ${value} does not satisfy \"${constraint.toStringHuman()}\"`\n    );\n  }\n\n  // WARNING: failing to specify the type parameter on this function exhibits unsound behavior\n  //          (thanks typescript)\n  // I think you can do something to fix this with NoInfer, but a first attempt at that seemed\n  // to break it even more.\n  function checkPrecondition<T>(\n    preconditionName: string,\n    constraint: { isSatisfied(x: T): Bool; toStringHuman(): string },\n    value: T\n  ): void {\n    if (constraint.isSatisfied(value).not().toBoolean())\n      errors.push(preconditionError(preconditionName, constraint, value));\n  }\n\n  // ACCOUNT PRECONDITIONS\n\n  checkPrecondition<UInt64>('balance', preconditions.account.balance, account.balance);\n  checkPrecondition<UInt32>('nonce', preconditions.account.nonce, account.nonce);\n  checkPrecondition<Field>(\n    'receiptChainHash',\n    preconditions.account.receiptChainHash,\n    account.receiptChainHash\n  );\n  if (account.delegate !== null)\n    checkPrecondition<PublicKey>('delegate', preconditions.account.delegate, account.delegate);\n  checkPrecondition<Bool>('isProven', preconditions.account.isProven, account.zkapp.isProven);\n  checkPrecondition<Bool>('isNew', preconditions.account.isNew, new Bool(account.isNew.get()));\n\n  StateValues.checkPreconditions(account.State, account.zkapp.state, preconditions.account.state);\n\n  const actionState = account.zkapp?.actionState ?? [];\n  const actionStateSatisfied = Bool.anyTrue(\n    actionState.map((s) => preconditions.account.actionState.isSatisfied(s))\n  );\n  if (actionStateSatisfied.not().toBoolean())\n    errors.push(preconditionError('actionState', preconditions.account.actionState, actionState));\n\n  // NETWORK PRECONDITIONS\n\n  checkPrecondition('validWhile', preconditions.validWhile, chain.globalSlotSinceGenesis);\n  checkPrecondition(\n    'snarkedLedgerHash',\n    preconditions.network.snarkedLedgerHash,\n    chain.snarkedLedgerHash\n  );\n  checkPrecondition(\n    'blockchainLength',\n    preconditions.network.blockchainLength,\n    chain.blockchainLength\n  );\n  checkPrecondition(\n    'minWindowDensity',\n    preconditions.network.minWindowDensity,\n    chain.minWindowDensity\n  );\n  checkPrecondition('totalCurrency', preconditions.network.totalCurrency, chain.totalCurrency);\n  checkPrecondition(\n    'globalSlotSinceGenesis',\n    preconditions.network.globalSlotSinceGenesis,\n    chain.globalSlotSinceGenesis\n  );\n\n  function checkEpochLedgerPreconditions(\n    name: string,\n    epochLedgerPreconditions: EpochLedgerPreconditions,\n    epochLedgerData: EpochLedgerData\n  ) {\n    checkPrecondition(`${name}.hash`, epochLedgerPreconditions.hash, epochLedgerData.hash);\n    checkPrecondition(\n      `${name}.totalCurrency`,\n      epochLedgerPreconditions.totalCurrency,\n      epochLedgerData.totalCurrency\n    );\n  }\n\n  function checkEpochDataPreconditions(\n    name: string,\n    epochDataPreconditions: EpochDataPreconditions,\n    epochData: EpochData\n  ): void {\n    checkPrecondition(`${name}.seed`, epochDataPreconditions.seed, epochData.seed);\n    checkPrecondition(\n      `${name}.startCheckpoint`,\n      epochDataPreconditions.startCheckpoint,\n      epochData.startCheckpoint\n    );\n    checkPrecondition(\n      `${name}.lockCheckpoint`,\n      epochDataPreconditions.lockCheckpoint,\n      epochData.lockCheckpoint\n    );\n    checkPrecondition(\n      `${name}.epochLength`,\n      epochDataPreconditions.epochLength,\n      epochData.epochLength\n    );\n\n    checkEpochLedgerPreconditions(\n      `${name}.ledger`,\n      epochDataPreconditions.ledger,\n      epochData.ledger\n    );\n  }\n\n  checkEpochDataPreconditions(\n    'stakingEpochData',\n    preconditions.network.stakingEpochData,\n    chain.stakingEpochData\n  );\n  checkEpochDataPreconditions(\n    'nextEpochData',\n    preconditions.network.nextEpochData,\n    chain.nextEpochData\n  );\n}\n\nfunction checkPermissions<State extends StateLayout, Event, Action>(\n  permissions: Permissions,\n  update: AccountUpdate<State, Event, Action>,\n  errors: Error[]\n): void {\n  function checkPermission(\n    permissionName: string,\n    requiredAuthLevel: AuthorizationLevel,\n    actionIsPerformed: boolean\n  ): void {\n    if (actionIsPerformed && !requiredAuthLevel.isSatisfied(update.authorizationKind))\n      errors.push(\n        new Error(\n          `${permissionName} permission was violated: account update has authorization kind ${update.authorizationKind.identifier()}, but required auth level is ${requiredAuthLevel.identifier()}`\n        )\n      );\n  }\n\n  checkPermission('access', permissions.access, true);\n  checkPermission('send', permissions.send, update.balanceChange.isNegative().toBoolean());\n  checkPermission('receive', permissions.receive, update.balanceChange.isPositive().toBoolean());\n  checkPermission('incrementNonce', permissions.incrementNonce, update.incrementNonce.toBoolean());\n  checkPermission('setDelegate', permissions.setDelegate, update.delegateUpdate.set.toBoolean());\n  checkPermission(\n    'setPermissions',\n    permissions.setPermissions,\n    update.permissionsUpdate.set.toBoolean()\n  );\n  checkPermission(\n    'setVerificationKey',\n    permissions.setVerificationKey.auth,\n    update.verificationKeyUpdate.set.toBoolean()\n  );\n  checkPermission('setZkappUri', permissions.setZkappUri, update.zkappUriUpdate.set.toBoolean());\n  checkPermission(\n    'setTokenSymbol',\n    permissions.setTokenSymbol,\n    update.tokenSymbolUpdate.set.toBoolean()\n  );\n  checkPermission('setVotingFor', permissions.setVotingFor, update.votingForUpdate.set.toBoolean());\n  checkPermission('setTiming', permissions.setTiming, update.timingUpdate.set.toBoolean());\n  checkPermission(\n    'editActionState',\n    permissions.editActionState,\n    update.pushActions.data.length > 0\n  );\n  checkPermission(\n    'editState',\n    permissions.editState,\n    StateUpdates.anyValuesAreSet(update.stateUpdates).toBoolean()\n  );\n}\n\nfunction applyUpdates<State extends StateLayout, Event, Action>(\n  account: Account<State>,\n  update: AccountUpdate<State, Event, Action>,\n  feeExcessState: ApplyState<Int64>,\n  errors: Error[]\n): {\n  updatedFeeExcessState: ApplyState<Int64>;\n  updatedAccount: Account<State>;\n} {\n  function applyUpdate<T>(update: Update<T>, value: T): T {\n    return update.set.toBoolean() ? update.value : value;\n  }\n\n  let actualBalanceChange: Int64 = update.balanceChange;\n\n  if (account.isNew.get()) {\n    const accountCreationFee = Int64.create(\n      UInt64.from(ZkappConstants.ACCOUNT_CREATION_FEE),\n      Sign.minusOne\n    );\n\n    feeExcessState = updateApplyState(\n      feeExcessState,\n      errors,\n      (feeExcess) =>\n        tryAddInt64(feeExcess, accountCreationFee) ??\n        new Error('fee excess underflowed due when subtracting the account creation fee')\n    );\n\n    if (update.implicitAccountCreationFee.toBoolean()) {\n      const balanceChangeWithoutCreationFee = tryAddInt64(actualBalanceChange, accountCreationFee);\n      if (balanceChangeWithoutCreationFee === null) {\n        errors.push(\n          new Error('balance change underflowed when subtracting the account creation fee')\n        );\n      } else {\n        actualBalanceChange = balanceChangeWithoutCreationFee;\n      }\n    }\n  }\n\n  const balanceSigned = Int64.create(account.balance, Sign.one);\n  const updatedBalanceSigned = tryAddInt64(balanceSigned, actualBalanceChange);\n\n  let updatedBalance = account.balance;\n  if (updatedBalanceSigned === null) {\n    errors.push(\n      new Error('account balance overflowed or underflowed when applying balance change')\n    );\n  } else if (updatedBalanceSigned.isNegative().toBoolean()) {\n    errors.push(new Error('account balance was negative after applying balance change'));\n  } else {\n    updatedBalance = updatedBalanceSigned.magnitude;\n  }\n\n  const allStateUpdated = Bool.allTrue(\n    StateUpdates.toFieldUpdates(account.State, update.stateUpdates).map((update) => update.set)\n  );\n\n  const updatedAccount = new Account(account.State, false, {\n    ...account,\n    balance: updatedBalance,\n    tokenSymbol: applyUpdate(update.tokenSymbolUpdate, account.tokenSymbol),\n    nonce: update.incrementNonce.toBoolean() ? account.nonce.add(UInt32.one) : account.nonce,\n    delegate: applyUpdate(update.delegateUpdate, account.delegate),\n    votingFor: applyUpdate(update.votingForUpdate, account.votingFor),\n    timing: applyUpdate(update.timingUpdate, account.timing),\n    permissions: applyUpdate(update.permissionsUpdate, account.permissions),\n    zkapp: {\n      state: StateValues.applyUpdates(account.State, account.zkapp.state, update.stateUpdates),\n      verificationKey: applyUpdate(update.verificationKeyUpdate, account.zkapp.verificationKey),\n      actionState: /* TODO */ [\n        new Field(0),\n        new Field(0),\n        new Field(0),\n        new Field(0),\n        new Field(0),\n      ],\n      isProven: account.zkapp.isProven.or(allStateUpdated),\n      zkappUri: applyUpdate(update.zkappUriUpdate, account.zkapp.zkappUri),\n    },\n  });\n\n  return { updatedFeeExcessState: feeExcessState, updatedAccount };\n}\n\nfunction checkAccountTiming<State extends StateLayout>(\n  account: Account<State>,\n  globalSlot: UInt32,\n  errors: Error[]\n): void {\n  const minimumBalance = account.timing.minimumBalanceAtSlot(globalSlot);\n  if (!account.balance.greaterThanOrEqual(minimumBalance).toBoolean())\n    errors.push(new Error('account has an insufficient minimum balance after applying update'));\n}\n\n// TODO: It's a good idea to have a check somewhere which asserts an account is valid before trying\n//       applying account updates (eg: the account balance already meets the minimum requirement of\n//       the account timing). This will help prevent other mistakes that occur before applying an\n//       account update.\nfunction checkAndApplyAccountUpdate<State extends StateLayout, Event, Action>(\n  chain: ChainView,\n  account: Account<State>,\n  update: AccountUpdate<State, Event, Action>,\n  feeExcessState: ApplyState<Int64>\n): ApplyResult<{\n  updatedFeeExcessState: ApplyState<Int64>;\n  updatedAccount: Account<State>;\n}> {\n  const errors: Error[] = [];\n\n  if (!account.accountId.equals(update.accountId).toBoolean())\n    errors.push(new Error('account id in account update does not match actual account id'));\n\n  if (!account.zkapp.verificationKey.hash.equals(update.verificationKeyHash).toBoolean())\n    errors.push(\n      new Error(\n        `account verification key does not match account update's verification key (account has ${account.zkapp.verificationKey.hash}, account update referenced ${update.verificationKeyHash})`\n      )\n    );\n\n  // TODO: check mayUseToken (somewhere, maybe not here)\n\n  checkPreconditions(chain, account, update.preconditions, errors);\n  checkPermissions(account.permissions, update, errors);\n  const { updatedFeeExcessState, updatedAccount } = applyUpdates(\n    account,\n    update,\n    feeExcessState,\n    errors\n  );\n  checkAccountTiming(updatedAccount, chain.globalSlotSinceGenesis, errors);\n\n  if (errors.length === 0) {\n    return { status: 'Applied', updatedFeeExcessState, updatedAccount };\n  } else {\n    return { status: 'Failed', errors };\n  }\n}\n\nfunction checkAndApplyFeePayment(\n  chain: ChainView,\n  account: Account,\n  feePayment: ZkappFeePayment\n): ApplyResult<{ updatedAccount: Account }> {\n  const result = checkAndApplyAccountUpdate(chain, account, feePayment.toAccountUpdate(), {\n    status: 'Alive',\n    value: Int64.zero,\n  });\n\n  if (result.status === 'Applied') {\n    return { status: 'Applied', updatedAccount: result.updatedAccount };\n  } else {\n    return result;\n  }\n}\n", "import {\n  AccountUpdateAuthorizationKind,\n  ZkappCommandAuthorizationEnvironment,\n  ZkappFeePaymentAuthorizationEnvironment,\n} from './authorization.js';\nimport { AccountUpdate, AccountUpdateTree, Authorized, GenericData } from './account-update.js';\nimport { Account, AccountId, AccountIdSet } from './account.js';\nimport { TokenId } from './core.js';\nimport { AccountUpdateErrorTrace, getCallerFrame, ZkappCommandErrorTrace } from './errors.js';\nimport { Precondition } from './preconditions.js';\nimport { StateLayout } from './state.js';\nimport { ChainView, LedgerView } from './views.js';\nimport { ApplyState, checkAndApplyAccountUpdate, checkAndApplyFeePayment } from './zkapp-logic.js';\nimport { Bool } from '../../provable/bool.js';\nimport { Field } from '../../provable/field.js';\nimport { Int64, Sign, UInt32, UInt64 } from '../../provable/int.js';\nimport { PublicKey } from '../../provable/crypto/signature.js';\nimport { mocks } from '../../../bindings/crypto/constants.js';\nimport * as BindingsLayout from '../../../bindings/mina-transaction/gen/v2/js-layout.js';\nimport { Memo } from '../../../mina-signer/src/memo.js';\nimport { hashWithPrefix, prefixes } from '../../../mina-signer/src/poseidon-bigint.js';\nimport { Signature, signFieldElement } from '../../../mina-signer/src/signature.js';\nimport { NetworkId } from '../../../mina-signer/src/types.js';\n\nexport {\n  ZkappCommand,\n  ZkappFeePayment,\n  ZkappCommandContext,\n  AuthorizedZkappCommand,\n  createZkappCommand,\n};\n\ninterface ZkappFeePaymentDescription {\n  publicKey: PublicKey;\n  fee: UInt64; // TODO: abstract currency representation\n  validUntil?: UInt32; // TODO: abstract slot representation\n  nonce: UInt32;\n}\n\nclass ZkappFeePayment {\n  readonly __type: 'ZkappCommand' = 'ZkappCommand' as const;\n\n  publicKey: PublicKey;\n  fee: UInt64;\n  validUntil: UInt32 | undefined;\n  nonce: UInt32;\n\n  constructor(descr: ZkappFeePaymentDescription) {\n    this.publicKey = descr.publicKey;\n    this.fee = descr.fee;\n    this.validUntil = descr.validUntil;\n    this.nonce = descr.nonce;\n  }\n\n  authorize({\n    networkId,\n    privateKey,\n    fullTransactionCommitment,\n  }: ZkappFeePaymentAuthorizationEnvironment): AuthorizedZkappFeePayment {\n    let signature = signFieldElement(fullTransactionCommitment, privateKey.toBigInt(), networkId);\n    return new AuthorizedZkappFeePayment(this, Signature.toBase58(signature));\n  }\n\n  toAccountUpdate(): AccountUpdate {\n    return new AccountUpdate('GenericState', GenericData, GenericData, {\n      authorizationKind: AccountUpdateAuthorizationKind.Signature(),\n      verificationKeyHash: new Field(mocks.dummyVerificationKeyHash),\n      callData: new Field(0),\n      accountId: new AccountId(this.publicKey, TokenId.MINA),\n      balanceChange: Int64.create(this.fee, Sign.minusOne),\n      incrementNonce: new Bool(true),\n      useFullCommitment: new Bool(true),\n      implicitAccountCreationFee: new Bool(true),\n      preconditions: {\n        account: {\n          nonce: this.nonce,\n        },\n        network: {\n          globalSlotSinceGenesis: Precondition.InRange.betweenInclusive(\n            UInt32.zero,\n            this.validUntil ?? UInt32.MAXINT()\n          ),\n        },\n      },\n    });\n  }\n\n  toDummyAuthorizedAccountUpdate(): Authorized {\n    return new Authorized({ signature: '', proof: null }, this.toAccountUpdate());\n  }\n\n  toInternalRepr(): BindingsLayout.FeePayerBody {\n    return {\n      publicKey: this.publicKey,\n      fee: this.fee,\n      validUntil: this.validUntil,\n      nonce: this.nonce,\n    };\n  }\n\n  toJSON(): any {\n    return ZkappFeePayment.toJSON(this);\n  }\n\n  static toJSON(x: ZkappFeePayment): any {\n    return BindingsLayout.FeePayerBody.toJSON(x.toInternalRepr());\n  }\n}\n\nclass AuthorizedZkappFeePayment {\n  constructor(\n    public readonly body: ZkappFeePayment,\n    public readonly signature: string\n  ) {}\n\n  toInternalRepr(): BindingsLayout.ZkappFeePayer {\n    return {\n      body: this.body.toInternalRepr(),\n      authorization: this.signature,\n    };\n  }\n}\n\ninterface ZkappCommandDescription {\n  feePayment: ZkappFeePayment;\n  // TODO: merge AccountUpdateTree and AccountUpdate\n  accountUpdates: (AccountUpdate | AccountUpdateTree<AccountUpdate>)[];\n  memo?: string;\n}\n\nclass ZkappCommand {\n  // TODO: put this on everything (in this case, we really need it to disambiguate the Description format)\n  readonly __type: 'ZkappCommand' = 'ZkappCommand' as const;\n\n  feePayment: ZkappFeePayment;\n  accountUpdateForest: AccountUpdateTree<AccountUpdate>[];\n  memo: string;\n\n  constructor(descr: ZkappCommandDescription) {\n    this.feePayment = descr.feePayment;\n    this.accountUpdateForest = descr.accountUpdates.map((update) =>\n      update instanceof AccountUpdateTree ? update : new AccountUpdateTree(update, [])\n    );\n    // TODO: we probably want an explicit memo type instead to help enforce these rules early and not surprise the user when their memo changes slightly later\n    this.memo = Memo.fromString(descr.memo ?? '');\n  }\n\n  commitments(networkId: NetworkId): {\n    accountUpdateForestCommitment: bigint;\n    fullTransactionCommitment: bigint;\n  } {\n    const feePayerCommitment = this.feePayment.toDummyAuthorizedAccountUpdate().hash(networkId);\n    const accountUpdateForestCommitment = AccountUpdateTree.hashForest(\n      networkId,\n      this.accountUpdateForest\n    );\n    const memoCommitment = Memo.hash(this.memo);\n    const fullTransactionCommitment = hashWithPrefix(prefixes.accountUpdateCons, [\n      memoCommitment,\n      feePayerCommitment.toBigInt(),\n      accountUpdateForestCommitment,\n    ]);\n    return { accountUpdateForestCommitment, fullTransactionCommitment };\n  }\n\n  async authorize(authEnv: ZkappCommandAuthorizationEnvironment): Promise<AuthorizedZkappCommand> {\n    const feePayerPrivateKey = await authEnv.getPrivateKey(this.feePayment.publicKey);\n\n    const commitments = this.commitments(authEnv.networkId);\n\n    const authorizedFeePayment = this.feePayment.authorize({\n      networkId: authEnv.networkId,\n      privateKey: feePayerPrivateKey,\n      fullTransactionCommitment: commitments.fullTransactionCommitment,\n    });\n\n    const accountUpdateAuthEnv = {\n      ...authEnv,\n      ...commitments,\n    };\n    const authorizedAccountUpdateForest = await AccountUpdateTree.mapForest(\n      this.accountUpdateForest,\n      (accountUpdate) => accountUpdate.authorize(accountUpdateAuthEnv)\n    );\n\n    return new AuthorizedZkappCommand({\n      feePayment: authorizedFeePayment,\n      accountUpdateForest: authorizedAccountUpdateForest,\n      memo: this.memo,\n    });\n  }\n}\n\nclass AuthorizedZkappCommand {\n  readonly __type: 'AuthorizedZkappCommand' = 'AuthorizedZkappCommand' as const;\n\n  readonly feePayment: AuthorizedZkappFeePayment;\n  readonly accountUpdateForest: AccountUpdateTree<Authorized>[];\n  readonly memo: string;\n\n  constructor({\n    feePayment,\n    accountUpdateForest,\n    memo,\n  }: {\n    feePayment: AuthorizedZkappFeePayment;\n    accountUpdateForest: AccountUpdateTree<Authorized>[];\n    memo: string;\n  }) {\n    this.feePayment = feePayment;\n    this.accountUpdateForest = accountUpdateForest;\n    // TODO: here we have to assume the Memo is already encoded correctly, but what we really want is a Memo type...\n    this.memo = memo;\n  }\n\n  toInternalRepr(): BindingsLayout.ZkappCommand {\n    return {\n      feePayer: this.feePayment.toInternalRepr(),\n      accountUpdates: AccountUpdateTree.unrollForest(this.accountUpdateForest, (update, depth) =>\n        update.toInternalRepr(depth)\n      ),\n      memo: Memo.toBase58(this.memo),\n    };\n  }\n\n  toJSON(): any {\n    return AuthorizedZkappCommand.toJSON(this);\n  }\n\n  static toJSON(x: AuthorizedZkappCommand): any {\n    return BindingsLayout.ZkappCommand.toJSON(x.toInternalRepr());\n  }\n}\n\n// NB: this is really more of an environment than a context, but this naming convention helps to\n//     disambiguate the transaction environment from the mina program environment\n\nclass ZkappCommandContext {\n  ledger: LedgerView;\n  chain: ChainView;\n  failedAccounts: AccountIdSet;\n  globalSlot: UInt32;\n  feeExcessState: ApplyState<Int64>;\n  private accountUpdateForest: AccountUpdateTree<AccountUpdate>[];\n  private accountUpdateForestTrace: AccountUpdateErrorTrace[];\n\n  constructor(\n    ledger: LedgerView,\n    chain: ChainView,\n    failedAccounts: AccountIdSet,\n    globalSlot: UInt32\n  ) {\n    this.ledger = ledger;\n    this.chain = chain;\n\n    this.failedAccounts = failedAccounts;\n    this.globalSlot = globalSlot;\n    this.feeExcessState = { status: 'Alive', value: Int64.zero };\n    this.accountUpdateForest = [];\n    this.accountUpdateForestTrace = [];\n  }\n\n  add<State extends StateLayout>(\n    x:\n      | AccountUpdate<State, any, any>\n      | AccountUpdateTree<AccountUpdate<State, any, any>, AccountUpdate>\n  ) {\n    const callSite = getCallerFrame();\n\n    const accountUpdateTree = x instanceof AccountUpdateTree ? x : new AccountUpdateTree(x, []);\n    const genericAccountUpdateTree = AccountUpdateTree.mapRoot(accountUpdateTree, (accountUpdate) =>\n      accountUpdate.toGeneric()\n    );\n\n    const trace = AccountUpdateTree.reduce(\n      genericAccountUpdateTree,\n      (\n        accountUpdate: AccountUpdate,\n        childTraces: AccountUpdateErrorTrace[]\n      ): AccountUpdateErrorTrace => {\n        let errors: Error[];\n        if (!this.failedAccounts.has(accountUpdate.accountId)) {\n          const account =\n            this.ledger.getAccount(accountUpdate.accountId) ??\n            Account.empty(accountUpdate.accountId);\n          const applied = checkAndApplyAccountUpdate(\n            this.chain,\n            account,\n            accountUpdate,\n            this.feeExcessState\n          );\n\n          switch (applied.status) {\n            case 'Applied':\n              errors = [];\n              this.ledger.setAccount(applied.updatedAccount);\n              this.feeExcessState = applied.updatedFeeExcessState;\n              break;\n            case 'Failed':\n              errors = applied.errors;\n              break;\n          }\n        } else {\n          errors = [\n            // TODO: this should be a warning\n            new Error(\n              'skipping account update because a previous account update failed when accessing the same account'\n            ),\n          ];\n        }\n\n        return {\n          accountId: accountUpdate.accountId,\n          callSite,\n          errors,\n          childTraces,\n        };\n      }\n    );\n\n    this.accountUpdateForest.push(genericAccountUpdateTree);\n    this.accountUpdateForestTrace.push(trace);\n  }\n\n  // only to be used when an account update tree has already been applied to the ledger view\n  unsafeAddWithoutApplying<State extends StateLayout>(\n    x:\n      | AccountUpdate<State, any, any>\n      | AccountUpdateTree<AccountUpdate<State, any, any>, AccountUpdate>,\n    trace: AccountUpdateErrorTrace\n  ) {\n    const accountUpdateTree = x instanceof AccountUpdateTree ? x : new AccountUpdateTree(x, []);\n    const genericAccountUpdateTree = AccountUpdateTree.mapRoot(accountUpdateTree, (accountUpdate) =>\n      accountUpdate.toGeneric()\n    );\n    this.accountUpdateForest.push(genericAccountUpdateTree);\n    // TODO: check that the trace shape matches the account update shape\n    this.accountUpdateForestTrace.push(trace);\n  }\n\n  finalize(): {\n    accountUpdateForest: AccountUpdateTree<AccountUpdate>[];\n    accountUpdateForestTrace: AccountUpdateErrorTrace[];\n    generalErrors: Error[];\n  } {\n    const errors: Error[] = [];\n\n    if (this.feeExcessState.status === 'Dead') {\n      errors.push(new Error('fee excess could not be computed due to other errors'));\n    } else if (!this.feeExcessState.value.equals(Int64.zero).toBoolean()) {\n      errors.push(\n        new Error(\n          'fee excess does not equal 0 (this transaction is attempting to either burn or mint new Mina tokens, which is disallowed)'\n        )\n      );\n    }\n\n    return {\n      accountUpdateForest: [...this.accountUpdateForest],\n      accountUpdateForestTrace: [...this.accountUpdateForestTrace],\n      generalErrors: errors,\n    };\n  }\n}\n\n// IMPORTANT TODO: Currently, if a zkapp command fails in the virtual application, any successful\n//                 account updates are still applied to the provided ledger view. We should\n//                 probably make the ledger view interface immutable, or clone it every time we\n//                 create a new zkapp command, to help avoid unexpected behavior externally.\n\nasync function createUnsignedZkappCommand(\n  ledger: LedgerView,\n  chain: ChainView,\n  {\n    feePayer,\n    fee,\n    validUntil,\n  }: {\n    feePayer: PublicKey;\n    fee: UInt64;\n    validUntil?: UInt32;\n  },\n  f: (ctx: ZkappCommandContext) => Promise<void>\n): Promise<ZkappCommand> {\n  // TODO\n  const globalSlot = UInt32.zero;\n\n  const failedAccounts = new AccountIdSet();\n  let feePaymentErrors: Error[] = [];\n  let feePayment: ZkappFeePayment | null = null;\n\n  const feePayerId = new AccountId(feePayer, TokenId.MINA);\n  const feePayerAccount = ledger.getAccount(feePayerId);\n\n  if (feePayerAccount !== null) {\n    feePayment = new ZkappFeePayment({\n      publicKey: feePayer,\n      nonce: feePayerAccount.nonce,\n      fee,\n      validUntil,\n    });\n\n    const applied = checkAndApplyFeePayment(chain, feePayerAccount, feePayment);\n    switch (applied.status) {\n      case 'Applied':\n        ledger.setAccount(applied.updatedAccount);\n        break;\n      case 'Failed':\n        feePaymentErrors = applied.errors;\n        failedAccounts.add(feePayerAccount.accountId);\n        break;\n    }\n  } else {\n    feePaymentErrors = [new Error('zkapp fee payer account not found')];\n    failedAccounts.add(feePayerId);\n  }\n\n  const ctx = new ZkappCommandContext(ledger, chain, failedAccounts, globalSlot);\n  await f(ctx);\n  const { accountUpdateForest, accountUpdateForestTrace, generalErrors } = ctx.finalize();\n\n  const errorTrace = new ZkappCommandErrorTrace(\n    generalErrors,\n    feePaymentErrors,\n    accountUpdateForestTrace\n  );\n\n  if (!errorTrace.hasErrors()) {\n    // should never be true if we hit this branch\n    if (feePayment === null) throw new Error('internal error');\n\n    return new ZkappCommand({\n      feePayment,\n      accountUpdates: accountUpdateForest,\n    });\n  } else {\n    console.log(errorTrace.generateReport());\n    throw new Error(\n      'errors were encountered while creating a ZkappCommand (an error report is available in the logs)'\n    );\n  }\n}\n\nasync function createZkappCommand(\n  ledger: LedgerView,\n  chain: ChainView,\n  authEnv: ZkappCommandAuthorizationEnvironment,\n  feePayment: {\n    feePayer: PublicKey;\n    fee: UInt64;\n    validUntil?: UInt32;\n  },\n  f: (ctx: ZkappCommandContext) => Promise<void>\n): Promise<AuthorizedZkappCommand> {\n  const unsignedCmd = await createUnsignedZkappCommand(ledger, chain, feePayment, f);\n  return unsignedCmd.authorize(authEnv);\n}\n", "// Views into chain-state (ledger and best block)\n\nimport { Account, AccountId, AccountIdMap } from './account.js';\nimport { Field } from '../../provable/field.js';\nimport { UInt32, UInt64 } from '../../provable/int.js';\nimport { MinaAmount } from './currency.js';\n\nexport { ChainView, EpochData, EpochLedgerData, LedgerView, LocalChain, LocalLedger };\ninterface ChainView {\n  snarkedLedgerHash: Field;\n  blockchainLength: UInt32;\n  minWindowDensity: UInt32;\n  totalCurrency: MinaAmount;\n  globalSlotSinceGenesis: UInt32;\n  stakingEpochData: EpochData;\n  nextEpochData: EpochData;\n}\n\ninterface EpochData {\n  ledger: EpochLedgerData;\n  seed: Field;\n  startCheckpoint: Field;\n  lockCheckpoint: Field;\n  epochLength: UInt32;\n}\n\ninterface EpochLedgerData {\n  hash: Field;\n  totalCurrency: MinaAmount;\n}\n\ninterface LedgerView {\n  hasAccount(accountId: AccountId): boolean;\n  getAccount(accountId: AccountId): Account | null;\n  setAccount(account: Account): void;\n  updateAccount(accountId: AccountId, f: (account: Account) => Account): void;\n}\n\nclass LocalChain implements ChainView {\n  snarkedLedgerHash: Field;\n  blockchainLength: UInt32;\n  minWindowDensity: UInt32;\n  totalCurrency: UInt64;\n  globalSlotSinceGenesis: UInt32;\n  stakingEpochData: EpochData;\n  nextEpochData: EpochData;\n\n  constructor(\n    snarkedLedgerHash: Field,\n    blockchainLength: UInt32,\n    minWindowDensity: UInt32,\n    totalCurrency: UInt64,\n    globalSlotSinceGenesis: UInt32,\n    stakingEpochData: EpochData,\n    nextEpochData: EpochData\n  ) {\n    this.snarkedLedgerHash = snarkedLedgerHash;\n    this.blockchainLength = blockchainLength;\n    this.minWindowDensity = minWindowDensity;\n    this.totalCurrency = totalCurrency;\n    this.globalSlotSinceGenesis = globalSlotSinceGenesis;\n    this.stakingEpochData = stakingEpochData;\n    this.nextEpochData = nextEpochData;\n  }\n\n  static initial(): LocalChain {\n    return new LocalChain(\n      Field.empty(),\n      UInt32.from(0),\n      UInt32.from(0),\n      UInt64.from(0),\n      UInt32.from(0),\n      {\n        ledger: {\n          hash: Field.empty(),\n          totalCurrency: UInt64.from(0),\n        },\n        seed: Field.empty(),\n        startCheckpoint: Field.empty(),\n        lockCheckpoint: Field.empty(),\n        epochLength: UInt32.from(0),\n      },\n      {\n        ledger: {\n          hash: Field.empty(),\n          totalCurrency: UInt64.from(0),\n        },\n        seed: Field.empty(),\n        startCheckpoint: Field.empty(),\n        lockCheckpoint: Field.empty(),\n        epochLength: UInt32.from(0),\n      }\n    );\n  }\n}\n\nclass LocalLedger implements LedgerView {\n  private accounts: AccountIdMap<Account>;\n\n  constructor(accounts: Account[]) {\n    this.accounts = new AccountIdMap();\n\n    for (const account of accounts) {\n      this.setAccount(account);\n    }\n  }\n\n  hasAccount(accountId: AccountId): boolean {\n    return this.accounts.has(accountId);\n  }\n\n  getAccount(accountId: AccountId): Account | null {\n    return this.accounts.get(accountId);\n  }\n\n  setAccount(account: Account): void {\n    return this.accounts.set(account.accountId, account);\n  }\n\n  updateAccount(accountId: AccountId, f: (account: Account) => Account): void {\n    return this.accounts.update(accountId, (possibleAccount) => {\n      const account = possibleAccount ?? Account.empty(accountId);\n      const updatedAccount = f(account);\n      // TODO: if(!updatedAccount.accountId.equals(accountId).toBoolean()) throw new Error('...')\n      return updatedAccount;\n    });\n  }\n}\n", "import {\n  AccountUpdate,\n  AccountUpdateCommitment,\n  AccountUpdateTree,\n  AccountUpdateTreeDescription,\n  ContextFreeAccountUpdateDescription,\n  ContextFreeAccountUpdate,\n  DynamicProvable,\n} from '../account-update.js';\nimport { AccountUpdateAuthorizationKind } from '../authorization.js';\nimport { Account, AccountId } from '../account.js';\nimport { mapObject, ProvableTuple, ProvableTupleInstances } from '../core.js';\nimport { getCallerFrame } from '../errors.js';\nimport { StateDefinition, StateMask, StateLayout, StateReader, StateValues } from '../state.js';\nimport { checkAndApplyAccountUpdate } from '../zkapp-logic.js';\nimport { ZkappCommandContext } from '../transaction.js';\nimport { Cache } from '../../../proof-system/cache.js';\nimport { Method as ZkProgramMethod, Proof, ZkProgram } from '../../../proof-system/zkprogram.js';\nimport { Bool } from '../../../provable/bool.js';\nimport { Field } from '../../../provable/field.js';\nimport { UInt32, UInt64 } from '../../../provable/int.js';\nimport { Provable } from '../../../provable/provable.js';\nimport { PublicKey } from '../../../provable/crypto/signature.js';\nimport { Unconstrained } from '../../../provable/types/unconstrained.js';\nimport { VerificationKey } from '../../../proof-system/verification-key.js';\nimport { ZkappConstants } from '../../v1/constants.js';\nimport { MinaAmount } from '../currency.js';\n\nexport {\n  MinaProgramEnv,\n  MinaProgramMethodReturn,\n  MinaProgramMethodImpl,\n  MinaProgramMethodProver,\n  MinaProgramDescription,\n  MinaProgram,\n};\n\nclass MinaProgramEnv<State extends StateLayout> {\n  private expectedPreconditions: Unconstrained<{\n    balance?: MinaAmount;\n    nonce?: UInt32;\n    receiptChainHash?: Field;\n    delegate?: PublicKey;\n    state: StateMask<State>;\n    actionState?: Field;\n    isProven?: Bool;\n  }>;\n\n  constructor(\n    public State: StateDefinition<State>,\n    private account: Unconstrained<Account<State>>,\n    // TODO: we can actually remove this since the verification key will always be set on an\n    //       account before we call a method on it\n    private verificationKey: Unconstrained<VerificationKey>\n  ) {\n    this.expectedPreconditions = Unconstrained.from({\n      state: StateMask.create(State),\n    });\n  }\n\n  get accountId(): AccountId {\n    return Provable.witness(AccountId, () => this.account.get().accountId);\n  }\n\n  get accountVerificationKeyHash(): Field {\n    return Provable.witness(Field, () => this.account.get().zkapp.verificationKey.hash);\n  }\n\n  get programVerificationKey(): VerificationKey {\n    return Provable.witness(VerificationKey, () => this.verificationKey.get());\n  }\n\n  get balance(): MinaAmount {\n    return Provable.witness(UInt64, () => {\n      const balance = this.account.get().balance;\n      this.expectedPreconditions.get().balance = balance;\n      return balance;\n    });\n  }\n\n  get nonce(): UInt32 {\n    return Provable.witness(UInt32, () => {\n      const nonce = this.account.get().nonce;\n      this.expectedPreconditions.get().nonce = nonce;\n      return nonce;\n    });\n  }\n\n  get receiptChainHash(): Field {\n    return Provable.witness(Field, () => {\n      const receiptChainHash = this.account.get().receiptChainHash;\n      this.expectedPreconditions.get().receiptChainHash = receiptChainHash;\n      return receiptChainHash;\n    });\n  }\n\n  get delegate(): PublicKey {\n    return Provable.witness(PublicKey, () => {\n      const delegate = this.account.get().delegate ?? this.account.get().accountId.publicKey;\n      this.expectedPreconditions.get().delegate = delegate;\n      return delegate;\n    });\n  }\n\n  get state(): StateReader<State> {\n    const accountState = Provable.witness(Unconstrained<StateValues<State>>, () => {\n      return Unconstrained.from(this.account.get().zkapp.state);\n    });\n    const accountStateMask = Provable.witness(Unconstrained<StateMask<State>>, () => {\n      return Unconstrained.from(this.expectedPreconditions.get().state);\n    });\n    return StateReader.create(this.State, accountState, accountStateMask);\n  }\n\n  // only returns the most recent action state for an account\n  get actionState(): Field {\n    return Provable.witness(Field, () => {\n      const actionState =\n        this.account.get().zkapp.actionState[ZkappConstants.ACCOUNT_ACTION_STATE_BUFFER_SIZE - 1];\n      this.expectedPreconditions.get().actionState = actionState;\n      return actionState;\n    });\n  }\n\n  get isProven(): Bool {\n    return Provable.witness(Bool, () => {\n      const isProven = this.account.get().zkapp.isProven;\n      this.expectedPreconditions.get().isProven = isProven;\n      return isProven;\n    });\n  }\n\n  static sizeInFields(): number {\n    return 0;\n  }\n\n  static toFields<State extends StateLayout>(_x: MinaProgramEnv<State>): Field[] {\n    return [];\n  }\n\n  static toAuxiliary<State extends StateLayout>(x?: MinaProgramEnv<State>): any[] {\n    // if(x === undefined) throw new Error('invalid call to MinaProgram#toAuxiliary');\n    // eww... how do I handle the undefined MinaProgramEnv situation?\n    return [x?.account, x?.verificationKey];\n  }\n\n  static fromFields(_fields: Field[], aux: any[]): MinaProgramEnv<'GenericState'> {\n    return new MinaProgramEnv('GenericState', aux[0], aux[1]);\n  }\n\n  static toValue<State extends StateLayout>(x: MinaProgramEnv<State>): MinaProgramEnv<State> {\n    return x;\n  }\n\n  static fromValue<State extends StateLayout>(x: MinaProgramEnv<State>): MinaProgramEnv<State> {\n    return x;\n  }\n\n  static check<State extends StateLayout>(_x: MinaProgramEnv<State>) {\n    // TODO NOW\n    //throw new Error('TODO');\n  }\n}\n\ntype MinaProgramMethodReturn<\n  State extends StateLayout = 'GenericState',\n  Event = Field[],\n  Action = Field[],\n> =\n  | Omit<\n      AccountUpdateTreeDescription<\n        ContextFreeAccountUpdateDescription<State, Event, Action>,\n        AccountUpdate\n      >,\n      'authorizationKind'\n    >\n  | ContextFreeAccountUpdate<State, Event, Action>;\n\ntype MinaProgramMethodImpl<\n  State extends StateLayout,\n  Event,\n  Action,\n  PrivateInputs extends ProvableTuple,\n> = {\n  privateInputs: PrivateInputs;\n  method(\n    env: MinaProgramEnv<State>,\n    ...args: ProvableTupleInstances<PrivateInputs>\n  ): Promise<MinaProgramMethodReturn<State, Event, Action>>;\n};\n\n// TODO: return the tree, not the proof and the single update\ntype MinaProgramMethodProver<\n  State extends StateLayout,\n  Event,\n  Action,\n  PrivateInputs extends ProvableTuple,\n> = (\n  env: ZkappCommandContext,\n  accountId: AccountId,\n  ...args: ProvableTupleInstances<PrivateInputs>\n) => Promise<AccountUpdateTree<AccountUpdate<State, Event, Action>, AccountUpdate>>;\n\ninterface MinaProgramDescription<\n  State extends StateLayout,\n  Event,\n  Action,\n  MethodPrivateInputs extends { [key: string]: ProvableTuple },\n> {\n  name: string;\n  State: StateDefinition<State>;\n  Event: DynamicProvable<Event>;\n  Action: DynamicProvable<Action>;\n  methods: {\n    [key in keyof MethodPrivateInputs]: MinaProgramMethodImpl<\n      State,\n      Event,\n      Action,\n      MethodPrivateInputs[key]\n    >;\n  };\n}\n\n// TODO: use ZkProgram types to help construct this\ntype MinaProgram<\n  State extends StateLayout,\n  Event,\n  Action,\n  MethodPrivateInputs extends { [key: string]: ProvableTuple },\n> = {\n  name: string;\n  State: StateDefinition<State>;\n  Event: DynamicProvable<Event>;\n  Action: DynamicProvable<Action>;\n  compile(options?: { cache?: Cache; forceRecompile?: boolean }): Promise<{\n    verificationKey: {\n      data: string;\n      hash: Field;\n    };\n  }>;\n} & {\n  [key in keyof MethodPrivateInputs]: MinaProgramMethodProver<\n    State,\n    Event,\n    Action,\n    MethodPrivateInputs[key]\n  >;\n};\n\n// TODO really need to fix the types here...\nfunction zkProgramMethod<\n  State extends StateLayout,\n  Event,\n  Action,\n  PrivateInputs extends ProvableTuple,\n>(\n  State: StateDefinition<State>,\n  Event: DynamicProvable<Event>,\n  Action: DynamicProvable<Action>,\n  impl: MinaProgramMethodImpl<State, Event, Action, PrivateInputs>\n): ZkProgramMethod<\n  undefined,\n  AccountUpdateCommitment,\n  {\n    privateInputs: [Provable<MinaProgramEnv<State>>, ...PrivateInputs];\n    auxiliaryOutput: typeof AccountUpdateTree<AccountUpdate>;\n  }\n> {\n  return {\n    privateInputs: [MinaProgramEnv, ...impl.privateInputs],\n    auxiliaryOutput: AccountUpdateTree,\n    // async method(env: MinaProgramEnv<State>, ...inputs: ProvableTupleInstances<PrivateInputs>) {\n    async method(\n      ...[env, ...inputs]: [MinaProgramEnv<State>, ...ProvableTupleInstances<PrivateInputs>]\n    ) {\n      const describedUpdate = await impl.method(env, ...inputs);\n      let describedUpdate2;\n      if (describedUpdate instanceof ContextFreeAccountUpdate) {\n        // TODO: is it ok that we allow signature and proof as an option here, but don't let the description return such an authorization kind?\n        if (!describedUpdate.authorizationKind.isProved.toBoolean()) {\n          throw new Error('TODO: error message');\n        }\n        describedUpdate2 = describedUpdate;\n      } else {\n        describedUpdate2 = {\n          ...describedUpdate,\n          authorizationKind: AccountUpdateAuthorizationKind.Proof(),\n        };\n      }\n\n      const callData = /* TODO */ new Field(0);\n      const updateTree = AccountUpdateTree.from(\n        {\n          ...describedUpdate2,\n          accountId: env.accountId,\n          // TODO: take the verification key from the account state after the virtual update application\n          verificationKeyHash: env.programVerificationKey.hash,\n          callData,\n        },\n        // TODO: return the specialized version...\n        (descr) => new AccountUpdate(State, Event, Action, descr)\n      );\n\n      // const freeUpdate = ContextFreeAccountUpdate.from(State, Event, Action, describedUpdate2);\n      // const update = new AccountUpdate(State, Event, Action, {\n      //   accountId: env.accountId,\n      //   verificationKeyHash: env.verificationKeyHash,\n      //   callData,\n      //   update: freeUpdate,\n      // })\n\n      if (Provable.inProver()) {\n        // env.checkAndApplyUpdateAsProver(update);\n      }\n\n      // TODO: return update as auxiliary output\n      return {\n        publicOutput: updateTree.rootAccountUpdate.commit('testnet' /* TODO */),\n        auxiliaryOutput: AccountUpdateTree.mapRoot(updateTree, (accountUpdate) =>\n          accountUpdate.toGeneric()\n        ),\n      };\n    },\n  } as unknown as ZkProgramMethod<\n    undefined,\n    AccountUpdateCommitment,\n    {\n      privateInputs: [Provable<MinaProgramEnv<State>>, ...PrivateInputs];\n      auxiliaryOutput: typeof AccountUpdateTree<AccountUpdate>;\n    }\n  >;\n}\n\nfunction proverMethod<\n  State extends StateLayout,\n  Event,\n  Action,\n  PrivateInputs extends ProvableTuple,\n>(\n  State: StateDefinition<State>,\n  Event: DynamicProvable<Event>,\n  Action: DynamicProvable<Action>,\n  getVerificationKey: () => VerificationKey,\n  rawProver: (\n    env: MinaProgramEnv<State>,\n    ...inputs: ProvableTupleInstances<PrivateInputs>\n  ) => Promise<{\n    proof: Proof<undefined, AccountUpdateCommitment>;\n    auxiliaryOutput: AccountUpdateTree<AccountUpdate>;\n  }>,\n  _impl: MinaProgramMethodImpl<State, Event, Action, PrivateInputs>\n): MinaProgramMethodProver<State, Event, Action, PrivateInputs> {\n  // TODO HORRIBLE HACK:\n  // In order to circumvent the lack of support for nested program calls, some hard assumptions are\n  // made within this function which will only work if certain rules are followed when prover\n  // methods are invoked externally.\n  //\n  // We perform shallow evaluation on the roots of account update trees returned by method\n  // invocations. This requires that all child updates were manually applied before invoking the\n  // method call. Importantly, with this restriction, methods cannot actually generate new\n  // children, the children must be passed in as private inputs and constrained accordingly.\n  // Unproven update arguments which are not at the root of the tree returned by a method must be\n  // manually applied to the ledger in the correct order.\n\n  return async (\n    ctx: ZkappCommandContext,\n    accountId: AccountId,\n    ...inputs: ProvableTupleInstances<PrivateInputs>\n  ) => {\n    const callSite = getCallerFrame();\n    const verificationKey = getVerificationKey();\n    const genericAccount = ctx.ledger.getAccount(accountId) ?? Account.empty(accountId);\n\n    // TODO: This conversion is safe only under the assumption that the account is new or the\n    //       verification key matches the current program's verification key. Assert this is true,\n    //       or throw an error.\n    const account: Account<State> = Account.fromGeneric(genericAccount, State);\n\n    const env = new MinaProgramEnv(\n      account.State,\n      Unconstrained.from(account),\n      Unconstrained.from(verificationKey)\n    );\n\n    const { proof, auxiliaryOutput: genericAccountUpdateTree } = await rawProver(env, ...inputs);\n    genericAccountUpdateTree.rootAccountUpdate.proof = proof;\n\n    // TODO: We currently throw an error here if there are any children, until we solve the\n    //       problems around account update tracing and not adding duplicate child updates\n    //       to the root (when calling this prover method).\n    if (genericAccountUpdateTree.children.length !== 0)\n      throw new Error('TODO: support nested account updates');\n\n    // TODO HACK: Currently, the rawProver is only able to return the generic state representation,\n    //            so we must convert it again for the return value.\n    const accountUpdateTree = AccountUpdateTree.mapRoot(genericAccountUpdateTree, (accountUpdate) =>\n      AccountUpdate.fromGeneric(accountUpdate, State, Event, Action)\n    );\n\n    // apply only the root update and not the children (see above for details)\n    const applied = checkAndApplyAccountUpdate(\n      ctx.chain,\n      account,\n      accountUpdateTree.rootAccountUpdate,\n      ctx.feeExcessState\n    );\n\n    let errors: Error[];\n    switch (applied.status) {\n      case 'Applied':\n        ctx.ledger.setAccount(applied.updatedAccount.toGeneric());\n        ctx.feeExcessState = applied.updatedFeeExcessState;\n        errors = [];\n        break;\n      case 'Failed':\n        errors = applied.errors;\n        break;\n    }\n\n    const trace = {\n      accountId,\n      callSite,\n      errors,\n      // TODO (for now, we throw an error above if there are children)\n      childTraces: [],\n    };\n\n    ctx.unsafeAddWithoutApplying(genericAccountUpdateTree, trace);\n\n    // TODO: do we need to clone the accountUpdate here so that we have fresh variables?\n    return accountUpdateTree;\n  };\n}\n\nfunction MinaProgram<\n  State extends StateLayout,\n  Event,\n  Action,\n  MethodPrivateInputs extends { [key: string]: ProvableTuple },\n>(\n  descr: MinaProgramDescription<State, Event, Action, MethodPrivateInputs>\n): MinaProgram<State, Event, Action, MethodPrivateInputs> {\n  const programMethods = mapObject<\n    {\n      [key in keyof MethodPrivateInputs]: MinaProgramMethodImpl<\n        State,\n        Event,\n        Action,\n        MethodPrivateInputs[key]\n      >;\n    },\n    {\n      [key in keyof MethodPrivateInputs]: ZkProgramMethod<\n        undefined,\n        AccountUpdateCommitment,\n        {\n          privateInputs: [Provable<MinaProgramEnv<State>>, ...MethodPrivateInputs[key]];\n          auxiliaryOutput: typeof AccountUpdateTree<AccountUpdate>;\n        }\n      >;\n    }\n  >(\n    descr.methods,\n    <Key extends keyof MethodPrivateInputs>(\n      key: Key\n    ): ZkProgramMethod<\n      undefined,\n      AccountUpdateCommitment,\n      {\n        privateInputs: [Provable<MinaProgramEnv<State>>, ...MethodPrivateInputs[Key]];\n        auxiliaryOutput: typeof AccountUpdateTree<AccountUpdate>;\n      }\n    > => zkProgramMethod(descr.State, descr.Event, descr.Action, descr.methods[key])\n  );\n\n  const Program = ZkProgram<\n    {\n      publicInput: undefined;\n      publicOutput: typeof AccountUpdateCommitment;\n      methods: {\n        [key in keyof MethodPrivateInputs]: {\n          privateInputs: [Provable<MinaProgramEnv<State>>, ...MethodPrivateInputs[key]];\n          auxiliaryOutput: typeof AccountUpdateTree;\n        };\n      };\n    },\n    {\n      [key in keyof MethodPrivateInputs]: {\n        // method(...privateInputs: [MinaProgramEnv<State>, ...({ [I in keyof MethodPrivateInputs[key]]: InferProvable<MethodPrivateInputs[key][I]>} & any[]) ]): Promise<{publicOutput: AccountUpdateCommitment, auxiliaryOutput: AccountUpdate}>\n        method(...privateInputs: any[]): Promise<any>;\n      };\n      // [key in keyof MethodPrivateInputs]: ZkProgramMethod<\n      //   any,\n      //   any,\n      //   any\n      //   // undefined,\n      //   // typeof AccountUpdateCommitment,\n      //   // {\n      //   //   privateInputs: [Provable<MinaProgramEnv<State>>, ...MethodPrivateInputs[key]],\n      //   //   auxiliaryOutput: typeof AccountUpdate\n      //   // }\n      // >\n    }\n  >({\n    name: descr.name,\n    publicInput: undefined,\n    publicOutput: AccountUpdateCommitment,\n\n    methods: programMethods as any /* TODO */,\n  });\n\n  // TODO: proper verification key caching\n  let verificationKey: VerificationKey | null = null;\n\n  function getVerificationKey() {\n    if (verificationKey === null) {\n      throw new Error('You must compile a MinaProgram before calling any of methods on it.');\n    }\n    return verificationKey;\n  }\n\n  // TODO: this is wrong -- we need to check and interact with options, not just forward them.\n  // A proper fix here is probably to refactor the compile interface for ZkProgram... this cache pattern is odd.\n  async function compile(options?: {\n    cache?: Cache;\n    forceRecompile?: boolean;\n    proofsEnabled?: boolean;\n  }): Promise<{\n    verificationKey: { data: string; hash: Field };\n  }> {\n    const compiledProgram = await Program.compile(options);\n    verificationKey = new VerificationKey(compiledProgram.verificationKey);\n    return compiledProgram;\n  }\n\n  const proverMethods = mapObject(descr.methods, (key: keyof MethodPrivateInputs) =>\n    proverMethod(\n      descr.State,\n      descr.Event,\n      descr.Action,\n      getVerificationKey,\n      Program[key] as any /* TODO */,\n      descr.methods[key]\n    )\n  );\n\n  return {\n    name: descr.name,\n    State: descr.State,\n    Event: descr.Event,\n    Action: descr.Action,\n    compile,\n    ...proverMethods,\n  };\n}\n", "import { Int64, UInt64 } from '../../provable/int.js';\n\nexport { MinaAmount, BalanceChange };\n\ntype MinaAmount = UInt64;\nconst MinaAmount = {\n  fromMINA: (amount: bigint | number): MinaAmount => {\n    if (typeof amount === 'number') {\n      return UInt64.from(amount * 1e9);\n    } else return UInt64.from(amount * BigInt(1e9));\n  },\n  toMINA: (amount: MinaAmount): bigint => {\n    return amount.toBigInt() / BigInt(1e9);\n  },\n  fromNanoMINA: (amount: bigint): MinaAmount => {\n    return UInt64.from(amount);\n  },\n  toNanoMINA: (amount: MinaAmount): bigint => {\n    return amount.toBigInt();\n  },\n};\n\ntype BalanceChange = Int64;\nconst BalanceChange = {\n  positive: {\n    fromMINA: (amount: bigint): BalanceChange => {\n      return Int64.from(amount * BigInt(1e9));\n    },\n  },\n  negative: {\n    fromMINA: (amount: bigint): BalanceChange => {\n      return Int64.from(-amount * BigInt(1e9));\n    },\n  },\n};\n", "export * as EllipticCurve from './crypto/elliptic-curve.js';\nexport * as FiniteField from './crypto/finite-field.js';\nexport * as BigIntHelpers from './crypto/bigint-helpers.js';\nexport * as Constants from './crypto/constants.js';\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;iBAAAA;EAAA,qBAAAC;EAAA;;cAAAC;EAAA,aAAAC;EAAA;;;;;;;;wBAAAC;EAAA;;;;;eAAAC;EAAA;;eAAAC;EAAA;;0BAAAC;EAAA;;;;;;;;;;;;;;;;kBAAAC;EAAA,kBAAAC;EAAA;;;mBAAAC;EAAA;;gBAAAC;EAAA;;cAAAC;EAAA,iBAAAC;EAAA;eAAAC;EAAA;;;iBAAAC;EAAA;;4BAAAC;EAAA;;gBAAAC;EAAA,cAAAC;EAAA;;;yBAAAC;EAAA;;;;gBAAAC;EAAA;;;;;;;;qBAAAC;EAAA;;;;;;;;;;;;;;;gBAAAC;;AAAA;;;ACAA;;;;;;;;;;;AAYA,IAAI,WAAW;EACb,OAAO;EACP,QAAQ;EACR,gBAAgB;EAChB,kBAAkB;EAClB,kBAAkB;EAClB,mBAAmB;EACnB,mBAAmB;EACnB,SAAS;EACT,cAAc;EACd,WAAW;EACX,kBAAkB;EAClB,kBAAkB;EAClB,UAAU;EACV,eAAe;EACf,cAAc;EACd,YAAY;IACV;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;AAGJ,IAAI,eAAe;EACjB,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,sBAAsB;IACpB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,sBAAsB;IACpB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,sBAAsB;IACpB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,kBAAkB;IAChB;IACA;IACA;;EAEF,sBAAsB;IACpB;IACA;IACA;;EAEF,uBAAuB;IACrB;IACA;IACA;;EAEF,8BAA8B;IAC5B;IACA;IACA;;EAEF,eAAe;IACb;IACA;IACA;;EAEF,2BAA2B;IACzB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;;AAGJ,IAAI,qBAAqB;EACvB,wBAAwB;IACtB;IACA;IACA;;EAEF,sBAAsB;IACpB;IACA;IACA;;EAEF,wBAAwB;IACtB;IACA;IACA;;;AAGJ,IAAI,eAAe;EACjB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,WAAW;EACX,WAAW;EACX,iBAAiB;EACjB,YAAY;EACZ,WAAW;EACX,iBAAiB;EACjB,iBAAiB;;AAEnB,IAAI,mBAAmB,EAAE,YAAY,EAAC;AACtC,IAAI,yBAAyB;EAC3B,KAAK;IACH;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;;EAGJ,gBAAgB;IACd;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;;EAGJ,YAAY;EACZ,eAAe;EACf,yBAAyB;EACzB,WAAW;EACX,MAAM;EACN,OAAO;;AAET,IAAI,yBAAyB;EAC3B,KAAK;IACH;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;;EAGJ,gBAAgB;IACd;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;IAEF;MACE;MACA;MACA;;;EAGJ,YAAY;EACZ,eAAe;EACf,yBAAyB;EACzB,WAAW;EACX,MAAM;EACN,OAAO;;AAET,IAAI,QAAQ;EACV,0BACE;;;;AC9wCJ,IAAM,UAAU;EACd,GAAM,KAAQ;AACZ,WAAO,CAAC,GAAG,GAAG,GAAG;EACnB;EACA,KAAQ,CAAC,EAAE,GAAG,GAAG,GAAa;AAC5B,WAAO;EACT;EACA,IAAU,CAAC,EAAE,GAAG,GAAG,GAAe,KAAgB;AAChD,WAAO,CAAC,GA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",
  "names": ["Account", "AccountUpdate", "Bool", "Bytes", "EcdsaSignature", "Field", "Group", "IndexedMerkleMap", "Poseidon", "PrivateKey", "PublicKey", "Scalar", "Sign", "Signature", "State", "TokenId", "TransactionVersion", "UInt32", "UInt64", "VerificationKey", "assert", "fetchEvents", "verify", "MlBool", "b", "MlOption", "MlTuple", "tuple", "tuple", "b", "a", "l", "bit", "power", "x", "a", "b", "randomBytesNode", "p", "a", "b", "q", "sizeInBits", "n", "assert", "Field", "Scalar", "a", "p", "double", "G", "q", "assert", "l", "quotient", "a", "b", "p", "double", "bit", "Field", "Scalar", "affineZero", "Field", "fields", "tmpBytes", "wasm", "wasm", "RuntimeTable", "lookup", "l", "id", "public_", "mapPointEvalsOption", "mapProofEvaluations", "MlTuple", "wasm", "lookup", "xor", "s", "srs", "wasm", "cache", "cachedir", "id", "wasm", "srs", "assert", "cache", "wasm", "initThreadPool", "exitThreadPool", "state", "withThreadPool", "wasm_", "resolve", "os", "resolve", "HashInput", "isProvable", "provable", "typeObj", "a", "b", "fields", "toCanonical", "empty", "signable", "primitives", "Field", "sizeInBits", "encoder", "sizeInBits", "Field", "Bool", "b", "Unsigned", "Sign", "module", "context", "id", "id", "FieldType", "createField", "tuple", "assert", "vars", "createField", "MlTuple", "x", "a", "b", "sign", "padding", "id", "KimchiGateType", "createField", "fields", "assert", "provable", "createField", "raw", "fields", "provable", "provable", "fields", "id", "value", "createField", "isConstant", "provable", "x", "Bool", "b", "clone", "fields", "Field", "context", "a", "createField", "a", "zj", "z", "i", "sum", "b", "x", "res", "isVar", "isVar", "a", "isVar", "getVar", "isConst", "getConst", "x", "y", "z", "assert", "Bool", "not", "Field", "isConstant", "b", "fields", "assert", "empty", "createField", "zero", "createField", "zero", "x", "y", "assert", "assert", "Field3", "inverse", "sign", "assert", "sum", "overflow", "carry", "r0", "r1", "r2", "a", "b", "q", "xInv", "createField", "a2", "b2", "q0", "q1", "q2", "r01", "p2", "p10", "p110", "p111", "c0", "c1_00", "c1_12", "c1_24", "c1_36", "c1_48", "c1_60", "c1_72", "c1_84", "c1_86", "c1_88", "c1_90", "q2Bound", "x", "x", "assert", "Field3", "x0", "sign", "overflow", "carry", "Field", "l2", "rangeCheck", "b", "p2", "Field3", "createField", "Field", "isConstant", "toFieldVar", "z", "Bool", "b", "assert", "bits", "bit", "x", "createField", "Field", "Point", "assert", "zero", "Field3", "t", "tHi", "inf", "s", "x3", "y3", "withVersion", "base58", "hash2", "Field", "TokenId", "ReceiptChainHash", "LedgerHash", "EpochSeed", "StateHash", "a", "b", "add", "Scalar", "Scalar", "Bool", "Field", "fields", "Group", "Field", "isConstant", "add", "Scalar", "Field", "Bool", "Group", "rangeCheck0", "rangeCheck1", "foreignFieldAdd", "foreignFieldMul", "xor", "lookup", "fields", "Bool", "Field", "fields", "primitives", "Field", "Bool", "Scalar", "Group", "isPrimitive", "a", "b", "assert", "q", "Field", "a", "max", "assert", "Field", "xor", "b", "out0", "zero", "sum", "excess", "shifted", "rotated", "bound", "fields", "assert", "a", "b", "Field", "assert", "bits", "sum", "i", "bit", "chunk", "UInt64", "UInt32", "Field", "uint32", "max", "q", "r", "xor", "Bool", "bit", "b", "Sign", "sign", "abs", "assert", "padding", "b", "Bool", "Field", "_a", "Bytes", "Bytes", "UInt32", "UInt64", "l", "padding", "a", "b", "sum", "xor", "padding", "Bytes", "l", "UInt32", "Ch", "Maj", "sum", "xor", "SigmaZero", "sigma", "SigmaOne", "DeltaZero", "DeltaOne", "ROTR", "SHR", "sigmaSimple", "a", "b", "UInt64", "assert", "state", "Bytes", "a", "b", "Field", "id", "a", "b", "xor", "id", "Field3", "ForeignField", "assert", "p", "Field3", "l", "fields", "isConstant", "sizeInBits", "l2", "Field", "provable", "import_js_sha256", "add", "negate", "p2", "assert", "Field3", "m", "x3", "y3", "p", "a", "b", "equals", "multiScalarMul", "Bool", "G", "Curve", "sum", "i", "endomorphism", "s0", "s1", "s00", "s01", "s10", "s11", "Field", "Scalar", "p", "assert", "assert", "Field", "Scalar", "Bytes", "pad", "state", "xor", "Field", "assert", "hash", "a", "b", "EcdsaSignature", "Bytes", "assert", "Signature", "hash", "Field", "Hash", "salt", "emptyHashWithPrefix", "hashWithPrefix", "Field", "x", "hash", "Fp", "power", "state", "update", "permutation", "round", "assert", "Field", "Poseidon", "isConstant", "state", "newState", "prefixToField", "Group", "sign", "bits", "fields", "Poseidon", "Scalar", "HashInput", "HashHelpers", "hashWithPrefix", "packToFields", "fields", "sign", "id", "HashInput", "packToFields", "hashWithPrefix", "scale", "b", "l", "diff", "PrivateKey", "Scalar", "PublicKey", "sign", "Group", "Field", "Bool", "Signature", "Bool", "Field", "PublicKey", "Sign", "TokenSymbol", "UInt32", "UInt64", "empty", "TypeMap", "customTypes", "Field", "signableFromLayout", "empty", "value", "json", "typeData", "fields", "toJSONEssential", "provableFromLayout", "Field", "Poseidon", "salt", "hashWithPrefix", "emptyHashWithPrefix", "Events", "hash", "Actions", "state", "empty", "Field", "Bool", "HashHelpers", "packToFields", "provable", "signable", "empty", "b", "hash", "TokenSymbol", "Field", "Bool", "Poseidon", "UInt32", "PublicKey", "UInt64", "UInt32", "Field", "Sign", "Bool", "TokenSymbol", "empty", "Account", "AccountUpdate", "ActionState", "Actions", "AuthRequired", "BalanceChange", "Events", "MayUseToken", "ReceiptChainHash", "StateHash", "TokenId", "TokenSymbol", "TransactionVersion", "TypeMap", "VerificationKeyHash", "ZkappCommand", "ZkappUri", "customTypes", "empty", "toJSONEssential", "TokenId", "StateHash", "TokenSymbol", "AuthRequired", "ZkappUri", "MayUseToken", "HashHelpers", "packToFields", "Events", "Actions", "ActionState", "VerificationKeyHash", "ReceiptChainHash", "TransactionVersion", "BalanceChange", "TypeMap", "TokenId", "AuthRequired", "BalanceChange", "customTypes", "TransactionVersion", "ZkappUri", "TokenSymbol", "StateHash", "Events", "Actions", "ActionState", "MayUseToken", "VerificationKeyHash", "ReceiptChainHash", "toJSONEssential", "empty", "ZkappCommand", "AccountUpdate", "Account", "import_reflect_metadata", "Proof", "id", "Bool", "fields", "assert", "provableArray", "provable", "a", "l", "Field", "fields", "i", "Array", "Bool", "_DynamicArrayBase_dummyMask", "isLength", "raw", "id", "chunk", "Field", "provable", "_a", "input", "assert", "Field", "hash", "Poseidon", "empty", "Field", "toConstant", "hash", "emptyHash", "provable", "assert", "_a", "Poseidon", "Field", "Poseidon", "witness", "hash", "Bool", "b", "assert", "_a", "Field", "Poseidon", "Bool", "witness", "index", "Nodes", "empty", "zero", "UInt64", "Field", "Bool", "UInt32", "UInt64", "PublicKey", "Account", "context", "update", "assert", "hasAccount", "KeyType", "hash", "rustConversion", "srs", "VerificationKey", "Field", "hash", "verify", "Field", "fields", "SelfProof", "cache", "p", "provers", "VerificationKey", "id", "publicOutput", "auxiliaryOutput", "proof", "maxProofsVerified", "state", "tag", "hash", "verificationKey", "method", "salt", "inProver", "assert", "Proof", "_a", "hash", "fields", "hashWithPrefix", "TokenId", "ReceiptChainHash", "StateHash", "Field", "update", "transactionCommitments", "hashWithPrefix", "AccountUpdate", "fields", "packToFields", "hash", "emptyHash", "AccountUpdate", "a", "TransactionVersion", "UInt32", "MayUseToken", "Bool", "a", "Events", "Field", "Actions", "TokenId", "AccountUpdate", "UInt64", "PublicKey", "currentSlot", "update", "Poseidon", "hash", "id", "fields", "merkleListHash", "final", "ZkappCommand", "transaction", "Proof", "Network", "Account", "accountId", "PublicKey", "TokenId", "UInt64", "UInt32", "ReceiptChainHash", "Bool", "Field", "record", "TokenId", "url", "PublicKey", "TokenId", "fetchActions", "network", "UInt32", "UInt64", "hash", "StateHash", "fetchEvents", "fetchActions", "TokenId", "Field", "Lightnet", "PublicKey", "PrivateKey", "Actions", "url", "TokenId", "sum", "a", "b", "transaction", "TransactionCost", "TransactionLimits", "ZkappConstants", "TokenId", "Field", "UInt64", "UInt32", "update", "transactionCommitments", "AccountUpdate", "PublicKey", "assert", "VerificationKey", "verify", "p", "a", "b", "Transaction", "transaction", "ZkappCommand", "PublicKey", "sender", "getAccount", "TokenId", "UInt32", "AccountUpdate", "UInt64", "hash", "Field", "Scalar", "PrivateKey", "PublicKey", "Bool", "update", "Account", "id", "update", "Field", "PublicKey", "TestPublicKey", "random", "PrivateKey", "fromBase58", "base58", "UInt64", "UInt32", "TokenId", "ZkappCommand", "update", "Account", "p", "Field", "Actions", "hash", "pendingTransaction", "sender", "sender", "Network", "TokenId", "hash", "error", "resolve", "options", "pendingTransaction", "fetchEvents", "fetchActions", "UInt64", "Actions", "contract", "state", "emptyHash", "isDummy", "hash", "ActionList", "MerkleActions", "actions", "Field", "a", "State", "SmartContract", "CircuitValue", "state", "AccountUpdate", "Bool", "Field", "contract", "stateAsFields", "TokenId", "context", "import_reflect_metadata", "fields", "Field", "p", "q", "bigIntToBytes", "bytesPerBigInt", "b", "reservedPropNames", "SelfProof", "PublicKey", "Field", "method", "AccountUpdate", "id", "context", "Poseidon", "a", "accountUpdate", "result", "assert", "callDataFields", "children", "_a", "sender", "TokenId", "cache", "verify", "hash", "VerificationKey", "Bool", "state", "update", "Events", "UInt32", "SmartContract", "transaction", "ZkappCommand", "AccountUpdate", "MayUseToken", "update", "TokenId", "assert", "id", "TokenId", "sender", "Bool", "AccountUpdate", "PublicKey", "Bool", "TokenId", "PublicKey", "AccountUpdate", "a", "sponge", "Poseidon", "Field", "Scalar", "Group", "chunk", "padding", "witness", "hash", "Field", "Poseidon", "bit", "Bool", "Field", "Bool", "Poseidon", "Group", "Scalar", "Field", "G", "Poseidon", "witness", "PublicKey", "Hash", "Actions", "hash", "fields", "Field", "a", "contract", "update", "fields", "Actions", "Field", "Bool", "actions", "hashWithPrefix", "proof", "state", "hash", "witness", "Field", "padding", "Bool", "Poseidon", "assert", "state", "pushAction", "Actions", "hash", "contract", "MerkleActions", "a", "updates", "hash", "Field", "Bool", "i", "assert", "actionsList", "proof", "slice", "actions", "assert", "get", "state", "map", "value", "Poseidon", "Field", "update", "Actions", "State", "SelfProof", "Bool", "proof", "mainFromCircuitData", "rustConversion", "Field", "id", "assert", "fields", "_a", "a", "q", "r", "Field", "isSquare", "p", "chunk", "bit", "sqrt", "b", "Bool", "x0", "x1", "max", "v2_exports", "Account", "AccountId", "AccountTiming", "AccountUpdate", "AccountUpdateTree", "BalanceChange", "CommittedList", "Option", "Permissions", "Preconditions", "Range", "State", "TokenId", "ZkappCommand", "ZkappUri", "mapObject", "Actions", "AuthRequired", "Bool", "Events", "Field", "Option", "PublicKey", "Sign", "StateHash", "TokenId", "TokenSymbol", "UInt32", "UInt64", "ZkappUri", "fields", "fields", "Option", "Bool", "decoder", "Field", "Events", "Actions", "AuthRequired", "StateHash", "Field", "TokenId", "TokenSymbol", "ZkappUri", "fields", "fields", "BindingsType", "Object", "sum", "decoder", "Array", "Option", "Leaf", "Number", "String", "Actions", "AuthRequired", "Bool", "Events", "Field", "Int64", "PublicKey", "Sign", "StateHash", "TokenId", "TokenSymbol", "UInt32", "UInt64", "ZkappUri", "Account", "AccountPrecondition", "FeePayerBody", "MayUseToken", "NetworkPrecondition", "Permissions", "Preconditions", "VerificationKeyPermission", "ZkappCommand", "FeePayerBody", "VerificationKeyPermission", "AccountPrecondition", "MayUseToken", "Permissions", "NetworkPrecondition", "Account", "Preconditions", "ZkappCommand", "Bool", "fields", "UInt32", "Permissions", "p", "fields", "mapObject", "Option", "Range", "ZkappUri", "Field", "b", "TokenId", "Bool", "Precondition", "Bool", "Preconditions", "State", "UInt32", "fields", "Field", "UInt64", "NetworkPrecondition", "PublicKey", "AccountPrecondition", "generic", "State", "a", "b", "fields", "preconditions", "Bool", "update", "update2", "empty", "Field", "accountId", "AccountId", "Bool", "PublicKey", "TokenId", "Field", "fields", "AccountTiming", "UInt32", "UInt64", "Account", "State", "VerificationKey", "ZkappUri", "Permissions", "Field", "fields", "CommittedList", "hash", "AccountUpdateTree", "hashWithPrefix", "packToFields", "AccountUpdate", "State", "Preconditions", "UInt64", "Bool", "Permissions", "PublicKey", "VerificationKey", "ZkappUri", "AccountTiming", "update", "Option", "AccountId", "TokenId", "StackTrace", "accountId", "TokenId", "a", "b", "preconditions", "Bool", "update", "UInt64", "Sign", "Account", "UInt32", "Field", "AccountUpdate", "Field", "AccountId", "TokenId", "Sign", "Bool", "UInt32", "FeePayerBody", "ZkappCommand", "update", "AccountUpdateTree", "hashWithPrefix", "Account", "Field", "UInt32", "UInt64", "accountId", "Account", "State", "AccountId", "Field", "VerificationKey", "UInt64", "UInt32", "PublicKey", "Bool", "AccountUpdateTree", "AccountUpdate", "accountId", "Account", "mapObject", "UInt64", "BalanceChange", "IndexedMerkleMap", "v2_exports", "Experimental", "OffchainStateCommitments", "BatchReducer"]
}
